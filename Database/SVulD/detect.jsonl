{"index": 174373, "code": "gnutls_session_get_data (gnutls_session_t session,\nvoid *session_data, size_t * session_data_size)\n{\ngnutls_datum_t psession;\nint ret;\nif (session->internals.resumable == RESUME_FALSE)\nreturn GNUTLS_E_INVALID_SESSION;\npsession.data = session_data;\nret = _gnutls_session_pack (session, &psession);\nif (ret < 0)\n{\ngnutls_assert ();\nreturn ret;\n}\n*session_data_size = psession.size;\nif (psession.size > *session_data_size)\n{\nret = GNUTLS_E_SHORT_MEMORY_BUFFER;\ngoto error;\n}\nif (session_data != NULL)\nmemcpy (session_data, psession.data, psession.size);\nret = 0;\nerror:\n_gnutls_free_datum (&psession);\nreturn ret;\n}", "contrast": "gnutls_session_get_data (gnutls_session_t session,\nvoid *session_data, size_t * session_data_size)\n{\ngnutls_datum_t psession;\nint ret;\nif (session->internals.resumable == RESUME_FALSE)\nreturn GNUTLS_E_INVALID_SESSION;\npsession.data = session_data;\nret = _gnutls_session_pack (session, &psession);\nif (ret < 0)\n{\ngnutls_assert ();\nreturn ret;\n}\nif (psession.size > *session_data_size)\n{\nret = GNUTLS_E_SHORT_MEMORY_BUFFER;\ngoto error;\n}\n*session_data_size = psession.size;\nif (session_data != NULL)\nmemcpy (session_data, psession.data, psession.size);\nret = 0;\nerror:\n_gnutls_free_datum (&psession);\nreturn ret;\n}", "label": 0}
{"index": 174380, "code": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\nint n = ss->n;\nfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\ncc->opaque = cached;\ncc->convert = fz_cached_color_convert;\ncc->ds = ds ? ds : fz_device_gray(ctx);\ncc->ss = ss;\ncc->is = is;\nfz_try(ctx)\n{\nfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\ncached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n}\nfz_catch(ctx)\n{\nfz_drop_color_converter(ctx, &cached->base);\nfz_drop_hash_table(ctx, cached->hash);\nfz_free(ctx, cached);\nfz_rethrow(ctx);\n}\n}", "contrast": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\nint n = ss->n;\nfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\ncc->opaque = cached;\ncc->convert = fz_cached_color_convert;\ncc->ds = ds ? ds : fz_device_gray(ctx);\ncc->ss = ss;\ncc->is = is;\nfz_try(ctx)\n{\nfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\ncached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n}\nfz_catch(ctx)\n{\nfz_drop_color_converter(ctx, &cached->base);\nfz_drop_hash_table(ctx, cached->hash);\nfz_free(ctx, cached);\ncc->opaque = NULL;\nfz_rethrow(ctx);\n}\n}", "label": 0}
{"index": 174384, "code": "pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n{\npdf_gstate *gstate = pr->gstate + pr->gtop;\nfz_matrix image_ctm;\nfz_rect bbox;\nsoftmask_save softmask = { NULL };\nif (pr->super.hidden)\nreturn;\nbreak;\ncase PDF_MAT_SHADE:\nif (gstate->fill.shade)\n{\nfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\nbbox = fz_unit_rect;\nfz_transform_rect(&bbox, &image_ctm);\nif (image->mask)\n{\nif (gstate->blendmode)\nfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\nfz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n}\nelse\ngstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\nif (!image->colorspace)\n{\nswitch (gstate->fill.kind)\n{\ncase PDF_MAT_NONE:\nbreak;\ncase PDF_MAT_COLOR:\nfz_fill_image_mask(ctx, pr->dev, image, &image_ctm,\ngstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\nbreak;\ncase PDF_MAT_PATTERN:\nif (gstate->fill.pattern)\n{\nfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\npdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\ncase PDF_MAT_SHADE:\nif (gstate->fill.shade)\n{\nfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\nfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\n}\n}\nelse\n{\nfz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);\n}\nif (image->mask)\n{\nfz_pop_clip(ctx, pr->dev);\nif (gstate->blendmode)\nfz_end_group(ctx, pr->dev);\n}\nelse\npdf_end_group(ctx, pr, &softmask);\n}\nstatic void\nif (pr->clip)\n{\ngstate->clip_depth++;\nfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);\npr->clip = 0;\n}\nif (pr->super.hidden)\ndostroke = dofill = 0;\nif (dofill || dostroke)\ngstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\nif (dofill && dostroke)\n{\nif (gstate->stroke.alpha == 0)\n{\n}\nelse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n{\n}\nelse\n{\nknockout_group = 1;\nfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n}\n}\nif (dofill)\n{\nswitch (gstate->fill.kind)\n{\ncase PDF_MAT_NONE:\nbreak;\ncase PDF_MAT_COLOR:\nfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,\ngstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\nbreak;\ncase PDF_MAT_PATTERN:\nif (gstate->fill.pattern)\n{\nfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\npdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\ncase PDF_MAT_SHADE:\nif (gstate->fill.shade)\n{\nfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\nfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\n}\n}\nif (dostroke)\n{\nswitch (gstate->stroke.kind)\n{\ncase PDF_MAT_NONE:\nbreak;\ncase PDF_MAT_COLOR:\nfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,\ngstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\nbreak;\ncase PDF_MAT_PATTERN:\nif (gstate->stroke.pattern)\n{\nfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\npdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\ncase PDF_MAT_SHADE:\nif (gstate->stroke.shade)\n{\nfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\nfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\n}\n}\nif (knockout_group)\nfz_end_group(ctx, pr->dev);\nif (dofill || dostroke)\npdf_end_group(ctx, pr, &softmask);\n}", "contrast": "pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n{\npdf_gstate *gstate = pr->gstate + pr->gtop;\nfz_matrix image_ctm;\nfz_rect bbox;\nif (pr->super.hidden)\nreturn;\nbreak;\ncase PDF_MAT_SHADE:\nif (gstate->fill.shade)\n{\nfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\nbbox = fz_unit_rect;\nfz_transform_rect(&bbox, &image_ctm);\nif (image->mask && gstate->blendmode)\n{\nfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\nfz_try(ctx)\nfz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\nfz_catch(ctx)\n{\nfz_end_group(ctx, pr->dev);\nfz_rethrow(ctx);\n}\nfz_try(ctx)\npdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\nfz_always(ctx)\n{\nfz_pop_clip(ctx, pr->dev);\nfz_end_group(ctx, pr->dev);\n}\nfz_catch(ctx)\nfz_rethrow(ctx);\n}\nelse if (image->mask)\n{\nfz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\nfz_try(ctx)\npdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\nfz_always(ctx)\nfz_pop_clip(ctx, pr->dev);\nfz_catch(ctx)\nfz_rethrow(ctx);\n}\nelse\n{\nsoftmask_save softmask = { NULL };\ngstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\nfz_try(ctx)\npdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\nfz_always(ctx)\npdf_end_group(ctx, pr, &softmask);\nfz_catch(ctx)\nfz_rethrow(ctx);\n}\n}\nstatic void\nif (pr->clip)\n{\ngstate->clip_depth++;\nfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);\npr->clip = 0;\n}\nif (pr->super.hidden)\ndostroke = dofill = 0;\nif (dofill || dostroke)\ngstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\nif (dofill && dostroke)\n{\nif (gstate->stroke.alpha == 0)\n{\n}\nelse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n{\n}\nelse\n{\nknockout_group = 1;\nfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n}\n}\nif (dofill)\n{\nswitch (gstate->fill.kind)\n{\ncase PDF_MAT_NONE:\nbreak;\ncase PDF_MAT_COLOR:\nfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,\ngstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\nbreak;\ncase PDF_MAT_PATTERN:\nif (gstate->fill.pattern)\n{\nfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\npdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\ncase PDF_MAT_SHADE:\nif (gstate->fill.shade)\n{\nfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\nfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\n}\n}\nif (dostroke)\n{\nswitch (gstate->stroke.kind)\n{\ncase PDF_MAT_NONE:\nbreak;\ncase PDF_MAT_COLOR:\nfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,\ngstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\nbreak;\ncase PDF_MAT_PATTERN:\nif (gstate->stroke.pattern)\n{\nfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\npdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\ncase PDF_MAT_SHADE:\nif (gstate->stroke.shade)\n{\nfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\nfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\nfz_pop_clip(ctx, pr->dev);\n}\nbreak;\n}\n}\nif (knockout_group)\nfz_end_group(ctx, pr->dev);\nif (dofill || dostroke)\npdf_end_group(ctx, pr, &softmask);\n}", "label": 0}
{"index": 174391, "code": "bool asn1_write_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blob)\n{\nasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(num));\nasn1_write(data, blob->data, blob->length);\nasn1_pop_tag(data);\nreturn !data->has_error;\n}", "contrast": "bool asn1_write_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blob)\n{\nif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(num))) return false;\nif (!asn1_write(data, blob->data, blob->length)) return false;\nreturn asn1_pop_tag(data);\n}", "label": 0}
{"index": 174434, "code": "static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)\n{\nct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,\nsizeof(struct nfct_attr_grp_port));\nif (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))\nreturn;\nct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);\nct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);\nct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);\n}", "contrast": "static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)\n{\nif (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))\nreturn;\nct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,\nsizeof(struct nfct_attr_grp_port));\nct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);\nct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);\nct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);\n}", "label": 0}
{"index": 174445, "code": "int csum_len_for_type(int cst)\n{\nswitch (cst) {\ncase CSUM_NONE:\nreturn 1;\ncase CSUM_ARCHAIC:\nreturn 2;\ncase CSUM_MD4:\ncase CSUM_MD4_OLD:\ncase CSUM_MD4_BUSTED:\nreturn MD4_DIGEST_LEN;\ncase CSUM_MD5:\nreturn MD5_DIGEST_LEN;\n}\nreturn 0;\n}", "contrast": "int csum_len_for_type(int cst)\n{\nswitch (cst) {\ncase CSUM_NONE:\nreturn 1;\ncase CSUM_MD4_ARCHAIC:\nreturn 2;\ncase CSUM_MD4:\ncase CSUM_MD4_OLD:\ncase CSUM_MD4_BUSTED:\nreturn MD4_DIGEST_LEN;\ncase CSUM_MD5:\nreturn MD5_DIGEST_LEN;\n}\nreturn 0;\n}", "label": 0}
{"index": 174457, "code": "static struct posix_acl *jffs2_get_acl(struct inode *inode, int type)\n{\nstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\nstruct posix_acl *acl;\nchar *value = NULL;\nint rc, xprefix;\nswitch (type) {\ncase ACL_TYPE_ACCESS:\nacl = jffs2_iget_acl(inode, &f->i_acl_access);\nif (acl != JFFS2_ACL_NOT_CACHED)\nreturn acl;\nxprefix = JFFS2_XPREFIX_ACL_ACCESS;\nbreak;\ncase ACL_TYPE_DEFAULT:\nacl = jffs2_iget_acl(inode, &f->i_acl_default);\nif (acl != JFFS2_ACL_NOT_CACHED)\nreturn acl;\nxprefix = JFFS2_XPREFIX_ACL_DEFAULT;\nbreak;\ndefault:\nreturn ERR_PTR(-EINVAL);\n}\nrc = do_jffs2_getxattr(inode, xprefix, \"\", NULL, 0);\nif (rc > 0) {\nvalue = kmalloc(rc, GFP_KERNEL);\nif (!value)\nreturn ERR_PTR(-ENOMEM);\nrc = do_jffs2_getxattr(inode, xprefix, \"\", value, rc);\n}\nif (rc > 0) {\nacl = jffs2_acl_from_medium(value, rc);\n} else if (rc == -ENODATA || rc == -ENOSYS) {\nacl = NULL;\n} else {\nacl = ERR_PTR(rc);\n}\nif (value)\nkfree(value);\nif (!IS_ERR(acl)) {\nswitch (type) {\ncase ACL_TYPE_ACCESS:\njffs2_iset_acl(inode, &f->i_acl_access, acl);\nbreak;\ncase ACL_TYPE_DEFAULT:\njffs2_iset_acl(inode, &f->i_acl_default, acl);\nbreak;\n}\n}\nreturn acl;\n}", "contrast": "static struct posix_acl *jffs2_get_acl(struct inode *inode, int type)\nstruct posix_acl *jffs2_get_acl(struct inode *inode, int type)\n{\nstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\nstruct posix_acl *acl;\nchar *value = NULL;\nint rc, xprefix;\nswitch (type) {\ncase ACL_TYPE_ACCESS:\nacl = jffs2_iget_acl(inode, &f->i_acl_access);\nif (acl != JFFS2_ACL_NOT_CACHED)\nreturn acl;\nxprefix = JFFS2_XPREFIX_ACL_ACCESS;\nbreak;\ncase ACL_TYPE_DEFAULT:\nacl = jffs2_iget_acl(inode, &f->i_acl_default);\nif (acl != JFFS2_ACL_NOT_CACHED)\nreturn acl;\nxprefix = JFFS2_XPREFIX_ACL_DEFAULT;\nbreak;\ndefault:\nreturn ERR_PTR(-EINVAL);\n}\nrc = do_jffs2_getxattr(inode, xprefix, \"\", NULL, 0);\nif (rc > 0) {\nvalue = kmalloc(rc, GFP_KERNEL);\nif (!value)\nreturn ERR_PTR(-ENOMEM);\nrc = do_jffs2_getxattr(inode, xprefix, \"\", value, rc);\n}\nif (rc > 0) {\nacl = jffs2_acl_from_medium(value, rc);\n} else if (rc == -ENODATA || rc == -ENOSYS) {\nacl = NULL;\n} else {\nacl = ERR_PTR(rc);\n}\nif (value)\nkfree(value);\nif (!IS_ERR(acl)) {\nswitch (type) {\ncase ACL_TYPE_ACCESS:\njffs2_iset_acl(inode, &f->i_acl_access, acl);\nbreak;\ncase ACL_TYPE_DEFAULT:\njffs2_iset_acl(inode, &f->i_acl_default, acl);\nbreak;\n}\n}\nreturn acl;\n}", "label": 0}
{"index": 174461, "code": "walk_string(fz_context *ctx, int uni, int remove, editable_str *str)\n{\nint rune;\nif (str->utf8 == NULL)\nreturn;\ndo\n{\nchar *s = &str->utf8[str->pos];\nsize_t len;\nint n = fz_chartorune(&rune, s);\nif (rune == uni)\n{\nstr->pos += n;\n}\nelse if (uni == 32) {\nbreak;\n}\nelse if (rune == 32) {\n}\nelse\n{\nstr->pos = -1;\nbreak;\n}\nif (remove)\n{\nlen = strlen(s+n);\nmemmove(s, s+n, len+1);\nstr->edited = 1;\n}\n}\nwhile (rune != uni);\n}", "contrast": "walk_string(fz_context *ctx, int uni, int remove, editable_str *str)\n{\nint rune;\nif (str->utf8 == NULL || str->pos == -1)\nreturn;\ndo\n{\nchar *s = &str->utf8[str->pos];\nsize_t len;\nint n = fz_chartorune(&rune, s);\nif (rune == uni)\n{\nstr->pos += n;\n}\nelse if (uni == 32) {\nbreak;\n}\nelse if (rune == 32) {\n}\nelse\n{\nstr->pos = -1;\nbreak;\n}\nif (remove)\n{\nlen = strlen(s+n);\nmemmove(s, s+n, len+1);\nstr->edited = 1;\n}\n}\nwhile (rune != uni);\n}", "label": 0}
{"index": 174469, "code": "static int ldb_dn_escape_internal(char *dst, const char *src, int len)\n{\nconst char *p, *s;\nchar *d;\nsize_t l;\np = s = src;\nd = dst;\nwhile (p - src < len) {\np += strcspn(p, \",=\\n\\r+<>#;\\\\\\\" \");\nif (p - src == len)\nbreak;\nmemcpy(d, s, p - s);\nd += (p - s);\nswitch (*p) {\ncase ' ':\nif (p == src || (p-src)==(len-1)) {\n*d++ = '\\\\';\n*d++ = *p++;\n} else {\n*d++ = *p++;\n}\nbreak;\n*d++ = '\\\\';\n*d++ = *p++;\n} else {\n*d++ = *p++;\n}\nbreak;\ncase '?':\n*d++ = '\\\\';\n*d++ = *p++;\nbreak;\ndefault: {\nunsigned char v;\nconst char *hexbytes = \"0123456789ABCDEF\";\nv = *(const unsigned char *)p;\n*d++ = '\\\\';\n*d++ = hexbytes[v>>4];\n*d++ = hexbytes[v&0xF];\np++;\nbreak;\n}\n}\ns = p;\n}", "contrast": "static int ldb_dn_escape_internal(char *dst, const char *src, int len)\n{\nchar c;\nchar *d;\nint i;\nd = dst;\nfor (i = 0; i < len; i++){\nc = src[i];\nswitch (c) {\ncase ' ':\nif (i == 0 || i == len - 1) {\n*d++ = '\\\\';\n*d++ = c;\n} else {\n*d++ = c;\n}\nbreak;\n*d++ = '\\\\';\n*d++ = *p++;\n} else {\n*d++ = *p++;\n}\nbreak;\ncase '?':\n*d++ = '\\\\';\n*d++ = c;\nbreak;\ncase ';':\ncase '\\r':\ncase '\\n':\ncase '=':\ncase '\\0': {\nunsigned char v;\nconst char *hexbytes = \"0123456789ABCDEF\";\nv = (const unsigned char)c;\n*d++ = '\\\\';\n*d++ = hexbytes[v>>4];\n*d++ = hexbytes[v&0xF];\nbreak;\n}\ndefault:\n*d++ = c;\n}\n}", "label": 0}
{"index": 174473, "code": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\nTALLOC_CTX *ctx, const char *src, size_t n)\n{\nsize_t size=0;\nchar *dest;\nif (!src) {\nreturn NULL;\n}\ndest = talloc_array(ctx, char, 2*(n+1));\nif (dest == NULL) {\nreturn NULL;\n}\nwhile (n-- && *src) {\nsize_t c_size;\ncodepoint_t c = next_codepoint_handle(iconv_handle, src, &c_size);\nsrc += c_size;\nc = toupper_m(c);\nc_size = push_codepoint_handle(iconv_handle, dest+size, c);\nif (c_size == -1) {\ntalloc_free(dest);\nreturn NULL;\n}\nsize += c_size;\n}\ndest[size] = 0;\ndest = talloc_realloc(ctx, dest, char, size+1);\ntalloc_set_name_const(dest, dest);\nreturn dest;\n}", "contrast": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\nTALLOC_CTX *ctx, const char *src, size_t n)\n{\nsize_t size=0;\nchar *dest;\nif (!src) {\nreturn NULL;\n}\ndest = talloc_array(ctx, char, 2*(n+1));\nif (dest == NULL) {\nreturn NULL;\n}\nwhile (n-- && *src) {\nsize_t c_size;\ncodepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,\nCH_UNIX, &c_size);\nsrc += c_size;\nc = toupper_m(c);\nc_size = push_codepoint_handle(iconv_handle, dest+size, c);\nif (c_size == -1) {\ntalloc_free(dest);\nreturn NULL;\n}\nsize += c_size;\n}\ndest[size] = 0;\ndest = talloc_realloc(ctx, dest, char, size+1);\ntalloc_set_name_const(dest, dest);\nreturn dest;\n}", "label": 0}
{"index": 174477, "code": "static NTSTATUS do_connect(TALLOC_CTX *ctx,\nconst char *server,\nconst char *share,\nconst struct user_auth_info *auth_info,\nbool show_sessetup,\nbool force_encrypt,\nint max_protocol,\nint port,\nint name_type,\nstruct cli_state **pcli)\n{\nstruct cli_state *c = NULL;\nchar *servicename;\nchar *sharename;\nchar *newserver, *newshare;\nconst char *username;\nconst char *password;\nconst char *domain;\nNTSTATUS status;\nint flags = 0;\nservicename = talloc_strdup(ctx,share);\nsharename += 2;\nif (server == NULL) {\nserver = sharename;\n}\nsharename = strchr_m(sharename,'\\\\');\nif (!sharename) {\nreturn NT_STATUS_NO_MEMORY;\n}\n*sharename = 0;\nsharename++;\n}", "contrast": "static NTSTATUS do_connect(TALLOC_CTX *ctx,\nconst char *server,\nconst char *share,\nconst struct user_auth_info *auth_info,\nbool show_sessetup,\nbool force_encrypt,\nint max_protocol,\nint port,\nint name_type,\nstruct cli_state **pcli)\n{\nstruct cli_state *c = NULL;\nchar *servicename;\nchar *sharename;\nchar *newserver, *newshare;\nconst char *username;\nconst char *password;\nconst char *domain;\nNTSTATUS status;\nint flags = 0;\nint signing_state = get_cmdline_auth_info_signing_state(auth_info);\nif (force_encrypt) {\nsigning_state = SMB_SIGNING_REQUIRED;\n}\nservicename = talloc_strdup(ctx,share);\nsharename += 2;\nif (server == NULL) {\nserver = sharename;\n}\nsharename = strchr_m(sharename,'\\\\');\nif (!sharename) {\nreturn NT_STATUS_NO_MEMORY;\n}\n*sharename = 0;\nsharename++;\n}", "label": 0}
{"index": 174478, "code": "SMBC_server_internal(TALLOC_CTX *ctx,\nSMBCCTX *context,\nbool connect_if_not_found,\nconst char *server,\nuint16_t port,\nconst char *share,\nchar **pp_workgroup,\nchar **pp_username,\nchar **pp_password,\nbool *in_cache)\n{\nSMBCSRV *srv=NULL;\nchar *workgroup = NULL;\nstruct cli_state *c = NULL;\nconst char *server_n = server;\nint is_ipc = (share != NULL && strcmp(share, \"IPC$\") == 0);\nuint32_t fs_attrs = 0;\nconst char *username_used;\nNTSTATUS status;\nchar *newserver, *newshare;\nint flags = 0;\nstruct smbXcli_tcon *tcon = NULL;\nZERO_STRUCT(c);\n*in_cache = false;\nif (server[0] == 0) {\nerrno = EPERM;\nreturn NULL;\n}\nsrv = SMBC_find_server(ctx, context, server, share,\npp_workgroup, pp_username, pp_password);\nif (srv &&\nshare != NULL && *share != '\\0' &&\nsmbc_getOptionOneSharePerServer(context)) {\nif (!cli_state_has_tcon(srv->cli)) {\nSMBC_call_auth_fn(ctx, context,\nsmbXcli_conn_remote_name(srv->cli->conn),\nsrv->cli->share,\npp_workgroup,\npp_username,\npp_password);\nif (!*pp_workgroup || !*pp_username || !*pp_password) {\nerrno = ENOMEM;\ncli_shutdown(srv->cli);\nsrv->cli = NULL;\nsmbc_getFunctionRemoveCachedServer(context)(context,\nsrv);\nreturn NULL;\n}\nstatus = cli_tree_connect(srv->cli,\nsrv->cli->share,\n\"?????\",\n*pp_password,\nstrlen(*pp_password)+1);\nif (!NT_STATUS_IS_OK(status)) {\nerrno = map_errno_from_nt_status(status);\ncli_shutdown(srv->cli);\nsrv->cli = NULL;\nsmbc_getFunctionRemoveCachedServer(context)(context,\nsrv);\nsrv = NULL;\n}\nif (is_ipc) {\nDEBUG(4,\n(\"IPC$ so ignore case sensitivity\\n\"));\nstatus = NT_STATUS_OK;\n} else {\nstatus = cli_get_fs_attr_info(c, &fs_attrs);\n}\nif (!NT_STATUS_IS_OK(status)) {\nDEBUG(4, (\"Could not retrieve \"\n\"case sensitivity flag: %s.\\n\",\nnt_errstr(status)));\nif (smbc_getOptionCaseSensitive(context)) {\ncli_set_case_sensitive(c, True);\n} else {\ncli_set_case_sensitive(c, False);\n}\n} else if (!is_ipc) {\nDEBUG(4,\n(\"Case sensitive: %s\\n\",\n(fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n? \"True\"\n: \"False\")));\ncli_set_case_sensitive(\nc,\n(fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n? True\n: False));\n}\nif (srv) {\nconst char *remote_name =\nsmbXcli_conn_remote_name(srv->cli->conn);\nsrv->dev = (dev_t)(str_checksum(remote_name) ^\nstr_checksum(srv->cli->share));\n}\n}\n}\nif (srv) {\n*in_cache = true;\ngoto done;\n}\nif (! connect_if_not_found) {\nreturn NULL;\n}\nif (!*pp_workgroup || !*pp_username || !*pp_password) {\nerrno = ENOMEM;\nreturn NULL;\n}\nDEBUG(4,(\"SMBC_server: server_n=[%s] server=[%s]\\n\", server_n, server));\nDEBUG(4,(\" -> server_n=[%s] server=[%s]\\n\", server_n, server));\nstatus = NT_STATUS_UNSUCCESSFUL;\nif (smbc_getOptionUseKerberos(context)) {\nflags |= CLI_FULL_CONNECTION_USE_KERBEROS;\n}\nif (smbc_getOptionFallbackAfterKerberos(context)) {\nflags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;\n}\nif (smbc_getOptionUseCCache(context)) {\nflags |= CLI_FULL_CONNECTION_USE_CCACHE;\n}\nif (smbc_getOptionUseNTHash(context)) {\nflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\nflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n}\nif (port == 0) {\nif (share == NULL || *share == '\\0' || is_ipc) {\nstatus = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\nsmbc_getNetbiosName(context),\nSMB_SIGNING_DEFAULT, flags, &c);\n}\n}", "contrast": "SMBC_server_internal(TALLOC_CTX *ctx,\nSMBCCTX *context,\nbool connect_if_not_found,\nconst char *server,\nuint16_t port,\nconst char *share,\nchar **pp_workgroup,\nchar **pp_username,\nchar **pp_password,\nbool *in_cache)\n{\nSMBCSRV *srv=NULL;\nchar *workgroup = NULL;\nstruct cli_state *c = NULL;\nconst char *server_n = server;\nint is_ipc = (share != NULL && strcmp(share, \"IPC$\") == 0);\nuint32_t fs_attrs = 0;\nconst char *username_used;\nNTSTATUS status;\nchar *newserver, *newshare;\nint flags = 0;\nstruct smbXcli_tcon *tcon = NULL;\nint signing_state = SMB_SIGNING_DEFAULT;\nZERO_STRUCT(c);\n*in_cache = false;\nif (server[0] == 0) {\nerrno = EPERM;\nreturn NULL;\n}\nsrv = SMBC_find_server(ctx, context, server, share,\npp_workgroup, pp_username, pp_password);\nif (srv &&\nshare != NULL && *share != '\\0' &&\nsmbc_getOptionOneSharePerServer(context)) {\nif (!cli_state_has_tcon(srv->cli)) {\nSMBC_call_auth_fn(ctx, context,\nsmbXcli_conn_remote_name(srv->cli->conn),\nsrv->cli->share,\npp_workgroup,\npp_username,\npp_password);\nif (!*pp_workgroup || !*pp_username || !*pp_password) {\nerrno = ENOMEM;\ncli_shutdown(srv->cli);\nsrv->cli = NULL;\nsmbc_getFunctionRemoveCachedServer(context)(context,\nsrv);\nreturn NULL;\n}\nstatus = cli_tree_connect(srv->cli,\nsrv->cli->share,\n\"?????\",\n*pp_password,\nstrlen(*pp_password)+1);\nif (!NT_STATUS_IS_OK(status)) {\nerrno = map_errno_from_nt_status(status);\ncli_shutdown(srv->cli);\nsrv->cli = NULL;\nsmbc_getFunctionRemoveCachedServer(context)(context,\nsrv);\nsrv = NULL;\n}\nif (is_ipc) {\nDEBUG(4,\n(\"IPC$ so ignore case sensitivity\\n\"));\nstatus = NT_STATUS_OK;\n} else {\nstatus = cli_get_fs_attr_info(c, &fs_attrs);\n}\nif (!NT_STATUS_IS_OK(status)) {\nDEBUG(4, (\"Could not retrieve \"\n\"case sensitivity flag: %s.\\n\",\nnt_errstr(status)));\nif (smbc_getOptionCaseSensitive(context)) {\ncli_set_case_sensitive(c, True);\n} else {\ncli_set_case_sensitive(c, False);\n}\n} else if (!is_ipc) {\nDEBUG(4,\n(\"Case sensitive: %s\\n\",\n(fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n? \"True\"\n: \"False\")));\ncli_set_case_sensitive(\nc,\n(fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n? True\n: False));\n}\nif (srv) {\nconst char *remote_name =\nsmbXcli_conn_remote_name(srv->cli->conn);\nsrv->dev = (dev_t)(str_checksum(remote_name) ^\nstr_checksum(srv->cli->share));\n}\n}\n}\nif (srv) {\n*in_cache = true;\ngoto done;\n}\nif (! connect_if_not_found) {\nreturn NULL;\n}\nif (!*pp_workgroup || !*pp_username || !*pp_password) {\nerrno = ENOMEM;\nreturn NULL;\n}\nDEBUG(4,(\"SMBC_server: server_n=[%s] server=[%s]\\n\", server_n, server));\nDEBUG(4,(\" -> server_n=[%s] server=[%s]\\n\", server_n, server));\nstatus = NT_STATUS_UNSUCCESSFUL;\nif (smbc_getOptionUseKerberos(context)) {\nflags |= CLI_FULL_CONNECTION_USE_KERBEROS;\n}\nif (smbc_getOptionFallbackAfterKerberos(context)) {\nflags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;\n}\nif (smbc_getOptionUseCCache(context)) {\nflags |= CLI_FULL_CONNECTION_USE_CCACHE;\n}\nif (smbc_getOptionUseNTHash(context)) {\nflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\nflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n}\nif (context->internal->smb_encryption_level != SMBC_ENCRYPTLEVEL_NONE) {\nsigning_state = SMB_SIGNING_REQUIRED;\n}\nif (port == 0) {\nif (share == NULL || *share == '\\0' || is_ipc) {\nstatus = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\nsmbc_getNetbiosName(context),\nsigning_state, flags, &c);\n}\n}", "label": 0}
{"index": 174479, "code": "datum_to_json(Datum val, bool is_null, StringInfo result,\nJsonTypeCategory tcategory, Oid outfuncoid,\nbool key_scalar)\n{\nchar\t   *outputstr;\ntext\t   *jsontext;\nchar       *outputstr;\ntext       *jsontext;\nAssert(!(key_scalar && is_null));\nif (key_scalar &&\n(tcategory == JSONTYPE_ARRAY ||\ntcategory == JSONTYPE_COMPOSITE ||\ntcategory == JSONTYPE_JSON ||\ntcategory == JSONTYPE_CAST))\nereport(ERROR,\n(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\nerrmsg(\"key value must be scalar, not array, composite, or json\")));\nswitch (tcategory)\n{\ncase JSONTYPE_ARRAY:\narray_to_json_internal(val, result, false);\nbreak;\ncase JSONTYPE_COMPOSITE:\ncomposite_to_json(val, result, false);\nbreak;\ncase JSONTYPE_BOOL:\noutputstr = DatumGetBool(val) ? \"true\" : \"false\";\nif (key_scalar)\nescape_json(result, outputstr);\nelse\nappendStringInfoString(result, outputstr);\nbreak;\ncase JSONTYPE_NUMERIC:\noutputstr = OidOutputFunctionCall(outfuncoid, val);\nif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\nappendStringInfoString(result, outputstr);\nelse\nescape_json(result, outputstr);\npfree(outputstr);\nbreak;\ncase JSONTYPE_DATE:\n{\nDateADT\t\tdate;\nstruct pg_tm tm;\nchar\t\tbuf[MAXDATELEN + 1];\ndate = DatumGetDateADT(val);\nif (DATE_NOT_FINITE(date))\n{\nappendStringInfoString(result, DT_INFINITY);\n}\nelse\n{\nj2date(date + POSTGRES_EPOCH_JDATE,\n&(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\nEncodeDateOnly(&tm, USE_XSD_DATES, buf);\nappendStringInfo(result, \"\\\"%s\\\"\", buf);\n}\n}\nbreak;\ncase JSONTYPE_TIMESTAMP:\n{\nTimestamp\ttimestamp;\nstruct pg_tm tm;\nfsec_t\t\tfsec;\nchar\t\tbuf[MAXDATELEN + 1];\ntimestamp = DatumGetTimestamp(val);\nif (TIMESTAMP_NOT_FINITE(timestamp))\n{\nappendStringInfoString(result, DT_INFINITY);\n}\nelse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n{\nEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\nappendStringInfo(result, \"\\\"%s\\\"\", buf);\n}\nelse\nereport(ERROR,\n(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\nerrmsg(\"timestamp out of range\")));\n}\nbreak;\ncase JSONTYPE_TIMESTAMPTZ:\n{\nTimestampTz timestamp;\nstruct pg_tm tm;\nint\t\t\ttz;\nfsec_t\t\tfsec;\nconst char *tzn = NULL;\nchar\t\tbuf[MAXDATELEN + 1];\ntimestamp = DatumGetTimestamp(val);\nif (TIMESTAMP_NOT_FINITE(timestamp))\n{\nappendStringInfoString(result, DT_INFINITY);\n}\nelse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n{\nEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\nappendStringInfo(result, \"\\\"%s\\\"\", buf);\n}\nelse\nereport(ERROR,\n(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\nerrmsg(\"timestamp out of range\")));\n}\nbreak;\ncase JSONTYPE_JSON:\noutputstr = OidOutputFunctionCall(outfuncoid, val);\nappendStringInfoString(result, outputstr);\npfree(outputstr);\nbreak;\ncase JSONTYPE_CAST:\njsontext = DatumGetTextP(OidFunctionCall1(outfuncoid, val));\noutputstr = text_to_cstring(jsontext);\nappendStringInfoString(result, outputstr);\npfree(outputstr);\npfree(jsontext);\nbreak;\ndefault:\noutputstr = OidOutputFunctionCall(outfuncoid, val);\nescape_json(result, outputstr);\npfree(outputstr);\nbreak;\n}\n}", "contrast": "datum_to_json(Datum val, bool is_null, StringInfo result,\nJsonTypeCategory tcategory, Oid outfuncoid,\nbool key_scalar)\n{\nchar\t   *outputstr;\ntext\t   *jsontext;\nchar       *outputstr;\ntext       *jsontext;\ncheck_stack_depth();\nAssert(!(key_scalar && is_null));\nif (key_scalar &&\n(tcategory == JSONTYPE_ARRAY ||\ntcategory == JSONTYPE_COMPOSITE ||\ntcategory == JSONTYPE_JSON ||\ntcategory == JSONTYPE_CAST))\nereport(ERROR,\n(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\nerrmsg(\"key value must be scalar, not array, composite, or json\")));\nswitch (tcategory)\n{\ncase JSONTYPE_ARRAY:\narray_to_json_internal(val, result, false);\nbreak;\ncase JSONTYPE_COMPOSITE:\ncomposite_to_json(val, result, false);\nbreak;\ncase JSONTYPE_BOOL:\noutputstr = DatumGetBool(val) ? \"true\" : \"false\";\nif (key_scalar)\nescape_json(result, outputstr);\nelse\nappendStringInfoString(result, outputstr);\nbreak;\ncase JSONTYPE_NUMERIC:\noutputstr = OidOutputFunctionCall(outfuncoid, val);\nif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\nappendStringInfoString(result, outputstr);\nelse\nescape_json(result, outputstr);\npfree(outputstr);\nbreak;\ncase JSONTYPE_DATE:\n{\nDateADT\t\tdate;\nstruct pg_tm tm;\nchar\t\tbuf[MAXDATELEN + 1];\ndate = DatumGetDateADT(val);\nif (DATE_NOT_FINITE(date))\n{\nappendStringInfoString(result, DT_INFINITY);\n}\nelse\n{\nj2date(date + POSTGRES_EPOCH_JDATE,\n&(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\nEncodeDateOnly(&tm, USE_XSD_DATES, buf);\nappendStringInfo(result, \"\\\"%s\\\"\", buf);\n}\n}\nbreak;\ncase JSONTYPE_TIMESTAMP:\n{\nTimestamp\ttimestamp;\nstruct pg_tm tm;\nfsec_t\t\tfsec;\nchar\t\tbuf[MAXDATELEN + 1];\ntimestamp = DatumGetTimestamp(val);\nif (TIMESTAMP_NOT_FINITE(timestamp))\n{\nappendStringInfoString(result, DT_INFINITY);\n}\nelse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n{\nEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\nappendStringInfo(result, \"\\\"%s\\\"\", buf);\n}\nelse\nereport(ERROR,\n(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\nerrmsg(\"timestamp out of range\")));\n}\nbreak;\ncase JSONTYPE_TIMESTAMPTZ:\n{\nTimestampTz timestamp;\nstruct pg_tm tm;\nint\t\t\ttz;\nfsec_t\t\tfsec;\nconst char *tzn = NULL;\nchar\t\tbuf[MAXDATELEN + 1];\ntimestamp = DatumGetTimestamp(val);\nif (TIMESTAMP_NOT_FINITE(timestamp))\n{\nappendStringInfoString(result, DT_INFINITY);\n}\nelse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n{\nEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\nappendStringInfo(result, \"\\\"%s\\\"\", buf);\n}\nelse\nereport(ERROR,\n(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\nerrmsg(\"timestamp out of range\")));\n}\nbreak;\ncase JSONTYPE_JSON:\noutputstr = OidOutputFunctionCall(outfuncoid, val);\nappendStringInfoString(result, outputstr);\npfree(outputstr);\nbreak;\ncase JSONTYPE_CAST:\njsontext = DatumGetTextP(OidFunctionCall1(outfuncoid, val));\noutputstr = text_to_cstring(jsontext);\nappendStringInfoString(result, outputstr);\npfree(outputstr);\npfree(jsontext);\nbreak;\ndefault:\noutputstr = OidOutputFunctionCall(outfuncoid, val);\nescape_json(result, outputstr);\npfree(outputstr);\nbreak;\n}\n}", "label": 0}
{"index": 174500, "code": "zsetstrokecolor(i_ctx_t * i_ctx_p)\n{\nint code;\ncode = zswapcolors(i_ctx_p);\nif (code < 0)\ncheck_estack(1);\npush_op_estack(setstrokecolor_cont);\ncode = zsetcolor(i_ctx_p);\nif (code >= 0)\nif (code >= 0)\nreturn o_push_estack;\nreturn code;\n}", "contrast": "zsetstrokecolor(i_ctx_t * i_ctx_p)\n{\nint code;\nes_ptr iesp = esp;\ncode = zswapcolors(i_ctx_p);\nif (code < 0)\ncheck_estack(1);\npush_op_estack(setstrokecolor_cont);\ncode = zsetcolor(i_ctx_p);\nif (code >= 0)\nif (code >= 0)\nreturn o_push_estack;\nesp = iesp;\n(void)zswapcolors(i_ctx_p);\nreturn code;\n}", "label": 0}
{"index": 174520, "code": "int test_mod_exp(BIO *bp, BN_CTX *ctx)\n{\nBIGNUM *a, *b, *c, *d, *e;\nint i;\na = BN_new();\nb = BN_new();\nc = BN_new();\nd = BN_new();\ne = BN_new();\nBN_one(a);\nBN_one(b);\nBN_zero(c);\nif (BN_mod_exp(d, a, b, c, ctx)) {\nfprintf(stderr, \"BN_mod_exp with zero modulus succeeded!\\n\");\nreturn 0;\n}\nBN_bntest_rand(c, 30, 0, 1);\nfor (i = 0; i < num2; i++) {\nBN_bntest_rand(a, 20 + i * 5, 0, 0);\nBN_bntest_rand(b, 2 + i, 0, 0);\nif (!BN_mod_exp(d, a, b, c, ctx))\nreturn (0);\nif (bp != NULL) {\nif (!results) {\nBN_print(bp, a);\nBIO_puts(bp, \" ^ \");\nBN_print(bp, b);\nBIO_puts(bp, \" % \");\nBN_print(bp, c);\nBIO_puts(bp, \" - \");\n}\nBN_print(bp, d);\nBIO_puts(bp, \"\\n\");\n}\nBN_exp(e, a, b, ctx);\nBN_sub(e, e, d);\nBN_div(a, b, e, c, ctx);\nif (!BN_is_zero(b)) {\nfprintf(stderr, \"Modulo exponentiation test failed!\\n\");\nreturn 0;\n}\n}\nBN_free(a);\nBN_free(b);\nBN_free(c);\nBN_zero(c);\nif (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\nfprintf(stderr, \"BN_mod_exp_mont_consttime with zero modulus \"\n\"succeeded\\n\");\nreturn 0;\n}\nBN_set_word(c, 16);\nif (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\nfprintf(stderr, \"BN_mod_exp_mont_consttime with even modulus \"\n\"succeeded\\n\");\nreturn 0;\n}\nBN_bntest_rand(c, 30, 0, 1);\nfor (i = 0; i < num2; i++) {\nBN_bntest_rand(a, 20 + i * 5, 0, 0);\nBN_bntest_rand(b, 2 + i, 0, 0);\nif (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))\nreturn (00);\nif (bp != NULL) {\nif (!results) {\nBN_print(bp, a);\nBIO_puts(bp, \" ^ \");\nBN_print(bp, b);\nBIO_puts(bp, \" % \");\nBN_print(bp, c);\nBIO_puts(bp, \" - \");\n}\nBN_print(bp, d);\nBIO_puts(bp, \"\\n\");\n}\nBN_exp(e, a, b, ctx);\nBN_sub(e, e, d);\nBN_div(a, b, e, c, ctx);\nif (!BN_is_zero(b)) {\nfprintf(stderr, \"Modulo exponentiation test failed!\\n\");\nreturn 0;\n}\n}\nBN_free(a);\nBN_free(b);\nBN_free(c);\nBN_free(d);\nBN_free(e);\nreturn (1);\n}", "contrast": "int test_mod_exp(BIO *bp, BN_CTX *ctx)\n{\nBIGNUM *a, *b, *c, *d, *e;\nint i;\na = BN_new();\nb = BN_new();\nc = BN_new();\nd = BN_new();\ne = BN_new();\nBN_one(a);\nBN_one(b);\nBN_zero(c);\nif (BN_mod_exp(d, a, b, c, ctx)) {\nfprintf(stderr, \"BN_mod_exp with zero modulus succeeded!\\n\");\nreturn 0;\n}\nBN_bntest_rand(c, 30, 0, 1);\nfor (i = 0; i < num2; i++) {\nBN_bntest_rand(a, 20 + i * 5, 0, 0);\nBN_bntest_rand(b, 2 + i, 0, 0);\nif (!BN_mod_exp(d, a, b, c, ctx))\nreturn (0);\nif (bp != NULL) {\nif (!results) {\nBN_print(bp, a);\nBIO_puts(bp, \" ^ \");\nBN_print(bp, b);\nBIO_puts(bp, \" % \");\nBN_print(bp, c);\nBIO_puts(bp, \" - \");\n}\nBN_print(bp, d);\nBIO_puts(bp, \"\\n\");\n}\nBN_exp(e, a, b, ctx);\nBN_sub(e, e, d);\nBN_div(a, b, e, c, ctx);\nif (!BN_is_zero(b)) {\nfprintf(stderr, \"Modulo exponentiation test failed!\\n\");\nreturn 0;\n}\n}\nBN_hex2bn(&a, \"050505050505\");\nBN_hex2bn(&b, \"02\");\nBN_hex2bn(&c,\n\"4141414141414141414141274141414141414141414141414141414141414141\"\n\"4141414141414141414141414141414141414141414141414141414141414141\"\n\"4141414141414141414141800000000000000000000000000000000000000000\"\n\"0000000000000000000000000000000000000000000000000000000000000000\"\n\"0000000000000000000000000000000000000000000000000000000000000000\"\n\"0000000000000000000000000000000000000000000000000000000001\");\nBN_mod_exp(d, a, b, c, ctx);\nBN_mul(e, a, a, ctx);\nif (BN_cmp(d, e)) {\nfprintf(stderr, \"BN_mod_exp and BN_mul produce different results!\\n\");\nreturn 0;\n}\nBN_free(a);\nBN_free(b);\nBN_free(c);\nBN_zero(c);\nif (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\nfprintf(stderr, \"BN_mod_exp_mont_consttime with zero modulus \"\n\"succeeded\\n\");\nreturn 0;\n}\nBN_set_word(c, 16);\nif (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\nfprintf(stderr, \"BN_mod_exp_mont_consttime with even modulus \"\n\"succeeded\\n\");\nreturn 0;\n}\nBN_bntest_rand(c, 30, 0, 1);\nfor (i = 0; i < num2; i++) {\nBN_bntest_rand(a, 20 + i * 5, 0, 0);\nBN_bntest_rand(b, 2 + i, 0, 0);\nif (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))\nreturn (00);\nif (bp != NULL) {\nif (!results) {\nBN_print(bp, a);\nBIO_puts(bp, \" ^ \");\nBN_print(bp, b);\nBIO_puts(bp, \" % \");\nBN_print(bp, c);\nBIO_puts(bp, \" - \");\n}\nBN_print(bp, d);\nBIO_puts(bp, \"\\n\");\n}\nBN_exp(e, a, b, ctx);\nBN_sub(e, e, d);\nBN_div(a, b, e, c, ctx);\nif (!BN_is_zero(b)) {\nfprintf(stderr, \"Modulo exponentiation test failed!\\n\");\nreturn 0;\n}\n}\nBN_free(a);\nBN_free(b);\nBN_free(c);\nBN_free(d);\nBN_free(e);\nreturn (1);\n}", "label": 0}
{"index": 174521, "code": "static void lsi_execute_script(LSIState *s)\n{\nPCIDevice *pci_dev = PCI_DEVICE(s);\nuint32_t insn;\nuint32_t addr, addr_high;\nint opcode;\nint insn_processed = 0;\ns->istat1 |= LSI_ISTAT1_SRUN;\nagain:\ns->istat1 |= LSI_ISTAT1_SRUN;\nagain:\ninsn_processed++;\ninsn = read_dword(s, s->dsp);\nif (!insn) {\ns->ia = s->dsp - 8;\nif (insn & (1 << 29)) {\naddr = read_dword(s, addr);\n} else if (insn & (1 << 28)) {\nuint32_t buf[2];\nint32_t offset;\noffset = sextract32(addr, 0, 24);\npci_dma_read(pci_dev, s->dsa + offset, buf, 8);\ns->dbc = cpu_to_le32(buf[0]) & 0xffffff;\ns->rbc = s->dbc;\naddr = cpu_to_le32(buf[1]);\nif (lsi_dma_40bit(s))\naddr_high = cpu_to_le32(buf[0]) >> 24;\nelse if (lsi_dma_ti64bit(s)) {\nint selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\nswitch (selector) {\ncase 0 ... 0x0f:\naddr_high = s->scratch[2 + selector];\nbreak;\ncase 0x10:\naddr_high = s->mmrs;\nbreak;\ncase 0x11:\naddr_high = s->mmws;\nbreak;\ncase 0x12:\naddr_high = s->sfs;\nbreak;\ncase 0x13:\naddr_high = s->drs;\nbreak;\ncase 0x14:\naddr_high = s->sbms;\nbreak;\ncase 0x15:\naddr_high = s->dbms;\nbreak;\ndefault:\nqemu_log_mask(LOG_GUEST_ERROR,\n\"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n\"for 64-bit DMA block move\", selector);\nbreak;\n}\n}\n} else if (lsi_dma_64bit(s)) {\ns->dbms = read_dword(s, s->dsp);\ns->dsp += 4;\ns->ia = s->dsp - 12;\n}\nif ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\ntrace_lsi_execute_script_blockmove_badphase(\nscsi_phase_name(s->sstat1),\nscsi_phase_name(insn >> 24));\nlsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\nbreak;\n}\ns->dnad = addr;\ns->dnad64 = addr_high;\nswitch (s->sstat1 & 0x7) {\ncase PHASE_DO:\ns->waiting = LSI_DMA_SCRIPTS;\nlsi_do_dma(s, 1);\nif (s->waiting)\ns->waiting = LSI_DMA_IN_PROGRESS;\nbreak;\ncase PHASE_DI:\ns->waiting = LSI_DMA_SCRIPTS;\nlsi_do_dma(s, 0);\nif (s->waiting)\ns->waiting = LSI_DMA_IN_PROGRESS;\nbreak;\ncase PHASE_CMD:\nlsi_do_command(s);\nbreak;\ncase PHASE_ST:\nlsi_do_status(s);\nbreak;\ncase PHASE_MO:\nlsi_do_msgout(s);\nbreak;\ncase PHASE_MI:\nlsi_do_msgin(s);\nbreak;\ndefault:\nqemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\nscsi_phase_name(s->sstat1));\n}\ns->dfifo = s->dbc & 0xff;\ns->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\ns->sbc = s->dbc;\ns->rbc -= s->dbc;\ns->ua = addr + s->dbc;\nbreak;\ncase 1:\nopcode = (insn >> 27) & 7;\nif (opcode < 5) {\nuint32_t id;\nif (insn & (1 << 25)) {\nid = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n} else {\nid = insn;\n}\nid = (id >> 16) & 0xf;\nif (insn & (1 << 26)) {\naddr = s->dsp + sextract32(addr, 0, 24);\n}\ns->dnad = addr;\nswitch (opcode) {\ncase 0:\ns->sdid = id;\nif (s->scntl1 & LSI_SCNTL1_CON) {\ntrace_lsi_execute_script_io_alreadyreselected();\ns->dsp = s->dnad;\nbreak;\n}\ns->sstat0 |= LSI_SSTAT0_WOA;\ns->scntl1 &= ~LSI_SCNTL1_IARB;\nif (!scsi_device_find(&s->bus, 0, id, 0)) {\nlsi_bad_selection(s, id);\nbreak;\n}\ntrace_lsi_execute_script_io_selected(id,\ninsn & (1 << 3) ? \" ATN\" : \"\");\ns->select_tag = id << 8;\ns->scntl1 |= LSI_SCNTL1_CON;\nif (insn & (1 << 3)) {\ns->socl |= LSI_SOCL_ATN;\ns->sbcl |= LSI_SBCL_ATN;\n}\ns->sbcl |= LSI_SBCL_BSY;\nlsi_set_phase(s, PHASE_MO);\ns->waiting = LSI_NOWAIT;\nbreak;\ncase 1:\ntrace_lsi_execute_script_io_disconnect();\ns->scntl1 &= ~LSI_SCNTL1_CON;\nif (!s->current) {\nlsi_request *p = get_pending_req(s);\nif (p) {\nlsi_reselect(s, p);\n}\n}\nbreak;\ncase 2:\nif (s->istat0 & LSI_ISTAT0_SIGP) {\ns->dsp = s->dnad;\n} else if (!lsi_irq_on_rsl(s)) {\nlsi_wait_reselect(s);\n}\nbreak;\ncase 3:\ntrace_lsi_execute_script_io_set(\ninsn & (1 << 3) ? \" ATN\" : \"\",\ninsn & (1 << 6) ? \" ACK\" : \"\",\ninsn & (1 << 9) ? \" TM\" : \"\",\ninsn & (1 << 10) ? \" CC\" : \"\");\nif (insn & (1 << 3)) {\ns->socl |= LSI_SOCL_ATN;\ns->sbcl |= LSI_SBCL_ATN;\nlsi_set_phase(s, PHASE_MO);\n}\nif (insn & (1 << 6)) {\ns->sbcl |= LSI_SBCL_ACK;\n}\nif (insn & (1 << 9)) {\nqemu_log_mask(LOG_UNIMP,\n\"lsi_scsi: Target mode not implemented\\n\");\n}\nif (insn & (1 << 10))\ns->carry = 1;\nbreak;\ncase 4:\ntrace_lsi_execute_script_io_clear(\ninsn & (1 << 3) ? \" ATN\" : \"\",\ninsn & (1 << 6) ? \" ACK\" : \"\",\ninsn & (1 << 9) ? \" TM\" : \"\",\ninsn & (1 << 10) ? \" CC\" : \"\");\nif (insn & (1 << 3)) {\ns->socl &= ~LSI_SOCL_ATN;\ns->sbcl &= ~LSI_SBCL_ATN;\n}\nif (insn & (1 << 6)) {\ns->sbcl &= ~LSI_SBCL_ACK;\n}\nif (insn & (1 << 10))\ns->carry = 0;\nbreak;\n}\n} else {\nuint8_t op0;\nuint8_t op1;\nuint8_t data8;\nint reg;\nint operator;\nstatic const char *opcode_names[3] =\n{\"Write\", \"Read\", \"Read-Modify-Write\"};\nstatic const char *operator_names[8] =\n{\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\nreg = ((insn >> 16) & 0x7f) | (insn & 0x80);\ndata8 = (insn >> 8) & 0xff;\nopcode = (insn >> 27) & 7;\noperator = (insn >> 24) & 7;\ntrace_lsi_execute_script_io_opcode(\nopcode_names[opcode - 5], reg,\noperator_names[operator], data8, s->sfbr,\n(insn & (1 << 23)) ? \" SFBR\" : \"\");\nop0 = op1 = 0;\nswitch (opcode) {\ncase 5:\nop0 = s->sfbr;\nop1 = data8;\nbreak;\ncase 6:\nif (operator)\nop0 = lsi_reg_readb(s, reg);\nop1 = data8;\nbreak;\ncase 7:\nif (operator)\nop0 = lsi_reg_readb(s, reg);\nif (insn & (1 << 23)) {\nop1 = s->sfbr;\n} else {\nop1 = data8;\n}\nbreak;\n}\nswitch (operator) {\ncase 0:\nop0 = op1;\nbreak;\ncase 1:\nop1 = op0 >> 7;\nop0 = (op0 << 1) | s->carry;\ns->carry = op1;\nbreak;\ncase 2:\nop0 |= op1;\nbreak;\ncase 3:\nop0 ^= op1;\nbreak;\ncase 4:\nop0 &= op1;\nbreak;\ncase 5:\nop1 = op0 & 1;\nop0 = (op0 >> 1) | (s->carry << 7);\ns->carry = op1;\nbreak;\ncase 6:\nop0 += op1;\ns->carry = op0 < op1;\nbreak;\ncase 7:\nop0 += op1 + s->carry;\nif (s->carry)\ns->carry = op0 <= op1;\nelse\ns->carry = op0 < op1;\nbreak;\n}\nswitch (opcode) {\ncase 5:\ncase 7:\nlsi_reg_writeb(s, reg, op0);\nbreak;\ncase 6:\ns->sfbr = op0;\nbreak;\n}\n}\nbreak;\ncase 2:\n{\nint cond;\nint jmp;\nif ((insn & 0x002e0000) == 0) {\ntrace_lsi_execute_script_tc_nop();\nbreak;\n}\nif (s->sist1 & LSI_SIST1_STO) {\ntrace_lsi_execute_script_tc_delayedselect_timeout();\nlsi_stop_script(s);\nbreak;\n}\ncond = jmp = (insn & (1 << 19)) != 0;\nif (cond == jmp && (insn & (1 << 21))) {\ntrace_lsi_execute_script_tc_compc(s->carry == jmp);\ncond = s->carry != 0;\n}\nif (cond == jmp && (insn & (1 << 17))) {\ntrace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\njmp ? '=' : '!', scsi_phase_name(insn >> 24));\ncond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n}\nif (cond == jmp && (insn & (1 << 18))) {\nuint8_t mask;\nmask = (~insn >> 8) & 0xff;\ntrace_lsi_execute_script_tc_compd(\ns->sfbr, mask, jmp ? '=' : '!', insn & mask);\ncond = (s->sfbr & mask) == (insn & mask);\n}\nif (cond == jmp) {\nif (insn & (1 << 23)) {\naddr = s->dsp + sextract32(addr, 0, 24);\n}\nswitch ((insn >> 27) & 7) {\ncase 0:\ntrace_lsi_execute_script_tc_jump(addr);\ns->adder = addr;\ns->dsp = addr;\nbreak;\ncase 1:\ntrace_lsi_execute_script_tc_call(addr);\ns->temp = s->dsp;\ns->dsp = addr;\nbreak;\ncase 2:\ntrace_lsi_execute_script_tc_return(s->temp);\ns->dsp = s->temp;\nbreak;\ncase 3:\ntrace_lsi_execute_script_tc_interrupt(s->dsps);\nif ((insn & (1 << 20)) != 0) {\ns->istat0 |= LSI_ISTAT0_INTF;\nlsi_update_irq(s);\n} else {\nlsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n}\nbreak;\ndefault:\ntrace_lsi_execute_script_tc_illegal();\nlsi_script_dma_interrupt(s, LSI_DSTAT_IID);\nbreak;\n}\n} else {\ntrace_lsi_execute_script_tc_cc_failed();\n}\n}\nbreak;\ncase 3:\nif ((insn & (1 << 29)) == 0) {\nuint32_t dest;\ndest = read_dword(s, s->dsp);\ns->dsp += 4;\nlsi_memcpy(s, dest, addr, insn & 0xffffff);\n} else {\nuint8_t data[7];\nint reg;\nint n;\nint i;\nif (insn & (1 << 28)) {\naddr = s->dsa + sextract32(addr, 0, 24);\n}\nn = (insn & 7);\nreg = (insn >> 16) & 0xff;\nif (insn & (1 << 24)) {\npci_dma_read(pci_dev, addr, data, n);\ntrace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\nfor (i = 0; i < n; i++) {\nlsi_reg_writeb(s, reg + i, data[i]);\n}\n} else {\ntrace_lsi_execute_script_mm_store(reg, n, addr);\nfor (i = 0; i < n; i++) {\ndata[i] = lsi_reg_readb(s, reg + i);\n}\npci_dma_write(pci_dev, addr, data, n);\n}\n}\n}\nif (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {\nif (!(s->sien0 & LSI_SIST0_UDC)) {\nqemu_log_mask(LOG_GUEST_ERROR,\n\"lsi_scsi: inf. loop with UDC masked\");\n}\nlsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\nlsi_disconnect(s);\n} else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\nif (s->dcntl & LSI_DCNTL_SSM) {\n}\n}\n}", "contrast": "static void lsi_execute_script(LSIState *s)\n{\nPCIDevice *pci_dev = PCI_DEVICE(s);\nuint32_t insn;\nuint32_t addr, addr_high;\nint opcode;\nint insn_processed = 0;\ns->istat1 |= LSI_ISTAT1_SRUN;\nagain:\ns->istat1 |= LSI_ISTAT1_SRUN;\nagain:\nif (++insn_processed > LSI_MAX_INSN) {\nif (!(s->sien0 & LSI_SIST0_UDC)) {\nqemu_log_mask(LOG_GUEST_ERROR,\n\"lsi_scsi: inf. loop with UDC masked\");\n}\nlsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\nlsi_disconnect(s);\ntrace_lsi_execute_script_stop();\nreturn;\n}\ninsn = read_dword(s, s->dsp);\nif (!insn) {\ns->ia = s->dsp - 8;\nif (insn & (1 << 29)) {\naddr = read_dword(s, addr);\n} else if (insn & (1 << 28)) {\nuint32_t buf[2];\nint32_t offset;\noffset = sextract32(addr, 0, 24);\npci_dma_read(pci_dev, s->dsa + offset, buf, 8);\ns->dbc = cpu_to_le32(buf[0]) & 0xffffff;\ns->rbc = s->dbc;\naddr = cpu_to_le32(buf[1]);\nif (lsi_dma_40bit(s))\naddr_high = cpu_to_le32(buf[0]) >> 24;\nelse if (lsi_dma_ti64bit(s)) {\nint selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\nswitch (selector) {\ncase 0 ... 0x0f:\naddr_high = s->scratch[2 + selector];\nbreak;\ncase 0x10:\naddr_high = s->mmrs;\nbreak;\ncase 0x11:\naddr_high = s->mmws;\nbreak;\ncase 0x12:\naddr_high = s->sfs;\nbreak;\ncase 0x13:\naddr_high = s->drs;\nbreak;\ncase 0x14:\naddr_high = s->sbms;\nbreak;\ncase 0x15:\naddr_high = s->dbms;\nbreak;\ndefault:\nqemu_log_mask(LOG_GUEST_ERROR,\n\"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n\"for 64-bit DMA block move\", selector);\nbreak;\n}\n}\n} else if (lsi_dma_64bit(s)) {\ns->dbms = read_dword(s, s->dsp);\ns->dsp += 4;\ns->ia = s->dsp - 12;\n}\nif ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\ntrace_lsi_execute_script_blockmove_badphase(\nscsi_phase_name(s->sstat1),\nscsi_phase_name(insn >> 24));\nlsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\nbreak;\n}\ns->dnad = addr;\ns->dnad64 = addr_high;\nswitch (s->sstat1 & 0x7) {\ncase PHASE_DO:\ns->waiting = LSI_DMA_SCRIPTS;\nlsi_do_dma(s, 1);\nif (s->waiting)\ns->waiting = LSI_DMA_IN_PROGRESS;\nbreak;\ncase PHASE_DI:\ns->waiting = LSI_DMA_SCRIPTS;\nlsi_do_dma(s, 0);\nif (s->waiting)\ns->waiting = LSI_DMA_IN_PROGRESS;\nbreak;\ncase PHASE_CMD:\nlsi_do_command(s);\nbreak;\ncase PHASE_ST:\nlsi_do_status(s);\nbreak;\ncase PHASE_MO:\nlsi_do_msgout(s);\nbreak;\ncase PHASE_MI:\nlsi_do_msgin(s);\nbreak;\ndefault:\nqemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\nscsi_phase_name(s->sstat1));\n}\ns->dfifo = s->dbc & 0xff;\ns->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\ns->sbc = s->dbc;\ns->rbc -= s->dbc;\ns->ua = addr + s->dbc;\nbreak;\ncase 1:\nopcode = (insn >> 27) & 7;\nif (opcode < 5) {\nuint32_t id;\nif (insn & (1 << 25)) {\nid = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n} else {\nid = insn;\n}\nid = (id >> 16) & 0xf;\nif (insn & (1 << 26)) {\naddr = s->dsp + sextract32(addr, 0, 24);\n}\ns->dnad = addr;\nswitch (opcode) {\ncase 0:\ns->sdid = id;\nif (s->scntl1 & LSI_SCNTL1_CON) {\ntrace_lsi_execute_script_io_alreadyreselected();\ns->dsp = s->dnad;\nbreak;\n}\ns->sstat0 |= LSI_SSTAT0_WOA;\ns->scntl1 &= ~LSI_SCNTL1_IARB;\nif (!scsi_device_find(&s->bus, 0, id, 0)) {\nlsi_bad_selection(s, id);\nbreak;\n}\ntrace_lsi_execute_script_io_selected(id,\ninsn & (1 << 3) ? \" ATN\" : \"\");\ns->select_tag = id << 8;\ns->scntl1 |= LSI_SCNTL1_CON;\nif (insn & (1 << 3)) {\ns->socl |= LSI_SOCL_ATN;\ns->sbcl |= LSI_SBCL_ATN;\n}\ns->sbcl |= LSI_SBCL_BSY;\nlsi_set_phase(s, PHASE_MO);\ns->waiting = LSI_NOWAIT;\nbreak;\ncase 1:\ntrace_lsi_execute_script_io_disconnect();\ns->scntl1 &= ~LSI_SCNTL1_CON;\nif (!s->current) {\nlsi_request *p = get_pending_req(s);\nif (p) {\nlsi_reselect(s, p);\n}\n}\nbreak;\ncase 2:\nif (s->istat0 & LSI_ISTAT0_SIGP) {\ns->dsp = s->dnad;\n} else if (!lsi_irq_on_rsl(s)) {\nlsi_wait_reselect(s);\n}\nbreak;\ncase 3:\ntrace_lsi_execute_script_io_set(\ninsn & (1 << 3) ? \" ATN\" : \"\",\ninsn & (1 << 6) ? \" ACK\" : \"\",\ninsn & (1 << 9) ? \" TM\" : \"\",\ninsn & (1 << 10) ? \" CC\" : \"\");\nif (insn & (1 << 3)) {\ns->socl |= LSI_SOCL_ATN;\ns->sbcl |= LSI_SBCL_ATN;\nlsi_set_phase(s, PHASE_MO);\n}\nif (insn & (1 << 6)) {\ns->sbcl |= LSI_SBCL_ACK;\n}\nif (insn & (1 << 9)) {\nqemu_log_mask(LOG_UNIMP,\n\"lsi_scsi: Target mode not implemented\\n\");\n}\nif (insn & (1 << 10))\ns->carry = 1;\nbreak;\ncase 4:\ntrace_lsi_execute_script_io_clear(\ninsn & (1 << 3) ? \" ATN\" : \"\",\ninsn & (1 << 6) ? \" ACK\" : \"\",\ninsn & (1 << 9) ? \" TM\" : \"\",\ninsn & (1 << 10) ? \" CC\" : \"\");\nif (insn & (1 << 3)) {\ns->socl &= ~LSI_SOCL_ATN;\ns->sbcl &= ~LSI_SBCL_ATN;\n}\nif (insn & (1 << 6)) {\ns->sbcl &= ~LSI_SBCL_ACK;\n}\nif (insn & (1 << 10))\ns->carry = 0;\nbreak;\n}\n} else {\nuint8_t op0;\nuint8_t op1;\nuint8_t data8;\nint reg;\nint operator;\nstatic const char *opcode_names[3] =\n{\"Write\", \"Read\", \"Read-Modify-Write\"};\nstatic const char *operator_names[8] =\n{\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\nreg = ((insn >> 16) & 0x7f) | (insn & 0x80);\ndata8 = (insn >> 8) & 0xff;\nopcode = (insn >> 27) & 7;\noperator = (insn >> 24) & 7;\ntrace_lsi_execute_script_io_opcode(\nopcode_names[opcode - 5], reg,\noperator_names[operator], data8, s->sfbr,\n(insn & (1 << 23)) ? \" SFBR\" : \"\");\nop0 = op1 = 0;\nswitch (opcode) {\ncase 5:\nop0 = s->sfbr;\nop1 = data8;\nbreak;\ncase 6:\nif (operator)\nop0 = lsi_reg_readb(s, reg);\nop1 = data8;\nbreak;\ncase 7:\nif (operator)\nop0 = lsi_reg_readb(s, reg);\nif (insn & (1 << 23)) {\nop1 = s->sfbr;\n} else {\nop1 = data8;\n}\nbreak;\n}\nswitch (operator) {\ncase 0:\nop0 = op1;\nbreak;\ncase 1:\nop1 = op0 >> 7;\nop0 = (op0 << 1) | s->carry;\ns->carry = op1;\nbreak;\ncase 2:\nop0 |= op1;\nbreak;\ncase 3:\nop0 ^= op1;\nbreak;\ncase 4:\nop0 &= op1;\nbreak;\ncase 5:\nop1 = op0 & 1;\nop0 = (op0 >> 1) | (s->carry << 7);\ns->carry = op1;\nbreak;\ncase 6:\nop0 += op1;\ns->carry = op0 < op1;\nbreak;\ncase 7:\nop0 += op1 + s->carry;\nif (s->carry)\ns->carry = op0 <= op1;\nelse\ns->carry = op0 < op1;\nbreak;\n}\nswitch (opcode) {\ncase 5:\ncase 7:\nlsi_reg_writeb(s, reg, op0);\nbreak;\ncase 6:\ns->sfbr = op0;\nbreak;\n}\n}\nbreak;\ncase 2:\n{\nint cond;\nint jmp;\nif ((insn & 0x002e0000) == 0) {\ntrace_lsi_execute_script_tc_nop();\nbreak;\n}\nif (s->sist1 & LSI_SIST1_STO) {\ntrace_lsi_execute_script_tc_delayedselect_timeout();\nlsi_stop_script(s);\nbreak;\n}\ncond = jmp = (insn & (1 << 19)) != 0;\nif (cond == jmp && (insn & (1 << 21))) {\ntrace_lsi_execute_script_tc_compc(s->carry == jmp);\ncond = s->carry != 0;\n}\nif (cond == jmp && (insn & (1 << 17))) {\ntrace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\njmp ? '=' : '!', scsi_phase_name(insn >> 24));\ncond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n}\nif (cond == jmp && (insn & (1 << 18))) {\nuint8_t mask;\nmask = (~insn >> 8) & 0xff;\ntrace_lsi_execute_script_tc_compd(\ns->sfbr, mask, jmp ? '=' : '!', insn & mask);\ncond = (s->sfbr & mask) == (insn & mask);\n}\nif (cond == jmp) {\nif (insn & (1 << 23)) {\naddr = s->dsp + sextract32(addr, 0, 24);\n}\nswitch ((insn >> 27) & 7) {\ncase 0:\ntrace_lsi_execute_script_tc_jump(addr);\ns->adder = addr;\ns->dsp = addr;\nbreak;\ncase 1:\ntrace_lsi_execute_script_tc_call(addr);\ns->temp = s->dsp;\ns->dsp = addr;\nbreak;\ncase 2:\ntrace_lsi_execute_script_tc_return(s->temp);\ns->dsp = s->temp;\nbreak;\ncase 3:\ntrace_lsi_execute_script_tc_interrupt(s->dsps);\nif ((insn & (1 << 20)) != 0) {\ns->istat0 |= LSI_ISTAT0_INTF;\nlsi_update_irq(s);\n} else {\nlsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n}\nbreak;\ndefault:\ntrace_lsi_execute_script_tc_illegal();\nlsi_script_dma_interrupt(s, LSI_DSTAT_IID);\nbreak;\n}\n} else {\ntrace_lsi_execute_script_tc_cc_failed();\n}\n}\nbreak;\ncase 3:\nif ((insn & (1 << 29)) == 0) {\nuint32_t dest;\ndest = read_dword(s, s->dsp);\ns->dsp += 4;\nlsi_memcpy(s, dest, addr, insn & 0xffffff);\n} else {\nuint8_t data[7];\nint reg;\nint n;\nint i;\nif (insn & (1 << 28)) {\naddr = s->dsa + sextract32(addr, 0, 24);\n}\nn = (insn & 7);\nreg = (insn >> 16) & 0xff;\nif (insn & (1 << 24)) {\npci_dma_read(pci_dev, addr, data, n);\ntrace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\nfor (i = 0; i < n; i++) {\nlsi_reg_writeb(s, reg + i, data[i]);\n}\n} else {\ntrace_lsi_execute_script_mm_store(reg, n, addr);\nfor (i = 0; i < n; i++) {\ndata[i] = lsi_reg_readb(s, reg + i);\n}\npci_dma_write(pci_dev, addr, data, n);\n}\n}\n}\nif (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {\nif (!(s->sien0 & LSI_SIST0_UDC)) {\nqemu_log_mask(LOG_GUEST_ERROR,\n\"lsi_scsi: inf. loop with UDC masked\");\n}\nlsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\nlsi_disconnect(s);\n} else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\nif (s->dcntl & LSI_DCNTL_SSM) {\n}\n}\n}", "label": 0}
{"index": 174537, "code": "token_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n{\nos_ptr op = osp;\nint code;\nref token;\npop(1);\nagain:\ngs_scanner_error_object(i_ctx_p, pstate, &i_ctx_p->error_object);\nbreak;\ncase scan_BOS:\ncode = 0;\ncase 0:\npush(2);\nref_assign(op - 1, &token);\nmake_true(op);\nbreak;\ncase scan_EOF:\npush(1);\nmake_false(op);\ncode = 0;\nbreak;\ncase scan_Refill:\ncode = gs_scan_handle_refill(i_ctx_p, pstate, save,\nztoken_continue);\nswitch (code) {\ncase 0:\ngoto again;\ncase o_push_estack:\nreturn code;\n}\nbreak;\n}", "contrast": "token_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n{\nos_ptr op = osp;\nint code;\nref token;\nmake_null(osp);\npop(1);\nagain:\ngs_scanner_error_object(i_ctx_p, pstate, &i_ctx_p->error_object);\nbreak;\ncase scan_BOS:\ncode = 0;\ncase 0:\npush(2);\nref_assign(op - 1, &token);\nmake_true(op);\nbreak;\ncase scan_EOF:\npush(1);\nmake_false(op);\ncode = 0;\nbreak;\ncase scan_Refill:\ncode = gs_scan_handle_refill(i_ctx_p, pstate, save,\nztoken_continue);\nswitch (code) {\ncase 0:\ngoto again;\ncase o_push_estack:\nreturn code;\n}\nbreak;\n}", "label": 0}
{"index": 174590, "code": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\nvoid *asn, EVP_PKEY *pkey)\n{\nEVP_MD_CTX ctx;\nconst EVP_MD *type = NULL;\nunsigned char *buf_in=NULL;\nint ret= -1,inl;\nint mdnid, pknid;\nEVP_MD_CTX_init(&ctx);\nif (type == NULL)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\ngoto err;\n}\nif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\ngoto err;\n}\nif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\nret=0;\ngoto err;\n}\ninl = ASN1_item_i2d(asn, &buf_in, it);\nif (buf_in == NULL)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\ngoto err;\n}\nEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\nOPENSSL_cleanse(buf_in,(unsigned int)inl);\nOPENSSL_free(buf_in);\nif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n(unsigned int)signature->length,pkey) <= 0)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\nret=0;\ngoto err;\n}\nret=1;\nerr:\nEVP_MD_CTX_cleanup(&ctx);\nreturn(ret);\n}", "contrast": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\nvoid *asn, EVP_PKEY *pkey)\n{\nEVP_MD_CTX ctx;\nconst EVP_MD *type = NULL;\nunsigned char *buf_in=NULL;\nint ret= -1,inl;\nint mdnid, pknid;\nif (!pkey)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\nreturn -1;\n}\nEVP_MD_CTX_init(&ctx);\nif (type == NULL)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\ngoto err;\n}\nif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\ngoto err;\n}\nif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\nret=0;\ngoto err;\n}\ninl = ASN1_item_i2d(asn, &buf_in, it);\nif (buf_in == NULL)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\ngoto err;\n}\nEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\nOPENSSL_cleanse(buf_in,(unsigned int)inl);\nOPENSSL_free(buf_in);\nif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n(unsigned int)signature->length,pkey) <= 0)\n{\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\nret=0;\ngoto err;\n}\nret=1;\nerr:\nEVP_MD_CTX_cleanup(&ctx);\nreturn(ret);\n}", "label": 0}
{"index": 174637, "code": "parse_fond( char*   fond_data,\nshort*  have_sfnt,\nResID*  sfnt_id,\nStr255  lwfn_file_name,\nshort   face_index )\n{\nAsscEntry*  assoc;\nAsscEntry*  base_assoc;\nFamRec*     fond;\n*sfnt_id          = 0;\n*have_sfnt        = 0;\nlwfn_file_name[0] = 0;\nfond       = (FamRec*)fond_data;\nassoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\nbase_assoc = assoc;\nif ( 47 < face_index )\nreturn;\nif ( face_index < count_faces_sfnt( fond_data ) )\n{\nassoc += face_index;\nif ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n{\n*have_sfnt = 1;\n*sfnt_id   = EndianS16_BtoN( assoc->fontID );\n}\nelse if ( base_assoc->fontSize == 0 )\n{\n*have_sfnt = 1;\n*sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n}\n}\nif ( EndianS32_BtoN( fond->ffStylOff ) )\n{\nunsigned char*  p = (unsigned char*)fond_data;\nStyleTable*     style;\nunsigned short  string_count;\nchar            ps_name[256];\nunsigned char*  names[64];\nint             i;\np += EndianS32_BtoN( fond->ffStylOff );\nstyle = (StyleTable*)p;\np += sizeof ( StyleTable );\nstring_count = EndianS16_BtoN( *(short*)(p) );\np += sizeof ( short );\nfor ( i = 0; i < string_count && i < 64; i++ )\n{\nnames[i] = p;\np       += names[i][0];\n}\n{\nsize_t  ps_name_len = (size_t)names[0][0];\nif ( ps_name_len != 0 )\n{\nft_memcpy(ps_name, names[0] + 1, ps_name_len);\nps_name[ps_name_len] = 0;\nps_name[ps_name_len] = 0;\n}\nif ( style->indexes[face_index] > 1 &&\nstyle->indexes[face_index] <= FT_MIN( string_count, 64 ) )\n{\nunsigned char*  suffixes = names[style->indexes[face_index] - 1];\nfor ( i = 1; i <= suffixes[0]; i++ )\n{\nunsigned char*  s;\nsize_t          j = suffixes[i] - 1;\nif ( j < string_count && ( s = names[j] ) != NULL )\n{\nsize_t  s_len = (size_t)s[0];\nif ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n{\nft_memcpy( ps_name + ps_name_len, s + 1, s_len );\nps_name_len += s_len;\nps_name[ps_name_len] = 0;\n}\n}\n}\n}\n}\ncreate_lwfn_name( ps_name, lwfn_file_name );\n}\n}", "contrast": "parse_fond( char*   fond_data,\nshort*  have_sfnt,\nResID*  sfnt_id,\nStr255  lwfn_file_name,\nshort   face_index )\n{\nAsscEntry*  assoc;\nAsscEntry*  base_assoc;\nFamRec*     fond;\n*sfnt_id          = 0;\n*have_sfnt        = 0;\nlwfn_file_name[0] = 0;\nfond       = (FamRec*)fond_data;\nassoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\nbase_assoc = assoc;\nif ( 47 < face_index )\nreturn;\nif ( face_index < count_faces_sfnt( fond_data ) )\n{\nassoc += face_index;\nif ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n{\n*have_sfnt = 1;\n*sfnt_id   = EndianS16_BtoN( assoc->fontID );\n}\nelse if ( base_assoc->fontSize == 0 )\n{\n*have_sfnt = 1;\n*sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n}\n}\nif ( EndianS32_BtoN( fond->ffStylOff ) )\n{\nunsigned char*  p = (unsigned char*)fond_data;\nStyleTable*     style;\nunsigned short  string_count;\nchar            ps_name[256];\nunsigned char*  names[64];\nint             i;\np += EndianS32_BtoN( fond->ffStylOff );\nstyle = (StyleTable*)p;\np += sizeof ( StyleTable );\nstring_count = EndianS16_BtoN( *(short*)(p) );\nstring_count = FT_MIN( 64, string_count );\np += sizeof ( short );\nfor ( i = 0; i < string_count; i++ )\n{\nnames[i] = p;\np       += names[i][0];\n}\n{\nsize_t  ps_name_len = (size_t)names[0][0];\nif ( ps_name_len != 0 )\n{\nft_memcpy(ps_name, names[0] + 1, ps_name_len);\nps_name[ps_name_len] = 0;\nps_name[ps_name_len] = 0;\n}\nif ( style->indexes[face_index] > 1 &&\nstyle->indexes[face_index] <= string_count )\n{\nunsigned char*  suffixes = names[style->indexes[face_index] - 1];\nfor ( i = 1; i <= suffixes[0]; i++ )\n{\nunsigned char*  s;\nsize_t          j = suffixes[i] - 1;\nif ( j < string_count && ( s = names[j] ) != NULL )\n{\nsize_t  s_len = (size_t)s[0];\nif ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n{\nft_memcpy( ps_name + ps_name_len, s + 1, s_len );\nps_name_len += s_len;\nps_name[ps_name_len] = 0;\n}\n}\n}\n}\n}\ncreate_lwfn_name( ps_name, lwfn_file_name );\n}\n}", "label": 0}
{"index": 174641, "code": "tt_sbit_decoder_init( TT_SBitDecoder       decoder,\nTT_Face              face,\nFT_ULong             strike_index,\nTT_SBit_MetricsRec*  metrics )\n{\nFT_Error   error;\nFT_Stream  stream = face->root.stream;\nFT_ULong   ebdt_size;\nerror = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\nif ( error )\nerror = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\nif ( error )\nerror = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\nif ( error )\ngoto Exit;\ndecoder->face    = face;\ndecoder->stream  = stream;\ndecoder->bitmap  = &face->root.glyph->bitmap;\ndecoder->metrics = metrics;\ndecoder->metrics_loaded   = 0;\ndecoder->bitmap_allocated = 0;\ndecoder->ebdt_start = FT_STREAM_POS();\ndecoder->ebdt_size  = ebdt_size;\ndecoder->eblc_base  = face->sbit_table;\ndecoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n{\nFT_Byte*  p;\nif ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n{\nerror = FT_THROW( Invalid_File_Format );\ngoto Exit;\n}\np = decoder->eblc_base + 8 + 48 * strike_index;\ndecoder->strike_index_array = FT_NEXT_ULONG( p );\np                          += 4;\ndecoder->strike_index_count = FT_NEXT_ULONG( p );\np                          += 34;\ndecoder->bit_depth          = *p;\nif ( decoder->strike_index_array > face->sbit_table_size             ||\ndecoder->strike_index_array + 8 * decoder->strike_index_count >\nface->sbit_table_size                                         )\nerror = FT_THROW( Invalid_File_Format );\n}\n}", "contrast": "tt_sbit_decoder_init( TT_SBitDecoder       decoder,\nTT_Face              face,\nFT_ULong             strike_index,\nTT_SBit_MetricsRec*  metrics )\n{\nFT_Error   error;\nFT_Stream  stream = face->root.stream;\nFT_ULong   ebdt_size;\nerror = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\nif ( error )\nerror = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\nif ( error )\nerror = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\nif ( error )\ngoto Exit;\ndecoder->face    = face;\ndecoder->stream  = stream;\ndecoder->bitmap  = &face->root.glyph->bitmap;\ndecoder->metrics = metrics;\ndecoder->metrics_loaded   = 0;\ndecoder->bitmap_allocated = 0;\ndecoder->ebdt_start = FT_STREAM_POS();\ndecoder->ebdt_size  = ebdt_size;\ndecoder->eblc_base  = face->sbit_table;\ndecoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n{\nFT_Byte*  p;\nif ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n{\nerror = FT_THROW( Invalid_File_Format );\ngoto Exit;\n}\np = decoder->eblc_base + 8 + 48 * strike_index;\ndecoder->strike_index_array = FT_NEXT_ULONG( p );\np                          += 4;\ndecoder->strike_index_count = FT_NEXT_ULONG( p );\np                          += 34;\ndecoder->bit_depth          = *p;\nif ( decoder->strike_index_array > face->sbit_table_size           ||\ndecoder->strike_index_count >\n( face->sbit_table_size - decoder->strike_index_array ) / 8 )\nerror = FT_THROW( Invalid_File_Format );\n}\n}", "label": 0}
{"index": 174677, "code": "ZEND_API void zend_ts_hash_graceful_destroy(TsHashTable *ht)\n{\nbegin_write(ht);\nzend_hash_graceful_destroy(TS_HASH(ht));\nend_write(ht);\n#ifdef ZTS\ntsrm_mutex_free(ht->mx_reader);\ntsrm_mutex_free(ht->mx_reader);\n#endif\n}", "contrast": "ZEND_API void zend_ts_hash_graceful_destroy(TsHashTable *ht)\n{\nbegin_write(ht);\nzend_hash_graceful_destroy(TS_HASH(ht));\nend_write(ht);\n#ifdef ZTS\ntsrm_mutex_free(ht->mx_reader);\ntsrm_mutex_free(ht->mx_writer);\n#endif\n}", "label": 0}
{"index": 174702, "code": "static void v9fs_read(void *opaque)\n{\nint32_t fid;\nuint64_t off;\nssize_t err = 0;\nint32_t count = 0;\nsize_t offset = 7;\nuint32_t max_count;\nV9fsFidState *fidp;\nV9fsPDU *pdu = opaque;\nV9fsState *s = pdu->s;\nerr = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\nif (err < 0) {\ngoto out_nofid;\n}\ntrace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\nfidp = get_fid(pdu, fid);\nif (fidp == NULL) {\nerr = -EINVAL;\ngoto out_nofid;\n}\nif (fidp->fid_type == P9_FID_DIR) {\nif (off == 0) {\nv9fs_co_rewinddir(pdu, fidp);\n}\ncount = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\nif (count < 0) {\nerr = count;\ngoto out;\n}\nerr = pdu_marshal(pdu, offset, \"d\", count);\nif (err < 0) {\ngoto out;\n}\nerr += offset + count;\n} else if (fidp->fid_type == P9_FID_FILE) {\nQEMUIOVector qiov_full;\nQEMUIOVector qiov;\nint32_t len;\nv9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\nqemu_iovec_init(&qiov, qiov_full.niov);\ndo {\nqemu_iovec_reset(&qiov);\nqemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\nif (0) {\nprint_sg(qiov.iov, qiov.niov);\n}\ndo {\nlen = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\nif (len >= 0) {\noff   += len;\ncount += len;\n}\n} while (len == -EINTR && !pdu->cancelled);\nif (len < 0) {\nerr = len;\ngoto out;\n}\n} while (count < max_count && len > 0);\nerr = pdu_marshal(pdu, offset, \"d\", count);\nif (err < 0) {\ngoto out;\n}\nerr += offset + count;\nqemu_iovec_destroy(&qiov);\nqemu_iovec_destroy(&qiov_full);\n} else if (fidp->fid_type == P9_FID_XATTR) {\n} else {\nerr = -EINVAL;\n}\ntrace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\nput_fid(pdu, fidp);\nout_nofid:\npdu_complete(pdu, err);\n}", "contrast": "static void v9fs_read(void *opaque)\n{\nint32_t fid;\nuint64_t off;\nssize_t err = 0;\nint32_t count = 0;\nsize_t offset = 7;\nuint32_t max_count;\nV9fsFidState *fidp;\nV9fsPDU *pdu = opaque;\nV9fsState *s = pdu->s;\nerr = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\nif (err < 0) {\ngoto out_nofid;\n}\ntrace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\nfidp = get_fid(pdu, fid);\nif (fidp == NULL) {\nerr = -EINVAL;\ngoto out_nofid;\n}\nif (fidp->fid_type == P9_FID_DIR) {\nif (off == 0) {\nv9fs_co_rewinddir(pdu, fidp);\n}\ncount = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\nif (count < 0) {\nerr = count;\ngoto out;\n}\nerr = pdu_marshal(pdu, offset, \"d\", count);\nif (err < 0) {\ngoto out;\n}\nerr += offset + count;\n} else if (fidp->fid_type == P9_FID_FILE) {\nQEMUIOVector qiov_full;\nQEMUIOVector qiov;\nint32_t len;\nv9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\nqemu_iovec_init(&qiov, qiov_full.niov);\ndo {\nqemu_iovec_reset(&qiov);\nqemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\nif (0) {\nprint_sg(qiov.iov, qiov.niov);\n}\ndo {\nlen = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\nif (len >= 0) {\noff   += len;\ncount += len;\n}\n} while (len == -EINTR && !pdu->cancelled);\nif (len < 0) {\nerr = len;\ngoto out_free_iovec;\n}\n} while (count < max_count && len > 0);\nerr = pdu_marshal(pdu, offset, \"d\", count);\nif (err < 0) {\ngoto out_free_iovec;\n}\nerr += offset + count;\nout_free_iovec:\nqemu_iovec_destroy(&qiov);\nqemu_iovec_destroy(&qiov_full);\n} else if (fidp->fid_type == P9_FID_XATTR) {\n} else {\nerr = -EINVAL;\n}\ntrace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\nput_fid(pdu, fidp);\nout_nofid:\npdu_complete(pdu, err);\n}", "label": 0}
{"index": 174706, "code": "XRRGetOutputInfo (Display *dpy, XRRScreenResources *resources, RROutput output)\n{\nXExtDisplayInfo\t\t*info = XRRFindDisplay(dpy);\nxRRGetOutputInfoReply\trep;\nxRRGetOutputInfoReq\t\t*req;\nint\t\t\t\tnbytes, nbytesRead, rbytes;\nXRROutputInfo\t\t*xoi;\nRRCheckExtension (dpy, info, NULL);\nLockDisplay (dpy);\nGetReq (RRGetOutputInfo, req);\nreq->reqType = info->codes->major_opcode;\nreq->randrReqType = X_RRGetOutputInfo;\nreq->output = output;\nreq->configTimestamp = resources->configTimestamp;\nif (!_XReply (dpy, (xReply *) &rep, OutputInfoExtra >> 2, xFalse))\n{\nUnlockDisplay (dpy);\nSyncHandle ();\nreturn NULL;\nreturn NULL;\n}\nnbytes = ((long) (rep.length) << 2) - OutputInfoExtra;\nnbytesRead = (long) (rep.nCrtcs * 4 +\nrep.nCrtcs * sizeof (RRCrtc) +\nrep.nModes * sizeof (RRMode) +\nrep.nClones * sizeof (RROutput) +\nrep.nameLength + 1);\nxoi = (XRROutputInfo *) Xmalloc(rbytes);\nif (xoi == NULL) {\n_XEatDataWords (dpy, rep.length - (OutputInfoExtra >> 2));\nUnlockDisplay (dpy);\nSyncHandle ();\nreturn NULL;\n}\nxoi->timestamp = rep.timestamp;\nxoi->crtc = rep.crtc;\nxoi->mm_width = rep.mmWidth;\nxoi->mm_height = rep.mmHeight;\nxoi->connection = rep.connection;\nxoi->subpixel_order = rep.subpixelOrder;\nxoi->ncrtc = rep.nCrtcs;\nxoi->crtcs = (RRCrtc *) (xoi + 1);\nxoi->nmode = rep.nModes;\nxoi->npreferred = rep.nPreferred;\nxoi->modes = (RRMode *) (xoi->crtcs + rep.nCrtcs);\nxoi->nclone = rep.nClones;\nxoi->clones = (RROutput *) (xoi->modes + rep.nModes);\nxoi->name = (char *) (xoi->clones + rep.nClones);\n_XRead32 (dpy, (long *) xoi->crtcs, rep.nCrtcs << 2);\n_XRead32 (dpy, (long *) xoi->modes, rep.nModes << 2);\n_XRead32 (dpy, (long *) xoi->clones, rep.nClones << 2);\n_XReadPad (dpy, xoi->name, rep.nameLength);\nxoi->name[rep.nameLength] = '\\0';\nxoi->nameLen = rep.nameLength;\nif (nbytes > nbytesRead)\n_XEatData (dpy, (unsigned long) (nbytes - nbytesRead));\nUnlockDisplay (dpy);\nSyncHandle ();\nreturn (XRROutputInfo *) xoi;\n}", "contrast": "XRRGetOutputInfo (Display *dpy, XRRScreenResources *resources, RROutput output)\n{\nXExtDisplayInfo\t\t*info = XRRFindDisplay(dpy);\nxRRGetOutputInfoReply\trep;\nxRRGetOutputInfoReq\t\t*req;\nint\t\t\t\tnbytes, nbytesRead, rbytes;\nXRROutputInfo\t\t*xoi;\nRRCheckExtension (dpy, info, NULL);\nLockDisplay (dpy);\nGetReq (RRGetOutputInfo, req);\nreq->reqType = info->codes->major_opcode;\nreq->randrReqType = X_RRGetOutputInfo;\nreq->output = output;\nreq->configTimestamp = resources->configTimestamp;\nif (!_XReply (dpy, (xReply *) &rep, OutputInfoExtra >> 2, xFalse))\n{\nUnlockDisplay (dpy);\nSyncHandle ();\nreturn NULL;\nreturn NULL;\n}\nif (rep.length > INT_MAX >> 2 || rep.length < (OutputInfoExtra >> 2))\n{\nif (rep.length > (OutputInfoExtra >> 2))\n_XEatDataWords (dpy, rep.length - (OutputInfoExtra >> 2));\nelse\n_XEatDataWords (dpy, rep.length);\nUnlockDisplay (dpy);\nSyncHandle ();\nreturn NULL;\n}\nnbytes = ((long) (rep.length) << 2) - OutputInfoExtra;\nnbytesRead = (long) (rep.nCrtcs * 4 +\nrep.nCrtcs * sizeof (RRCrtc) +\nrep.nModes * sizeof (RRMode) +\nrep.nClones * sizeof (RROutput) +\nrep.nameLength + 1);\nxoi = (XRROutputInfo *) Xmalloc(rbytes);\nif (xoi == NULL) {\n_XEatDataWords (dpy, rep.length - (OutputInfoExtra >> 2));\nUnlockDisplay (dpy);\nSyncHandle ();\nreturn NULL;\n}\nxoi->timestamp = rep.timestamp;\nxoi->crtc = rep.crtc;\nxoi->mm_width = rep.mmWidth;\nxoi->mm_height = rep.mmHeight;\nxoi->connection = rep.connection;\nxoi->subpixel_order = rep.subpixelOrder;\nxoi->ncrtc = rep.nCrtcs;\nxoi->crtcs = (RRCrtc *) (xoi + 1);\nxoi->nmode = rep.nModes;\nxoi->npreferred = rep.nPreferred;\nxoi->modes = (RRMode *) (xoi->crtcs + rep.nCrtcs);\nxoi->nclone = rep.nClones;\nxoi->clones = (RROutput *) (xoi->modes + rep.nModes);\nxoi->name = (char *) (xoi->clones + rep.nClones);\n_XRead32 (dpy, (long *) xoi->crtcs, rep.nCrtcs << 2);\n_XRead32 (dpy, (long *) xoi->modes, rep.nModes << 2);\n_XRead32 (dpy, (long *) xoi->clones, rep.nClones << 2);\n_XReadPad (dpy, xoi->name, rep.nameLength);\nxoi->name[rep.nameLength] = '\\0';\nxoi->nameLen = rep.nameLength;\nif (nbytes > nbytesRead)\n_XEatData (dpy, (unsigned long) (nbytes - nbytesRead));\nUnlockDisplay (dpy);\nSyncHandle ();\nreturn (XRROutputInfo *) xoi;\n}", "label": 0}
{"index": 174722, "code": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\nuint32_t cmd, colour;\nint args, len, maxloop = 1024;\nint x, y, dx, dy, width, height;\nstruct vmsvga_cursor_definition_s cursor;\nuint32_t cmd_start;\nlen = vmsvga_fifo_length(s);\nwhile (len > 0 && --maxloop > 0) {\ncmd_start = s->fifo_stop;\nswitch (cmd = vmsvga_fifo_read(s)) {\ncase SVGA_CMD_UPDATE:\ncase SVGA_CMD_UPDATE_VERBOSE:\nlen -= 5;\nif (len < 0) {\ngoto rewind;\n}\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\nwidth = vmsvga_fifo_read(s);\nheight = vmsvga_fifo_read(s);\nvmsvga_update_rect_delayed(s, x, y, width, height);\nbreak;\ncase SVGA_CMD_RECT_FILL:\nlen -= 6;\nif (len < 0) {\ngoto rewind;\n}\ncolour = vmsvga_fifo_read(s);\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\nwidth = vmsvga_fifo_read(s);\nheight = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\nif (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\nbreak;\n}\n#endif\nargs = 0;\ngoto badcmd;\ncase SVGA_CMD_RECT_COPY:\nlen -= 7;\nif (len < 0) {\ngoto rewind;\n}\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\ndx = vmsvga_fifo_read(s);\ndy = vmsvga_fifo_read(s);\nwidth = vmsvga_fifo_read(s);\nheight = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\nif (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\nbreak;\n}\n#endif\nargs = 0;\ngoto badcmd;\ncase SVGA_CMD_DEFINE_CURSOR:\nlen -= 8;\nif (len < 0) {\ngoto rewind;\n}\ncursor.id = vmsvga_fifo_read(s);\ncursor.hot_x = vmsvga_fifo_read(s);\ncursor.hot_y = vmsvga_fifo_read(s);\ncursor.width = x = vmsvga_fifo_read(s);\ncursor.height = y = vmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\ncursor.bpp = vmsvga_fifo_read(s);\nargs = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\nif (cursor.width > 256 ||\ncursor.height > 256 ||\ncursor.bpp > 32 ||\nSVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\nSVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\ngoto badcmd;\n}\ngoto rewind;\n}\nfor (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\ncursor.mask[args] = vmsvga_fifo_read_raw(s);\n}\nfor (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\ncursor.image[args] = vmsvga_fifo_read_raw(s);\n}\n#ifdef HW_MOUSE_ACCEL\nvmsvga_cursor_define(s, &cursor);\nbreak;\n#else\nargs = 0;\ngoto badcmd;\n#endif\ncase SVGA_CMD_DEFINE_ALPHA_CURSOR:\nlen -= 6;\nif (len < 0) {\ngoto rewind;\n}\nvmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\nargs = x * y;\ngoto badcmd;\ncase SVGA_CMD_RECT_ROP_FILL:\nargs = 6;\ngoto badcmd;\ncase SVGA_CMD_RECT_ROP_COPY:\nargs = 7;\ngoto badcmd;\ncase SVGA_CMD_DRAW_GLYPH_CLIPPED:\nlen -= 4;\nif (len < 0) {\ngoto rewind;\n}\nvmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\nargs = 7 + (vmsvga_fifo_read(s) >> 2);\ngoto badcmd;\ncase SVGA_CMD_SURFACE_ALPHA_BLEND:\nargs = 12;\ngoto badcmd;\ncase SVGA_CMD_SURFACE_FILL:\ncase SVGA_CMD_SURFACE_COPY:\ncase SVGA_CMD_FRONT_ROP_FILL:\ncase SVGA_CMD_FENCE:\ncase SVGA_CMD_INVALID_CMD:\nbreak;\ndefault:\nargs = 0;\nbadcmd:\nlen -= args;\nif (len < 0) {\ngoto rewind;\n}\nwhile (args--) {\nvmsvga_fifo_read(s);\n}\nprintf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n__func__, cmd);\nbreak;\nrewind:\ns->fifo_stop = cmd_start;\ns->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\nbreak;\n}\n}", "contrast": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\nuint32_t cmd, colour;\nint args, len, maxloop = 1024;\nint x, y, dx, dy, width, height;\nstruct vmsvga_cursor_definition_s cursor;\nuint32_t cmd_start;\nlen = vmsvga_fifo_length(s);\nwhile (len > 0 && --maxloop > 0) {\ncmd_start = s->fifo_stop;\nswitch (cmd = vmsvga_fifo_read(s)) {\ncase SVGA_CMD_UPDATE:\ncase SVGA_CMD_UPDATE_VERBOSE:\nlen -= 5;\nif (len < 0) {\ngoto rewind;\n}\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\nwidth = vmsvga_fifo_read(s);\nheight = vmsvga_fifo_read(s);\nvmsvga_update_rect_delayed(s, x, y, width, height);\nbreak;\ncase SVGA_CMD_RECT_FILL:\nlen -= 6;\nif (len < 0) {\ngoto rewind;\n}\ncolour = vmsvga_fifo_read(s);\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\nwidth = vmsvga_fifo_read(s);\nheight = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\nif (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\nbreak;\n}\n#endif\nargs = 0;\ngoto badcmd;\ncase SVGA_CMD_RECT_COPY:\nlen -= 7;\nif (len < 0) {\ngoto rewind;\n}\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\ndx = vmsvga_fifo_read(s);\ndy = vmsvga_fifo_read(s);\nwidth = vmsvga_fifo_read(s);\nheight = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\nif (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\nbreak;\n}\n#endif\nargs = 0;\ngoto badcmd;\ncase SVGA_CMD_DEFINE_CURSOR:\nlen -= 8;\nif (len < 0) {\ngoto rewind;\n}\ncursor.id = vmsvga_fifo_read(s);\ncursor.hot_x = vmsvga_fifo_read(s);\ncursor.hot_y = vmsvga_fifo_read(s);\ncursor.width = x = vmsvga_fifo_read(s);\ncursor.height = y = vmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\ncursor.bpp = vmsvga_fifo_read(s);\nargs = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\nif (cursor.width > 256\n|| cursor.height > 256\n|| cursor.bpp > 32\n|| SVGA_BITMAP_SIZE(x, y)\n> sizeof(cursor.mask) / sizeof(cursor.mask[0])\n|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)\n> sizeof(cursor.image) / sizeof(cursor.image[0])) {\ngoto badcmd;\n}\ngoto rewind;\n}\nfor (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\ncursor.mask[args] = vmsvga_fifo_read_raw(s);\n}\nfor (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\ncursor.image[args] = vmsvga_fifo_read_raw(s);\n}\n#ifdef HW_MOUSE_ACCEL\nvmsvga_cursor_define(s, &cursor);\nbreak;\n#else\nargs = 0;\ngoto badcmd;\n#endif\ncase SVGA_CMD_DEFINE_ALPHA_CURSOR:\nlen -= 6;\nif (len < 0) {\ngoto rewind;\n}\nvmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\nx = vmsvga_fifo_read(s);\ny = vmsvga_fifo_read(s);\nargs = x * y;\ngoto badcmd;\ncase SVGA_CMD_RECT_ROP_FILL:\nargs = 6;\ngoto badcmd;\ncase SVGA_CMD_RECT_ROP_COPY:\nargs = 7;\ngoto badcmd;\ncase SVGA_CMD_DRAW_GLYPH_CLIPPED:\nlen -= 4;\nif (len < 0) {\ngoto rewind;\n}\nvmsvga_fifo_read(s);\nvmsvga_fifo_read(s);\nargs = 7 + (vmsvga_fifo_read(s) >> 2);\ngoto badcmd;\ncase SVGA_CMD_SURFACE_ALPHA_BLEND:\nargs = 12;\ngoto badcmd;\ncase SVGA_CMD_SURFACE_FILL:\ncase SVGA_CMD_SURFACE_COPY:\ncase SVGA_CMD_FRONT_ROP_FILL:\ncase SVGA_CMD_FENCE:\ncase SVGA_CMD_INVALID_CMD:\nbreak;\ndefault:\nargs = 0;\nbadcmd:\nlen -= args;\nif (len < 0) {\ngoto rewind;\n}\nwhile (args--) {\nvmsvga_fifo_read(s);\n}\nprintf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n__func__, cmd);\nbreak;\nrewind:\ns->fifo_stop = cmd_start;\ns->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\nbreak;\n}\n}", "label": 0}
{"index": 174735, "code": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\nuint32_t max_frags, bool has_virt_hdr)\n{\nstruct NetTxPkt *p = g_malloc0(sizeof *p);\np->pci_dev = pci_dev;\np->vec = g_malloc((sizeof *p->vec) *\n(max_frags + NET_TX_PKT_PL_START_FRAG));\np->raw = g_malloc((sizeof *p->raw) * max_frags);\np->max_payload_frags = max_frags;\np->max_raw_frags = max_frags;\np->max_raw_frags = max_frags;\np->has_virt_hdr = has_virt_hdr;\np->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\np->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\np->has_virt_hdr ? sizeof p->virt_hdr : 0;\np->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\np->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n*pkt = p;\n}", "contrast": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\nuint32_t max_frags, bool has_virt_hdr)\n{\nstruct NetTxPkt *p = g_malloc0(sizeof *p);\np->pci_dev = pci_dev;\np->vec = g_new(struct iovec, max_frags + NET_TX_PKT_PL_START_FRAG);\np->raw = g_new(struct iovec, max_frags);\np->max_payload_frags = max_frags;\np->max_raw_frags = max_frags;\np->max_raw_frags = max_frags;\np->has_virt_hdr = has_virt_hdr;\np->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\np->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\np->has_virt_hdr ? sizeof p->virt_hdr : 0;\np->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\np->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n*pkt = p;\n}", "label": 0}
{"index": 174742, "code": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\nuint32_t handle,\nunsigned num_elements,\nconst struct pipe_vertex_element *elements)\n{\nstruct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\nconst struct util_format_description *desc;\nGLenum type;\nint i;\nuint32_t ret_handle;\nif (!v)\nreturn ENOMEM;\nv->count = num_elements;\nfor (i = 0; i < num_elements; i++) {\nmemcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\nFREE(v);\nreturn EINVAL;\n}\ntype = GL_FALSE;\nif (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\nif (desc->channel[0].size == 32)\ntype = GL_FLOAT;\nelse if (desc->channel[0].size == 64)\ntype = GL_DOUBLE;\nelse if (desc->channel[0].size == 16)\ntype = GL_HALF_FLOAT;\n} else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\ndesc->channel[0].size == 8)\ntype = GL_UNSIGNED_BYTE;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\ndesc->channel[0].size == 8)\ntype = GL_BYTE;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\ndesc->channel[0].size == 16)\ntype = GL_UNSIGNED_SHORT;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\ndesc->channel[0].size == 16)\ntype = GL_SHORT;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\ndesc->channel[0].size == 32)\ntype = GL_UNSIGNED_INT;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\ndesc->channel[0].size == 32)\ntype = GL_INT;\nelse if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\nelements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\nelements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\ntype = GL_INT_2_10_10_10_REV;\nelse if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\nelements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\nelements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\ntype = GL_UNSIGNED_INT_2_10_10_10_REV;\nelse if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\ntype = GL_UNSIGNED_INT_10F_11F_11F_REV;\nif (type == GL_FALSE) {\nreport_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\nFREE(v);\nreturn EINVAL;\n}\nv->elements[i].type = type;\nif (desc->channel[0].normalized)\nv->elements[i].norm = GL_TRUE;\nif (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\nv->elements[i].nr_chan = GL_BGRA;\nelse if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\nv->elements[i].nr_chan = 3;\nelse\nv->elements[i].nr_chan = desc->nr_channels;\n}", "contrast": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\nuint32_t handle,\nunsigned num_elements,\nconst struct pipe_vertex_element *elements)\n{\nstruct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\nconst struct util_format_description *desc;\nGLenum type;\nint i;\nuint32_t ret_handle;\nif (!v)\nreturn ENOMEM;\nif (num_elements > PIPE_MAX_ATTRIBS)\nreturn EINVAL;\nv->count = num_elements;\nfor (i = 0; i < num_elements; i++) {\nmemcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\nFREE(v);\nreturn EINVAL;\n}\ntype = GL_FALSE;\nif (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\nif (desc->channel[0].size == 32)\ntype = GL_FLOAT;\nelse if (desc->channel[0].size == 64)\ntype = GL_DOUBLE;\nelse if (desc->channel[0].size == 16)\ntype = GL_HALF_FLOAT;\n} else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\ndesc->channel[0].size == 8)\ntype = GL_UNSIGNED_BYTE;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\ndesc->channel[0].size == 8)\ntype = GL_BYTE;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\ndesc->channel[0].size == 16)\ntype = GL_UNSIGNED_SHORT;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\ndesc->channel[0].size == 16)\ntype = GL_SHORT;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\ndesc->channel[0].size == 32)\ntype = GL_UNSIGNED_INT;\nelse if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\ndesc->channel[0].size == 32)\ntype = GL_INT;\nelse if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\nelements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\nelements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\ntype = GL_INT_2_10_10_10_REV;\nelse if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\nelements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\nelements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\ntype = GL_UNSIGNED_INT_2_10_10_10_REV;\nelse if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\ntype = GL_UNSIGNED_INT_10F_11F_11F_REV;\nif (type == GL_FALSE) {\nreport_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\nFREE(v);\nreturn EINVAL;\n}\nv->elements[i].type = type;\nif (desc->channel[0].normalized)\nv->elements[i].norm = GL_TRUE;\nif (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\nv->elements[i].nr_chan = GL_BGRA;\nelse if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\nv->elements[i].nr_chan = 3;\nelse\nv->elements[i].nr_chan = desc->nr_channels;\n}", "label": 0}
{"index": 174752, "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\nint eticklen, const unsigned char *sess_id,\nint sesslen, SSL_SESSION **psess)\n{\nSSL_SESSION *sess;\nunsigned char *sdec;\nconst unsigned char *p;\nint slen, mlen, renew_ticket = 0, ret = -1;\nunsigned char tick_hmac[EVP_MAX_MD_SIZE];\nHMAC_CTX *hctx = NULL;\nEVP_CIPHER_CTX *ctx;\nSSL_CTX *tctx = s->initial_ctx;\nif (eticklen < 48)\nreturn 2;\nhctx = HMAC_CTX_new();\nif (hctx == NULL)\nhctx = HMAC_CTX_new();\nif (hctx == NULL)\nreturn -2;\nctx = EVP_CIPHER_CTX_new();\nif (ctx == NULL) {\nret = -2;\ngoto err;\n}\nif (tctx->tlsext_ticket_key_cb) {\nunsigned char *nctick = (unsigned char *)etick;\nint rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\nctx, hctx, 0);\nif (rv < 0)\ngoto err;\nif (rv == 0) {\nret = 2;\ngoto err;\n}\nif (rv == 2)\nrenew_ticket = 1;\n} else {\nif (memcmp(etick, tctx->tlsext_tick_key_name,\nsizeof(tctx->tlsext_tick_key_name)) != 0) {\nret = 2;\ngoto err;\n}\nif (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,\nsizeof(tctx->tlsext_tick_hmac_key),\nEVP_sha256(), NULL) <= 0\n|| EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,\ntctx->tlsext_tick_aes_key,\netick + sizeof(tctx->tlsext_tick_key_name)) <=\n0) {\ngoto err;\n}\n}\nif (HMAC_Update(hctx, etick, eticklen) <= 0\nif (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\nEVP_CIPHER_CTX_free(ctx);\nreturn 2;\n}\np = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);\neticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);\nsdec = OPENSSL_malloc(eticklen);\nif (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {\nEVP_CIPHER_CTX_free(ctx);\nOPENSSL_free(sdec);\nreturn -1;\n}\nif (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {\nEVP_CIPHER_CTX_free(ctx);\nOPENSSL_free(sdec);\nreturn 2;\n}\nslen += mlen;\nEVP_CIPHER_CTX_free(ctx);\nctx = NULL;\np = sdec;\nsess = d2i_SSL_SESSION(NULL, &p, slen);\nOPENSSL_free(sdec);\nif (sess) {\nif (sesslen)\nmemcpy(sess->session_id, sess_id, sesslen);\nsess->session_id_length = sesslen;\n*psess = sess;\nif (renew_ticket)\nreturn 4;\nelse\nreturn 3;\n}\nERR_clear_error();\nreturn 2;\nerr:\nEVP_CIPHER_CTX_free(ctx);\nHMAC_CTX_free(hctx);\nreturn ret;\n}", "contrast": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\nint eticklen, const unsigned char *sess_id,\nint sesslen, SSL_SESSION **psess)\n{\nSSL_SESSION *sess;\nunsigned char *sdec;\nconst unsigned char *p;\nint slen, mlen, renew_ticket = 0, ret = -1;\nunsigned char tick_hmac[EVP_MAX_MD_SIZE];\nHMAC_CTX *hctx = NULL;\nEVP_CIPHER_CTX *ctx;\nSSL_CTX *tctx = s->initial_ctx;\nhctx = HMAC_CTX_new();\nif (hctx == NULL)\nhctx = HMAC_CTX_new();\nif (hctx == NULL)\nreturn -2;\nctx = EVP_CIPHER_CTX_new();\nif (ctx == NULL) {\nret = -2;\ngoto err;\n}\nif (tctx->tlsext_ticket_key_cb) {\nunsigned char *nctick = (unsigned char *)etick;\nint rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\nctx, hctx, 0);\nif (rv < 0)\ngoto err;\nif (rv == 0) {\nret = 2;\ngoto err;\n}\nif (rv == 2)\nrenew_ticket = 1;\n} else {\nif (memcmp(etick, tctx->tlsext_tick_key_name,\nsizeof(tctx->tlsext_tick_key_name)) != 0) {\nret = 2;\ngoto err;\n}\nif (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,\nsizeof(tctx->tlsext_tick_hmac_key),\nEVP_sha256(), NULL) <= 0\n|| EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,\ntctx->tlsext_tick_aes_key,\netick + sizeof(tctx->tlsext_tick_key_name)) <=\n0) {\ngoto err;\n}\n}\nif (eticklen <=\nTLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {\nret = 2;\ngoto err;\n}\neticklen -= mlen;\nif (HMAC_Update(hctx, etick, eticklen) <= 0\nif (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\nEVP_CIPHER_CTX_free(ctx);\nreturn 2;\n}\np = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);\neticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);\nsdec = OPENSSL_malloc(eticklen);\nif (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {\nEVP_CIPHER_CTX_free(ctx);\nOPENSSL_free(sdec);\nreturn -1;\n}\nif (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {\nEVP_CIPHER_CTX_free(ctx);\nOPENSSL_free(sdec);\nreturn 2;\n}\nslen += mlen;\nEVP_CIPHER_CTX_free(ctx);\nctx = NULL;\np = sdec;\nsess = d2i_SSL_SESSION(NULL, &p, slen);\nOPENSSL_free(sdec);\nif (sess) {\nif (sesslen)\nmemcpy(sess->session_id, sess_id, sesslen);\nsess->session_id_length = sesslen;\n*psess = sess;\nif (renew_ticket)\nreturn 4;\nelse\nreturn 3;\n}\nERR_clear_error();\nreturn 2;\nerr:\nEVP_CIPHER_CTX_free(ctx);\nHMAC_CTX_free(hctx);\nreturn ret;\n}", "label": 0}
{"index": 174784, "code": "XvQueryAdaptors(\nDisplay *dpy,\nWindow window,\nunsigned int *p_nAdaptors,\nXvAdaptorInfo **p_pAdaptors)\n{\nXExtDisplayInfo *info = xv_find_display(dpy);\nxvQueryAdaptorsReq *req;\nxvQueryAdaptorsReply rep;\nsize_t size;\nunsigned int ii, jj;\nchar *name;\nXvAdaptorInfo *pas = NULL, *pa;\nXvFormat *pfs, *pf;\nchar *buffer = NULL;\nchar *buffer;\nchar *string;\nxvAdaptorInfo *pa;\nxvFormat *pf;\n} u;", "contrast": "XvQueryAdaptors(\nDisplay *dpy,\nWindow window,\nunsigned int *p_nAdaptors,\nXvAdaptorInfo **p_pAdaptors)\n{\nXExtDisplayInfo *info = xv_find_display(dpy);\nxvQueryAdaptorsReq *req;\nxvQueryAdaptorsReply rep;\nsize_t size;\nunsigned int ii, jj;\nchar *name;\nchar *end;\nXvAdaptorInfo *pas = NULL, *pa;\nXvFormat *pfs, *pf;\nchar *buffer = NULL;\nchar *buffer;\nchar *string;\nxvAdaptorInfo *pa;\nxvFormat *pf;\n} u;", "label": 0}
{"index": 174807, "code": "void _xml_characterDataHandler(void *userData, const XML_Char *s, int len)\n{\nxml_parser *parser = (xml_parser *)userData;\nif (parser) {\nzval *retval, *args[2];\nif (parser->characterDataHandler) {\nargs[0] = _xml_resource_zval(parser->index);\nargs[1] = _xml_xmlchar_zval(s, len, parser->target_encoding);\nif ((retval = xml_call_handler(parser, parser->characterDataHandler, parser->characterDataPtr, 2, args))) {\nzval_ptr_dtor(&retval);\n}\n}\nif (parser->data) {\nint i;\nint doprint = 0;\nchar *decoded_value;\nint decoded_len;\ndecoded_value = xml_utf8_decode(s,len,&decoded_len,parser->target_encoding);\nfor (i = 0; i < decoded_len; i++) {\nswitch (decoded_value[i]) {\ncase ' ':\ncase '\\t':\ncase '\\n':\ncontinue;\ndefault:\ndoprint = 1;\nbreak;\n}\nif (doprint) {\nbreak;\n}\n}\nif (doprint || (! parser->skipwhite)) {\nif (parser->lastwasopen) {\nzval **myval;\nif (zend_hash_find(Z_ARRVAL_PP(parser->ctag),\"value\",sizeof(\"value\"),(void **) &myval) == SUCCESS) {\nint newlen = Z_STRLEN_PP(myval) + decoded_len;\nZ_STRVAL_PP(myval) = erealloc(Z_STRVAL_PP(myval),newlen+1);\nstrncpy(Z_STRVAL_PP(myval) + Z_STRLEN_PP(myval), decoded_value, decoded_len + 1);\nZ_STRLEN_PP(myval) += decoded_len;\nefree(decoded_value);\n} else {\nadd_assoc_string(*(parser->ctag),\"value\",decoded_value,0);\n}\n} else {\nzval *tag;\nzval **curtag, **mytype, **myval;\nHashPosition hpos=NULL;\nzend_hash_internal_pointer_end_ex(Z_ARRVAL_P(parser->data), &hpos);\nif (hpos && (zend_hash_get_current_data_ex(Z_ARRVAL_P(parser->data), (void **) &curtag, &hpos) == SUCCESS)) {\nif (zend_hash_find(Z_ARRVAL_PP(curtag),\"type\",sizeof(\"type\"),(void **) &mytype) == SUCCESS) {\nif (!strcmp(Z_STRVAL_PP(mytype), \"cdata\")) {\nif (zend_hash_find(Z_ARRVAL_PP(curtag),\"value\",sizeof(\"value\"),(void **) &myval) == SUCCESS) {\nint newlen = Z_STRLEN_PP(myval) + decoded_len;\nZ_STRVAL_PP(myval) = erealloc(Z_STRVAL_PP(myval),newlen+1);\nstrncpy(Z_STRVAL_PP(myval) + Z_STRLEN_PP(myval), decoded_value, decoded_len + 1);\nZ_STRLEN_PP(myval) += decoded_len;\nefree(decoded_value);\nreturn;\n}\n}\n}\n}\nif (parser->level <= XML_MAXLEVEL) {\nMAKE_STD_ZVAL(tag);\narray_init(tag);\n_xml_add_to_info(parser,parser->ltags[parser->level-1] + parser->toffset);\nadd_assoc_string(tag,\"tag\",parser->ltags[parser->level-1] + parser->toffset,1);\nadd_assoc_string(tag,\"value\",decoded_value,0);\nadd_assoc_string(tag,\"type\",\"cdata\",1);\nadd_assoc_long(tag,\"level\",parser->level);\nzend_hash_next_index_insert(Z_ARRVAL_P(parser->data),&tag,sizeof(zval*),NULL);\n} else if (parser->level == (XML_MAXLEVEL + 1)) {\nTSRMLS_FETCH();\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Maximum depth exceeded - Results truncated\");\n}\n}\n} else {\nefree(decoded_value);\n}\n}\n}\n}", "contrast": "void _xml_characterDataHandler(void *userData, const XML_Char *s, int len)\n{\nxml_parser *parser = (xml_parser *)userData;\nif (parser) {\nzval *retval, *args[2];\nif (parser->characterDataHandler) {\nargs[0] = _xml_resource_zval(parser->index);\nargs[1] = _xml_xmlchar_zval(s, len, parser->target_encoding);\nif ((retval = xml_call_handler(parser, parser->characterDataHandler, parser->characterDataPtr, 2, args))) {\nzval_ptr_dtor(&retval);\n}\n}\nif (parser->data) {\nint i;\nint doprint = 0;\nchar *decoded_value;\nint decoded_len;\ndecoded_value = xml_utf8_decode(s,len,&decoded_len,parser->target_encoding);\nfor (i = 0; i < decoded_len; i++) {\nswitch (decoded_value[i]) {\ncase ' ':\ncase '\\t':\ncase '\\n':\ncontinue;\ndefault:\ndoprint = 1;\nbreak;\n}\nif (doprint) {\nbreak;\n}\n}\nif (doprint || (! parser->skipwhite)) {\nif (parser->lastwasopen) {\nzval **myval;\nif (zend_hash_find(Z_ARRVAL_PP(parser->ctag),\"value\",sizeof(\"value\"),(void **) &myval) == SUCCESS) {\nint newlen = Z_STRLEN_PP(myval) + decoded_len;\nZ_STRVAL_PP(myval) = erealloc(Z_STRVAL_PP(myval),newlen+1);\nstrncpy(Z_STRVAL_PP(myval) + Z_STRLEN_PP(myval), decoded_value, decoded_len + 1);\nZ_STRLEN_PP(myval) += decoded_len;\nefree(decoded_value);\n} else {\nadd_assoc_string(*(parser->ctag),\"value\",decoded_value,0);\n}\n} else {\nzval *tag;\nzval **curtag, **mytype, **myval;\nHashPosition hpos=NULL;\nzend_hash_internal_pointer_end_ex(Z_ARRVAL_P(parser->data), &hpos);\nif (hpos && (zend_hash_get_current_data_ex(Z_ARRVAL_P(parser->data), (void **) &curtag, &hpos) == SUCCESS)) {\nif (zend_hash_find(Z_ARRVAL_PP(curtag),\"type\",sizeof(\"type\"),(void **) &mytype) == SUCCESS) {\nif (!strcmp(Z_STRVAL_PP(mytype), \"cdata\")) {\nif (zend_hash_find(Z_ARRVAL_PP(curtag),\"value\",sizeof(\"value\"),(void **) &myval) == SUCCESS) {\nint newlen = Z_STRLEN_PP(myval) + decoded_len;\nZ_STRVAL_PP(myval) = erealloc(Z_STRVAL_PP(myval),newlen+1);\nstrncpy(Z_STRVAL_PP(myval) + Z_STRLEN_PP(myval), decoded_value, decoded_len + 1);\nZ_STRLEN_PP(myval) += decoded_len;\nefree(decoded_value);\nreturn;\n}\n}\n}\n}\nif (parser->level <= XML_MAXLEVEL && parser->level > 0) {\nMAKE_STD_ZVAL(tag);\narray_init(tag);\n_xml_add_to_info(parser,parser->ltags[parser->level-1] + parser->toffset);\nadd_assoc_string(tag,\"tag\",parser->ltags[parser->level-1] + parser->toffset,1);\nadd_assoc_string(tag,\"value\",decoded_value,0);\nadd_assoc_string(tag,\"type\",\"cdata\",1);\nadd_assoc_long(tag,\"level\",parser->level);\nzend_hash_next_index_insert(Z_ARRVAL_P(parser->data),&tag,sizeof(zval*),NULL);\n} else if (parser->level == (XML_MAXLEVEL + 1)) {\nTSRMLS_FETCH();\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Maximum depth exceeded - Results truncated\");\n}\n}\n} else {\nefree(decoded_value);\n}\n}\n}\n}", "label": 0}
{"index": 174816, "code": "void chain_reply(struct smb_request *req)\n{\nsize_t smblen = smb_len(req->inbuf);\nsize_t already_used, length_needed;\nuint8_t chain_cmd;\nuint32_t chain_offset;\nuint8_t wct;\nuint16_t *vwv;\nuint16_t buflen;\nuint8_t *buf;\nif (IVAL(req->outbuf, smb_rcls) != 0) {\nfixup_chain_error_packet(req);\n}\nif ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {\ngoto error;\n}\nif (req->chain_outbuf == NULL) {\nreq->chain_outbuf = TALLOC_REALLOC_ARRAY(\nreq, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);\nif (req->chain_outbuf == NULL) {\ngoto error;\n}\nreq->outbuf = NULL;\n} else {\nchain_cmd = CVAL(req->vwv+0, 0);\nchain_offset = SVAL(req->vwv+1, 0);\nif (chain_cmd == 0xff) {\nsmb_setlen((char *)(req->chain_outbuf),\ntalloc_get_size(req->chain_outbuf) - 4);\nif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\ntrue, req->seqnum+1,\nIS_CONN_ENCRYPTED(req->conn)\n||req->encrypted,\n&req->pcd)) {\nexit_server_cleanly(\"chain_reply: srv_send_smb \"\n\"failed.\");\n}\nTALLOC_FREE(req->chain_outbuf);\nreq->done = true;\nreturn;\n}\nSMB_PERFCOUNT_ADD(&req->pcd);\nSMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);\nSMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);\nalready_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));\nif (chain_offset < already_used) {\ngoto error;\n}\nlength_needed = chain_offset+1;\nif (length_needed > smblen) {\ngoto error;\n}\nwct = CVAL(smb_base(req->inbuf), chain_offset);\nlength_needed += (wct+1)*sizeof(uint16_t);\nif (length_needed > smblen) {\ngoto error;\n}\nvwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);\nbuflen = SVAL(vwv+wct, 0);\nlength_needed += buflen;\nif (length_needed > smblen) {\ngoto error;\n}\nbuf = (uint8_t *)(vwv+wct+1);\nreq->cmd = chain_cmd;\nreq->wct = wct;\nreq->vwv = vwv;\nreq->buflen = buflen;\nreq->buf = buf;\nswitch_message(chain_cmd, req, smblen);\nif (req->outbuf == NULL) {\nreturn;\n}\ngoto done;\nerror:\nreply_force_doserror(req, ERRSRV, ERRerror);\nfixup_chain_error_packet(req);\ndone:\nSSVAL(req->chain_outbuf, smb_flg2,\n(SVAL(req->chain_outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)\n| (SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));\nSSVAL(req->chain_outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));\nSSVAL(req->chain_outbuf, smb_err, SVAL(req->outbuf, smb_err));\nif (!smb_splice_chain(&req->chain_outbuf,\nCVAL(req->outbuf, smb_com),\nCVAL(req->outbuf, smb_wct),\n(uint16_t *)(req->outbuf + smb_vwv),\n0, smb_buflen(req->outbuf),\n(uint8_t *)smb_buf(req->outbuf))) {\nexit_server_cleanly(\"chain_reply: smb_splice_chain failed\\n\");\n}\nTALLOC_FREE(req->outbuf);\nsmb_setlen((char *)(req->chain_outbuf),\ntalloc_get_size(req->chain_outbuf) - 4);\nshow_msg((char *)(req->chain_outbuf));\nif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\ntrue, req->seqnum+1,\nIS_CONN_ENCRYPTED(req->conn)||req->encrypted,\n&req->pcd)) {\nexit_server_cleanly(\"construct_reply: srv_send_smb failed.\");\n}\nTALLOC_FREE(req->chain_outbuf);\nreq->done = true;\n}", "contrast": "void chain_reply(struct smb_request *req)\n{\nsize_t smblen = smb_len(req->inbuf);\nsize_t already_used, length_needed;\nuint8_t chain_cmd;\nuint32_t chain_offset;\nuint8_t wct;\nuint16_t *vwv;\nuint16_t buflen;\nuint8_t *buf;\nif (IVAL(req->outbuf, smb_rcls) != 0) {\nfixup_chain_error_packet(req);\n}\nif ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {\nif (req->chain_outbuf == NULL) {\nreq->chain_outbuf = TALLOC_REALLOC_ARRAY(\nreq, req->outbuf, uint8_t,\nsmb_len(req->outbuf) + 4);\nif (req->chain_outbuf == NULL) {\nsmb_panic(\"talloc failed\");\n}\n}\nreq->outbuf = NULL;\ngoto error;\n}\nif (req->chain_outbuf == NULL) {\nreq->chain_outbuf = TALLOC_REALLOC_ARRAY(\nreq, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);\nif (req->chain_outbuf == NULL) {\ngoto error;\n}\nreq->outbuf = NULL;\n} else {\nchain_cmd = CVAL(req->vwv+0, 0);\nchain_offset = SVAL(req->vwv+1, 0);\nif (chain_cmd == 0xff) {\nsmb_setlen((char *)(req->chain_outbuf),\ntalloc_get_size(req->chain_outbuf) - 4);\nif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\ntrue, req->seqnum+1,\nIS_CONN_ENCRYPTED(req->conn)\n||req->encrypted,\n&req->pcd)) {\nexit_server_cleanly(\"chain_reply: srv_send_smb \"\n\"failed.\");\n}\nTALLOC_FREE(req->chain_outbuf);\nreq->done = true;\nreturn;\n}\nSMB_PERFCOUNT_ADD(&req->pcd);\nSMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);\nSMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);\nalready_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));\nif (chain_offset < already_used) {\ngoto error;\n}\nlength_needed = chain_offset+1;\nif (length_needed > smblen) {\ngoto error;\n}\nwct = CVAL(smb_base(req->inbuf), chain_offset);\nlength_needed += (wct+1)*sizeof(uint16_t);\nif (length_needed > smblen) {\ngoto error;\n}\nvwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);\nbuflen = SVAL(vwv+wct, 0);\nlength_needed += buflen;\nif (length_needed > smblen) {\ngoto error;\n}\nbuf = (uint8_t *)(vwv+wct+1);\nreq->cmd = chain_cmd;\nreq->wct = wct;\nreq->vwv = vwv;\nreq->buflen = buflen;\nreq->buf = buf;\nswitch_message(chain_cmd, req, smblen);\nif (req->outbuf == NULL) {\nreturn;\n}\ngoto done;\nerror:\nreply_force_doserror(req, ERRSRV, ERRerror);\nfixup_chain_error_packet(req);\ndone:\nSSVAL(req->chain_outbuf, smb_flg2,\n(SVAL(req->chain_outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)\n| (SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));\nSSVAL(req->chain_outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));\nSSVAL(req->chain_outbuf, smb_err, SVAL(req->outbuf, smb_err));\nif (!smb_splice_chain(&req->chain_outbuf,\nCVAL(req->outbuf, smb_com),\nCVAL(req->outbuf, smb_wct),\n(uint16_t *)(req->outbuf + smb_vwv),\n0, smb_buflen(req->outbuf),\n(uint8_t *)smb_buf(req->outbuf))) {\nexit_server_cleanly(\"chain_reply: smb_splice_chain failed\\n\");\n}\nTALLOC_FREE(req->outbuf);\nsmb_setlen((char *)(req->chain_outbuf),\ntalloc_get_size(req->chain_outbuf) - 4);\nshow_msg((char *)(req->chain_outbuf));\nif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\ntrue, req->seqnum+1,\nIS_CONN_ENCRYPTED(req->conn)||req->encrypted,\n&req->pcd)) {\nexit_server_cleanly(\"construct_reply: srv_send_smb failed.\");\n}\nTALLOC_FREE(req->chain_outbuf);\nreq->done = true;\n}", "label": 0}
{"index": 174822, "code": "PHP_METHOD(Phar, unlinkArchive)\n{\nchar *fname, *error, *zname, *arch, *entry;\nsize_t fname_len;\nint zname_len, arch_len, entry_len;\nphar_archive_data *phar;\nif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\nRETURN_FALSE;\n}\nif (!fname_len) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"\\\"\");\nreturn;\n}\nif (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error)) {\nif (error) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"%s\\\": %s\", fname, error);\nefree(error);\n} else {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"%s\\\"\", fname);\n}\nreturn;\n}\nzname = (char*)zend_get_executed_filename();\nzname_len = strlen(zname);\nif (zname_len > 7 && !memcmp(zname, \"phar://\", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0)) {\nif (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" cannot be unlinked from within itself\", fname);\nefree(arch);\nefree(entry);\nreturn;\n}\nefree(arch);\nefree(entry);\n}\nif (phar->is_persistent) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" is in phar.cache_list, cannot unlinkArchive()\", fname);\nreturn;\n}\nif (phar->refcount) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()\", fname);\nreturn;\n}\nfname = estrndup(phar->fname, phar->fname_len);\nPHAR_G(last_phar) = NULL;\nPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\nphar_archive_delref(phar);\nunlink(fname);\nefree(fname);\nRETURN_TRUE;\n}", "contrast": "PHP_METHOD(Phar, unlinkArchive)\n{\nchar *fname, *error, *zname, *arch, *entry;\nsize_t fname_len;\nint zname_len, arch_len, entry_len;\nphar_archive_data *phar;\nif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {\nRETURN_FALSE;\n}\nif (!fname_len) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"\\\"\");\nreturn;\n}\nif (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error)) {\nif (error) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"%s\\\": %s\", fname, error);\nefree(error);\n} else {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"%s\\\"\", fname);\n}\nreturn;\n}\nzname = (char*)zend_get_executed_filename();\nzname_len = strlen(zname);\nif (zname_len > 7 && !memcmp(zname, \"phar://\", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0)) {\nif (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" cannot be unlinked from within itself\", fname);\nefree(arch);\nefree(entry);\nreturn;\n}\nefree(arch);\nefree(entry);\n}\nif (phar->is_persistent) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" is in phar.cache_list, cannot unlinkArchive()\", fname);\nreturn;\n}\nif (phar->refcount) {\nzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()\", fname);\nreturn;\n}\nfname = estrndup(phar->fname, phar->fname_len);\nPHAR_G(last_phar) = NULL;\nPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\nphar_archive_delref(phar);\nunlink(fname);\nefree(fname);\nRETURN_TRUE;\n}", "label": 0}
{"index": 174833, "code": "PHP_METHOD(Phar, extractTo)\n{\nchar *error = NULL;\nphp_stream *fp;\nphp_stream_statbuf ssb;\nphar_entry_info *entry;\nchar *pathto, *filename;\nsize_t pathto_len, filename_len;\nint ret, i;\nint nelems;\nzval *zval_files = NULL;\nzend_bool overwrite = 0;\nPHAR_ARCHIVE_OBJECT();\nif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z!b\", &pathto, &pathto_len, &zval_files, &overwrite) == FAILURE) {\nreturn;\n}\nfp = php_stream_open_wrapper(phar_obj->archive->fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK, NULL);\nif (!fp) {\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, %s cannot be found\", phar_obj->archive->fname);\nreturn;\n}\nphp_stream_close(fp);\nif (pathto_len < 1) {\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, extraction path must be non-zero length\");\nreturn;\n}\nif (pathto_len >= MAXPATHLEN) {\nchar *tmp = estrndup(pathto, 50);\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0, \"Cannot extract to \\\"%s...\\\", destination directory is too long for filesystem\", tmp);\nefree(tmp);\nreturn;\n}\nif (php_stream_stat_path(pathto, &ssb) < 0) {\nret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\nif (!ret) {\nzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\"Unable to create path \\\"%s\\\" for extraction\", pathto);\nreturn;\n}\n} else if (!(ssb.sb.st_mode & S_IFDIR)) {\nzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\"Unable to use path \\\"%s\\\" for extraction, it is a file, must be a directory\", pathto);\nreturn;\n}\nif (zval_files) {\nswitch (Z_TYPE_P(zval_files)) {\ncase IS_NULL:\ngoto all_files;\ncase IS_STRING:\nfilename = Z_STRVAL_P(zval_files);\nfilename_len = Z_STRLEN_P(zval_files);\nbreak;\ncase IS_ARRAY:\nnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\nif (nelems == 0 ) {\nRETURN_FALSE;\n}\nfor (i = 0; i < nelems; i++) {\nzval *zval_file;\nif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\nswitch (Z_TYPE_P(zval_file)) {\ncase IS_STRING:\nbreak;\ndefault:\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, array of filenames to extract contains non-string value\");\nreturn;\n}\nif (NULL == (entry = zend_hash_find_ptr(&phar_obj->archive->manifest, Z_STR_P(zval_file)))) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Phar Error: attempted to extract non-existent file \\\"%s\\\" from phar \\\"%s\\\"\", Z_STRVAL_P(zval_file), phar_obj->archive->fname);\n}\nif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Extraction from phar \\\"%s\\\" failed: %s\", phar_obj->archive->fname, error);\nefree(error);\nreturn;\n}\n}\n}\nRETURN_TRUE;\ndefault:\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, expected a filename (string) or array of filenames\");\nreturn;\n}\nif (NULL == (entry = zend_hash_str_find_ptr(&phar_obj->archive->manifest, filename, filename_len))) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Phar Error: attempted to extract non-existent file \\\"%s\\\" from phar \\\"%s\\\"\", filename, phar_obj->archive->fname);\nreturn;\n}\nif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Extraction from phar \\\"%s\\\" failed: %s\", phar_obj->archive->fname, error);\nefree(error);\nreturn;\n}\n} else {\nphar_archive_data *phar;\nall_files:\nphar = phar_obj->archive;\nif (!zend_hash_num_elements(&(phar->manifest))) {\nRETURN_TRUE;\n}\nZEND_HASH_FOREACH_PTR(&phar->manifest, entry) {\nif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Extraction from phar \\\"%s\\\" failed: %s\", phar->fname, error);\nefree(error);\nreturn;\n}\n} ZEND_HASH_FOREACH_END();\n}\nRETURN_TRUE;\n}", "contrast": "PHP_METHOD(Phar, extractTo)\n{\nchar *error = NULL;\nphp_stream *fp;\nphp_stream_statbuf ssb;\nphar_entry_info *entry;\nchar *pathto, *filename;\nsize_t pathto_len, filename_len;\nint ret, i;\nint nelems;\nzval *zval_files = NULL;\nzend_bool overwrite = 0;\nPHAR_ARCHIVE_OBJECT();\nif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p|z!b\", &pathto, &pathto_len, &zval_files, &overwrite) == FAILURE) {\nreturn;\n}\nfp = php_stream_open_wrapper(phar_obj->archive->fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK, NULL);\nif (!fp) {\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, %s cannot be found\", phar_obj->archive->fname);\nreturn;\n}\nphp_stream_close(fp);\nif (pathto_len < 1) {\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, extraction path must be non-zero length\");\nreturn;\n}\nif (pathto_len >= MAXPATHLEN) {\nchar *tmp = estrndup(pathto, 50);\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0, \"Cannot extract to \\\"%s...\\\", destination directory is too long for filesystem\", tmp);\nefree(tmp);\nreturn;\n}\nif (php_stream_stat_path(pathto, &ssb) < 0) {\nret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\nif (!ret) {\nzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\"Unable to create path \\\"%s\\\" for extraction\", pathto);\nreturn;\n}\n} else if (!(ssb.sb.st_mode & S_IFDIR)) {\nzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\"Unable to use path \\\"%s\\\" for extraction, it is a file, must be a directory\", pathto);\nreturn;\n}\nif (zval_files) {\nswitch (Z_TYPE_P(zval_files)) {\ncase IS_NULL:\ngoto all_files;\ncase IS_STRING:\nfilename = Z_STRVAL_P(zval_files);\nfilename_len = Z_STRLEN_P(zval_files);\nbreak;\ncase IS_ARRAY:\nnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\nif (nelems == 0 ) {\nRETURN_FALSE;\n}\nfor (i = 0; i < nelems; i++) {\nzval *zval_file;\nif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\nswitch (Z_TYPE_P(zval_file)) {\ncase IS_STRING:\nbreak;\ndefault:\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, array of filenames to extract contains non-string value\");\nreturn;\n}\nif (NULL == (entry = zend_hash_find_ptr(&phar_obj->archive->manifest, Z_STR_P(zval_file)))) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Phar Error: attempted to extract non-existent file \\\"%s\\\" from phar \\\"%s\\\"\", Z_STRVAL_P(zval_file), phar_obj->archive->fname);\n}\nif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Extraction from phar \\\"%s\\\" failed: %s\", phar_obj->archive->fname, error);\nefree(error);\nreturn;\n}\n}\n}\nRETURN_TRUE;\ndefault:\nzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\"Invalid argument, expected a filename (string) or array of filenames\");\nreturn;\n}\nif (NULL == (entry = zend_hash_str_find_ptr(&phar_obj->archive->manifest, filename, filename_len))) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Phar Error: attempted to extract non-existent file \\\"%s\\\" from phar \\\"%s\\\"\", filename, phar_obj->archive->fname);\nreturn;\n}\nif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Extraction from phar \\\"%s\\\" failed: %s\", phar_obj->archive->fname, error);\nefree(error);\nreturn;\n}\n} else {\nphar_archive_data *phar;\nall_files:\nphar = phar_obj->archive;\nif (!zend_hash_num_elements(&(phar->manifest))) {\nRETURN_TRUE;\n}\nZEND_HASH_FOREACH_PTR(&phar->manifest, entry) {\nif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\nzend_throw_exception_ex(phar_ce_PharException, 0,\n\"Extraction from phar \\\"%s\\\" failed: %s\", phar->fname, error);\nefree(error);\nreturn;\n}\n} ZEND_HASH_FOREACH_END();\n}\nRETURN_TRUE;\n}", "label": 0}
{"index": 174857, "code": "my_object_emit_signals (MyObject *obj, GError **error)\n{\nGValue val = {0, };\ng_signal_emit (obj, signals[SIG0], 0, \"foo\", 22, \"moo\");\ng_value_init (&val, G_TYPE_STRING);\ng_value_set_string (&val, \"bar\");\ng_signal_emit (obj, signals[SIG1], 0, \"baz\", &val);\ng_value_unset (&val);\nreturn TRUE;\n}", "contrast": "my_object_emit_signals (MyObject *obj, GError **error)", "label": 0}
{"index": 174859, "code": "my_object_error_quark (void)\n{\nstatic GQuark quark = 0;\nif (!quark)\nquark = g_quark_from_static_string (\"my_object_error\");\nreturn quark;\n}", "contrast": "my_object_error_quark (void)", "label": 0}
{"index": 174868, "code": "my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)\n{\nif (x + 1 > 10)\n{\ng_set_error (error,\nMY_OBJECT_ERROR,\nMY_OBJECT_ERROR_FOO,\n\"%s\",\n\"x is bigger than 9\");\nreturn FALSE;\n}\nreturn x + 1;\n}", "contrast": "my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)", "label": 0}
{"index": 174869, "code": "my_object_increment_val (MyObject *obj, GError **error)\n{\nobj->val++;\nreturn TRUE;\n}", "contrast": "my_object_increment_val (MyObject *obj, GError **error)", "label": 0}
{"index": 174886, "code": "my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error)\n{\nif (str[0] == '\\0' || !g_ascii_isdigit (str[0])) {\ng_value_init (value, G_TYPE_STRING);\ng_value_set_string (value, str);\n} else {\ng_value_init (value, G_TYPE_INT);\ng_value_set_int (value, (int) g_ascii_strtoull (str, NULL, 10));\n}\nreturn TRUE;\n}", "contrast": "my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error)", "label": 0}
{"index": 174888, "code": "unset_and_free_gvalue (gpointer val)\n{\ng_value_unset (val);\ng_free (val);\n}", "contrast": "unset_and_free_gvalue (gpointer val)", "label": 0}
{"index": 174895, "code": "static js_Ast *memberexp(js_State *J)\n{\njs_Ast *a;\nINCREC();\na = newexp(J);\nloop:\nif (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }\nif (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }\nDECREC();\nreturn a;\n}", "contrast": "static js_Ast *memberexp(js_State *J)\n{\njs_Ast *a = newexp(J);\nSAVEREC();\nloop:\nINCREC();\nif (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }\nif (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }\nPOPREC();\nreturn a;\n}", "label": 0}
{"index": 174899, "code": "int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n{\nint al, i, j, ret;\nunsigned int n;\nSSL3_RECORD *rr;\nvoid (*cb) (const SSL *ssl, int type2, int val) = NULL;\nif (s->s3->rbuf.buf == NULL)\nif (!ssl3_setup_read_buffer(s))\nreturn (-1);\nif ((type && (type != SSL3_RT_APPLICATION_DATA)\n&& (type != SSL3_RT_HANDSHAKE)) || (peek\n&& (type !=\nSSL3_RT_APPLICATION_DATA))) {\nSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\nreturn -1;\n}\nif ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))\n{\nunsigned char *src = s->s3->handshake_fragment;\nunsigned char *dst = buf;\nunsigned int k;\nn = 0;\nwhile ((len > 0) && (s->s3->handshake_fragment_len > 0)) {\n*dst++ = *src++;\nlen--;\ns->s3->handshake_fragment_len--;\nn++;\n}\nfor (k = 0; k < s->s3->handshake_fragment_len; k++)\ns->s3->handshake_fragment[k] = *src++;\nreturn n;\n}\nif (!s->in_handshake && SSL_in_init(s)) {\ni = s->handshake_func(s);\nif (i < 0)\nreturn (i);\nif (i == 0) {\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\nreturn (-1);\n}\n}\nstart:\ns->rwstate = SSL_NOTHING;\nrr = &(s->s3->rrec);\nif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY)) {\nret = ssl3_get_record(s);\nif (ret <= 0)\nreturn (ret);\n}\nif (rr->type != SSL3_RT_ALERT && rr->length != 0)\ns->cert->alert_count = 0;\nif (s->s3->change_cipher_spec\n&& (rr->type != SSL3_RT_HANDSHAKE)) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\ngoto f_err;\n}\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\nrr->length = 0;\ns->rwstate = SSL_NOTHING;\nreturn (0);\n}\nif (type == rr->type) {\nif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n(s->enc_read_ctx == NULL)) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\ngoto f_err;\n}\nif (len <= 0)\nreturn (len);\nif ((unsigned int)len > rr->length)\nn = rr->length;\nelse\nn = (unsigned int)len;\nmemcpy(buf, &(rr->data[rr->off]), n);\nif (!peek) {\nrr->length -= n;\nrr->off += n;\nif (rr->length == 0) {\ns->rstate = SSL_ST_READ_HEADER;\nrr->off = 0;\nif (s->mode & SSL_MODE_RELEASE_BUFFERS\n&& s->s3->rbuf.left == 0)\nssl3_release_read_buffer(s);\n}\n}\nreturn (n);\n}\n{\nunsigned int dest_maxlen = 0;\nunsigned char *dest = NULL;\nunsigned int *dest_len = NULL;\nif (rr->type == SSL3_RT_HANDSHAKE) {\ndest_maxlen = sizeof(s->s3->handshake_fragment);\ndest = s->s3->handshake_fragment;\ndest_len = &s->s3->handshake_fragment_len;\n} else if (rr->type == SSL3_RT_ALERT) {\ndest_maxlen = sizeof(s->s3->alert_fragment);\ndest = s->s3->alert_fragment;\ndest_len = &s->s3->alert_fragment_len;\n}\n#ifndef OPENSSL_NO_HEARTBEATS\nelse if (rr->type == TLS1_RT_HEARTBEAT) {\ni = tls1_process_heartbeat(s);\nif (i < 0)\nreturn i;\nrr->length = 0;\nif (s->mode & SSL_MODE_AUTO_RETRY)\ngoto start;\ns->rwstate = SSL_READING;\nBIO_clear_retry_flags(SSL_get_rbio(s));\nBIO_set_retry_read(SSL_get_rbio(s));\nreturn (-1);\n}\n#endif\nif (dest_maxlen > 0) {\nn = dest_maxlen - *dest_len;\nif (rr->length < n)\nn = rr->length;\nwhile (n-- > 0) {\ndest[(*dest_len)++] = rr->data[rr->off++];\nrr->length--;\n}\nif (*dest_len < dest_maxlen)\ngoto start;\n}\n}\nif ((!s->server) &&\n(s->s3->handshake_fragment_len >= 4) &&\n(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n(s->session != NULL) && (s->session->cipher != NULL)) {\ns->s3->handshake_fragment_len = 0;\nif ((s->s3->handshake_fragment[1] != 0) ||\n(s->s3->handshake_fragment[2] != 0) ||\n(s->s3->handshake_fragment[3] != 0)) {\nal = SSL_AD_DECODE_ERROR;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\ngoto f_err;\n}\nif (s->msg_callback)\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\ns->s3->handshake_fragment, 4, s,\ns->msg_callback_arg);\nif (SSL_is_init_finished(s) &&\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n!s->s3->renegotiate) {\nssl3_renegotiate(s);\nif (ssl3_renegotiate_check(s)) {\ni = s->handshake_func(s);\nif (i < 0)\nreturn (i);\nif (i == 0) {\nSSLerr(SSL_F_SSL3_READ_BYTES,\nSSL_R_SSL_HANDSHAKE_FAILURE);\nreturn (-1);\n}\nif (!(s->mode & SSL_MODE_AUTO_RETRY)) {\nif (s->s3->rbuf.left == 0) {\nBIO *bio;\ns->rwstate = SSL_READING;\nbio = SSL_get_rbio(s);\nBIO_clear_retry_flags(bio);\nBIO_set_retry_read(bio);\nreturn (-1);\n}\n}\n}\n}\ngoto start;\n}\nif (s->server\n&& SSL_is_init_finished(s)\n&& !s->s3->send_connection_binding\n&& s->version > SSL3_VERSION\n&& s->s3->handshake_fragment_len >= SSL3_HM_HEADER_LENGTH\n&& s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO\n&& s->s3->previous_client_finished_len != 0\n&& (s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) == 0) {\ns->s3->handshake_fragment_len = 0;\nrr->length = 0;\nssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\ngoto start;\n}\nif (s->s3->alert_fragment_len >= 2) {\nint alert_level = s->s3->alert_fragment[0];\nint alert_descr = s->s3->alert_fragment[1];\ns->s3->alert_fragment_len = 0;\nif (s->msg_callback)\ns->msg_callback(0, s->version, SSL3_RT_ALERT,\ns->s3->alert_fragment, 2, s, s->msg_callback_arg);\nif (s->info_callback != NULL)\ncb = s->info_callback;\nelse if (s->ctx->info_callback != NULL)\ncb = s->ctx->info_callback;\nif (cb != NULL) {\nj = (alert_level << 8) | alert_descr;\ncb(s, SSL_CB_READ_ALERT, j);\n}\nif (alert_level == SSL3_AL_WARNING) {\ns->s3->warn_alert = alert_descr;\ns->cert->alert_count++;\nif (s->cert->alert_count == MAX_WARN_ALERT_COUNT) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\ngoto f_err;\n}\nif (alert_descr == SSL_AD_CLOSE_NOTIFY) {\ns->shutdown |= SSL_RECEIVED_SHUTDOWN;\nreturn (0);\n}\nelse if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\nal = SSL_AD_HANDSHAKE_FAILURE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\ngoto f_err;\n}\n#ifdef SSL_AD_MISSING_SRP_USERNAME\nelse if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\nreturn (0);\n#endif\n} else if (alert_level == SSL3_AL_FATAL) {\nchar tmp[16];\ns->rwstate = SSL_NOTHING;\ns->s3->fatal_alert = alert_descr;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\nBIO_snprintf(tmp, sizeof(tmp), \"%d\", alert_descr);\nERR_add_error_data(2, \"SSL alert number \", tmp);\ns->shutdown |= SSL_RECEIVED_SHUTDOWN;\nSSL_CTX_remove_session(s->session_ctx, s->session);\nreturn (0);\n} else {\nal = SSL_AD_ILLEGAL_PARAMETER;\ngoto f_err;\n}\ngoto start;\n}\nif (s->shutdown & SSL_SENT_SHUTDOWN) {\ns->rwstate = SSL_NOTHING;\nrr->length = 0;\nreturn (0);\n}\nif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {\nif ((rr->length != 1) || (rr->off != 0) ||\n(rr->data[0] != SSL3_MT_CCS)) {\nal = SSL_AD_ILLEGAL_PARAMETER;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_CHANGE_CIPHER_SPEC);\ngoto f_err;\n}\nif (s->s3->tmp.new_cipher == NULL) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\ngoto f_err;\n}\nif (!(s->s3->flags & SSL3_FLAGS_CCS_OK)) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\ngoto f_err;\n}\ns->s3->flags &= ~SSL3_FLAGS_CCS_OK;\nrr->length = 0;\nif (s->msg_callback)\ns->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC,\nrr->data, 1, s, s->msg_callback_arg);\ns->s3->change_cipher_spec = 1;\nif (!ssl3_do_change_cipher_spec(s))\ngoto err;\nelse\ngoto start;\n}\nif ((s->s3->handshake_fragment_len >= 4) && !s->in_handshake) {\nif (((s->state & SSL_ST_MASK) == SSL_ST_OK) &&\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n#if 0\ns->state = SSL_ST_BEFORE | (s->server)\n? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#else\ns->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\ns->renegotiate = 1;\ns->new_session = 1;\n}\ni = s->handshake_func(s);\nif (i < 0)\nreturn (i);\nif (i == 0) {\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\nreturn (-1);\n}\nif (!(s->mode & SSL_MODE_AUTO_RETRY)) {\nif (s->s3->rbuf.left == 0) {\nBIO *bio;\ns->rwstate = SSL_READING;\nbio = SSL_get_rbio(s);\nBIO_clear_retry_flags(bio);\nBIO_set_retry_read(bio);\nreturn (-1);\n}\n}\ngoto start;\n}\nswitch (rr->type) {\ndefault:\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\ngoto f_err;\ncase SSL3_RT_CHANGE_CIPHER_SPEC:\ncase SSL3_RT_ALERT:\ncase SSL3_RT_HANDSHAKE:\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\ngoto f_err;\ncase SSL3_RT_APPLICATION_DATA:\nif (s->s3->in_read_app_data &&\n(s->s3->total_renegotiations != 0) &&\n(((s->state & SSL_ST_CONNECT) &&\n(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n) || ((s->state & SSL_ST_ACCEPT) &&\n(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n)\n)) {\ns->s3->in_read_app_data = 2;\nreturn (-1);\n} else {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\ngoto f_err;\n}\n}\nf_err:\nssl3_send_alert(s, SSL3_AL_FATAL, al);\nerr:\nreturn (-1);\n}", "contrast": "int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n{\nint al, i, j, ret;\nunsigned int n;\nSSL3_RECORD *rr;\nvoid (*cb) (const SSL *ssl, int type2, int val) = NULL;\nif (s->s3->rbuf.buf == NULL)\nif (!ssl3_setup_read_buffer(s))\nreturn (-1);\nif ((type && (type != SSL3_RT_APPLICATION_DATA)\n&& (type != SSL3_RT_HANDSHAKE)) || (peek\n&& (type !=\nSSL3_RT_APPLICATION_DATA))) {\nSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\nreturn -1;\n}\nif ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))\n{\nunsigned char *src = s->s3->handshake_fragment;\nunsigned char *dst = buf;\nunsigned int k;\nn = 0;\nwhile ((len > 0) && (s->s3->handshake_fragment_len > 0)) {\n*dst++ = *src++;\nlen--;\ns->s3->handshake_fragment_len--;\nn++;\n}\nfor (k = 0; k < s->s3->handshake_fragment_len; k++)\ns->s3->handshake_fragment[k] = *src++;\nreturn n;\n}\nif (!s->in_handshake && SSL_in_init(s)) {\ni = s->handshake_func(s);\nif (i < 0)\nreturn (i);\nif (i == 0) {\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\nreturn (-1);\n}\n}\nstart:\ns->rwstate = SSL_NOTHING;\nrr = &(s->s3->rrec);\nif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY)) {\nret = ssl3_get_record(s);\nif (ret <= 0)\nreturn (ret);\n}\nif (rr->type != SSL3_RT_ALERT && rr->length != 0)\ns->cert->alert_count = 0;\nif (s->s3->change_cipher_spec\n&& (rr->type != SSL3_RT_HANDSHAKE)) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\ngoto f_err;\n}\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\nrr->length = 0;\ns->rwstate = SSL_NOTHING;\nreturn (0);\n}\nif (type == rr->type) {\nif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n(s->enc_read_ctx == NULL)) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\ngoto f_err;\n}\nif (len <= 0)\nreturn (len);\nif ((unsigned int)len > rr->length)\nn = rr->length;\nelse\nn = (unsigned int)len;\nmemcpy(buf, &(rr->data[rr->off]), n);\nif (!peek) {\nrr->length -= n;\nrr->off += n;\nif (rr->length == 0) {\ns->rstate = SSL_ST_READ_HEADER;\nrr->off = 0;\nif (s->mode & SSL_MODE_RELEASE_BUFFERS\n&& s->s3->rbuf.left == 0)\nssl3_release_read_buffer(s);\n}\n}\nreturn (n);\n}\n{\nunsigned int dest_maxlen = 0;\nunsigned char *dest = NULL;\nunsigned int *dest_len = NULL;\nif (rr->type == SSL3_RT_HANDSHAKE) {\ndest_maxlen = sizeof(s->s3->handshake_fragment);\ndest = s->s3->handshake_fragment;\ndest_len = &s->s3->handshake_fragment_len;\n} else if (rr->type == SSL3_RT_ALERT) {\ndest_maxlen = sizeof(s->s3->alert_fragment);\ndest = s->s3->alert_fragment;\ndest_len = &s->s3->alert_fragment_len;\n}\n#ifndef OPENSSL_NO_HEARTBEATS\nelse if (rr->type == TLS1_RT_HEARTBEAT) {\ni = tls1_process_heartbeat(s);\nif (i < 0)\nreturn i;\nrr->length = 0;\nif (s->mode & SSL_MODE_AUTO_RETRY)\ngoto start;\ns->rwstate = SSL_READING;\nBIO_clear_retry_flags(SSL_get_rbio(s));\nBIO_set_retry_read(SSL_get_rbio(s));\nreturn (-1);\n}\n#endif\nif (dest_maxlen > 0) {\nn = dest_maxlen - *dest_len;\nif (rr->length < n)\nn = rr->length;\nwhile (n-- > 0) {\ndest[(*dest_len)++] = rr->data[rr->off++];\nrr->length--;\n}\nif (*dest_len < dest_maxlen)\ngoto start;\n}\n}\nif ((!s->server) &&\n(s->s3->handshake_fragment_len >= 4) &&\n(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n(s->session != NULL) && (s->session->cipher != NULL)) {\ns->s3->handshake_fragment_len = 0;\nif ((s->s3->handshake_fragment[1] != 0) ||\n(s->s3->handshake_fragment[2] != 0) ||\n(s->s3->handshake_fragment[3] != 0)) {\nal = SSL_AD_DECODE_ERROR;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\ngoto f_err;\n}\nif (s->msg_callback)\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\ns->s3->handshake_fragment, 4, s,\ns->msg_callback_arg);\nif (SSL_is_init_finished(s) &&\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n!s->s3->renegotiate) {\nssl3_renegotiate(s);\nif (ssl3_renegotiate_check(s)) {\ni = s->handshake_func(s);\nif (i < 0)\nreturn (i);\nif (i == 0) {\nSSLerr(SSL_F_SSL3_READ_BYTES,\nSSL_R_SSL_HANDSHAKE_FAILURE);\nreturn (-1);\n}\nif (!(s->mode & SSL_MODE_AUTO_RETRY)) {\nif (s->s3->rbuf.left == 0) {\nBIO *bio;\ns->rwstate = SSL_READING;\nbio = SSL_get_rbio(s);\nBIO_clear_retry_flags(bio);\nBIO_set_retry_read(bio);\nreturn (-1);\n}\n}\n}\n}\ngoto start;\n}\nif (s->server\n&& SSL_is_init_finished(s)\n&& !s->s3->send_connection_binding\n&& s->version > SSL3_VERSION\n&& s->s3->handshake_fragment_len >= SSL3_HM_HEADER_LENGTH\n&& s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO\n&& s->s3->previous_client_finished_len != 0\n&& (s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) == 0) {\ns->s3->handshake_fragment_len = 0;\nrr->length = 0;\nssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\ngoto start;\n}\nif (s->s3->alert_fragment_len >= 2) {\nint alert_level = s->s3->alert_fragment[0];\nint alert_descr = s->s3->alert_fragment[1];\ns->s3->alert_fragment_len = 0;\nif (s->msg_callback)\ns->msg_callback(0, s->version, SSL3_RT_ALERT,\ns->s3->alert_fragment, 2, s, s->msg_callback_arg);\nif (s->info_callback != NULL)\ncb = s->info_callback;\nelse if (s->ctx->info_callback != NULL)\ncb = s->ctx->info_callback;\nif (cb != NULL) {\nj = (alert_level << 8) | alert_descr;\ncb(s, SSL_CB_READ_ALERT, j);\n}\nif (alert_level == SSL3_AL_WARNING) {\ns->s3->warn_alert = alert_descr;\ns->cert->alert_count++;\nif (s->cert->alert_count == MAX_WARN_ALERT_COUNT) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\ngoto f_err;\n}\nif (alert_descr == SSL_AD_CLOSE_NOTIFY) {\ns->shutdown |= SSL_RECEIVED_SHUTDOWN;\nreturn (0);\n}\nelse if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\nal = SSL_AD_HANDSHAKE_FAILURE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\ngoto f_err;\n}\n#ifdef SSL_AD_MISSING_SRP_USERNAME\nelse if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\nreturn (0);\n#endif\n} else if (alert_level == SSL3_AL_FATAL) {\nchar tmp[16];\ns->rwstate = SSL_NOTHING;\ns->s3->fatal_alert = alert_descr;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\nBIO_snprintf(tmp, sizeof(tmp), \"%d\", alert_descr);\nERR_add_error_data(2, \"SSL alert number \", tmp);\ns->shutdown |= SSL_RECEIVED_SHUTDOWN;\nSSL_CTX_remove_session(s->session_ctx, s->session);\ns->state = SSL_ST_ERR;\nreturn (0);\n} else {\nal = SSL_AD_ILLEGAL_PARAMETER;\ngoto f_err;\n}\ngoto start;\n}\nif (s->shutdown & SSL_SENT_SHUTDOWN) {\ns->rwstate = SSL_NOTHING;\nrr->length = 0;\nreturn (0);\n}\nif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {\nif ((rr->length != 1) || (rr->off != 0) ||\n(rr->data[0] != SSL3_MT_CCS)) {\nal = SSL_AD_ILLEGAL_PARAMETER;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_CHANGE_CIPHER_SPEC);\ngoto f_err;\n}\nif (s->s3->tmp.new_cipher == NULL) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\ngoto f_err;\n}\nif (!(s->s3->flags & SSL3_FLAGS_CCS_OK)) {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\ngoto f_err;\n}\ns->s3->flags &= ~SSL3_FLAGS_CCS_OK;\nrr->length = 0;\nif (s->msg_callback)\ns->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC,\nrr->data, 1, s, s->msg_callback_arg);\ns->s3->change_cipher_spec = 1;\nif (!ssl3_do_change_cipher_spec(s))\ngoto err;\nelse\ngoto start;\n}\nif ((s->s3->handshake_fragment_len >= 4) && !s->in_handshake) {\nif (((s->state & SSL_ST_MASK) == SSL_ST_OK) &&\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n#if 0\ns->state = SSL_ST_BEFORE | (s->server)\n? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#else\ns->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\ns->renegotiate = 1;\ns->new_session = 1;\n}\ni = s->handshake_func(s);\nif (i < 0)\nreturn (i);\nif (i == 0) {\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\nreturn (-1);\n}\nif (!(s->mode & SSL_MODE_AUTO_RETRY)) {\nif (s->s3->rbuf.left == 0) {\nBIO *bio;\ns->rwstate = SSL_READING;\nbio = SSL_get_rbio(s);\nBIO_clear_retry_flags(bio);\nBIO_set_retry_read(bio);\nreturn (-1);\n}\n}\ngoto start;\n}\nswitch (rr->type) {\ndefault:\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\ngoto f_err;\ncase SSL3_RT_CHANGE_CIPHER_SPEC:\ncase SSL3_RT_ALERT:\ncase SSL3_RT_HANDSHAKE:\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\ngoto f_err;\ncase SSL3_RT_APPLICATION_DATA:\nif (s->s3->in_read_app_data &&\n(s->s3->total_renegotiations != 0) &&\n(((s->state & SSL_ST_CONNECT) &&\n(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n) || ((s->state & SSL_ST_ACCEPT) &&\n(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n)\n)) {\ns->s3->in_read_app_data = 2;\nreturn (-1);\n} else {\nal = SSL_AD_UNEXPECTED_MESSAGE;\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\ngoto f_err;\n}\n}\nf_err:\nssl3_send_alert(s, SSL3_AL_FATAL, al);\nerr:\nreturn (-1);\n}", "label": 0}
{"index": 174913, "code": "int ssl23_get_client_hello(SSL *s)\n{\nchar buf_space[11];\nchar *buf= &(buf_space[0]);\nunsigned char *p,*d,*d_len,*dd;\nunsigned int i;\nunsigned int csl,sil,cl;\nint n=0,j;\nint type=0;\nint v[2];\nif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)\n{\nv[0]=v[1]=0;\nif (!ssl3_setup_buffers(s)) goto err;\nn=ssl23_read_bytes(s, sizeof buf_space);\nif (n != sizeof buf_space) return(n);\np=s->packet;\nmemcpy(buf,p,n);\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\n{\nif ((p[3] == 0x00) && (p[4] == 0x02))\n{\nv[0]=p[3]; v[1]=p[4];\nif (!(s->options & SSL_OP_NO_SSLv2))\ntype=1;\n}\nelse if (p[3] == SSL3_VERSION_MAJOR)\n{\nv[0]=p[3]; v[1]=p[4];\nif (p[4] >= TLS1_VERSION_MINOR)\n{\nif (p[4] >= TLS1_2_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_2))\n{\ns->version=TLS1_2_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (p[4] >= TLS1_1_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_1))\n{\ns->version=TLS1_1_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_TLSv1))\n{\ns->version=TLS1_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv2))\n{\ntype=1;\n}\n}\nelse if (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv2))\ntype=1;\n}\n}\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\n(p[1] == SSL3_VERSION_MAJOR) &&\n(p[5] == SSL3_MT_CLIENT_HELLO) &&\n((p[3] == 0 && p[4] < 5  )\n|| (p[9] >= p[1])))\n{\nv[0]=p[1];\nif (p[3] == 0 && p[4] < 6)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);\ngoto err;\n}\nif (p[9] > SSL3_VERSION_MAJOR)\nv[1]=0xff;\nelse\nv[1]=p[10];\nif (v[1] >= TLS1_VERSION_MINOR)\n{\nif (v[1] >= TLS1_2_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_2))\n{\ns->version=TLS1_2_VERSION;\ntype=3;\n}\nelse if (v[1] >= TLS1_1_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_1))\n{\ns->version=TLS1_1_VERSION;\ntype=3;\n}\nelse if (!(s->options & SSL_OP_NO_TLSv1))\n{\ns->version=TLS1_VERSION;\ntype=3;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ntype=3;\n}\n}\nelse\n{\nif (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ntype=3;\n}\nelse if (!(s->options & SSL_OP_NO_TLSv1))\n{\ns->version=TLS1_VERSION;\ntype=3;\n}\n}\n}\nelse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\n(strncmp(\"POST \",(char *)p,5) == 0) ||\n(strncmp(\"HEAD \",(char *)p,5) == 0) ||\n(strncmp(\"PUT \", (char *)p,4) == 0))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\ngoto err;\n}\nelse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\ngoto err;\n}\n}\nOPENSSL_assert(s->version <= TLS_MAX_VERSION);\n#ifdef OPENSSL_FIPS\nif (FIPS_mode() && (s->version < TLS1_VERSION))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,\nSSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\ngoto err;\n}\n#endif\nif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\n{\ntype=2;\np=s->packet;\nv[0] = p[3];\nv[1] = p[4];\nn=((p[0]&0x7f)<<8)|p[1];\nif (n > (1024*4))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\ngoto err;\n}\nif (n < 9)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\ngoto err;\n}\nj=ssl23_read_bytes(s,n+2);\nif (j <= 0) return(j);\nssl3_finish_mac(s, s->packet+2, s->packet_length-2);\nif (s->msg_callback)\ns->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg);\np=s->packet;\np+=5;\nn2s(p,csl);\nn2s(p,sil);\nn2s(p,cl);\nd=(unsigned char *)s->init_buf->data;\nif ((csl+sil+cl+11) != s->packet_length)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\ngoto err;\n}\n*(d++) = SSL3_MT_CLIENT_HELLO;\nd_len = d;\nd += 3;\n*(d++) = SSL3_VERSION_MAJOR;\n*(d++) = v[1];\ni=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\nmemset(d,0,SSL3_RANDOM_SIZE);\nmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\nd+=SSL3_RANDOM_SIZE;\n*(d++)=0;\nj=0;\ndd=d;\nd+=2;\nfor (i=0; i<csl; i+=3)\n{\nif (p[i] != 0) continue;\n*(d++)=p[i+1];\n*(d++)=p[i+2];\nj+=2;\n}\ns2n(j,dd);\n*(d++)=1;\n*(d++)=0;\n#if 0\np = p+csl+sil+cl;\nwhile (p <  s->packet+s->packet_length)\n{\n*(d++)=*(p++);\n}\n#endif\ni = (d-(unsigned char *)s->init_buf->data) - 4;\nl2n3((long)i, d_len);\ns->s3->tmp.reuse_message=1;\ns->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\ns->s3->tmp.message_size=i;\n}\nif (type == 1)\n{\n#ifdef OPENSSL_NO_SSL2\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\ngoto err;\n#else\nif (s->s2 == NULL)\n{\nif (!ssl2_new(s))\ngoto err;\n}\nelse\nssl2_clear(s);\nif (s->s3 != NULL) ssl3_free(s);\nif (!BUF_MEM_grow_clean(s->init_buf,\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n{\ngoto err;\n}\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\nif (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)\ns->s2->ssl2_rollback=0;\nelse\ns->s2->ssl2_rollback=1;\ns->rstate=SSL_ST_READ_HEADER;\ns->packet_length=n;\ns->packet= &(s->s2->rbuf[0]);\nmemcpy(s->packet,buf,n);\ns->s2->rbuf_left=n;\ns->s2->rbuf_offs=0;\ns->method=SSLv2_server_method();\ns->handshake_func=s->method->ssl_accept;\n#endif\n}\nif ((type == 2) || (type == 3))\n{\ns->method = ssl23_get_server_method(s->version);\nif (s->method == NULL)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\ngoto err;\n}\nif (!ssl_init_wbio_buffer(s,1)) goto err;\nif (type == 3)\n{\ns->rstate=SSL_ST_READ_HEADER;\ns->packet_length=n;\nif (s->s3->rbuf.buf == NULL)\nif (!ssl3_setup_read_buffer(s))\ngoto err;\ns->packet= &(s->s3->rbuf.buf[0]);\nmemcpy(s->packet,buf,n);\ns->s3->rbuf.left=n;\ns->s3->rbuf.offset=0;\n}\nelse\n{\ns->packet_length=0;\ns->s3->rbuf.left=0;\ns->s3->rbuf.offset=0;\n}\n#if 0\ns->client_version=(v[0]<<8)|v[1];\n#endif\ns->handshake_func=s->method->ssl_accept;\n}\nif ((type < 1) || (type > 3))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\ngoto err;\n}\ns->init_num=0;\nif (buf != buf_space) OPENSSL_free(buf);\nreturn(SSL_accept(s));\nerr:\nif (buf != buf_space) OPENSSL_free(buf);\nreturn(-1);\n}", "contrast": "int ssl23_get_client_hello(SSL *s)\n{\nchar buf_space[11];\nchar *buf= &(buf_space[0]);\nunsigned char *p,*d,*d_len,*dd;\nunsigned int i;\nunsigned int csl,sil,cl;\nint n=0,j;\nint type=0;\nint v[2];\nif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)\n{\nv[0]=v[1]=0;\nif (!ssl3_setup_buffers(s)) goto err;\nn=ssl23_read_bytes(s, sizeof buf_space);\nif (n != sizeof buf_space) return(n);\np=s->packet;\nmemcpy(buf,p,n);\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\n{\nif ((p[3] == 0x00) && (p[4] == 0x02))\n{\nv[0]=p[3]; v[1]=p[4];\nif (!(s->options & SSL_OP_NO_SSLv2))\ntype=1;\n}\nelse if (p[3] == SSL3_VERSION_MAJOR)\n{\nv[0]=p[3]; v[1]=p[4];\nif (p[4] >= TLS1_VERSION_MINOR)\n{\nif (p[4] >= TLS1_2_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_2))\n{\ns->version=TLS1_2_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (p[4] >= TLS1_1_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_1))\n{\ns->version=TLS1_1_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_TLSv1))\n{\ns->version=TLS1_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv2))\n{\ntype=1;\n}\n}\nelse if (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv2))\ntype=1;\n}\n}\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\n(p[1] == SSL3_VERSION_MAJOR) &&\n(p[5] == SSL3_MT_CLIENT_HELLO) &&\n((p[3] == 0 && p[4] < 5  )\n|| (p[9] >= p[1])))\n{\nv[0]=p[1];\nif (p[3] == 0 && p[4] < 6)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);\ngoto err;\n}\nif (p[9] > SSL3_VERSION_MAJOR)\nv[1]=0xff;\nelse\nv[1]=p[10];\nif (v[1] >= TLS1_VERSION_MINOR)\n{\nif (v[1] >= TLS1_2_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_2))\n{\ns->version=TLS1_2_VERSION;\ntype=3;\n}\nelse if (v[1] >= TLS1_1_VERSION_MINOR &&\n!(s->options & SSL_OP_NO_TLSv1_1))\n{\ns->version=TLS1_1_VERSION;\ntype=3;\n}\nelse if (!(s->options & SSL_OP_NO_TLSv1))\n{\ns->version=TLS1_VERSION;\ntype=3;\n}\nelse if (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ntype=3;\n}\n}\nelse\n{\nif (!(s->options & SSL_OP_NO_SSLv3))\n{\ns->version=SSL3_VERSION;\ntype=3;\n}\nelse if (!(s->options & SSL_OP_NO_TLSv1))\n{\ns->version=TLS1_VERSION;\ntype=3;\n}\n}\n}\nelse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\n(strncmp(\"POST \",(char *)p,5) == 0) ||\n(strncmp(\"HEAD \",(char *)p,5) == 0) ||\n(strncmp(\"PUT \", (char *)p,4) == 0))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\ngoto err;\n}\nelse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\ngoto err;\n}\n}\nOPENSSL_assert(s->version <= TLS_MAX_VERSION);\n#ifdef OPENSSL_FIPS\nif (FIPS_mode() && (s->version < TLS1_VERSION))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,\nSSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\ngoto err;\n}\n#endif\nif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\n{\ntype=2;\np=s->packet;\nv[0] = p[3];\nv[1] = p[4];\nn=((p[0]&0x7f)<<8)|p[1];\nif (n > (1024*4))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\ngoto err;\n}\nif (n < 9)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\ngoto err;\n}\nj=ssl23_read_bytes(s,n+2);\nif (j <= 0) return(j);\nssl3_finish_mac(s, s->packet+2, s->packet_length-2);\nif (s->msg_callback)\ns->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg);\np=s->packet;\np+=5;\nn2s(p,csl);\nn2s(p,sil);\nn2s(p,cl);\nd=(unsigned char *)s->init_buf->data;\nif ((csl+sil+cl+11) != s->packet_length)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\ngoto err;\n}\n*(d++) = SSL3_MT_CLIENT_HELLO;\nd_len = d;\nd += 3;\n*(d++) = SSL3_VERSION_MAJOR;\n*(d++) = v[1];\ni=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\nmemset(d,0,SSL3_RANDOM_SIZE);\nmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\nd+=SSL3_RANDOM_SIZE;\n*(d++)=0;\nj=0;\ndd=d;\nd+=2;\nfor (i=0; i<csl; i+=3)\n{\nif (p[i] != 0) continue;\n*(d++)=p[i+1];\n*(d++)=p[i+2];\nj+=2;\n}\ns2n(j,dd);\n*(d++)=1;\n*(d++)=0;\n#if 0\np = p+csl+sil+cl;\nwhile (p <  s->packet+s->packet_length)\n{\n*(d++)=*(p++);\n}\n#endif\ni = (d-(unsigned char *)s->init_buf->data) - 4;\nl2n3((long)i, d_len);\ns->s3->tmp.reuse_message=1;\ns->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\ns->s3->tmp.message_size=i;\n}\nif (type == 1)\n{\n#ifdef OPENSSL_NO_SSL2\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\ngoto err;\n#else\nif (s->s2 == NULL)\n{\nif (!ssl2_new(s))\ngoto err;\n}\nelse\nssl2_clear(s);\nif (s->s3 != NULL) ssl3_free(s);\nif (!BUF_MEM_grow_clean(s->init_buf,\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n{\ngoto err;\n}\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\nif (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)\ns->s2->ssl2_rollback=0;\nelse\ns->s2->ssl2_rollback=1;\ns->rstate=SSL_ST_READ_HEADER;\ns->packet_length=n;\ns->packet= &(s->s2->rbuf[0]);\nmemcpy(s->packet,buf,n);\ns->s2->rbuf_left=n;\ns->s2->rbuf_offs=0;\ns->method=SSLv2_server_method();\ns->handshake_func=s->method->ssl_accept;\n#endif\n}\nif ((type == 2) || (type == 3))\n{\nconst SSL_METHOD *new_method;\nnew_method = ssl23_get_server_method(s->version);\nif (new_method == NULL)\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\ngoto err;\n}\ns->method = new_method;\nif (!ssl_init_wbio_buffer(s,1)) goto err;\nif (type == 3)\n{\ns->rstate=SSL_ST_READ_HEADER;\ns->packet_length=n;\nif (s->s3->rbuf.buf == NULL)\nif (!ssl3_setup_read_buffer(s))\ngoto err;\ns->packet= &(s->s3->rbuf.buf[0]);\nmemcpy(s->packet,buf,n);\ns->s3->rbuf.left=n;\ns->s3->rbuf.offset=0;\n}\nelse\n{\ns->packet_length=0;\ns->s3->rbuf.left=0;\ns->s3->rbuf.offset=0;\n}\n#if 0\ns->client_version=(v[0]<<8)|v[1];\n#endif\ns->handshake_func=s->method->ssl_accept;\n}\nif ((type < 1) || (type > 3))\n{\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\ngoto err;\n}\ns->init_num=0;\nif (buf != buf_space) OPENSSL_free(buf);\nreturn(SSL_accept(s));\nerr:\nif (buf != buf_space) OPENSSL_free(buf);\nreturn(-1);\n}", "label": 0}
{"index": 174930, "code": "BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\n{\nBIGNUM *u;\nunsigned char cu[SHA_DIGEST_LENGTH];\nunsigned char *cAB;\nEVP_MD_CTX ctxt;\nint longN;\nif ((A == NULL) ||(B == NULL) || (N == NULL))\nreturn NULL;\nif ((A == NULL) ||(B == NULL) || (N == NULL))\nreturn NULL;\nlongN= BN_num_bytes(N);\nif ((cAB = OPENSSL_malloc(2*longN)) == NULL)\nEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);\nEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);\nOPENSSL_free(cAB);\nEVP_DigestFinal_ex(&ctxt, cu, NULL);\nEVP_MD_CTX_cleanup(&ctxt);\nif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\nreturn NULL;\nif (!BN_is_zero(u))\nreturn u;\nBN_free(u);\nreturn NULL;\n}", "contrast": "BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\n{\nBIGNUM *u;\nunsigned char cu[SHA_DIGEST_LENGTH];\nunsigned char *cAB;\nEVP_MD_CTX ctxt;\nint longN;\nif ((A == NULL) ||(B == NULL) || (N == NULL))\nreturn NULL;\nif ((A == NULL) ||(B == NULL) || (N == NULL))\nreturn NULL;\nif (BN_ucmp(A, N) >= 0 || BN_ucmp(B, N) >= 0)\nreturn NULL;\nlongN= BN_num_bytes(N);\nif ((cAB = OPENSSL_malloc(2*longN)) == NULL)\nEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);\nEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);\nOPENSSL_free(cAB);\nEVP_DigestFinal_ex(&ctxt, cu, NULL);\nEVP_MD_CTX_cleanup(&ctxt);\nif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\nreturn NULL;\nif (!BN_is_zero(u))\nreturn u;\nBN_free(u);\nreturn NULL;\n}", "label": 0}
{"index": 174933, "code": "static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)\n{\nunsigned short length;\nunsigned short type;\nunsigned short size;\nunsigned char *data = *p;\nint tlsext_servername = 0;\nint renegotiate_seen = 0;\n#ifndef OPENSSL_NO_NEXTPROTONEG\ns->s3->next_proto_neg_seen = 0;\n#endif\nif (s->s3->alpn_selected)\n{\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = NULL;\n}\n#ifndef OPENSSL_NO_HEARTBEATS\ns->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\nSSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n#ifdef TLSEXT_TYPE_encrypt_then_mac\ns->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n#endif\nif (data >= (d+n-2))\ngoto ri_check;\nn2s(data,length);\nif (data+length != d+n)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nwhile(data <= (d+n-4))\n{\nn2s(data,type);\nn2s(data,size);\nif (data+size > (d+n))\ngoto ri_check;\nif (s->tlsext_debug_cb)\ns->tlsext_debug_cb(s, 1, type, data, size,\ns->tlsext_debug_arg);\nif (type == TLSEXT_TYPE_server_name)\n{\nif (s->tlsext_hostname == NULL || size > 0)\n{\n*al = TLS1_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\ntlsext_servername = 1;\n}\n#ifndef OPENSSL_NO_EC\nelse if (type == TLSEXT_TYPE_ec_point_formats)\n{\nunsigned char *sdata = data;\nint ecpointformatlist_length = *(sdata++);\nif (ecpointformatlist_length != size - 1)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\ns->session->tlsext_ecpointformatlist_length = 0;\nif (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);\nif ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;\nmemcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);\n#if 0\nfprintf(stderr,\"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist \");\nsdata = s->session->tlsext_ecpointformatlist;\n#endif\n}\n#endif\nelse if (type == TLSEXT_TYPE_session_ticket)\n{\nif (s->tls_session_ticket_ext_cb &&\n!s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nif (!tls_use_ticket(s) || (size > 0))\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_ticket_expected = 1;\n}\n#ifdef TLSEXT_TYPE_opaque_prf_input\nelse if (type == TLSEXT_TYPE_opaque_prf_input)\n{\nunsigned char *sdata = data;\nif (size < 2)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nn2s(sdata, s->s3->server_opaque_prf_input_len);\nif (s->s3->server_opaque_prf_input_len != size - 2)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->server_opaque_prf_input != NULL)\nOPENSSL_free(s->s3->server_opaque_prf_input);\nif (s->s3->server_opaque_prf_input_len == 0)\ns->s3->server_opaque_prf_input = OPENSSL_malloc(1);\nelse\ns->s3->server_opaque_prf_input = BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);\nif (s->s3->server_opaque_prf_input == NULL)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\n}\n#endif\nelse if (type == TLSEXT_TYPE_status_request)\n{\nif ((s->tlsext_status_type == -1) || (size > 0))\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_status_expected = 1;\n}\n#ifndef OPENSSL_NO_NEXTPROTONEG\nelse if (type == TLSEXT_TYPE_next_proto_neg &&\ns->s3->tmp.finish_md_len == 0)\n{\nunsigned char *selected;\nunsigned char selected_len;\nif (s->ctx->next_proto_select_cb == NULL)\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (!ssl_next_proto_validate(data, size))\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s->ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->next_proto_negotiated = OPENSSL_malloc(selected_len);\nif (!s->next_proto_negotiated)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->next_proto_negotiated, selected, selected_len);\ns->next_proto_negotiated_len = selected_len;\ns->s3->next_proto_neg_seen = 1;\n}\n#endif\nelse if (type == TLSEXT_TYPE_application_layer_protocol_negotiation)\n{\nunsigned len;\nif (s->alpn_client_proto_list == NULL)\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (size < 4)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[0];\nlen <<= 8;\nlen |= data[1];\nif (len != (unsigned) size - 2)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[2];\nif (len != (unsigned) size - 3)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->alpn_selected)\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = OPENSSL_malloc(len);\nif (!s->s3->alpn_selected)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->s3->alpn_selected, data + 3, len);\ns->s3->alpn_selected_len = len;\n}\nelse if (type == TLSEXT_TYPE_renegotiate)\n{\nif(!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))\nreturn 0;\nrenegotiate_seen = 1;\n}\n#ifndef OPENSSL_NO_HEARTBEATS\nelse if (type == TLSEXT_TYPE_heartbeat)\n{\nswitch(data[0])\n{\ncase 0x01:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\nbreak;\ncase 0x02:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\nbreak;\ndefault:\t*al = SSL_AD_ILLEGAL_PARAMETER;\nreturn 0;\n}\n}\n#endif\nelse if (type == TLSEXT_TYPE_use_srtp)\n{\nif(ssl_parse_serverhello_use_srtp_ext(s, data, size,\nal))\nreturn 0;\n}\nelse if (s->ctx->custom_cli_ext_records_count)\n{\nsize_t i;\ncustom_cli_ext_record* record;\nfor (i = 0; i < s->ctx->custom_cli_ext_records_count; i++)\n{\nrecord = &s->ctx->custom_cli_ext_records[i];\nif (record->ext_type == type)\n{\nif (record->fn2 && !record->fn2(s, type, data, size, al, record->arg))\nreturn 0;\nbreak;\n}\n}\n}\n#ifdef TLSEXT_TYPE_encrypt_then_mac\nelse if (type == TLSEXT_TYPE_encrypt_then_mac)\n{\nif (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD)\ns->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n}\n#endif\ndata += size;\n}\nif (data != d+n)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (!s->hit && tlsext_servername == 1)\n{\nif (s->tlsext_hostname)\n{\nif (s->session->tlsext_hostname == NULL)\n{\ns->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\nif (!s->session->tlsext_hostname)\n{\n*al = SSL_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\n}\nelse\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\n}\n}\n*p = data;\nri_check:\nif (!renegotiate_seen\n&& !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\n&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n{\n*al = SSL_AD_HANDSHAKE_FAILURE;\nSSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\nSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\nreturn 0;\n}\nreturn 1;\n}", "contrast": "static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)\n{\nunsigned short length;\nunsigned short type;\nunsigned short size;\nunsigned char *data = *p;\nint tlsext_servername = 0;\nint renegotiate_seen = 0;\n#ifndef OPENSSL_NO_NEXTPROTONEG\ns->s3->next_proto_neg_seen = 0;\n#endif\nif (s->s3->alpn_selected)\n{\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = NULL;\n}\n#ifndef OPENSSL_NO_HEARTBEATS\ns->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\nSSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n#ifdef TLSEXT_TYPE_encrypt_then_mac\ns->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n#endif\nif (data >= (d+n-2))\ngoto ri_check;\nn2s(data,length);\nif (data+length != d+n)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nwhile(data <= (d+n-4))\n{\nn2s(data,type);\nn2s(data,size);\nif (data+size > (d+n))\ngoto ri_check;\nif (s->tlsext_debug_cb)\ns->tlsext_debug_cb(s, 1, type, data, size,\ns->tlsext_debug_arg);\nif (type == TLSEXT_TYPE_server_name)\n{\nif (s->tlsext_hostname == NULL || size > 0)\n{\n*al = TLS1_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\ntlsext_servername = 1;\n}\n#ifndef OPENSSL_NO_EC\nelse if (type == TLSEXT_TYPE_ec_point_formats)\n{\nunsigned char *sdata = data;\nint ecpointformatlist_length = *(sdata++);\nif (ecpointformatlist_length != size - 1)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (!s->hit)\n{\ns->session->tlsext_ecpointformatlist_length = 0;\nif (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);\nif ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;\nmemcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);\n}\n#if 0\nfprintf(stderr,\"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist \");\nsdata = s->session->tlsext_ecpointformatlist;\n#endif\n}\n#endif\nelse if (type == TLSEXT_TYPE_session_ticket)\n{\nif (s->tls_session_ticket_ext_cb &&\n!s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nif (!tls_use_ticket(s) || (size > 0))\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_ticket_expected = 1;\n}\n#ifdef TLSEXT_TYPE_opaque_prf_input\nelse if (type == TLSEXT_TYPE_opaque_prf_input)\n{\nunsigned char *sdata = data;\nif (size < 2)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nn2s(sdata, s->s3->server_opaque_prf_input_len);\nif (s->s3->server_opaque_prf_input_len != size - 2)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->server_opaque_prf_input != NULL)\nOPENSSL_free(s->s3->server_opaque_prf_input);\nif (s->s3->server_opaque_prf_input_len == 0)\ns->s3->server_opaque_prf_input = OPENSSL_malloc(1);\nelse\ns->s3->server_opaque_prf_input = BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);\nif (s->s3->server_opaque_prf_input == NULL)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\n}\n#endif\nelse if (type == TLSEXT_TYPE_status_request)\n{\nif ((s->tlsext_status_type == -1) || (size > 0))\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_status_expected = 1;\n}\n#ifndef OPENSSL_NO_NEXTPROTONEG\nelse if (type == TLSEXT_TYPE_next_proto_neg &&\ns->s3->tmp.finish_md_len == 0)\n{\nunsigned char *selected;\nunsigned char selected_len;\nif (s->ctx->next_proto_select_cb == NULL)\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (!ssl_next_proto_validate(data, size))\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s->ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->next_proto_negotiated = OPENSSL_malloc(selected_len);\nif (!s->next_proto_negotiated)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->next_proto_negotiated, selected, selected_len);\ns->next_proto_negotiated_len = selected_len;\ns->s3->next_proto_neg_seen = 1;\n}\n#endif\nelse if (type == TLSEXT_TYPE_application_layer_protocol_negotiation)\n{\nunsigned len;\nif (s->alpn_client_proto_list == NULL)\n{\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (size < 4)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[0];\nlen <<= 8;\nlen |= data[1];\nif (len != (unsigned) size - 2)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[2];\nif (len != (unsigned) size - 3)\n{\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->alpn_selected)\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = OPENSSL_malloc(len);\nif (!s->s3->alpn_selected)\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->s3->alpn_selected, data + 3, len);\ns->s3->alpn_selected_len = len;\n}\nelse if (type == TLSEXT_TYPE_renegotiate)\n{\nif(!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))\nreturn 0;\nrenegotiate_seen = 1;\n}\n#ifndef OPENSSL_NO_HEARTBEATS\nelse if (type == TLSEXT_TYPE_heartbeat)\n{\nswitch(data[0])\n{\ncase 0x01:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\nbreak;\ncase 0x02:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\nbreak;\ndefault:\t*al = SSL_AD_ILLEGAL_PARAMETER;\nreturn 0;\n}\n}\n#endif\nelse if (type == TLSEXT_TYPE_use_srtp)\n{\nif(ssl_parse_serverhello_use_srtp_ext(s, data, size,\nal))\nreturn 0;\n}\nelse if (s->ctx->custom_cli_ext_records_count)\n{\nsize_t i;\ncustom_cli_ext_record* record;\nfor (i = 0; i < s->ctx->custom_cli_ext_records_count; i++)\n{\nrecord = &s->ctx->custom_cli_ext_records[i];\nif (record->ext_type == type)\n{\nif (record->fn2 && !record->fn2(s, type, data, size, al, record->arg))\nreturn 0;\nbreak;\n}\n}\n}\n#ifdef TLSEXT_TYPE_encrypt_then_mac\nelse if (type == TLSEXT_TYPE_encrypt_then_mac)\n{\nif (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD)\ns->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n}\n#endif\ndata += size;\n}\nif (data != d+n)\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (!s->hit && tlsext_servername == 1)\n{\nif (s->tlsext_hostname)\n{\nif (s->session->tlsext_hostname == NULL)\n{\ns->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\nif (!s->session->tlsext_hostname)\n{\n*al = SSL_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\n}\nelse\n{\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\n}\n}\n*p = data;\nri_check:\nif (!renegotiate_seen\n&& !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\n&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n{\n*al = SSL_AD_HANDSHAKE_FAILURE;\nSSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\nSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\nreturn 0;\n}\nreturn 1;\n}", "label": 0}
{"index": 174938, "code": "static void rng_egd_request_entropy(RngBackend *b, size_t size,\nEntropyReceiveFunc *receive_entropy,\nvoid *opaque)\n{\nRngEgd *s = RNG_EGD(b);\nRngRequest *req;\nreq = g_malloc(sizeof(*req));\nreq->offset = 0;\nreq->size = size;\nreq->receive_entropy = receive_entropy;\nreq->opaque = opaque;\nreq->data = g_malloc(req->size);\nwhile (size > 0) {\nuint8_t header[2];\nreq = g_malloc(sizeof(*req));\nreq->offset = 0;\nreq->size = size;\nreq->receive_entropy = receive_entropy;\nreq->opaque = opaque;\nreq->data = g_malloc(req->size);\nsize -= len;\n}\ns->parent.requests = g_slist_append(s->parent.requests, req);\n}", "contrast": "static void rng_egd_request_entropy(RngBackend *b, size_t size,\nstatic void rng_egd_request_entropy(RngBackend *b, RngRequest *req)\n{\nRngEgd *s = RNG_EGD(b);\nsize_t size = req->size;\nwhile (size > 0) {\nuint8_t header[2];\nreq = g_malloc(sizeof(*req));\nreq->offset = 0;\nreq->size = size;\nreq->receive_entropy = receive_entropy;\nreq->opaque = opaque;\nreq->data = g_malloc(req->size);\nsize -= len;\n}\n}", "label": 0}
{"index": 174948, "code": "eval_condition(uschar *s, BOOL *resetok, BOOL *yield)\n{\nBOOL testfor = TRUE;\nBOOL tempcond, combined_cond;\nBOOL *subcondptr;\nBOOL sub2_honour_dollar = TRUE;\nint i, rc, cond_type, roffset;\nint_eximarith_t num[2];\nstruct stat statbuf;\nuschar name[256];\nuschar *sub[10];\nconst pcre *re;\nconst uschar *rerror;\nfor (;;)\n{\nwhile (isspace(*s)) s++;\nif (*s == '!') { testfor = !testfor; s++; } else break;\n}\nif (*s == '=' || *s == '>' || *s == '<')\n{\nint p = 0;\nname[p++] = *s++;\nif (*s == '=')\n{\nname[p++] = '=';\ns++;\n}\nname[p] = 0;\n}\nelse s = read_name(name, 256, s, US\"_\");\nif (name[0] == 0)\n{\nexpand_string_message = string_sprintf(\"condition name expected, \"\n\"but found \\\"%.16s\\\"\", s);\nreturn NULL;\n}\ncond_type = chop_match(name, cond_table, sizeof(cond_table)/sizeof(uschar *));\nswitch(cond_type)\n{\ncase ECOND_DEF:\nif (*s != ':')\n{\nexpand_string_message = US\"\\\":\\\" expected after \\\"def\\\"\";\nreturn NULL;\n}\ns = read_name(name, 256, s+1, US\"_\");\nif (Ustrncmp(name, \"h_\", 2) == 0 ||\nUstrncmp(name, \"rh_\", 3) == 0 ||\nUstrncmp(name, \"bh_\", 3) == 0 ||\nUstrncmp(name, \"header_\", 7) == 0 ||\nUstrncmp(name, \"rheader_\", 8) == 0 ||\nUstrncmp(name, \"bheader_\", 8) == 0)\n{\ns = read_header_name(name, 256, s);\nif (Ustrchr(name, '}') != NULL) malformed_header = TRUE;\nif (yield != NULL) *yield =\n(find_header(name, TRUE, NULL, FALSE, NULL) != NULL) == testfor;\n}\nelse\n{\nuschar *value = find_variable(name, TRUE, yield == NULL, NULL);\nif (value == NULL)\n{\nexpand_string_message = (name[0] == 0)?\nstring_sprintf(\"variable name omitted after \\\"def:\\\"\") :\nstring_sprintf(\"unknown variable \\\"%s\\\" after \\\"def:\\\"\", name);\ncheck_variable_error_message(name);\nreturn NULL;\n}\nif (yield != NULL) *yield = (value[0] != 0) == testfor;\n}\nreturn s;\ncase ECOND_FIRST_DELIVERY:\nif (yield != NULL) *yield = deliver_firsttime == testfor;\nreturn s;\ncase ECOND_QUEUE_RUNNING:\nif (yield != NULL) *yield = (queue_run_pid != (pid_t)0) == testfor;\nreturn s;\ncase ECOND_EXISTS:\ncase ECOND_ISIP:\ncase ECOND_ISIP4:\ncase ECOND_ISIP6:\ncase ECOND_PAM:\ncase ECOND_RADIUS:\ncase ECOND_LDAPAUTH:\ncase ECOND_PWCHECK:\nwhile (isspace(*s)) s++;\nif (*s != '{') goto COND_FAILED_CURLY_START;\nsub[0] = expand_string_internal(s+1, TRUE, &s, yield == NULL, TRUE, resetok);\nif (sub[0] == NULL) return NULL;\nif (*s++ != '}') goto COND_FAILED_CURLY_END;\nif (yield == NULL) return s;\nswitch(cond_type)\n{\ncase ECOND_EXISTS:\nif ((expand_forbid & RDO_EXISTS) != 0)\n{\nexpand_string_message = US\"File existence tests are not permitted\";\nreturn NULL;\n}\n*yield = (Ustat(sub[0], &statbuf) == 0) == testfor;\nbreak;\ncase ECOND_ISIP:\ncase ECOND_ISIP4:\ncase ECOND_ISIP6:\nrc = string_is_ip_address(sub[0], NULL);\n*yield = ((cond_type == ECOND_ISIP)? (rc != 0) :\n(cond_type == ECOND_ISIP4)? (rc == 4) : (rc == 6)) == testfor;\nbreak;\ncase ECOND_PAM:\n#ifdef SUPPORT_PAM\nrc = auth_call_pam(sub[0], &expand_string_message);\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\ncase ECOND_RADIUS:\n#ifdef RADIUS_CONFIG_FILE\nrc = auth_call_radius(sub[0], &expand_string_message);\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\ncase ECOND_LDAPAUTH:\n#ifdef LOOKUP_LDAP\n{\nBOOL do_cache;\nint old_pool = store_pool;\nstore_pool = POOL_SEARCH;\nrc = eldapauth_find((void *)(-1), NULL, sub[0], Ustrlen(sub[0]), NULL,\n&expand_string_message, &do_cache);\nstore_pool = old_pool;\n}\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\ncase ECOND_PWCHECK:\n#ifdef CYRUS_PWCHECK_SOCKET\nrc = auth_call_pwcheck(sub[0], &expand_string_message);\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\n#if defined(SUPPORT_PAM) || defined(RADIUS_CONFIG_FILE) || \\\ndefined(LOOKUP_LDAP) || defined(CYRUS_PWCHECK_SOCKET)\nEND_AUTH:\nif (rc == ERROR || rc == DEFER) return NULL;\n*yield = (rc == OK) == testfor;\n#endif\n}\nreturn s;\ncase ECOND_ACL:\n{\nuschar *user_msg;\nBOOL cond = FALSE;\nint size = 0;\nint ptr = 0;\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nswitch(read_subs(sub, sizeof(sub)/sizeof(*sub), 1,\n&s, yield == NULL, TRUE, US\"acl\", resetok))\n{\ncase 1: expand_string_message = US\"too few arguments or bracketing \"\n\"error for acl\";\ncase 2:\ncase 3: return NULL;\n}\n*resetok = FALSE;\nif (yield != NULL) switch(eval_acl(sub, sizeof(sub)/sizeof(*sub), &user_msg))\n{\ncase OK:\ncond = TRUE;\ncase FAIL:\nlookup_value = NULL;\nif (user_msg)\n{\nlookup_value = string_cat(NULL, &size, &ptr, user_msg, Ustrlen(user_msg));\nlookup_value[ptr] = '\\0';\n}\n*yield = cond == testfor;\nbreak;\ncase DEFER:\nexpand_string_forcedfail = TRUE;\ndefault:\nexpand_string_message = string_sprintf(\"error from acl \\\"%s\\\"\", sub[0]);\nreturn NULL;\n}\nreturn s;\n}\ncase ECOND_SASLAUTHD:\n#ifndef CYRUS_SASLAUTHD_SOCKET\ngoto COND_FAILED_NOT_COMPILED;\n#else\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nswitch(read_subs(sub, 4, 2, &s, yield == NULL, TRUE, US\"saslauthd\", resetok))\n{\ncase 1: expand_string_message = US\"too few arguments or bracketing \"\n\"error for saslauthd\";\ncase 2:\ncase 3: return NULL;\n}\nif (sub[2] == NULL) sub[3] = NULL;\nif (yield != NULL)\n{\nint rc;\nrc = auth_call_saslauthd(sub[0], sub[1], sub[2], sub[3],\n&expand_string_message);\nif (rc == ERROR || rc == DEFER) return NULL;\n*yield = (rc == OK) == testfor;\n}\nreturn s;\n#endif\ncase ECOND_MATCH_ADDRESS:\ncase ECOND_MATCH_DOMAIN:\ncase ECOND_MATCH_IP:\ncase ECOND_MATCH_LOCAL_PART:\n#ifndef EXPAND_LISTMATCH_RHS\nsub2_honour_dollar = FALSE;\n#endif\ncase ECOND_CRYPTEQ:\ncase ECOND_INLIST:\ncase ECOND_INLISTI:\ncase ECOND_MATCH:\ncase ECOND_NUM_L:\ncase ECOND_NUM_LE:\ncase ECOND_NUM_E:\ncase ECOND_NUM_EE:\ncase ECOND_NUM_G:\ncase ECOND_NUM_GE:\ncase ECOND_STR_LT:\ncase ECOND_STR_LTI:\ncase ECOND_STR_LE:\ncase ECOND_STR_LEI:\ncase ECOND_STR_EQ:\ncase ECOND_STR_EQI:\ncase ECOND_STR_GT:\ncase ECOND_STR_GTI:\ncase ECOND_STR_GE:\ncase ECOND_STR_GEI:\nfor (i = 0; i < 2; i++)\n{\nBOOL honour_dollar = TRUE;\nif ((i > 0) && !sub2_honour_dollar)\nhonour_dollar = FALSE;\nwhile (isspace(*s)) s++;\nif (*s != '{')\n{\nif (i == 0) goto COND_FAILED_CURLY_START;\nexpand_string_message = string_sprintf(\"missing 2nd string in {} \"\n\"after \\\"%s\\\"\", name);\nreturn NULL;\n}\nsub[i] = expand_string_internal(s+1, TRUE, &s, yield == NULL,\nhonour_dollar, resetok);\nif (sub[i] == NULL) return NULL;\nif (*s++ != '}') goto COND_FAILED_CURLY_END;\nif (!isalpha(name[0]) && yield != NULL)\n{\nif (sub[i][0] == 0)\n{\nnum[i] = 0;\nDEBUG(D_expand)\ndebug_printf(\"empty string cast to zero for numerical comparison\\n\");\n}\nelse\n{\nnum[i] = expand_string_integer(sub[i], FALSE);\nif (expand_string_message != NULL) return NULL;\n}\n}\n}\nif (yield == NULL) return s;\nswitch(cond_type)\n{\ncase ECOND_NUM_E:\ncase ECOND_NUM_EE:\ntempcond = (num[0] == num[1]);\nbreak;\ncase ECOND_NUM_G:\ntempcond = (num[0] > num[1]);\nbreak;\ncase ECOND_NUM_GE:\ntempcond = (num[0] >= num[1]);\nbreak;\ncase ECOND_NUM_L:\ntempcond = (num[0] < num[1]);\nbreak;\ncase ECOND_NUM_LE:\ntempcond = (num[0] <= num[1]);\nbreak;\ncase ECOND_STR_LT:\ntempcond = (Ustrcmp(sub[0], sub[1]) < 0);\nbreak;\ncase ECOND_STR_LTI:\ntempcond = (strcmpic(sub[0], sub[1]) < 0);\nbreak;\ncase ECOND_STR_LE:\ntempcond = (Ustrcmp(sub[0], sub[1]) <= 0);\nbreak;\ncase ECOND_STR_LEI:\ntempcond = (strcmpic(sub[0], sub[1]) <= 0);\nbreak;\ncase ECOND_STR_EQ:\ntempcond = (Ustrcmp(sub[0], sub[1]) == 0);\nbreak;\ncase ECOND_STR_EQI:\ntempcond = (strcmpic(sub[0], sub[1]) == 0);\nbreak;\ncase ECOND_STR_GT:\ntempcond = (Ustrcmp(sub[0], sub[1]) > 0);\nbreak;\ncase ECOND_STR_GTI:\ntempcond = (strcmpic(sub[0], sub[1]) > 0);\nbreak;\ncase ECOND_STR_GE:\ntempcond = (Ustrcmp(sub[0], sub[1]) >= 0);\nbreak;\ncase ECOND_STR_GEI:\ntempcond = (strcmpic(sub[0], sub[1]) >= 0);\nbreak;\ncase ECOND_MATCH:\nre = pcre_compile(CS sub[1], PCRE_COPT, (const char **)&rerror, &roffset,\nNULL);\nif (re == NULL)\n{\nexpand_string_message = string_sprintf(\"regular expression error in \"\n\"\\\"%s\\\": %s at offset %d\", sub[1], rerror, roffset);\nreturn NULL;\n}\ntempcond = regex_match_and_setup(re, sub[0], 0, -1);\nbreak;\ncase ECOND_MATCH_ADDRESS:\nrc = match_address_list(sub[0], TRUE, FALSE, &(sub[1]), NULL, -1, 0, NULL);\ngoto MATCHED_SOMETHING;\ncase ECOND_MATCH_DOMAIN:\nrc = match_isinlist(sub[0], &(sub[1]), 0, &domainlist_anchor, NULL,\nMCL_DOMAIN + MCL_NOEXPAND, TRUE, NULL);\ngoto MATCHED_SOMETHING;\ncase ECOND_MATCH_IP:\nif (sub[0][0] != 0 && string_is_ip_address(sub[0], NULL) == 0)\n{\nexpand_string_message = string_sprintf(\"\\\"%s\\\" is not an IP address\",\nsub[0]);\nreturn NULL;\n}\nelse\n{\nunsigned int *nullcache = NULL;\ncheck_host_block cb;\ncb.host_name = US\"\";\ncb.host_address = sub[0];\ncb.host_ipv4 = (Ustrncmp(cb.host_address, \"::ffff:\", 7) == 0)?\ncb.host_address + 7 : cb.host_address;\nrc = match_check_list(\n&sub[1],\n0,\n&hostlist_anchor,\n&nullcache,\ncheck_host,\n&cb,\nMCL_HOST,\nsub[0],\nNULL);\n}\ngoto MATCHED_SOMETHING;\ncase ECOND_MATCH_LOCAL_PART:\nrc = match_isinlist(sub[0], &(sub[1]), 0, &localpartlist_anchor, NULL,\nMCL_LOCALPART + MCL_NOEXPAND, TRUE, NULL);\nMATCHED_SOMETHING:\nswitch(rc)\n{\ncase OK:\ntempcond = TRUE;\nbreak;\ncase FAIL:\ntempcond = FALSE;\nbreak;\ncase DEFER:\nexpand_string_message = string_sprintf(\"unable to complete match \"\n\"against \\\"%s\\\": %s\", sub[1], search_error_message);\nreturn NULL;\n}\nbreak;\ncase ECOND_CRYPTEQ:\n#ifndef SUPPORT_CRYPTEQ\ngoto COND_FAILED_NOT_COMPILED;\n#else\nif (strncmpic(sub[1], US\"{md5}\", 5) == 0)\n{\nint sublen = Ustrlen(sub[1]+5);\nmd5 base;\nuschar digest[16];\nmd5_start(&base);\nmd5_end(&base, (uschar *)sub[0], Ustrlen(sub[0]), digest);\nif (sublen == 24)\n{\nuschar *coded = auth_b64encode((uschar *)digest, 16);\nDEBUG(D_auth) debug_printf(\"crypteq: using MD5+B64 hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+5);\ntempcond = (Ustrcmp(coded, sub[1]+5) == 0);\n}\nelse if (sublen == 32)\n{\nint i;\nuschar coded[36];\nfor (i = 0; i < 16; i++) sprintf(CS (coded+2*i), \"%02X\", digest[i]);\ncoded[32] = 0;\nDEBUG(D_auth) debug_printf(\"crypteq: using MD5+hex hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+5);\ntempcond = (strcmpic(coded, sub[1]+5) == 0);\n}\nelse\n{\nDEBUG(D_auth) debug_printf(\"crypteq: length for MD5 not 24 or 32: \"\n\"fail\\n  crypted=%s\\n\", sub[1]+5);\ntempcond = FALSE;\n}\n}\nelse if (strncmpic(sub[1], US\"{sha1}\", 6) == 0)\n{\nint sublen = Ustrlen(sub[1]+6);\nsha1 base;\nuschar digest[20];\nsha1_start(&base);\nsha1_end(&base, (uschar *)sub[0], Ustrlen(sub[0]), digest);\nif (sublen == 28)\n{\nuschar *coded = auth_b64encode((uschar *)digest, 20);\nDEBUG(D_auth) debug_printf(\"crypteq: using SHA1+B64 hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+6);\ntempcond = (Ustrcmp(coded, sub[1]+6) == 0);\n}\nelse if (sublen == 40)\n{\nint i;\nuschar coded[44];\nfor (i = 0; i < 20; i++) sprintf(CS (coded+2*i), \"%02X\", digest[i]);\ncoded[40] = 0;\nDEBUG(D_auth) debug_printf(\"crypteq: using SHA1+hex hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+6);\ntempcond = (strcmpic(coded, sub[1]+6) == 0);\n}\nelse\n{\nDEBUG(D_auth) debug_printf(\"crypteq: length for SHA-1 not 28 or 40: \"\n\"fail\\n  crypted=%s\\n\", sub[1]+6);\ntempcond = FALSE;\n}\n}\nelse\n{\nint which = 0;\nuschar *coded;\nif (strncmpic(sub[1], US\"{crypt}\", 7) == 0)\n{\nsub[1] += 7;\nwhich = 1;\n}\nelse if (strncmpic(sub[1], US\"{crypt16}\", 9) == 0)\n{\nsub[1] += 9;\nwhich = 2;\n}\nelse if (sub[1][0] == '{')\n{\nexpand_string_message = string_sprintf(\"unknown encryption mechanism \"\n\"in \\\"%s\\\"\", sub[1]);\nreturn NULL;\n}\nswitch(which)\n{\ncase 0:  coded = US DEFAULT_CRYPT(CS sub[0], CS sub[1]); break;\ncase 1:  coded = US crypt(CS sub[0], CS sub[1]); break;\ndefault: coded = US crypt16(CS sub[0], CS sub[1]); break;\n}\n#define STR(s) # s\n#define XSTR(s) STR(s)\nDEBUG(D_auth) debug_printf(\"crypteq: using %s()\\n\"\n\"  subject=%s\\n  crypted=%s\\n\",\n(which == 0)? XSTR(DEFAULT_CRYPT) : (which == 1)? \"crypt\" : \"crypt16\",\ncoded, sub[1]);\n#undef STR\n#undef XSTR\ntempcond = (Ustrlen(sub[1]) < 2)? FALSE :\n(Ustrcmp(coded, sub[1]) == 0);\n}\nbreak;\n#endif\ncase ECOND_INLIST:\ncase ECOND_INLISTI:\n{\nint sep = 0;\nuschar *save_iterate_item = iterate_item;\nint (*compare)(const uschar *, const uschar *);\ntempcond = FALSE;\nif (cond_type == ECOND_INLISTI)\ncompare = strcmpic;\nelse\ncompare = (int (*)(const uschar *, const uschar *)) strcmp;\nwhile ((iterate_item = string_nextinlist(&sub[1], &sep, NULL, 0)) != NULL)\nif (compare(sub[0], iterate_item) == 0)\n{\ntempcond = TRUE;\nbreak;\n}\niterate_item = save_iterate_item;\n}\n}\n*yield = tempcond == testfor;\nreturn s;\ncase ECOND_AND:\ncase ECOND_OR:\nsubcondptr = (yield == NULL)? NULL : &tempcond;\ncombined_cond = (cond_type == ECOND_AND);\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nfor (;;)\n{\nwhile (isspace(*s)) s++;\nif (*s == '}') break;\nif (*s != '{')\n{\nexpand_string_message = string_sprintf(\"each subcondition \"\n\"inside an \\\"%s{...}\\\" condition must be in its own {}\", name);\nreturn NULL;\n}\nif (!(s = eval_condition(s+1, resetok, subcondptr)))\n{\nexpand_string_message = string_sprintf(\"%s inside \\\"%s{...}\\\" condition\",\nexpand_string_message, name);\nreturn NULL;\n}\nwhile (isspace(*s)) s++;\nif (*s++ != '}')\n{\nexpand_string_message = string_sprintf(\"missing } at end of condition \"\n\"inside \\\"%s\\\" group\", name);\nreturn NULL;\n}\nif (yield != NULL)\n{\nif (cond_type == ECOND_AND)\n{\ncombined_cond &= tempcond;\nif (!combined_cond) subcondptr = NULL;\n}\nelse\n{\ncombined_cond |= tempcond;\nif (combined_cond) subcondptr = NULL;\n}\n}\n}\nif (yield != NULL) *yield = (combined_cond == testfor);\nreturn ++s;\ncase ECOND_FORALL:\ncase ECOND_FORANY:\n{\nint sep = 0;\nuschar *save_iterate_item = iterate_item;\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nsub[0] = expand_string_internal(s, TRUE, &s, (yield == NULL), TRUE, resetok);\nif (sub[0] == NULL) return NULL;\nif (*s++ != '}') goto COND_FAILED_CURLY_END;\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nsub[1] = s;\nif (!(s = eval_condition(sub[1], resetok, NULL)))\n{\nexpand_string_message = string_sprintf(\"%s inside \\\"%s\\\" condition\",\nexpand_string_message, name);\nreturn NULL;\n}\nwhile (isspace(*s)) s++;\nif (*s++ != '}')\n{\nexpand_string_message = string_sprintf(\"missing } at end of condition \"\n\"inside \\\"%s\\\"\", name);\nreturn NULL;\n}\nif (yield != NULL) *yield = !testfor;\nwhile ((iterate_item = string_nextinlist(&sub[0], &sep, NULL, 0)) != NULL)\n{\nDEBUG(D_expand) debug_printf(\"%s: $item = \\\"%s\\\"\\n\", name, iterate_item);\nif (!eval_condition(sub[1], resetok, &tempcond))\n{\nexpand_string_message = string_sprintf(\"%s inside \\\"%s\\\" condition\",\nexpand_string_message, name);\niterate_item = save_iterate_item;\nreturn NULL;\n}\nDEBUG(D_expand) debug_printf(\"%s: condition evaluated to %s\\n\", name,\ntempcond? \"true\":\"false\");\nif (yield != NULL) *yield = (tempcond == testfor);\nif (tempcond == (cond_type == ECOND_FORANY)) break;\n}\niterate_item = save_iterate_item;\nreturn s;\n}\ncase ECOND_BOOL:\ncase ECOND_BOOL_LAX:\n{\nuschar *sub_arg[1];\nuschar *t, *t2;\nuschar *ourname;\nsize_t len;\nBOOL boolvalue = FALSE;\nwhile (isspace(*s)) s++;\nif (*s != '{') goto COND_FAILED_CURLY_START;\nourname = cond_type == ECOND_BOOL_LAX ? US\"bool_lax\" : US\"bool\";\nswitch(read_subs(sub_arg, 1, 1, &s, yield == NULL, FALSE, ourname, resetok))\n{\ncase 1: expand_string_message = string_sprintf(\n\"too few arguments or bracketing error for %s\",\nourname);\ncase 2:\ncase 3: return NULL;\n}\nt = sub_arg[0];\nwhile (isspace(*t)) t++;\nlen = Ustrlen(t);\nif (len)\n{\nt2 = t + len - 1;\nwhile (isspace(*t2)) t2--;\nif (t2 != (t + len))\n{\n*++t2 = '\\0';\nlen = t2 - t;\n}\n}\nDEBUG(D_expand)\ndebug_printf(\"considering %s: %s\\n\", ourname, len ? t : US\"<empty>\");\nif (len == 0)\nboolvalue = FALSE;\nelse if (*t == '-'\n? Ustrspn(t+1, \"0123456789\") == len-1\n: Ustrspn(t,   \"0123456789\") == len)\n{\nboolvalue = (Uatoi(t) == 0) ? FALSE : TRUE;\nif ((cond_type == ECOND_BOOL_LAX) && (len > 1))\nboolvalue = TRUE;\n}\nelse if (strcmpic(t, US\"true\") == 0 || strcmpic(t, US\"yes\") == 0)\nboolvalue = TRUE;\nelse if (strcmpic(t, US\"false\") == 0 || strcmpic(t, US\"no\") == 0)\nboolvalue = FALSE;\nelse if (cond_type == ECOND_BOOL_LAX)\nboolvalue = TRUE;\nelse\n{\nexpand_string_message = string_sprintf(\"unrecognised boolean \"\n\"value \\\"%s\\\"\", t);\nreturn NULL;\n}\nif (yield != NULL) *yield = (boolvalue == testfor);\nreturn s;\n}\ndefault:\nexpand_string_message = string_sprintf(\"unknown condition \\\"%s\\\"\", name);\nreturn NULL;\n}\nCOND_FAILED_CURLY_START:\nexpand_string_message = string_sprintf(\"missing { after \\\"%s\\\"\", name);\nreturn NULL;\nCOND_FAILED_CURLY_END:\nexpand_string_message = string_sprintf(\"missing } at end of \\\"%s\\\" condition\",\nname);\nreturn NULL;\n#if !defined(SUPPORT_PAM) || !defined(RADIUS_CONFIG_FILE) || \\\n!defined(LOOKUP_LDAP) || !defined(CYRUS_PWCHECK_SOCKET) || \\\n!defined(SUPPORT_CRYPTEQ) || !defined(CYRUS_SASLAUTHD_SOCKET)\nCOND_FAILED_NOT_COMPILED:\nexpand_string_message = string_sprintf(\"support for \\\"%s\\\" not compiled\",\nname);\nreturn NULL;\n#endif\n}", "contrast": "eval_condition(uschar *s, BOOL *resetok, BOOL *yield)\n{\nBOOL testfor = TRUE;\nBOOL tempcond, combined_cond;\nBOOL *subcondptr;\nBOOL sub2_honour_dollar = TRUE;\nint i, rc, cond_type, roffset;\nint_eximarith_t num[2];\nstruct stat statbuf;\nuschar name[256];\nuschar *sub[10];\nconst pcre *re;\nconst uschar *rerror;\nfor (;;)\n{\nwhile (isspace(*s)) s++;\nif (*s == '!') { testfor = !testfor; s++; } else break;\n}\nif (*s == '=' || *s == '>' || *s == '<')\n{\nint p = 0;\nname[p++] = *s++;\nif (*s == '=')\n{\nname[p++] = '=';\ns++;\n}\nname[p] = 0;\n}\nelse s = read_name(name, 256, s, US\"_\");\nif (name[0] == 0)\n{\nexpand_string_message = string_sprintf(\"condition name expected, \"\n\"but found \\\"%.16s\\\"\", s);\nreturn NULL;\n}\ncond_type = chop_match(name, cond_table, sizeof(cond_table)/sizeof(uschar *));\nswitch(cond_type)\n{\ncase ECOND_DEF:\nif (*s != ':')\n{\nexpand_string_message = US\"\\\":\\\" expected after \\\"def\\\"\";\nreturn NULL;\n}\ns = read_name(name, 256, s+1, US\"_\");\nif (Ustrncmp(name, \"h_\", 2) == 0 ||\nUstrncmp(name, \"rh_\", 3) == 0 ||\nUstrncmp(name, \"bh_\", 3) == 0 ||\nUstrncmp(name, \"header_\", 7) == 0 ||\nUstrncmp(name, \"rheader_\", 8) == 0 ||\nUstrncmp(name, \"bheader_\", 8) == 0)\n{\ns = read_header_name(name, 256, s);\nif (Ustrchr(name, '}') != NULL) malformed_header = TRUE;\nif (yield != NULL) *yield =\n(find_header(name, TRUE, NULL, FALSE, NULL) != NULL) == testfor;\n}\nelse\n{\nuschar *value = find_variable(name, TRUE, yield == NULL, NULL);\nif (value == NULL)\n{\nexpand_string_message = (name[0] == 0)?\nstring_sprintf(\"variable name omitted after \\\"def:\\\"\") :\nstring_sprintf(\"unknown variable \\\"%s\\\" after \\\"def:\\\"\", name);\ncheck_variable_error_message(name);\nreturn NULL;\n}\nif (yield != NULL) *yield = (value[0] != 0) == testfor;\n}\nreturn s;\ncase ECOND_FIRST_DELIVERY:\nif (yield != NULL) *yield = deliver_firsttime == testfor;\nreturn s;\ncase ECOND_QUEUE_RUNNING:\nif (yield != NULL) *yield = (queue_run_pid != (pid_t)0) == testfor;\nreturn s;\ncase ECOND_EXISTS:\ncase ECOND_ISIP:\ncase ECOND_ISIP4:\ncase ECOND_ISIP6:\ncase ECOND_PAM:\ncase ECOND_RADIUS:\ncase ECOND_LDAPAUTH:\ncase ECOND_PWCHECK:\nwhile (isspace(*s)) s++;\nif (*s != '{') goto COND_FAILED_CURLY_START;\nsub[0] = expand_string_internal(s+1, TRUE, &s, yield == NULL, TRUE, resetok);\nif (sub[0] == NULL) return NULL;\nif (*s++ != '}') goto COND_FAILED_CURLY_END;\nif (yield == NULL) return s;\nswitch(cond_type)\n{\ncase ECOND_EXISTS:\nif ((expand_forbid & RDO_EXISTS) != 0)\n{\nexpand_string_message = US\"File existence tests are not permitted\";\nreturn NULL;\n}\n*yield = (Ustat(sub[0], &statbuf) == 0) == testfor;\nbreak;\ncase ECOND_ISIP:\ncase ECOND_ISIP4:\ncase ECOND_ISIP6:\nrc = string_is_ip_address(sub[0], NULL);\n*yield = ((cond_type == ECOND_ISIP)? (rc != 0) :\n(cond_type == ECOND_ISIP4)? (rc == 4) : (rc == 6)) == testfor;\nbreak;\ncase ECOND_PAM:\n#ifdef SUPPORT_PAM\nrc = auth_call_pam(sub[0], &expand_string_message);\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\ncase ECOND_RADIUS:\n#ifdef RADIUS_CONFIG_FILE\nrc = auth_call_radius(sub[0], &expand_string_message);\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\ncase ECOND_LDAPAUTH:\n#ifdef LOOKUP_LDAP\n{\nBOOL do_cache;\nint old_pool = store_pool;\nstore_pool = POOL_SEARCH;\nrc = eldapauth_find((void *)(-1), NULL, sub[0], Ustrlen(sub[0]), NULL,\n&expand_string_message, &do_cache);\nstore_pool = old_pool;\n}\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\ncase ECOND_PWCHECK:\n#ifdef CYRUS_PWCHECK_SOCKET\nrc = auth_call_pwcheck(sub[0], &expand_string_message);\ngoto END_AUTH;\n#else\ngoto COND_FAILED_NOT_COMPILED;\n#endif\n#if defined(SUPPORT_PAM) || defined(RADIUS_CONFIG_FILE) || \\\ndefined(LOOKUP_LDAP) || defined(CYRUS_PWCHECK_SOCKET)\nEND_AUTH:\nif (rc == ERROR || rc == DEFER) return NULL;\n*yield = (rc == OK) == testfor;\n#endif\n}\nreturn s;\ncase ECOND_ACL:\n{\nuschar *user_msg;\nBOOL cond = FALSE;\nint size = 0;\nint ptr = 0;\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nswitch(read_subs(sub, sizeof(sub)/sizeof(*sub), 1,\n&s, yield == NULL, TRUE, US\"acl\", resetok))\n{\ncase 1: expand_string_message = US\"too few arguments or bracketing \"\n\"error for acl\";\ncase 2:\ncase 3: return NULL;\n}\n*resetok = FALSE;\nif (yield != NULL) switch(eval_acl(sub, sizeof(sub)/sizeof(*sub), &user_msg))\n{\ncase OK:\ncond = TRUE;\ncase FAIL:\nlookup_value = NULL;\nif (user_msg)\n{\nlookup_value = string_cat(NULL, &size, &ptr, user_msg, Ustrlen(user_msg));\nlookup_value[ptr] = '\\0';\n}\n*yield = cond == testfor;\nbreak;\ncase DEFER:\nexpand_string_forcedfail = TRUE;\ndefault:\nexpand_string_message = string_sprintf(\"error from acl \\\"%s\\\"\", sub[0]);\nreturn NULL;\n}\nreturn s;\n}\ncase ECOND_SASLAUTHD:\n#ifndef CYRUS_SASLAUTHD_SOCKET\ngoto COND_FAILED_NOT_COMPILED;\n#else\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nswitch(read_subs(sub, 4, 2, &s, yield == NULL, TRUE, US\"saslauthd\", resetok))\n{\ncase 1: expand_string_message = US\"too few arguments or bracketing \"\n\"error for saslauthd\";\ncase 2:\ncase 3: return NULL;\n}\nif (sub[2] == NULL) sub[3] = NULL;\nif (yield != NULL)\n{\nint rc;\nrc = auth_call_saslauthd(sub[0], sub[1], sub[2], sub[3],\n&expand_string_message);\nif (rc == ERROR || rc == DEFER) return NULL;\n*yield = (rc == OK) == testfor;\n}\nreturn s;\n#endif\ncase ECOND_MATCH_ADDRESS:\ncase ECOND_MATCH_DOMAIN:\ncase ECOND_MATCH_IP:\ncase ECOND_MATCH_LOCAL_PART:\n#ifndef EXPAND_LISTMATCH_RHS\nsub2_honour_dollar = FALSE;\n#endif\ncase ECOND_CRYPTEQ:\ncase ECOND_INLIST:\ncase ECOND_INLISTI:\ncase ECOND_MATCH:\ncase ECOND_NUM_L:\ncase ECOND_NUM_LE:\ncase ECOND_NUM_E:\ncase ECOND_NUM_EE:\ncase ECOND_NUM_G:\ncase ECOND_NUM_GE:\ncase ECOND_STR_LT:\ncase ECOND_STR_LTI:\ncase ECOND_STR_LE:\ncase ECOND_STR_LEI:\ncase ECOND_STR_EQ:\ncase ECOND_STR_EQI:\ncase ECOND_STR_GT:\ncase ECOND_STR_GTI:\ncase ECOND_STR_GE:\ncase ECOND_STR_GEI:\nfor (i = 0; i < 2; i++)\n{\nBOOL honour_dollar = TRUE;\nif ((i > 0) && !sub2_honour_dollar)\nhonour_dollar = FALSE;\nwhile (isspace(*s)) s++;\nif (*s != '{')\n{\nif (i == 0) goto COND_FAILED_CURLY_START;\nexpand_string_message = string_sprintf(\"missing 2nd string in {} \"\n\"after \\\"%s\\\"\", name);\nreturn NULL;\n}\nsub[i] = expand_string_internal(s+1, TRUE, &s, yield == NULL,\nhonour_dollar, resetok);\nif (sub[i] == NULL) return NULL;\nif (*s++ != '}') goto COND_FAILED_CURLY_END;\nif (!isalpha(name[0]) && yield != NULL)\n{\nif (sub[i][0] == 0)\n{\nnum[i] = 0;\nDEBUG(D_expand)\ndebug_printf(\"empty string cast to zero for numerical comparison\\n\");\n}\nelse\n{\nnum[i] = expanded_string_integer(sub[i], FALSE);\nif (expand_string_message != NULL) return NULL;\n}\n}\n}\nif (yield == NULL) return s;\nswitch(cond_type)\n{\ncase ECOND_NUM_E:\ncase ECOND_NUM_EE:\ntempcond = (num[0] == num[1]);\nbreak;\ncase ECOND_NUM_G:\ntempcond = (num[0] > num[1]);\nbreak;\ncase ECOND_NUM_GE:\ntempcond = (num[0] >= num[1]);\nbreak;\ncase ECOND_NUM_L:\ntempcond = (num[0] < num[1]);\nbreak;\ncase ECOND_NUM_LE:\ntempcond = (num[0] <= num[1]);\nbreak;\ncase ECOND_STR_LT:\ntempcond = (Ustrcmp(sub[0], sub[1]) < 0);\nbreak;\ncase ECOND_STR_LTI:\ntempcond = (strcmpic(sub[0], sub[1]) < 0);\nbreak;\ncase ECOND_STR_LE:\ntempcond = (Ustrcmp(sub[0], sub[1]) <= 0);\nbreak;\ncase ECOND_STR_LEI:\ntempcond = (strcmpic(sub[0], sub[1]) <= 0);\nbreak;\ncase ECOND_STR_EQ:\ntempcond = (Ustrcmp(sub[0], sub[1]) == 0);\nbreak;\ncase ECOND_STR_EQI:\ntempcond = (strcmpic(sub[0], sub[1]) == 0);\nbreak;\ncase ECOND_STR_GT:\ntempcond = (Ustrcmp(sub[0], sub[1]) > 0);\nbreak;\ncase ECOND_STR_GTI:\ntempcond = (strcmpic(sub[0], sub[1]) > 0);\nbreak;\ncase ECOND_STR_GE:\ntempcond = (Ustrcmp(sub[0], sub[1]) >= 0);\nbreak;\ncase ECOND_STR_GEI:\ntempcond = (strcmpic(sub[0], sub[1]) >= 0);\nbreak;\ncase ECOND_MATCH:\nre = pcre_compile(CS sub[1], PCRE_COPT, (const char **)&rerror, &roffset,\nNULL);\nif (re == NULL)\n{\nexpand_string_message = string_sprintf(\"regular expression error in \"\n\"\\\"%s\\\": %s at offset %d\", sub[1], rerror, roffset);\nreturn NULL;\n}\ntempcond = regex_match_and_setup(re, sub[0], 0, -1);\nbreak;\ncase ECOND_MATCH_ADDRESS:\nrc = match_address_list(sub[0], TRUE, FALSE, &(sub[1]), NULL, -1, 0, NULL);\ngoto MATCHED_SOMETHING;\ncase ECOND_MATCH_DOMAIN:\nrc = match_isinlist(sub[0], &(sub[1]), 0, &domainlist_anchor, NULL,\nMCL_DOMAIN + MCL_NOEXPAND, TRUE, NULL);\ngoto MATCHED_SOMETHING;\ncase ECOND_MATCH_IP:\nif (sub[0][0] != 0 && string_is_ip_address(sub[0], NULL) == 0)\n{\nexpand_string_message = string_sprintf(\"\\\"%s\\\" is not an IP address\",\nsub[0]);\nreturn NULL;\n}\nelse\n{\nunsigned int *nullcache = NULL;\ncheck_host_block cb;\ncb.host_name = US\"\";\ncb.host_address = sub[0];\ncb.host_ipv4 = (Ustrncmp(cb.host_address, \"::ffff:\", 7) == 0)?\ncb.host_address + 7 : cb.host_address;\nrc = match_check_list(\n&sub[1],\n0,\n&hostlist_anchor,\n&nullcache,\ncheck_host,\n&cb,\nMCL_HOST,\nsub[0],\nNULL);\n}\ngoto MATCHED_SOMETHING;\ncase ECOND_MATCH_LOCAL_PART:\nrc = match_isinlist(sub[0], &(sub[1]), 0, &localpartlist_anchor, NULL,\nMCL_LOCALPART + MCL_NOEXPAND, TRUE, NULL);\nMATCHED_SOMETHING:\nswitch(rc)\n{\ncase OK:\ntempcond = TRUE;\nbreak;\ncase FAIL:\ntempcond = FALSE;\nbreak;\ncase DEFER:\nexpand_string_message = string_sprintf(\"unable to complete match \"\n\"against \\\"%s\\\": %s\", sub[1], search_error_message);\nreturn NULL;\n}\nbreak;\ncase ECOND_CRYPTEQ:\n#ifndef SUPPORT_CRYPTEQ\ngoto COND_FAILED_NOT_COMPILED;\n#else\nif (strncmpic(sub[1], US\"{md5}\", 5) == 0)\n{\nint sublen = Ustrlen(sub[1]+5);\nmd5 base;\nuschar digest[16];\nmd5_start(&base);\nmd5_end(&base, (uschar *)sub[0], Ustrlen(sub[0]), digest);\nif (sublen == 24)\n{\nuschar *coded = auth_b64encode((uschar *)digest, 16);\nDEBUG(D_auth) debug_printf(\"crypteq: using MD5+B64 hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+5);\ntempcond = (Ustrcmp(coded, sub[1]+5) == 0);\n}\nelse if (sublen == 32)\n{\nint i;\nuschar coded[36];\nfor (i = 0; i < 16; i++) sprintf(CS (coded+2*i), \"%02X\", digest[i]);\ncoded[32] = 0;\nDEBUG(D_auth) debug_printf(\"crypteq: using MD5+hex hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+5);\ntempcond = (strcmpic(coded, sub[1]+5) == 0);\n}\nelse\n{\nDEBUG(D_auth) debug_printf(\"crypteq: length for MD5 not 24 or 32: \"\n\"fail\\n  crypted=%s\\n\", sub[1]+5);\ntempcond = FALSE;\n}\n}\nelse if (strncmpic(sub[1], US\"{sha1}\", 6) == 0)\n{\nint sublen = Ustrlen(sub[1]+6);\nsha1 base;\nuschar digest[20];\nsha1_start(&base);\nsha1_end(&base, (uschar *)sub[0], Ustrlen(sub[0]), digest);\nif (sublen == 28)\n{\nuschar *coded = auth_b64encode((uschar *)digest, 20);\nDEBUG(D_auth) debug_printf(\"crypteq: using SHA1+B64 hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+6);\ntempcond = (Ustrcmp(coded, sub[1]+6) == 0);\n}\nelse if (sublen == 40)\n{\nint i;\nuschar coded[44];\nfor (i = 0; i < 20; i++) sprintf(CS (coded+2*i), \"%02X\", digest[i]);\ncoded[40] = 0;\nDEBUG(D_auth) debug_printf(\"crypteq: using SHA1+hex hashing\\n\"\n\"  subject=%s\\n  crypted=%s\\n\", coded, sub[1]+6);\ntempcond = (strcmpic(coded, sub[1]+6) == 0);\n}\nelse\n{\nDEBUG(D_auth) debug_printf(\"crypteq: length for SHA-1 not 28 or 40: \"\n\"fail\\n  crypted=%s\\n\", sub[1]+6);\ntempcond = FALSE;\n}\n}\nelse\n{\nint which = 0;\nuschar *coded;\nif (strncmpic(sub[1], US\"{crypt}\", 7) == 0)\n{\nsub[1] += 7;\nwhich = 1;\n}\nelse if (strncmpic(sub[1], US\"{crypt16}\", 9) == 0)\n{\nsub[1] += 9;\nwhich = 2;\n}\nelse if (sub[1][0] == '{')\n{\nexpand_string_message = string_sprintf(\"unknown encryption mechanism \"\n\"in \\\"%s\\\"\", sub[1]);\nreturn NULL;\n}\nswitch(which)\n{\ncase 0:  coded = US DEFAULT_CRYPT(CS sub[0], CS sub[1]); break;\ncase 1:  coded = US crypt(CS sub[0], CS sub[1]); break;\ndefault: coded = US crypt16(CS sub[0], CS sub[1]); break;\n}\n#define STR(s) # s\n#define XSTR(s) STR(s)\nDEBUG(D_auth) debug_printf(\"crypteq: using %s()\\n\"\n\"  subject=%s\\n  crypted=%s\\n\",\n(which == 0)? XSTR(DEFAULT_CRYPT) : (which == 1)? \"crypt\" : \"crypt16\",\ncoded, sub[1]);\n#undef STR\n#undef XSTR\ntempcond = (Ustrlen(sub[1]) < 2)? FALSE :\n(Ustrcmp(coded, sub[1]) == 0);\n}\nbreak;\n#endif\ncase ECOND_INLIST:\ncase ECOND_INLISTI:\n{\nint sep = 0;\nuschar *save_iterate_item = iterate_item;\nint (*compare)(const uschar *, const uschar *);\ntempcond = FALSE;\nif (cond_type == ECOND_INLISTI)\ncompare = strcmpic;\nelse\ncompare = (int (*)(const uschar *, const uschar *)) strcmp;\nwhile ((iterate_item = string_nextinlist(&sub[1], &sep, NULL, 0)) != NULL)\nif (compare(sub[0], iterate_item) == 0)\n{\ntempcond = TRUE;\nbreak;\n}\niterate_item = save_iterate_item;\n}\n}\n*yield = tempcond == testfor;\nreturn s;\ncase ECOND_AND:\ncase ECOND_OR:\nsubcondptr = (yield == NULL)? NULL : &tempcond;\ncombined_cond = (cond_type == ECOND_AND);\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nfor (;;)\n{\nwhile (isspace(*s)) s++;\nif (*s == '}') break;\nif (*s != '{')\n{\nexpand_string_message = string_sprintf(\"each subcondition \"\n\"inside an \\\"%s{...}\\\" condition must be in its own {}\", name);\nreturn NULL;\n}\nif (!(s = eval_condition(s+1, resetok, subcondptr)))\n{\nexpand_string_message = string_sprintf(\"%s inside \\\"%s{...}\\\" condition\",\nexpand_string_message, name);\nreturn NULL;\n}\nwhile (isspace(*s)) s++;\nif (*s++ != '}')\n{\nexpand_string_message = string_sprintf(\"missing } at end of condition \"\n\"inside \\\"%s\\\" group\", name);\nreturn NULL;\n}\nif (yield != NULL)\n{\nif (cond_type == ECOND_AND)\n{\ncombined_cond &= tempcond;\nif (!combined_cond) subcondptr = NULL;\n}\nelse\n{\ncombined_cond |= tempcond;\nif (combined_cond) subcondptr = NULL;\n}\n}\n}\nif (yield != NULL) *yield = (combined_cond == testfor);\nreturn ++s;\ncase ECOND_FORALL:\ncase ECOND_FORANY:\n{\nint sep = 0;\nuschar *save_iterate_item = iterate_item;\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nsub[0] = expand_string_internal(s, TRUE, &s, (yield == NULL), TRUE, resetok);\nif (sub[0] == NULL) return NULL;\nif (*s++ != '}') goto COND_FAILED_CURLY_END;\nwhile (isspace(*s)) s++;\nif (*s++ != '{') goto COND_FAILED_CURLY_START;\nsub[1] = s;\nif (!(s = eval_condition(sub[1], resetok, NULL)))\n{\nexpand_string_message = string_sprintf(\"%s inside \\\"%s\\\" condition\",\nexpand_string_message, name);\nreturn NULL;\n}\nwhile (isspace(*s)) s++;\nif (*s++ != '}')\n{\nexpand_string_message = string_sprintf(\"missing } at end of condition \"\n\"inside \\\"%s\\\"\", name);\nreturn NULL;\n}\nif (yield != NULL) *yield = !testfor;\nwhile ((iterate_item = string_nextinlist(&sub[0], &sep, NULL, 0)) != NULL)\n{\nDEBUG(D_expand) debug_printf(\"%s: $item = \\\"%s\\\"\\n\", name, iterate_item);\nif (!eval_condition(sub[1], resetok, &tempcond))\n{\nexpand_string_message = string_sprintf(\"%s inside \\\"%s\\\" condition\",\nexpand_string_message, name);\niterate_item = save_iterate_item;\nreturn NULL;\n}\nDEBUG(D_expand) debug_printf(\"%s: condition evaluated to %s\\n\", name,\ntempcond? \"true\":\"false\");\nif (yield != NULL) *yield = (tempcond == testfor);\nif (tempcond == (cond_type == ECOND_FORANY)) break;\n}\niterate_item = save_iterate_item;\nreturn s;\n}\ncase ECOND_BOOL:\ncase ECOND_BOOL_LAX:\n{\nuschar *sub_arg[1];\nuschar *t, *t2;\nuschar *ourname;\nsize_t len;\nBOOL boolvalue = FALSE;\nwhile (isspace(*s)) s++;\nif (*s != '{') goto COND_FAILED_CURLY_START;\nourname = cond_type == ECOND_BOOL_LAX ? US\"bool_lax\" : US\"bool\";\nswitch(read_subs(sub_arg, 1, 1, &s, yield == NULL, FALSE, ourname, resetok))\n{\ncase 1: expand_string_message = string_sprintf(\n\"too few arguments or bracketing error for %s\",\nourname);\ncase 2:\ncase 3: return NULL;\n}\nt = sub_arg[0];\nwhile (isspace(*t)) t++;\nlen = Ustrlen(t);\nif (len)\n{\nt2 = t + len - 1;\nwhile (isspace(*t2)) t2--;\nif (t2 != (t + len))\n{\n*++t2 = '\\0';\nlen = t2 - t;\n}\n}\nDEBUG(D_expand)\ndebug_printf(\"considering %s: %s\\n\", ourname, len ? t : US\"<empty>\");\nif (len == 0)\nboolvalue = FALSE;\nelse if (*t == '-'\n? Ustrspn(t+1, \"0123456789\") == len-1\n: Ustrspn(t,   \"0123456789\") == len)\n{\nboolvalue = (Uatoi(t) == 0) ? FALSE : TRUE;\nif ((cond_type == ECOND_BOOL_LAX) && (len > 1))\nboolvalue = TRUE;\n}\nelse if (strcmpic(t, US\"true\") == 0 || strcmpic(t, US\"yes\") == 0)\nboolvalue = TRUE;\nelse if (strcmpic(t, US\"false\") == 0 || strcmpic(t, US\"no\") == 0)\nboolvalue = FALSE;\nelse if (cond_type == ECOND_BOOL_LAX)\nboolvalue = TRUE;\nelse\n{\nexpand_string_message = string_sprintf(\"unrecognised boolean \"\n\"value \\\"%s\\\"\", t);\nreturn NULL;\n}\nif (yield != NULL) *yield = (boolvalue == testfor);\nreturn s;\n}\ndefault:\nexpand_string_message = string_sprintf(\"unknown condition \\\"%s\\\"\", name);\nreturn NULL;\n}\nCOND_FAILED_CURLY_START:\nexpand_string_message = string_sprintf(\"missing { after \\\"%s\\\"\", name);\nreturn NULL;\nCOND_FAILED_CURLY_END:\nexpand_string_message = string_sprintf(\"missing } at end of \\\"%s\\\" condition\",\nname);\nreturn NULL;\n#if !defined(SUPPORT_PAM) || !defined(RADIUS_CONFIG_FILE) || \\\n!defined(LOOKUP_LDAP) || !defined(CYRUS_PWCHECK_SOCKET) || \\\n!defined(SUPPORT_CRYPTEQ) || !defined(CYRUS_SASLAUTHD_SOCKET)\nCOND_FAILED_NOT_COMPILED:\nexpand_string_message = string_sprintf(\"support for \\\"%s\\\" not compiled\",\nname);\nreturn NULL;\n#endif\n}", "label": 0}
{"index": 174949, "code": "expand_string_integer(uschar *string, BOOL isplus)\n{\nint_eximarith_t value;\nuschar *s = expand_string(string);\nuschar *msg = US\"invalid integer \\\"%s\\\"\";\nuschar *endptr;\nif (s == NULL) return -1;\nerrno = 0;\nexpand_string_message = NULL;\nif (isspace(*s))\n{\nwhile (isspace(*s)) ++s;\nif (*s == '\\0')\n{\nDEBUG(D_expand)\ndebug_printf(\"treating blank string as number 0\\n\");\nreturn 0;\n}\n}\nvalue = strtoll(CS s, CSS &endptr, 10);\nif (endptr == s)\n{\nmsg = US\"integer expected but \\\"%s\\\" found\";\n}\nelse if (value < 0 && isplus)\n{\nmsg = US\"non-negative integer expected but \\\"%s\\\" found\";\n}\nelse\n{\nswitch (tolower(*endptr))\n{\ndefault:\nbreak;\ncase 'k':\nif (value > EXIM_ARITH_MAX/1024 || value < EXIM_ARITH_MIN/1024) errno = ERANGE;\nelse value *= 1024;\nendptr++;\nbreak;\ncase 'm':\nif (value > EXIM_ARITH_MAX/(1024*1024) || value < EXIM_ARITH_MIN/(1024*1024)) errno = ERANGE;\nelse value *= 1024*1024;\nendptr++;\nbreak;\ncase 'g':\nif (value > EXIM_ARITH_MAX/(1024*1024*1024) || value < EXIM_ARITH_MIN/(1024*1024*1024)) errno = ERANGE;\nelse value *= 1024*1024*1024;\nendptr++;\nbreak;\n}\nif (errno == ERANGE)\nmsg = US\"absolute value of integer \\\"%s\\\" is too large (overflow)\";\nelse\n{\nwhile (isspace(*endptr)) endptr++;\nif (*endptr == 0) return value;\n}\n}\nexpand_string_message = string_sprintf(CS msg, s);\nreturn -2;\n}", "contrast": "expand_string_integer(uschar *string, BOOL isplus)\n{\nreturn expanded_string_integer(expand_string(string), isplus);\n}\nstatic int_eximarith_t\nexpanded_string_integer(uschar *s, BOOL isplus)\n{\nint_eximarith_t value;\nuschar *msg = US\"invalid integer \\\"%s\\\"\";\nuschar *endptr;\nif (s == NULL) return -1;\nerrno = 0;\nexpand_string_message = NULL;\nif (isspace(*s))\n{\nwhile (isspace(*s)) ++s;\nif (*s == '\\0')\n{\nDEBUG(D_expand)\ndebug_printf(\"treating blank string as number 0\\n\");\nreturn 0;\n}\n}\nvalue = strtoll(CS s, CSS &endptr, 10);\nif (endptr == s)\n{\nmsg = US\"integer expected but \\\"%s\\\" found\";\n}\nelse if (value < 0 && isplus)\n{\nmsg = US\"non-negative integer expected but \\\"%s\\\" found\";\n}\nelse\n{\nswitch (tolower(*endptr))\n{\ndefault:\nbreak;\ncase 'k':\nif (value > EXIM_ARITH_MAX/1024 || value < EXIM_ARITH_MIN/1024) errno = ERANGE;\nelse value *= 1024;\nendptr++;\nbreak;\ncase 'm':\nif (value > EXIM_ARITH_MAX/(1024*1024) || value < EXIM_ARITH_MIN/(1024*1024)) errno = ERANGE;\nelse value *= 1024*1024;\nendptr++;\nbreak;\ncase 'g':\nif (value > EXIM_ARITH_MAX/(1024*1024*1024) || value < EXIM_ARITH_MIN/(1024*1024*1024)) errno = ERANGE;\nelse value *= 1024*1024*1024;\nendptr++;\nbreak;\n}\nif (errno == ERANGE)\nmsg = US\"absolute value of integer \\\"%s\\\" is too large (overflow)\";\nelse\n{\nwhile (isspace(*endptr)) endptr++;\nif (*endptr == 0) return value;\n}\n}\nexpand_string_message = string_sprintf(CS msg, s);\nreturn -2;\n}", "label": 0}
{"index": 174960, "code": "static int ssl_scan_clienthello_custom_tlsext(SSL *s,\nconst unsigned char *data,\nconst unsigned char *limit,\nint *al)\n{\nunsigned short type, size, len;\nif (s->hit || s->cert->srv_ext.meths_count == 0)\nreturn 1;\nif (data >= limit - 2)\nreturn 1;\nn2s(data, len);\nif (data > limit - len)\nreturn 1;\nwhile (data <= limit - 4) {\nn2s(data, type);\nn2s(data, size);\nif (data + size > limit)\nreturn 1;\nif (custom_ext_parse(s, 1   , type, data, size, al) <= 0)\nreturn 0;\ndata += size;\n}\nreturn 1;\n}", "contrast": "static int ssl_scan_clienthello_custom_tlsext(SSL *s,\nconst unsigned char *data,\nconst unsigned char *limit,\nint *al)\n{\nunsigned short type, size, len;\nif (s->hit || s->cert->srv_ext.meths_count == 0)\nreturn 1;\nif (limit - data <= 2)\nreturn 1;\nn2s(data, len);\nif (limit - data < len)\nreturn 1;\nwhile (limit - data >= 4) {\nn2s(data, type);\nn2s(data, size);\nif (limit - data < size)\nreturn 1;\nif (custom_ext_parse(s, 1   , type, data, size, al) <= 0)\nreturn 0;\ndata += size;\n}\nreturn 1;\n}", "label": 0}
{"index": 174962, "code": "static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p,\nunsigned char *d, int n, int *al)\n{\nunsigned short length;\nunsigned short type;\nunsigned short size;\nunsigned char *data = *p;\nint tlsext_servername = 0;\nint renegotiate_seen = 0;\n# ifndef OPENSSL_NO_NEXTPROTONEG\ns->s3->next_proto_neg_seen = 0;\n# endif\ns->tlsext_ticket_expected = 0;\nif (s->s3->alpn_selected) {\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = NULL;\n}\n# ifndef OPENSSL_NO_HEARTBEATS\ns->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\nSSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n# endif\nif (data >= (d + n - 2))\ngoto ri_check;\nn2s(data, length);\nif (data + length != d + n) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nwhile (data <= (d + n - 4)) {\nn2s(data, type);\nn2s(data, size);\nif (data + size > (d + n))\ngoto ri_check;\nif (s->tlsext_debug_cb)\ns->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);\nif (type == TLSEXT_TYPE_server_name) {\nif (s->tlsext_hostname == NULL || size > 0) {\n*al = TLS1_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\ntlsext_servername = 1;\n}\n# ifndef OPENSSL_NO_EC\nelse if (type == TLSEXT_TYPE_ec_point_formats) {\nunsigned char *sdata = data;\nint ecpointformatlist_length = *(sdata++);\nif (ecpointformatlist_length != size - 1) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (!s->hit) {\ns->session->tlsext_ecpointformatlist_length = 0;\nif (s->session->tlsext_ecpointformatlist != NULL)\nOPENSSL_free(s->session->tlsext_ecpointformatlist);\nif ((s->session->tlsext_ecpointformatlist =\nOPENSSL_malloc(ecpointformatlist_length)) == NULL) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->session->tlsext_ecpointformatlist_length =\necpointformatlist_length;\nmemcpy(s->session->tlsext_ecpointformatlist, sdata,\necpointformatlist_length);\n}\n#  if 0\nfprintf(stderr,\n\"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist \");\nsdata = s->session->tlsext_ecpointformatlist;\nfor (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\nfprintf(stderr, \"%i \", *(sdata++));\nfprintf(stderr, \"\\n\");\n#  endif\n}\n# endif\nelse if (type == TLSEXT_TYPE_session_ticket) {\nif (s->tls_session_ticket_ext_cb &&\n!s->tls_session_ticket_ext_cb(s, data, size,\ns->tls_session_ticket_ext_cb_arg))\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nif ((SSL_get_options(s) & SSL_OP_NO_TICKET)\n|| (size > 0)) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_ticket_expected = 1;\n}\n# ifdef TLSEXT_TYPE_opaque_prf_input\nelse if (type == TLSEXT_TYPE_opaque_prf_input) {\nunsigned char *sdata = data;\nif (size < 2) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nn2s(sdata, s->s3->server_opaque_prf_input_len);\nif (s->s3->server_opaque_prf_input_len != size - 2) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->server_opaque_prf_input != NULL) {\nOPENSSL_free(s->s3->server_opaque_prf_input);\n}\nif (s->s3->server_opaque_prf_input_len == 0) {\ns->s3->server_opaque_prf_input = OPENSSL_malloc(1);\n} else {\ns->s3->server_opaque_prf_input =\nBUF_memdup(sdata, s->s3->server_opaque_prf_input_len);\n}\nif (s->s3->server_opaque_prf_input == NULL) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\n}\n# endif\nelse if (type == TLSEXT_TYPE_status_request) {\nif ((s->tlsext_status_type == -1) || (size > 0)) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_status_expected = 1;\n}\n# ifndef OPENSSL_NO_NEXTPROTONEG\nelse if (type == TLSEXT_TYPE_next_proto_neg &&\ns->s3->tmp.finish_md_len == 0) {\nunsigned char *selected;\nunsigned char selected_len;\nif (s->ctx->next_proto_select_cb == NULL) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (!ssl_next_proto_validate(data, size)) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->\nctx->next_proto_select_cb(s, &selected, &selected_len, data,\nsize,\ns->ctx->next_proto_select_cb_arg) !=\nSSL_TLSEXT_ERR_OK) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->next_proto_negotiated = OPENSSL_malloc(selected_len);\nif (!s->next_proto_negotiated) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->next_proto_negotiated, selected, selected_len);\ns->next_proto_negotiated_len = selected_len;\ns->s3->next_proto_neg_seen = 1;\n}\n# endif\nelse if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {\nunsigned len;\nif (!s->cert->alpn_sent) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (size < 4) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[0];\nlen <<= 8;\nlen |= data[1];\nif (len != (unsigned)size - 2) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[2];\nif (len != (unsigned)size - 3) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->alpn_selected)\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = OPENSSL_malloc(len);\nif (!s->s3->alpn_selected) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->s3->alpn_selected, data + 3, len);\ns->s3->alpn_selected_len = len;\n}\nelse if (type == TLSEXT_TYPE_renegotiate) {\nif (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))\nreturn 0;\nrenegotiate_seen = 1;\n}\n# ifndef OPENSSL_NO_HEARTBEATS\nelse if (type == TLSEXT_TYPE_heartbeat) {\nswitch (data[0]) {\ncase 0x01:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\nbreak;\ncase 0x02:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\nbreak;\ndefault:\n*al = SSL_AD_ILLEGAL_PARAMETER;\nreturn 0;\n}\n}\n# endif\n# ifndef OPENSSL_NO_SRTP\nelse if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {\nif (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))\nreturn 0;\n}\n# endif\nelse if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\nreturn 0;\ndata += size;\n}\nif (data != d + n) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (!s->hit && tlsext_servername == 1) {\nif (s->tlsext_hostname) {\nif (s->session->tlsext_hostname == NULL) {\ns->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\nif (!s->session->tlsext_hostname) {\n*al = SSL_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\n} else {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\n}\n}\n*p = data;\nri_check:\nif (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\n&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n*al = SSL_AD_HANDSHAKE_FAILURE;\nSSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\nSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\nreturn 0;\n}\nreturn 1;\n}", "contrast": "static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p,\nunsigned char *d, int n, int *al)\n{\nunsigned short length;\nunsigned short type;\nunsigned short size;\nunsigned char *data = *p;\nint tlsext_servername = 0;\nint renegotiate_seen = 0;\n# ifndef OPENSSL_NO_NEXTPROTONEG\ns->s3->next_proto_neg_seen = 0;\n# endif\ns->tlsext_ticket_expected = 0;\nif (s->s3->alpn_selected) {\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = NULL;\n}\n# ifndef OPENSSL_NO_HEARTBEATS\ns->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\nSSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n# endif\nif ((d + n) - data <= 2)\ngoto ri_check;\nn2s(data, length);\nif ((d + n) - data != length) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nwhile ((d + n) - data >= 4) {\nn2s(data, type);\nn2s(data, size);\nif ((d + n) - data < size)\ngoto ri_check;\nif (s->tlsext_debug_cb)\ns->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);\nif (type == TLSEXT_TYPE_server_name) {\nif (s->tlsext_hostname == NULL || size > 0) {\n*al = TLS1_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\ntlsext_servername = 1;\n}\n# ifndef OPENSSL_NO_EC\nelse if (type == TLSEXT_TYPE_ec_point_formats) {\nunsigned char *sdata = data;\nint ecpointformatlist_length = *(sdata++);\nif (ecpointformatlist_length != size - 1) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (!s->hit) {\ns->session->tlsext_ecpointformatlist_length = 0;\nif (s->session->tlsext_ecpointformatlist != NULL)\nOPENSSL_free(s->session->tlsext_ecpointformatlist);\nif ((s->session->tlsext_ecpointformatlist =\nOPENSSL_malloc(ecpointformatlist_length)) == NULL) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->session->tlsext_ecpointformatlist_length =\necpointformatlist_length;\nmemcpy(s->session->tlsext_ecpointformatlist, sdata,\necpointformatlist_length);\n}\n#  if 0\nfprintf(stderr,\n\"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist \");\nsdata = s->session->tlsext_ecpointformatlist;\nfor (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\nfprintf(stderr, \"%i \", *(sdata++));\nfprintf(stderr, \"\\n\");\n#  endif\n}\n# endif\nelse if (type == TLSEXT_TYPE_session_ticket) {\nif (s->tls_session_ticket_ext_cb &&\n!s->tls_session_ticket_ext_cb(s, data, size,\ns->tls_session_ticket_ext_cb_arg))\n{\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nif ((SSL_get_options(s) & SSL_OP_NO_TICKET)\n|| (size > 0)) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_ticket_expected = 1;\n}\n# ifdef TLSEXT_TYPE_opaque_prf_input\nelse if (type == TLSEXT_TYPE_opaque_prf_input) {\nunsigned char *sdata = data;\nif (size < 2) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nn2s(sdata, s->s3->server_opaque_prf_input_len);\nif (s->s3->server_opaque_prf_input_len != size - 2) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->server_opaque_prf_input != NULL) {\nOPENSSL_free(s->s3->server_opaque_prf_input);\n}\nif (s->s3->server_opaque_prf_input_len == 0) {\ns->s3->server_opaque_prf_input = OPENSSL_malloc(1);\n} else {\ns->s3->server_opaque_prf_input =\nBUF_memdup(sdata, s->s3->server_opaque_prf_input_len);\n}\nif (s->s3->server_opaque_prf_input == NULL) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\n}\n# endif\nelse if (type == TLSEXT_TYPE_status_request) {\nif ((s->tlsext_status_type == -1) || (size > 0)) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\ns->tlsext_status_expected = 1;\n}\n# ifndef OPENSSL_NO_NEXTPROTONEG\nelse if (type == TLSEXT_TYPE_next_proto_neg &&\ns->s3->tmp.finish_md_len == 0) {\nunsigned char *selected;\nunsigned char selected_len;\nif (s->ctx->next_proto_select_cb == NULL) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (!ssl_next_proto_validate(data, size)) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->\nctx->next_proto_select_cb(s, &selected, &selected_len, data,\nsize,\ns->ctx->next_proto_select_cb_arg) !=\nSSL_TLSEXT_ERR_OK) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\ns->next_proto_negotiated = OPENSSL_malloc(selected_len);\nif (!s->next_proto_negotiated) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->next_proto_negotiated, selected, selected_len);\ns->next_proto_negotiated_len = selected_len;\ns->s3->next_proto_neg_seen = 1;\n}\n# endif\nelse if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {\nunsigned len;\nif (!s->cert->alpn_sent) {\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\nreturn 0;\n}\nif (size < 4) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[0];\nlen <<= 8;\nlen |= data[1];\nif (len != (unsigned)size - 2) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nlen = data[2];\nif (len != (unsigned)size - 3) {\n*al = TLS1_AD_DECODE_ERROR;\nreturn 0;\n}\nif (s->s3->alpn_selected)\nOPENSSL_free(s->s3->alpn_selected);\ns->s3->alpn_selected = OPENSSL_malloc(len);\nif (!s->s3->alpn_selected) {\n*al = TLS1_AD_INTERNAL_ERROR;\nreturn 0;\n}\nmemcpy(s->s3->alpn_selected, data + 3, len);\ns->s3->alpn_selected_len = len;\n}\nelse if (type == TLSEXT_TYPE_renegotiate) {\nif (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))\nreturn 0;\nrenegotiate_seen = 1;\n}\n# ifndef OPENSSL_NO_HEARTBEATS\nelse if (type == TLSEXT_TYPE_heartbeat) {\nswitch (data[0]) {\ncase 0x01:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\nbreak;\ncase 0x02:\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\nbreak;\ndefault:\n*al = SSL_AD_ILLEGAL_PARAMETER;\nreturn 0;\n}\n}\n# endif\n# ifndef OPENSSL_NO_SRTP\nelse if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {\nif (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))\nreturn 0;\n}\n# endif\nelse if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\nreturn 0;\ndata += size;\n}\nif (data != d + n) {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\nif (!s->hit && tlsext_servername == 1) {\nif (s->tlsext_hostname) {\nif (s->session->tlsext_hostname == NULL) {\ns->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\nif (!s->session->tlsext_hostname) {\n*al = SSL_AD_UNRECOGNIZED_NAME;\nreturn 0;\n}\n} else {\n*al = SSL_AD_DECODE_ERROR;\nreturn 0;\n}\n}\n}\n*p = data;\nri_check:\nif (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\n&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n*al = SSL_AD_HANDSHAKE_FAILURE;\nSSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\nSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\nreturn 0;\n}\nreturn 1;\n}", "label": 0}
{"index": 174965, "code": "static const char *check_secret(int module, const char *user, const char *group,\nconst char *challenge, const char *pass)\n{\nchar line[1024];\nchar pass2[MAX_DIGEST_LEN*2];\nconst char *fname = lp_secrets_file(module);\nSTRUCT_STAT st;\nint fd, ok = 1;\nint user_len = strlen(user);\nint group_len = group ? strlen(group) : 0;\nchar *err;\nif (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)\nreturn \"no secrets file\";\nif (do_fstat(fd, &st) == -1) {\nrsyserr(FLOG, errno, \"fstat(%s)\", fname);\nok = 0;\n} else if (lp_strict_modes(module)) {\nrprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\nok = 0;\n} else if (MY_UID() == 0 && st.st_uid != 0) {\nrprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\nok = 0;\n}\n}", "contrast": "static const char *check_secret(int module, const char *user, const char *group,\nconst char *challenge, const char *pass)\n{\nchar line[1024];\nchar pass2[MAX_DIGEST_LEN*2];\nconst char *fname = lp_secrets_file(module);\nSTRUCT_STAT st;\nint ok = 1;\nint user_len = strlen(user);\nint group_len = group ? strlen(group) : 0;\nchar *err;\nFILE *fh;\nif (!fname || !*fname || (fh = fopen(fname, \"r\")) == NULL)\nreturn \"no secrets file\";\nif (do_fstat(fileno(fh), &st) == -1) {\nrsyserr(FLOG, errno, \"fstat(%s)\", fname);\nok = 0;\n} else if (lp_strict_modes(module)) {\nrprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\nok = 0;\n} else if (MY_UID() == 0 && st.st_uid != 0) {\nrprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\nok = 0;\n}\n}", "label": 0}
{"index": 174973, "code": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\nconst unsigned char *in, int inl)\n{\nint i, j, bl;\nif (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\ni = ctx->cipher->do_cipher(ctx, out, in, inl);\nif (i < 0)\nreturn 0;\nelse\n*outl = i;\nreturn 1;\n}\nif (inl <= 0) {\n*outl = 0;\nreturn inl == 0;\n}\nif (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\nif (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n*outl = inl;\nreturn 1;\n} else {\n*outl = 0;\nreturn 0;\n}\n}\ni = ctx->buf_len;\nbl = ctx->cipher->block_size;\nOPENSSL_assert(bl <= (int)sizeof(ctx->buf));\nif (i != 0) {\nif (i + inl < bl) {\nmemcpy(&(ctx->buf[i]), in, inl);\nctx->buf_len += inl;\n*outl = 0;\nreturn 1;\n} else {\nj = bl - i;\nmemcpy(&(ctx->buf[i]), in, j);\nif (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\nreturn 0;\ninl -= j;\nin += j;\nout += bl;\n*outl = bl;\n}\n} else\n*outl = 0;\ni = inl & (bl - 1);\ninl -= i;\nif (inl > 0) {\nif (!ctx->cipher->do_cipher(ctx, out, in, inl))\nreturn 0;\n*outl += inl;\n}\nif (i != 0)\nmemcpy(ctx->buf, &(in[inl]), i);\nctx->buf_len = i;\nreturn 1;\n}", "contrast": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\nconst unsigned char *in, int inl)\n{\nint i, j, bl;\nif (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\ni = ctx->cipher->do_cipher(ctx, out, in, inl);\nif (i < 0)\nreturn 0;\nelse\n*outl = i;\nreturn 1;\n}\nif (inl <= 0) {\n*outl = 0;\nreturn inl == 0;\n}\nif (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\nif (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n*outl = inl;\nreturn 1;\n} else {\n*outl = 0;\nreturn 0;\n}\n}\ni = ctx->buf_len;\nbl = ctx->cipher->block_size;\nOPENSSL_assert(bl <= (int)sizeof(ctx->buf));\nif (i != 0) {\nif (bl - i > inl) {\nmemcpy(&(ctx->buf[i]), in, inl);\nctx->buf_len += inl;\n*outl = 0;\nreturn 1;\n} else {\nj = bl - i;\nmemcpy(&(ctx->buf[i]), in, j);\nif (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\nreturn 0;\ninl -= j;\nin += j;\nout += bl;\n*outl = bl;\n}\n} else\n*outl = 0;\ni = inl & (bl - 1);\ninl -= i;\nif (inl > 0) {\nif (!ctx->cipher->do_cipher(ctx, out, in, inl))\nreturn 0;\n*outl += inl;\n}\nif (i != 0)\nmemcpy(ctx->buf, &(in[inl]), i);\nctx->buf_len = i;\nreturn 1;\n}", "label": 0}
{"index": 174995, "code": "XpmCreateDataFromXpmImage(\nchar\t***data_return,\nXpmImage\t  *image,\nXpmInfo\t  *info)\n{\nint ErrorStatus;\nchar buf[BUFSIZ];\nchar **header = NULL, **data, **sptr, **sptr2, *s;\nunsigned int header_size, header_nlines;\nunsigned int data_size, data_nlines;\nunsigned int extensions = 0, ext_size = 0, ext_nlines = 0;\nunsigned int offset, l, n;\n*data_return = NULL;\nextensions = info && (info->valuemask & XpmExtensions)\n&& info->nextensions;\nif (extensions)\nCountExtensions(info->extensions, info->nextensions,\n&ext_size, &ext_nlines);\nheader_nlines = 1 + image->ncolors;\nif(header_nlines <= image->ncolors ||\nheader_nlines >= UINT_MAX / sizeof(char *))\nreturn(XpmNoMemory);\nheader_size = sizeof(char *) * header_nlines;\nif (header_size >= UINT_MAX / sizeof(char *))\nreturn (XpmNoMemory);\nheader = (char **) XpmCalloc(header_size, sizeof(char *));\nif (!header)\nreturn (XpmNoMemory);\ns = buf;\n#ifndef VOID_SPRINTF\ns +=\n#endif\nsprintf(s, \"%d %d %d %d\", image->width, image->height,\nimage->ncolors, image->cpp);\n#ifdef VOID_SPRINTF\ns += strlen(s);\n#endif\nif (info && (info->valuemask & XpmHotspot)) {\n#ifndef VOID_SPRINTF\ns +=\n#endif\nsprintf(s, \" %d %d\", info->x_hotspot, info->y_hotspot);\n#ifdef VOID_SPRINTF\ns += strlen(s);\n#endif\n}\nif (extensions) {\nstrcpy(s, \" XPMEXT\");\ns += 7;\n}\nl = s - buf + 1;\n*header = (char *) XpmMalloc(l);\nif (!*header)\nRETURN(XpmNoMemory);\nheader_size += l;\nstrcpy(*header, buf);\nErrorStatus = CreateColors(header + 1, &header_size,\nimage->colorTable, image->ncolors, image->cpp);\nif (ErrorStatus != XpmSuccess)\nRETURN(ErrorStatus);\noffset = image->width * image->cpp + 1;\nif(offset <= image->width || offset <= image->cpp)\nif(offset <= image->width || offset <= image->cpp)\nRETURN(XpmNoMemory);\nif( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))\nRETURN(XpmNoMemory);\ndata_size = (image->height + ext_nlines) * sizeof(char *);\nRETURN(XpmNoMemory);\ndata_size += image->height * offset;\nRETURN(XpmNoMemory);\ndata_size += image->height * offset;\nif( (header_size + ext_size) >= (UINT_MAX - data_size) )\nRETURN(XpmNoMemory);\ndata_size += header_size + ext_size;\ndata_nlines = header_nlines + image->height + ext_nlines;\n*data = (char *) (data + data_nlines);\nn = image->ncolors;\nfor (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {\nstrcpy(*sptr, *sptr2);\n*(sptr + 1) = *sptr + strlen(*sptr2) + 1;\n}\ndata[header_nlines] = (char *) data + header_size\n+ (image->height + ext_nlines) * sizeof(char *);\nCreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,\nimage->cpp, image->data, image->colorTable);\nif (extensions)\nCreateExtensions(data + header_nlines + image->height - 1,\ndata_size - header_nlines - image->height + 1, offset,\ninfo->extensions, info->nextensions,\next_nlines);\n*data_return = data;\nErrorStatus = XpmSuccess;\nexit:\nif (header) {\nfor (l = 0; l < header_nlines; l++)\nif (header[l])\nXpmFree(header[l]);\nXpmFree(header);\n}\nreturn(ErrorStatus);\n}", "contrast": "XpmCreateDataFromXpmImage(\nchar\t***data_return,\nXpmImage\t  *image,\nXpmInfo\t  *info)\n{\nint ErrorStatus;\nchar buf[BUFSIZ];\nchar **header = NULL, **data, **sptr, **sptr2, *s;\nunsigned int header_size, header_nlines;\nunsigned int data_size, data_nlines;\nunsigned int extensions = 0, ext_size = 0, ext_nlines = 0;\nunsigned int offset, l, n;\n*data_return = NULL;\nextensions = info && (info->valuemask & XpmExtensions)\n&& info->nextensions;\nif (extensions)\nif (CountExtensions(info->extensions, info->nextensions,\n&ext_size, &ext_nlines))\nreturn(XpmNoMemory);\nheader_nlines = 1 + image->ncolors;\nif(header_nlines <= image->ncolors ||\nheader_nlines >= UINT_MAX / sizeof(char *))\nreturn(XpmNoMemory);\nheader_size = sizeof(char *) * header_nlines;\nif (header_size >= UINT_MAX / sizeof(char *))\nreturn (XpmNoMemory);\nheader = (char **) XpmCalloc(header_size, sizeof(char *));\nif (!header)\nreturn (XpmNoMemory);\ns = buf;\n#ifndef VOID_SPRINTF\ns +=\n#endif\nsprintf(s, \"%d %d %d %d\", image->width, image->height,\nimage->ncolors, image->cpp);\n#ifdef VOID_SPRINTF\ns += strlen(s);\n#endif\nif (info && (info->valuemask & XpmHotspot)) {\n#ifndef VOID_SPRINTF\ns +=\n#endif\nsprintf(s, \" %d %d\", info->x_hotspot, info->y_hotspot);\n#ifdef VOID_SPRINTF\ns += strlen(s);\n#endif\n}\nif (extensions) {\nstrcpy(s, \" XPMEXT\");\ns += 7;\n}\nl = s - buf + 1;\n*header = (char *) XpmMalloc(l);\nif (!*header)\nRETURN(XpmNoMemory);\nheader_size += l;\nstrcpy(*header, buf);\nErrorStatus = CreateColors(header + 1, &header_size,\nimage->colorTable, image->ncolors, image->cpp);\nif (ErrorStatus != XpmSuccess)\nRETURN(ErrorStatus);\noffset = image->width * image->cpp + 1;\nif(offset <= image->width || offset <= image->cpp)\nif(offset <= image->width || offset <= image->cpp)\nRETURN(XpmNoMemory);\nif (image->height > UINT_MAX - ext_nlines ||\nimage->height + ext_nlines >= UINT_MAX / sizeof(char *))\nRETURN(XpmNoMemory);\ndata_size = (image->height + ext_nlines) * sizeof(char *);\nRETURN(XpmNoMemory);\ndata_size += image->height * offset;\nRETURN(XpmNoMemory);\ndata_size += image->height * offset;\nif (header_size > UINT_MAX - ext_size ||\nheader_size + ext_size >= (UINT_MAX - data_size) )\nRETURN(XpmNoMemory);\ndata_size += header_size + ext_size;\ndata_nlines = header_nlines + image->height + ext_nlines;\n*data = (char *) (data + data_nlines);\nn = image->ncolors;\nfor (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {\nstrcpy(*sptr, *sptr2);\n*(sptr + 1) = *sptr + strlen(*sptr2) + 1;\n}\ndata[header_nlines] = (char *) data + header_size\n+ (image->height + ext_nlines) * sizeof(char *);\nCreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,\nimage->cpp, image->data, image->colorTable);\nif (extensions)\nCreateExtensions(data + header_nlines + image->height - 1,\ndata_size - header_nlines - image->height + 1, offset,\ninfo->extensions, info->nextensions,\next_nlines);\n*data_return = data;\nErrorStatus = XpmSuccess;\nexit:\nif (header) {\nfor (l = 0; l < header_nlines; l++)\nif (header[l])\nXpmFree(header[l]);\nXpmFree(header);\n}\nreturn(ErrorStatus);\n}", "label": 0}
{"index": 174997, "code": "static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\njs_Value v;\nint i;\njsR_savescope(J, scope);\nif (n > F->numparams) {\njs_pop(J, F->numparams - n);\nn = F->numparams;\n}\nfor (i = n; i < F->varlen; ++i)\njs_pushundefined(J);\njsR_run(J, F);\nv = *stackidx(J, -1);\nTOP = --BOT;\njs_pushvalue(J, v);\njsR_restorescope(J);\n}", "contrast": "static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\njs_Value v;\nint i;\njsR_savescope(J, scope);\nif (n > F->numparams) {\njs_pop(J, n - F->numparams);\nn = F->numparams;\n}\nfor (i = n; i < F->varlen; ++i)\njs_pushundefined(J);\njsR_run(J, F);\nv = *stackidx(J, -1);\nTOP = --BOT;\njs_pushvalue(J, v);\njsR_restorescope(J);\n}", "label": 0}
{"index": 174998, "code": "static int dpcm_decode_frame(AVCodecContext *avctx, void *data,\nint *got_frame_ptr, AVPacket *avpkt)\n{\nconst uint8_t *buf = avpkt->data;\nint buf_size = avpkt->size;\nconst uint8_t *buf_end = buf + buf_size;\nDPCMContext *s = avctx->priv_data;\nint out = 0, ret;\nint predictor[2];\nint ch = 0;\nint stereo = s->channels - 1;\nint16_t *output_samples;\nswitch(avctx->codec->id) {\ncase CODEC_ID_ROQ_DPCM:\ncase CODEC_ID_XAN_DPCM:\nout = buf_size - 2 * s->channels;\nbreak;\ncase CODEC_ID_SOL_DPCM:\nif (avctx->codec_tag != 3)\nout = buf_size * 2;\nelse\nout = buf_size;\nbreak;\n}\nif (out <= 0) {\nav_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\nreturn AVERROR(EINVAL);\n}\ns->frame.nb_samples = out / s->channels;\nif ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\nreturn ret;\n}\noutput_samples = (int16_t *)s->frame.data[0];\nswitch(avctx->codec->id) {\ncase CODEC_ID_ROQ_DPCM:\nbuf += 6;\nif (stereo) {\npredictor[1] = (int16_t)(bytestream_get_byte(&buf) << 8);\npredictor[0] = (int16_t)(bytestream_get_byte(&buf) << 8);\n} else {\npredictor[0] = (int16_t)bytestream_get_le16(&buf);\n}\nwhile (buf < buf_end) {\npredictor[ch] += s->roq_square_array[*buf++];\npredictor[ch]  = av_clip_int16(predictor[ch]);\n*output_samples++ = predictor[ch];\nch ^= stereo;\n}\nbreak;\ncase CODEC_ID_INTERPLAY_DPCM:\nbuf += 6;\nfor (ch = 0; ch < s->channels; ch++) {\npredictor[ch] = (int16_t)bytestream_get_le16(&buf);\n*output_samples++ = predictor[ch];\n}\nch = 0;\nwhile (buf < buf_end) {\npredictor[ch] += interplay_delta_table[*buf++];\npredictor[ch]  = av_clip_int16(predictor[ch]);\n*output_samples++ = predictor[ch];\nch ^= stereo;\n}\nbreak;\ncase CODEC_ID_XAN_DPCM:\n{\nint shift[2] = { 4, 4 };\nfor (ch = 0; ch < s->channels; ch++)\npredictor[ch] = (int16_t)bytestream_get_le16(&buf);\nch = 0;\nwhile (buf < buf_end) {\nuint8_t n = *buf++;\nint16_t diff = (n & 0xFC) << 8;\nif ((n & 0x03) == 3)\nshift[ch]++;\nelse\nshift[ch] -= (2 * (n & 3));\nif (shift[ch] < 0)\nshift[ch] = 0;\ndiff >>= shift[ch];\npredictor[ch] += diff;\npredictor[ch] = av_clip_int16(predictor[ch]);\n*output_samples++ = predictor[ch];\nch ^= stereo;\n}\nbreak;\n}\ncase CODEC_ID_SOL_DPCM:\nif (avctx->codec_tag != 3) {\nuint8_t *output_samples_u8 = s->frame.data[0];\nwhile (buf < buf_end) {\nuint8_t n = *buf++;\ns->sample[0] += s->sol_table[n >> 4];\ns->sample[0]  = av_clip_uint8(s->sample[0]);\n*output_samples_u8++ = s->sample[0];\ns->sample[stereo] += s->sol_table[n & 0x0F];\ns->sample[stereo]  = av_clip_uint8(s->sample[stereo]);\n*output_samples_u8++ = s->sample[stereo];\n}\n} else {\nwhile (buf < buf_end) {\nuint8_t n = *buf++;\nif (n & 0x80) s->sample[ch] -= sol_table_16[n & 0x7F];\nelse          s->sample[ch] += sol_table_16[n & 0x7F];\ns->sample[ch] = av_clip_int16(s->sample[ch]);\n*output_samples++ = s->sample[ch];\nch ^= stereo;\n}\n}\nbreak;\n}\n*got_frame_ptr   = 1;\n*(AVFrame *)data = s->frame;\nreturn buf_size;\n}", "contrast": "static int dpcm_decode_frame(AVCodecContext *avctx, void *data,\nint *got_frame_ptr, AVPacket *avpkt)\n{\nconst uint8_t *buf = avpkt->data;\nint buf_size = avpkt->size;\nconst uint8_t *buf_end = buf + buf_size;\nDPCMContext *s = avctx->priv_data;\nint out = 0, ret;\nint predictor[2];\nint ch = 0;\nint stereo = s->channels - 1;\nint16_t *output_samples;\nif (stereo && (buf_size & 1)) {\nbuf_size--;\nbuf_end--;\n}\nswitch(avctx->codec->id) {\ncase CODEC_ID_ROQ_DPCM:\ncase CODEC_ID_XAN_DPCM:\nout = buf_size - 2 * s->channels;\nbreak;\ncase CODEC_ID_SOL_DPCM:\nif (avctx->codec_tag != 3)\nout = buf_size * 2;\nelse\nout = buf_size;\nbreak;\n}\nif (out <= 0) {\nav_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\nreturn AVERROR(EINVAL);\n}\ns->frame.nb_samples = out / s->channels;\nif ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\nreturn ret;\n}\noutput_samples = (int16_t *)s->frame.data[0];\nswitch(avctx->codec->id) {\ncase CODEC_ID_ROQ_DPCM:\nbuf += 6;\nif (stereo) {\npredictor[1] = (int16_t)(bytestream_get_byte(&buf) << 8);\npredictor[0] = (int16_t)(bytestream_get_byte(&buf) << 8);\n} else {\npredictor[0] = (int16_t)bytestream_get_le16(&buf);\n}\nwhile (buf < buf_end) {\npredictor[ch] += s->roq_square_array[*buf++];\npredictor[ch]  = av_clip_int16(predictor[ch]);\n*output_samples++ = predictor[ch];\nch ^= stereo;\n}\nbreak;\ncase CODEC_ID_INTERPLAY_DPCM:\nbuf += 6;\nfor (ch = 0; ch < s->channels; ch++) {\npredictor[ch] = (int16_t)bytestream_get_le16(&buf);\n*output_samples++ = predictor[ch];\n}\nch = 0;\nwhile (buf < buf_end) {\npredictor[ch] += interplay_delta_table[*buf++];\npredictor[ch]  = av_clip_int16(predictor[ch]);\n*output_samples++ = predictor[ch];\nch ^= stereo;\n}\nbreak;\ncase CODEC_ID_XAN_DPCM:\n{\nint shift[2] = { 4, 4 };\nfor (ch = 0; ch < s->channels; ch++)\npredictor[ch] = (int16_t)bytestream_get_le16(&buf);\nch = 0;\nwhile (buf < buf_end) {\nuint8_t n = *buf++;\nint16_t diff = (n & 0xFC) << 8;\nif ((n & 0x03) == 3)\nshift[ch]++;\nelse\nshift[ch] -= (2 * (n & 3));\nif (shift[ch] < 0)\nshift[ch] = 0;\ndiff >>= shift[ch];\npredictor[ch] += diff;\npredictor[ch] = av_clip_int16(predictor[ch]);\n*output_samples++ = predictor[ch];\nch ^= stereo;\n}\nbreak;\n}\ncase CODEC_ID_SOL_DPCM:\nif (avctx->codec_tag != 3) {\nuint8_t *output_samples_u8 = s->frame.data[0];\nwhile (buf < buf_end) {\nuint8_t n = *buf++;\ns->sample[0] += s->sol_table[n >> 4];\ns->sample[0]  = av_clip_uint8(s->sample[0]);\n*output_samples_u8++ = s->sample[0];\ns->sample[stereo] += s->sol_table[n & 0x0F];\ns->sample[stereo]  = av_clip_uint8(s->sample[stereo]);\n*output_samples_u8++ = s->sample[stereo];\n}\n} else {\nwhile (buf < buf_end) {\nuint8_t n = *buf++;\nif (n & 0x80) s->sample[ch] -= sol_table_16[n & 0x7F];\nelse          s->sample[ch] += sol_table_16[n & 0x7F];\ns->sample[ch] = av_clip_int16(s->sample[ch]);\n*output_samples++ = s->sample[ch];\nch ^= stereo;\n}\n}\nbreak;\n}\n*got_frame_ptr   = 1;\n*(AVFrame *)data = s->frame;\nreturn buf_size;\n}", "label": 0}
{"index": 175009, "code": "static int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\n{\nconst unsigned char *p, *pm;\nint pklen, pmlen;\nint ptype;\nvoid *pval;\nASN1_STRING *pstr;\nX509_ALGOR *palg;\nASN1_INTEGER *privkey = NULL;\nBN_CTX *ctx = NULL;\nSTACK_OF(ASN1_TYPE) *ndsa = NULL;\nDSA *dsa = NULL;\nif (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))\nreturn 0;\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\nif (*p == (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {\nASN1_TYPE *t1, *t2;\nif (!(ndsa = d2i_ASN1_SEQUENCE_ANY(NULL, &p, pklen)))\ngoto decerr;\nif (sk_ASN1_TYPE_num(ndsa) != 2)\ngoto decerr;\nt1 = sk_ASN1_TYPE_value(ndsa, 0);\nt2 = sk_ASN1_TYPE_value(ndsa, 1);\nif (t1->type == V_ASN1_SEQUENCE) {\np8->broken = PKCS8_EMBEDDED_PARAM;\npval = t1->value.ptr;\n} else if (ptype == V_ASN1_SEQUENCE)\np8->broken = PKCS8_NS_DB;\nelse\ngoto decerr;\nif (t2->type != V_ASN1_INTEGER)\ngoto decerr;\nprivkey = t2->value.integer;\n} else {\nconst unsigned char *q = p;\nif (!(privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)))\ngoto decerr;\nif (privkey->type == V_ASN1_NEG_INTEGER) {\np8->broken = PKCS8_NEG_PRIVKEY;\nASN1_STRING_clear_free(privkey);\nif (!(privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)))\ngoto decerr;\n}\nif (ptype != V_ASN1_SEQUENCE)\ngoto decerr;\n}\npstr = pval;\npm = pstr->data;\npmlen = pstr->length;\nif (!(dsa = d2i_DSAparams(NULL, &pm, pmlen)))\ngoto decerr;\nif (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\ngoto dsaerr;\n}\nif (!(dsa->pub_key = BN_new())) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\ngoto dsaerr;\n}\nif (!(ctx = BN_CTX_new())) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\ngoto dsaerr;\n}\nif (!BN_mod_exp(dsa->pub_key, dsa->g, dsa->priv_key, dsa->p, ctx)) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\ngoto dsaerr;\n}\n}", "contrast": "static int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\n{\nconst unsigned char *p, *pm;\nint pklen, pmlen;\nint ptype;\nvoid *pval;\nASN1_STRING *pstr;\nX509_ALGOR *palg;\nASN1_INTEGER *privkey = NULL;\nBN_CTX *ctx = NULL;\nSTACK_OF(ASN1_TYPE) *ndsa = NULL;\nDSA *dsa = NULL;\nint ret = 0;\nif (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))\nreturn 0;\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\nif (*p == (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {\nASN1_TYPE *t1, *t2;\nif (!(ndsa = d2i_ASN1_SEQUENCE_ANY(NULL, &p, pklen)))\ngoto decerr;\nif (sk_ASN1_TYPE_num(ndsa) != 2)\ngoto decerr;\nt1 = sk_ASN1_TYPE_value(ndsa, 0);\nt2 = sk_ASN1_TYPE_value(ndsa, 1);\nif (t1->type == V_ASN1_SEQUENCE) {\np8->broken = PKCS8_EMBEDDED_PARAM;\npval = t1->value.ptr;\n} else if (ptype == V_ASN1_SEQUENCE)\np8->broken = PKCS8_NS_DB;\nelse\ngoto decerr;\nif (t2->type != V_ASN1_INTEGER)\ngoto decerr;\nprivkey = t2->value.integer;\n} else {\nconst unsigned char *q = p;\nif (!(privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)))\ngoto decerr;\nif (privkey->type == V_ASN1_NEG_INTEGER) {\np8->broken = PKCS8_NEG_PRIVKEY;\nASN1_STRING_clear_free(privkey);\nif (!(privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)))\ngoto decerr;\n}\nif (ptype != V_ASN1_SEQUENCE)\ngoto decerr;\n}\npstr = pval;\npm = pstr->data;\npmlen = pstr->length;\nif (!(dsa = d2i_DSAparams(NULL, &pm, pmlen)))\ngoto decerr;\nif (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\ngoto dsaerr;\n}\nif (!(dsa->pub_key = BN_new())) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\ngoto dsaerr;\n}\nif (!(ctx = BN_CTX_new())) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\ngoto dsaerr;\n}\nif (!BN_mod_exp(dsa->pub_key, dsa->g, dsa->priv_key, dsa->p, ctx)) {\nDSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\ngoto dsaerr;\n}\n}", "label": 0}
{"index": 175010, "code": "static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\nunsigned char *buf, int idx,\nint width)\n{\nsize_t i, j;\nif (top > b->top)\ntop = b->top;\nfor (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\nbuf[j] = ((unsigned char *)b->d)[i];\n}\nreturn 1;\nunsigned char *buf, int idx,\nstatic int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\nunsigned char *buf, int idx,\nint width)\n{\nsize_t i, j;\nif (bn_wexpand(b, top) == NULL)\nreturn 0;\nfor (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\n((unsigned char *)b->d)[i] = buf[j];\n}\nb->top = top;\nif (!BN_is_odd(m)) {\nBNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\nreturn (0);\n}\ntop = m->top;\nbits = BN_num_bits(p);\nif (bits == 0) {\nif (BN_is_one(m)) {\nret = 1;\nBN_zero(rr);\n} else {\nret = BN_one(rr);\n}\nreturn ret;\n}\nBN_CTX_start(ctx);\nif (in_mont != NULL)\nmont = in_mont;\nelse {\nif ((mont = BN_MONT_CTX_new()) == NULL)\ngoto err;\nif (!BN_MONT_CTX_set(mont, m, ctx))\ngoto err;\n}\n#ifdef RSAZ_ENABLED\nif ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n&& rsaz_avx2_eligible()) {\nif (NULL == bn_wexpand(rr, 16))\ngoto err;\nRSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\nmont->n0[0]);\nrr->top = 16;\nrr->neg = 0;\nbn_correct_top(rr);\nret = 1;\ngoto err;\n} else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\nif (NULL == bn_wexpand(rr, 8))\ngoto err;\nRSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\nrr->top = 8;\nrr->neg = 0;\nbn_correct_top(rr);\nret = 1;\ngoto err;\n}\n#endif\nwindow = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\nif (window >= 5 && (top & 15) == 0 && top <= 64 &&\n(OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n(CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\nwindow = 5;\nelse\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\nif (window >= 5) {\nwindow = 5;\nif ((top & 7) == 0)\npowerbufLen += 2 * top * sizeof(m->d[0]);\n}\n#endif\n(void)0;\nnumPowers = 1 << window;\npowerbufLen += sizeof(m->d[0]) * (top * numPowers +\n((2 * top) >\nnumPowers ? (2 * top) : numPowers));\n#ifdef alloca\nif (powerbufLen < 3072)\npowerbufFree =\nalloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\nelse\n#endif\nif ((powerbufFree =\n(unsigned char *)OPENSSL_malloc(powerbufLen +\nMOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n== NULL)\ngoto err;\npowerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\nmemset(powerbuf, 0, powerbufLen);\n#ifdef alloca\nif (powerbufLen < 3072)\npowerbufFree = NULL;\n#endif\ntmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\nam.d = tmp.d + top;\ntmp.top = am.top = 0;\ntmp.dmax = am.dmax = top;\ntmp.neg = am.neg = 0;\ntmp.flags = am.flags = BN_FLG_STATIC_DATA;\n#if 1\nif (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\ntmp.d[0] = (0 - m->d[0]) & BN_MASK2;\nfor (i = 1; i < top; i++)\ntmp.d[i] = (~m->d[i]) & BN_MASK2;\ntmp.top = top;\n} else\n#endif\nif (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\ngoto err;\nif (a->neg || BN_ucmp(a, m) >= 0) {\nif (!BN_mod(&am, a, m, ctx))\ngoto err;\nif (!BN_to_montgomery(&am, &am, mont, ctx))\ngoto err;\n} else if (!BN_to_montgomery(&am, a, mont, ctx))\ngoto err;\n#if defined(SPARC_T4_MONT)\nif (t4) {\ntypedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nstatic const bn_pwr5_mont_f pwr5_funcs[4] = {\nbn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\nbn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n};\nbn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\ntypedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nint bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\nconst BN_ULONG *np, const BN_ULONG *n0);\nint bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nint bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nint bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nstatic const bn_mul_mont_f mul_funcs[4] = {\nbn_mul_mont_t4_8, bn_mul_mont_t4_16,\nbn_mul_mont_t4_24, bn_mul_mont_t4_32\n};\nbn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\nvoid bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0, int num);\nvoid bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0, int num);\nvoid bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *table, const BN_ULONG *np,\nconst BN_ULONG *n0, int num, int power);\nvoid bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\nvoid *table, size_t power);\nvoid bn_gather5_t4(BN_ULONG *out, size_t num,\nvoid *table, size_t power);\nvoid bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\nBN_ULONG *np = mont->N.d, *n0 = mont->n0;\nint stride = 5 * (6 - (top / 16 - 1));\nfor (i = am.top; i < top; i++)\nam.d[i] = 0;\nfor (i = tmp.top; i < top; i++)\ntmp.d[i] = 0;\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\nbn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\nif (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n!(*mul_worker) (tmp.d, am.d, am.d, np, n0))\nbn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\nfor (i = 3; i < 32; i++) {\nif (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\nbn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n}\nnp = alloca(top * sizeof(BN_ULONG));\ntop /= 2;\nbn_flip_t4(np, mont->N.d, top);\nbits--;\nfor (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nbn_gather5_t4(tmp.d, top, powerbuf, wvalue);\nwhile (bits >= 0) {\nif (bits < stride)\nstride = bits + 1;\nbits -= stride;\nwvalue = bn_get_bits(p, bits + 1);\nif ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\ncontinue;\nif ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\ncontinue;\nbits += stride - 5;\nwvalue >>= stride - 5;\nwvalue &= 31;\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\nwvalue);\n}\nbn_flip_t4(tmp.d, tmp.d, top);\ntop *= 2;\ntmp.top = top;\nbn_correct_top(&tmp);\nOPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n} else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\nif (window == 5 && top > 1) {\nvoid bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *table, const BN_ULONG *np,\nconst BN_ULONG *n0, int num, int power);\nvoid bn_scatter5(const BN_ULONG *inp, size_t num,\nvoid *table, size_t power);\nvoid bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\nvoid bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *table, const BN_ULONG *np,\nconst BN_ULONG *n0, int num, int power);\nint bn_get_bits5(const BN_ULONG *ap, int off);\nint bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\nconst BN_ULONG *not_used, const BN_ULONG *np,\nconst BN_ULONG *n0, int num);\nBN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\nfor (i = am.top; i < top; i++)\nam.d[i] = 0;\nfor (i = tmp.top; i < top; i++)\ntmp.d[i] = 0;\nif (top & 7)\nnp2 = np;\nelse\nfor (np2 = am.d + top, i = 0; i < top; i++)\nnp2[2 * i] = np[i];\nbn_scatter5(tmp.d, top, powerbuf, 0);\nbn_scatter5(am.d, am.top, powerbuf, 1);\nbn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, 2);\n# if 0\nfor (i = 3; i < 32; i++) {\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\n}\n# else\nfor (i = 4; i < 32; i *= 2) {\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, i);\n}\nfor (i = 3; i < 8; i += 2) {\nint j;\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\nfor (j = 2 * i; j < 32; j *= 2) {\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, j);\n}\n}\nfor (; i < 16; i += 2) {\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, 2 * i);\n}\nfor (; i < 32; i += 2) {\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\n}\n# endif\nbits--;\nfor (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nbn_gather5(tmp.d, top, powerbuf, wvalue);\nif (top & 7)\nwhile (bits >= 0) {\nfor (wvalue = 0, i = 0; i < 5; i++, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\nwvalue);\n} else {\nwhile (bits >= 0) {\nwvalue = bn_get_bits5(p->d, bits - 4);\nbits -= 5;\nbn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\n}\n}\nret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\ntmp.top = top;\nbn_correct_top(&tmp);\nif (ret) {\nif (!BN_copy(rr, &tmp))\nret = 0;\ngoto err;\n}\n} else\n#endif\n{\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\ngoto err;\nif (window > 1) {\nif (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF\n(&tmp, top, powerbuf, 2, numPowers))\ngoto err;\nfor (i = 3; i < numPowers; i++) {\nif (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF\n(&tmp, top, powerbuf, i, numPowers))\ngoto err;\n}\n}\nbits--;\nfor (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n(&tmp, top, powerbuf, wvalue, numPowers))\ngoto err;\nif (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF\n(&tmp, top, powerbuf, i, numPowers))\ngoto err;\n}\n}\nfor (i = 1; i < top; i++)\nbits--;\nfor (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n(&tmp, top, powerbuf, wvalue, numPowers))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n(&am, top, powerbuf, wvalue, numPowers))\ngoto err;\n#define BN_MOD_MUL_WORD(r, w, m) \\\n(BN_mul_word(r, (w)) && \\\n(   \\\n(BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n(BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\nif (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\nreturn -1;\n}\nbn_check_top(p);\nbn_check_top(m);\nif (!BN_is_odd(m)) {\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\nreturn (0);\n}\nif (m->top == 1)\na %= m->d[0];\nbits = BN_num_bits(p);\nif (bits == 0) {\nif (BN_is_one(m)) {\nret = 1;\nBN_zero(rr);\n} else {\nret = BN_one(rr);\n}\nreturn ret;\n}\nif (a == 0) {\nBN_zero(rr);\nret = 1;\nreturn ret;\n}\nBN_CTX_start(ctx);\nd = BN_CTX_get(ctx);\nr = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nif (d == NULL || r == NULL || t == NULL)\ngoto err;\nif (in_mont != NULL)\nmont = in_mont;\nelse {\nif ((mont = BN_MONT_CTX_new()) == NULL)\ngoto err;\nif (!BN_MONT_CTX_set(mont, m, ctx))\ngoto err;\n}\nr_is_one = 1;\nw = a;\nfor (b = bits - 2; b >= 0; b--) {\nnext_w = w * w;\nif ((next_w / w) != w) {\nif (r_is_one) {\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\ngoto err;\nr_is_one = 0;\n} else {\nif (!BN_MOD_MUL_WORD(r, w, m))\ngoto err;\n}\nnext_w = 1;\n}\nw = next_w;\nif (!r_is_one) {\nif (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\ngoto err;\n}\nif (BN_is_bit_set(p, b)) {\nnext_w = w * a;\nif ((next_w / a) != w) {\nif (r_is_one) {\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\ngoto err;\nr_is_one = 0;\n} else {\nif (!BN_MOD_MUL_WORD(r, w, m))\ngoto err;\n}\nnext_w = a;\n}\nw = next_w;\n}\n}\nif (w != 1) {\nif (r_is_one) {\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\ngoto err;\nr_is_one = 0;\n} else {\nif (!BN_MOD_MUL_WORD(r, w, m))\ngoto err;\n}\n}\nif (r_is_one) {\nif (!BN_one(rr))\ngoto err;\n} else {\nif (!BN_from_montgomery(rr, r, mont, ctx))\ngoto err;\n}\nret = 1;\nerr:\nif ((in_mont == NULL) && (mont != NULL))\nBN_MONT_CTX_free(mont);\nBN_CTX_end(ctx);\nbn_check_top(rr);\nreturn (ret);\n}", "contrast": "static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\nunsigned char *buf, int idx,\nint window)\n{\nint i, j;\nint width = 1 << window;\nBN_ULONG *table = (BN_ULONG *)buf;\nif (top > b->top)\ntop = b->top;\nfor (i = 0, j = idx; i < top; i++, j += width) {\ntable[j] = b->d[i];\n}\nreturn 1;\nunsigned char *buf, int idx,\nstatic int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\nunsigned char *buf, int idx,\nint window)\n{\nint i, j;\nint width = 1 << window;\nvolatile BN_ULONG *table = (volatile BN_ULONG *)buf;\nif (bn_wexpand(b, top) == NULL)\nreturn 0;\nif (window <= 3) {\nfor (i = 0; i < top; i++, table += width) {\nBN_ULONG acc = 0;\nfor (j = 0; j < width; j++) {\nacc |= table[j] &\n((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));\n}\nb->d[i] = acc;\n}\n} else {\nint xstride = 1 << (window - 2);\nBN_ULONG y0, y1, y2, y3;\ni = idx >> (window - 2);\nidx &= xstride - 1;\ny0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);\ny1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);\ny2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);\ny3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);\nfor (i = 0; i < top; i++, table += width) {\nBN_ULONG acc = 0;\nfor (j = 0; j < xstride; j++) {\nacc |= ( (table[j + 0 * xstride] & y0) |\n(table[j + 1 * xstride] & y1) |\n(table[j + 2 * xstride] & y2) |\n(table[j + 3 * xstride] & y3) )\n& ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));\n}\nb->d[i] = acc;\n}\n}\nb->top = top;\nif (!BN_is_odd(m)) {\nBNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\nreturn (0);\n}\ntop = m->top;\nbits = BN_num_bits(p);\nif (bits == 0) {\nif (BN_is_one(m)) {\nret = 1;\nBN_zero(rr);\n} else {\nret = BN_one(rr);\n}\nreturn ret;\n}\nBN_CTX_start(ctx);\nif (in_mont != NULL)\nmont = in_mont;\nelse {\nif ((mont = BN_MONT_CTX_new()) == NULL)\ngoto err;\nif (!BN_MONT_CTX_set(mont, m, ctx))\ngoto err;\n}\n#ifdef RSAZ_ENABLED\nif ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n&& rsaz_avx2_eligible()) {\nif (NULL == bn_wexpand(rr, 16))\ngoto err;\nRSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\nmont->n0[0]);\nrr->top = 16;\nrr->neg = 0;\nbn_correct_top(rr);\nret = 1;\ngoto err;\n} else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\nif (NULL == bn_wexpand(rr, 8))\ngoto err;\nRSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\nrr->top = 8;\nrr->neg = 0;\nbn_correct_top(rr);\nret = 1;\ngoto err;\n}\n#endif\nwindow = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\nif (window >= 5 && (top & 15) == 0 && top <= 64 &&\n(OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n(CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\nwindow = 5;\nelse\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\nif (window >= 5) {\nwindow = 5;\nif ((top & 7) == 0)\npowerbufLen += 2 * top * sizeof(m->d[0]);\n}\n#endif\n(void)0;\nnumPowers = 1 << window;\npowerbufLen += sizeof(m->d[0]) * (top * numPowers +\n((2 * top) >\nnumPowers ? (2 * top) : numPowers));\n#ifdef alloca\nif (powerbufLen < 3072)\npowerbufFree =\nalloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\nelse\n#endif\nif ((powerbufFree =\n(unsigned char *)OPENSSL_malloc(powerbufLen +\nMOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n== NULL)\ngoto err;\npowerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\nmemset(powerbuf, 0, powerbufLen);\n#ifdef alloca\nif (powerbufLen < 3072)\npowerbufFree = NULL;\n#endif\ntmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\nam.d = tmp.d + top;\ntmp.top = am.top = 0;\ntmp.dmax = am.dmax = top;\ntmp.neg = am.neg = 0;\ntmp.flags = am.flags = BN_FLG_STATIC_DATA;\n#if 1\nif (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\ntmp.d[0] = (0 - m->d[0]) & BN_MASK2;\nfor (i = 1; i < top; i++)\ntmp.d[i] = (~m->d[i]) & BN_MASK2;\ntmp.top = top;\n} else\n#endif\nif (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\ngoto err;\nif (a->neg || BN_ucmp(a, m) >= 0) {\nif (!BN_mod(&am, a, m, ctx))\ngoto err;\nif (!BN_to_montgomery(&am, &am, mont, ctx))\ngoto err;\n} else if (!BN_to_montgomery(&am, a, mont, ctx))\ngoto err;\n#if defined(SPARC_T4_MONT)\nif (t4) {\ntypedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nint bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\nconst BN_ULONG *n0, const void *table,\nint power, int bits);\nstatic const bn_pwr5_mont_f pwr5_funcs[4] = {\nbn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\nbn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n};\nbn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\ntypedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nint bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\nconst BN_ULONG *np, const BN_ULONG *n0);\nint bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nint bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nint bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0);\nstatic const bn_mul_mont_f mul_funcs[4] = {\nbn_mul_mont_t4_8, bn_mul_mont_t4_16,\nbn_mul_mont_t4_24, bn_mul_mont_t4_32\n};\nbn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\nvoid bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0, int num);\nvoid bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *bp, const BN_ULONG *np,\nconst BN_ULONG *n0, int num);\nvoid bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *table, const BN_ULONG *np,\nconst BN_ULONG *n0, int num, int power);\nvoid bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\nvoid *table, size_t power);\nvoid bn_gather5_t4(BN_ULONG *out, size_t num,\nvoid *table, size_t power);\nvoid bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\nBN_ULONG *np = mont->N.d, *n0 = mont->n0;\nint stride = 5 * (6 - (top / 16 - 1));\nfor (i = am.top; i < top; i++)\nam.d[i] = 0;\nfor (i = tmp.top; i < top; i++)\ntmp.d[i] = 0;\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\nbn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\nif (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n!(*mul_worker) (tmp.d, am.d, am.d, np, n0))\nbn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\nfor (i = 3; i < 32; i++) {\nif (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\nbn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n}\nnp = alloca(top * sizeof(BN_ULONG));\ntop /= 2;\nbn_flip_t4(np, mont->N.d, top);\nbits--;\nfor (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nbn_gather5_t4(tmp.d, top, powerbuf, wvalue);\nwhile (bits >= 0) {\nif (bits < stride)\nstride = bits + 1;\nbits -= stride;\nwvalue = bn_get_bits(p, bits + 1);\nif ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\ncontinue;\nif ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\ncontinue;\nbits += stride - 5;\nwvalue >>= stride - 5;\nwvalue &= 31;\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\nwvalue);\n}\nbn_flip_t4(tmp.d, tmp.d, top);\ntop *= 2;\ntmp.top = top;\nbn_correct_top(&tmp);\nOPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n} else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\nif (window == 5 && top > 1) {\nvoid bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *table, const BN_ULONG *np,\nconst BN_ULONG *n0, int num, int power);\nvoid bn_scatter5(const BN_ULONG *inp, size_t num,\nvoid *table, size_t power);\nvoid bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\nvoid bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\nconst void *table, const BN_ULONG *np,\nconst BN_ULONG *n0, int num, int power);\nint bn_get_bits5(const BN_ULONG *ap, int off);\nint bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\nconst BN_ULONG *not_used, const BN_ULONG *np,\nconst BN_ULONG *n0, int num);\nBN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\nfor (i = am.top; i < top; i++)\nam.d[i] = 0;\nfor (i = tmp.top; i < top; i++)\ntmp.d[i] = 0;\nif (top & 7)\nnp2 = np;\nelse\nfor (np2 = am.d + top, i = 0; i < top; i++)\nnp2[2 * i] = np[i];\nbn_scatter5(tmp.d, top, powerbuf, 0);\nbn_scatter5(am.d, am.top, powerbuf, 1);\nbn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, 2);\n# if 0\nfor (i = 3; i < 32; i++) {\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\n}\n# else\nfor (i = 4; i < 32; i *= 2) {\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, i);\n}\nfor (i = 3; i < 8; i += 2) {\nint j;\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\nfor (j = 2 * i; j < 32; j *= 2) {\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, j);\n}\n}\nfor (; i < 16; i += 2) {\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_scatter5(tmp.d, top, powerbuf, 2 * i);\n}\nfor (; i < 32; i += 2) {\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\nbn_scatter5(tmp.d, top, powerbuf, i);\n}\n# endif\nbits--;\nfor (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nbn_gather5(tmp.d, top, powerbuf, wvalue);\nif (top & 7)\nwhile (bits >= 0) {\nfor (wvalue = 0, i = 0; i < 5; i++, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\nbn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\nwvalue);\n} else {\nwhile (bits >= 0) {\nwvalue = bn_get_bits5(p->d, bits - 4);\nbits -= 5;\nbn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\n}\n}\nret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\ntmp.top = top;\nbn_correct_top(&tmp);\nif (ret) {\nif (!BN_copy(rr, &tmp))\nret = 0;\ngoto err;\n}\n} else\n#endif\n{\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\ngoto err;\nif (window > 1) {\nif (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF\n(&tmp, top, powerbuf, 2, numPowers))\ngoto err;\nfor (i = 3; i < numPowers; i++) {\nif (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF\n(&tmp, top, powerbuf, i, numPowers))\ngoto err;\n}\n}\nbits--;\nfor (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n(&tmp, top, powerbuf, wvalue, numPowers))\ngoto err;\nif (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,\nwindow))\ngoto err;\n}\n}\nfor (i = 1; i < top; i++)\nbits--;\nfor (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,\nwindow))\ngoto err;\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,\nwindow))\ngoto err;\n#define BN_MOD_MUL_WORD(r, w, m) \\\n(BN_mul_word(r, (w)) && \\\n(   \\\n(BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n(BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\nif (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\nreturn -1;\n}\nbn_check_top(p);\nbn_check_top(m);\nif (!BN_is_odd(m)) {\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\nreturn (0);\n}\nif (m->top == 1)\na %= m->d[0];\nbits = BN_num_bits(p);\nif (bits == 0) {\nif (BN_is_one(m)) {\nret = 1;\nBN_zero(rr);\n} else {\nret = BN_one(rr);\n}\nreturn ret;\n}\nif (a == 0) {\nBN_zero(rr);\nret = 1;\nreturn ret;\n}\nBN_CTX_start(ctx);\nd = BN_CTX_get(ctx);\nr = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nif (d == NULL || r == NULL || t == NULL)\ngoto err;\nif (in_mont != NULL)\nmont = in_mont;\nelse {\nif ((mont = BN_MONT_CTX_new()) == NULL)\ngoto err;\nif (!BN_MONT_CTX_set(mont, m, ctx))\ngoto err;\n}\nr_is_one = 1;\nw = a;\nfor (b = bits - 2; b >= 0; b--) {\nnext_w = w * w;\nif ((next_w / w) != w) {\nif (r_is_one) {\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\ngoto err;\nr_is_one = 0;\n} else {\nif (!BN_MOD_MUL_WORD(r, w, m))\ngoto err;\n}\nnext_w = 1;\n}\nw = next_w;\nif (!r_is_one) {\nif (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\ngoto err;\n}\nif (BN_is_bit_set(p, b)) {\nnext_w = w * a;\nif ((next_w / a) != w) {\nif (r_is_one) {\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\ngoto err;\nr_is_one = 0;\n} else {\nif (!BN_MOD_MUL_WORD(r, w, m))\ngoto err;\n}\nnext_w = a;\n}\nw = next_w;\n}\n}\nif (w != 1) {\nif (r_is_one) {\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\ngoto err;\nr_is_one = 0;\n} else {\nif (!BN_MOD_MUL_WORD(r, w, m))\ngoto err;\n}\n}\nif (r_is_one) {\nif (!BN_one(rr))\ngoto err;\n} else {\nif (!BN_from_montgomery(rr, r, mont, ctx))\ngoto err;\n}\nret = 1;\nerr:\nif ((in_mont == NULL) && (mont != NULL))\nBN_MONT_CTX_free(mont);\nBN_CTX_end(ctx);\nbn_check_top(rr);\nreturn (ret);\n}", "label": 0}
{"index": 175022, "code": "int gs_lib_ctx_init( gs_memory_t *mem )\n{\ngs_lib_ctx_t *pio = 0;\nif (mem == 0 || mem != mem->non_gc_memory)\nreturn_error(gs_error_Fatal);\n#ifndef GS_THREADSAFE\nmem_err_print = mem;\n#endif\nif (mem->gs_lib_ctx)\nreturn 0;\npio = (gs_lib_ctx_t*)gs_alloc_bytes_immovable(mem,\nsizeof(gs_lib_ctx_t),\n\"gs_lib_ctx_init\");\nif( pio == 0 )\nreturn -1;\nmemset(pio, 0, sizeof(*pio));\npio->memory               = mem;\ngs_lib_ctx_get_real_stdio(&pio->fstdin, &pio->fstdout, &pio->fstderr );\npio->stdin_is_interactive = true;\npio->gs_next_id           = 5;\nmem->gs_lib_ctx = pio;\npio->profiledir = NULL;\npio->profiledir_len = 0;\ngs_lib_ctx_set_icc_directory(mem, DEFAULT_DIR_ICC, strlen(DEFAULT_DIR_ICC));\nif (gs_lib_ctx_set_default_device_list(mem, gs_dev_defaults,\nstrlen(gs_dev_defaults)) < 0) {\ngs_free_object(mem, pio, \"gs_lib_ctx_init\");\nmem->gs_lib_ctx = NULL;\n}\nif (gscms_create(mem)) {\nFailure:\ngs_free_object(mem, mem->gs_lib_ctx->default_device_list,\n\"gs_lib_ctx_fin\");\ngs_free_object(mem, pio, \"gs_lib_ctx_init\");\nmem->gs_lib_ctx = NULL;\nreturn -1;\n}\nif (sjpxd_create(mem)) {\ngscms_destroy(mem);\ngoto Failure;\n}\ngp_get_realtime(pio->real_time_0);\npio->scanconverter = GS_SCANCONVERTER_DEFAULT;\nreturn 0;\n}", "contrast": "int gs_lib_ctx_init( gs_memory_t *mem )\n{\ngs_lib_ctx_t *pio = 0;\nif (mem == 0 || mem != mem->non_gc_memory)\nreturn_error(gs_error_Fatal);\n#ifndef GS_THREADSAFE\nmem_err_print = mem;\n#endif\nif (mem->gs_lib_ctx)\nreturn 0;\npio = (gs_lib_ctx_t*)gs_alloc_bytes_immovable(mem,\nsizeof(gs_lib_ctx_t),\n\"gs_lib_ctx_init\");\nif( pio == 0 )\nreturn -1;\nmemset(pio, 0, sizeof(*pio));\npio->memory               = mem;\ngs_lib_ctx_get_real_stdio(&pio->fstdin, &pio->fstdout, &pio->fstderr );\npio->stdin_is_interactive = true;\npio->gs_next_id           = 5;\nmem->gs_lib_ctx = pio;\npio->profiledir = NULL;\npio->profiledir_len = 0;\ngs_lib_ctx_set_icc_directory(mem, DEFAULT_DIR_ICC, strlen(DEFAULT_DIR_ICC));\nif (gs_lib_ctx_set_default_device_list(mem, gs_dev_defaults,\nstrlen(gs_dev_defaults)) < 0) {\ngs_free_object(mem, pio, \"gs_lib_ctx_init\");\nmem->gs_lib_ctx = NULL;\n}\nif (gscms_create(mem)) {\nFailure:\ngs_free_object(mem, mem->gs_lib_ctx->default_device_list,\n\"gs_lib_ctx_fin\");\ngs_free_object(mem, pio, \"gs_lib_ctx_init\");\nmem->gs_lib_ctx = NULL;\nreturn -1;\n}\nif (sjpxd_create(mem)) {\ngscms_destroy(mem);\ngoto Failure;\n}\npio->client_check_file_permission = NULL;\ngp_get_realtime(pio->real_time_0);\npio->scanconverter = GS_SCANCONVERTER_DEFAULT;\nreturn 0;\n}", "label": 0}
{"index": 175050, "code": "PHPAPI char *php_escape_shell_arg(char *str)\n{\nint x, y = 0, l = strlen(str);\nchar *cmd;\nsize_t estimate = (4 * l) + 3;\nTSRMLS_FETCH();\ncmd = safe_emalloc(4, l, 3);\n#ifdef PHP_WIN32\ncmd[y++] = '\"';\n#else\ncmd[y++] = '\\'';\n#endif\nfor (x = 0; x < l; x++) {\nint mb_len = php_mblen(str + x, (l - x));\nif (mb_len < 0) {\ncontinue;\n} else if (mb_len > 1) {\nmemcpy(cmd + y, str + x, mb_len);\ny += mb_len;\nx += mb_len - 1;\ncontinue;\n}\nswitch (str[x]) {\n#ifdef PHP_WIN32\ncase '\"':\ncase '%':\ncmd[y++] = ' ';\nbreak;\n#else\ncase '\\'':\ncmd[y++] = '\\'';\ncmd[y++] = '\\\\';\ncmd[y++] = '\\'';\n#endif\ndefault:\ncmd[y++] = str[x];\n}\n}\n#ifdef PHP_WIN32\ncmd[y++] = '\"';\n#else\ncmd[y++] = '\\'';\nreturn cmd;\n}", "contrast": "PHPAPI char *php_escape_shell_arg(char *str)\n{\nint x, y = 0, l = strlen(str);\nchar *cmd;\nsize_t estimate = (4 * l) + 3;\nTSRMLS_FETCH();\ncmd = safe_emalloc(4, l, 3);\n#ifdef PHP_WIN32\ncmd[y++] = '\"';\n#else\ncmd[y++] = '\\'';\n#endif\nfor (x = 0; x < l; x++) {\nint mb_len = php_mblen(str + x, (l - x));\nif (mb_len < 0) {\ncontinue;\n} else if (mb_len > 1) {\nmemcpy(cmd + y, str + x, mb_len);\ny += mb_len;\nx += mb_len - 1;\ncontinue;\n}\nswitch (str[x]) {\n#ifdef PHP_WIN32\ncase '\"':\ncase '%':\ncmd[y++] = ' ';\nbreak;\n#else\ncase '\\'':\ncmd[y++] = '\\'';\ncmd[y++] = '\\\\';\ncmd[y++] = '\\'';\n#endif\ndefault:\ncmd[y++] = str[x];\n}\n}\n#ifdef PHP_WIN32\nif (y > 0 && '\\\\' == cmd[y - 1]) {\nint k = 0, n = y - 1;\nfor (; n >= 0 && '\\\\' == cmd[n]; n--, k++);\nif (k % 2) {\ncmd[y++] = '\\\\';\n}\n}\ncmd[y++] = '\"';\n#else\ncmd[y++] = '\\'';\nreturn cmd;\n}", "label": 0}
{"index": 175059, "code": "PHP_FUNCTION(imageloadfont)\n{\nchar *file;\nint file_name, hdr_size = sizeof(gdFont) - sizeof(char *);\nint ind, body_size, n = 0, b, i, body_size_check;\ngdFontPtr font;\nphp_stream *stream;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &file, &file_name) == FAILURE) {\nreturn;\n}\nstream = php_stream_open_wrapper(file, \"rb\", IGNORE_PATH | IGNORE_URL_WIN | REPORT_ERRORS, NULL);\nif (stream == NULL) {\nRETURN_FALSE;\n}\nfont = (gdFontPtr) emalloc(sizeof(gdFont));\nb = 0;\nwhile (b < hdr_size && (n = php_stream_read(stream, (char*)&font[b], hdr_size - b))) {\nb += n;\n}\nif (!n) {\nefree(font);\nif (php_stream_eof(stream)) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"End of file while reading header\");\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error while reading header\");\n}\nphp_stream_close(stream);\nRETURN_FALSE;\n}\ni = php_stream_tell(stream);\nphp_stream_seek(stream, 0, SEEK_END);\nbody_size_check = php_stream_tell(stream) - hdr_size;\nphp_stream_seek(stream, i, SEEK_SET);\nbody_size = font->w * font->h * font->nchars;\nif (body_size != body_size_check) {\nfont->w = FLIPWORD(font->w);\nfont->h = FLIPWORD(font->h);\nfont->nchars = FLIPWORD(font->nchars);\nbody_size = font->w * font->h * font->nchars;\n}\nif (overflow2(font->nchars, font->h)) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error reading font, invalid font header\");\nefree(font);\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nif (overflow2(font->nchars * font->h, font->w )) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error reading font, invalid font header\");\nefree(font);\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nif (body_size != body_size_check) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error reading font\");\nefree(font);\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nfont->data = emalloc(body_size);\nb = 0;\nwhile (b < body_size && (n = php_stream_read(stream, &font->data[b], body_size - b))) {\nb += n;\n}\nif (!n) {\nefree(font->data);\nefree(font);\nif (php_stream_eof(stream)) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"End of file while reading body\");\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error while reading body\");\n}\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nphp_stream_close(stream);\nind = 5 + zend_list_insert(font, le_gd_font TSRMLS_CC);\nRETURN_LONG(ind);\n}", "contrast": "PHP_FUNCTION(imageloadfont)\n{\nchar *file;\nint file_name, hdr_size = sizeof(gdFont) - sizeof(char *);\nint ind, body_size, n = 0, b, i, body_size_check;\ngdFontPtr font;\nphp_stream *stream;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_name) == FAILURE) {\nreturn;\n}\nstream = php_stream_open_wrapper(file, \"rb\", IGNORE_PATH | IGNORE_URL_WIN | REPORT_ERRORS, NULL);\nif (stream == NULL) {\nRETURN_FALSE;\n}\nfont = (gdFontPtr) emalloc(sizeof(gdFont));\nb = 0;\nwhile (b < hdr_size && (n = php_stream_read(stream, (char*)&font[b], hdr_size - b))) {\nb += n;\n}\nif (!n) {\nefree(font);\nif (php_stream_eof(stream)) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"End of file while reading header\");\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error while reading header\");\n}\nphp_stream_close(stream);\nRETURN_FALSE;\n}\ni = php_stream_tell(stream);\nphp_stream_seek(stream, 0, SEEK_END);\nbody_size_check = php_stream_tell(stream) - hdr_size;\nphp_stream_seek(stream, i, SEEK_SET);\nbody_size = font->w * font->h * font->nchars;\nif (body_size != body_size_check) {\nfont->w = FLIPWORD(font->w);\nfont->h = FLIPWORD(font->h);\nfont->nchars = FLIPWORD(font->nchars);\nbody_size = font->w * font->h * font->nchars;\n}\nif (overflow2(font->nchars, font->h)) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error reading font, invalid font header\");\nefree(font);\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nif (overflow2(font->nchars * font->h, font->w )) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error reading font, invalid font header\");\nefree(font);\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nif (body_size != body_size_check) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error reading font\");\nefree(font);\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nfont->data = emalloc(body_size);\nb = 0;\nwhile (b < body_size && (n = php_stream_read(stream, &font->data[b], body_size - b))) {\nb += n;\n}\nif (!n) {\nefree(font->data);\nefree(font);\nif (php_stream_eof(stream)) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"End of file while reading body\");\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error while reading body\");\n}\nphp_stream_close(stream);\nRETURN_FALSE;\n}\nphp_stream_close(stream);\nind = 5 + zend_list_insert(font, le_gd_font TSRMLS_CC);\nRETURN_LONG(ind);\n}", "label": 0}
{"index": 175072, "code": "SSH_PACKET_CALLBACK(ssh_packet_newkeys){\nssh_string sig_blob = NULL;\nint rc;\n(void)packet;\n(void)user;\n(void)type;\nSSH_LOG(SSH_LOG_PROTOCOL, \"Received SSH_MSG_NEWKEYS\");\nif(session->session_state!= SSH_SESSION_STATE_DH &&\nsession->dh_handshake_state != DH_STATE_NEWKEYS_SENT){\nssh_set_error(session,SSH_FATAL,\"ssh_packet_newkeys called in wrong state : %d:%d\",\nsession->session_state,session->dh_handshake_state);\ngoto error;\n}\nif(session->server){\nsession->dh_handshake_state=DH_STATE_FINISHED;\nif (rc != SSH_OK) {\ngoto error;\n}\nif (crypt_set_algorithms(session, SSH_3DES)   ) {\ngoto error;\n}\nif (generate_session_keys(session) < 0) {\ngoto error;\n}\nsig_blob = session->next_crypto->dh_server_signature;\nsession->next_crypto->dh_server_signature = NULL;\nrc = ssh_pki_import_pubkey_blob(session->next_crypto->server_pubkey, &key);\nif (rc < 0) {\nreturn SSH_ERROR;\n}\nif (session->opts.wanted_methods[SSH_HOSTKEYS]) {\nif(!ssh_match_group(session->opts.wanted_methods[SSH_HOSTKEYS],\nkey->type_c)) {\nssh_set_error(session,\nSSH_FATAL,\n\"Public key from server (%s) doesn't match user \"\n\"preference (%s)\",\nkey->type_c,\nsession->opts.wanted_methods[SSH_HOSTKEYS]);\nssh_key_free(key);\nreturn -1;\n}\n}\nrc = ssh_pki_signature_verify_blob(session,\nsig_blob,\nkey,\nsession->next_crypto->secret_hash,\nsession->next_crypto->digest_len);\nsession->next_crypto->server_pubkey_type = key->type_c;\nssh_key_free(key);\nssh_string_burn(sig_blob);\nssh_string_free(sig_blob);\nsig_blob = NULL;\nif (rc == SSH_ERROR) {\ngoto error;\n}\nSSH_LOG(SSH_LOG_PROTOCOL,\"Signature verified and valid\");\nif (session->current_crypto) {\ncrypto_free(session->current_crypto);\nsession->current_crypto=NULL;\n}\nsession->current_crypto = session->next_crypto;\nsession->next_crypto = crypto_new();\nif (session->next_crypto == NULL) {\nssh_set_error_oom(session);\ngoto error;\n}\nsession->next_crypto->session_id = malloc(session->current_crypto->digest_len);\nif (session->next_crypto->session_id == NULL) {\nssh_set_error_oom(session);\ngoto error;\n}\nmemcpy(session->next_crypto->session_id, session->current_crypto->session_id,\nsession->current_crypto->digest_len);\n}\nsession->dh_handshake_state = DH_STATE_FINISHED;\nsession->ssh_connection_callback(session);\nreturn SSH_PACKET_USED;\nerror:\nsession->session_state=SSH_SESSION_STATE_ERROR;\nreturn SSH_PACKET_USED;\n}", "contrast": "SSH_PACKET_CALLBACK(ssh_packet_newkeys){\nssh_string sig_blob = NULL;\nint rc;\n(void)packet;\n(void)user;\n(void)type;\nSSH_LOG(SSH_LOG_PROTOCOL, \"Received SSH_MSG_NEWKEYS\");\nif (session->session_state != SSH_SESSION_STATE_DH ||\nsession->dh_handshake_state != DH_STATE_NEWKEYS_SENT) {\nssh_set_error(session,\nSSH_FATAL,\n\"ssh_packet_newkeys called in wrong state : %d:%d\",\nsession->session_state,session->dh_handshake_state);\ngoto error;\n}\nif(session->server){\nsession->dh_handshake_state=DH_STATE_FINISHED;\nif (rc != SSH_OK) {\ngoto error;\n}\nif (crypt_set_algorithms(session, SSH_3DES)   ) {\ngoto error;\n}\nif (generate_session_keys(session) < 0) {\ngoto error;\n}\nsig_blob = session->next_crypto->dh_server_signature;\nsession->next_crypto->dh_server_signature = NULL;\nrc = ssh_pki_import_pubkey_blob(session->next_crypto->server_pubkey, &key);\nif (rc < 0) {\nreturn SSH_ERROR;\n}\nif (session->opts.wanted_methods[SSH_HOSTKEYS]) {\nif(!ssh_match_group(session->opts.wanted_methods[SSH_HOSTKEYS],\nkey->type_c)) {\nssh_set_error(session,\nSSH_FATAL,\n\"Public key from server (%s) doesn't match user \"\n\"preference (%s)\",\nkey->type_c,\nsession->opts.wanted_methods[SSH_HOSTKEYS]);\nssh_key_free(key);\nreturn -1;\n}\n}\nrc = ssh_pki_signature_verify_blob(session,\nsig_blob,\nkey,\nsession->next_crypto->secret_hash,\nsession->next_crypto->digest_len);\nsession->next_crypto->server_pubkey_type = key->type_c;\nssh_key_free(key);\nssh_string_burn(sig_blob);\nssh_string_free(sig_blob);\nsig_blob = NULL;\nif (rc == SSH_ERROR) {\ngoto error;\n}\nSSH_LOG(SSH_LOG_PROTOCOL,\"Signature verified and valid\");\nif (session->current_crypto) {\ncrypto_free(session->current_crypto);\nsession->current_crypto=NULL;\n}\nsession->current_crypto = session->next_crypto;\nsession->next_crypto = crypto_new();\nif (session->next_crypto == NULL) {\nssh_set_error_oom(session);\ngoto error;\n}\nsession->next_crypto->session_id = malloc(session->current_crypto->digest_len);\nif (session->next_crypto->session_id == NULL) {\nssh_set_error_oom(session);\ngoto error;\n}\nmemcpy(session->next_crypto->session_id, session->current_crypto->session_id,\nsession->current_crypto->digest_len);\n}\nsession->dh_handshake_state = DH_STATE_FINISHED;\nsession->ssh_connection_callback(session);\nreturn SSH_PACKET_USED;\nerror:\nsession->session_state=SSH_SESSION_STATE_ERROR;\nreturn SSH_PACKET_USED;\n}", "label": 0}
{"index": 175073, "code": "SSH_PACKET_CALLBACK(ssh_packet_kexdh_init){\nint rc;\n(void)type;\n(void)user;\nSSH_LOG(SSH_LOG_PACKET,\"Received SSH_MSG_KEXDH_INIT\");\nif(session->dh_handshake_state != DH_STATE_INIT){\nSSH_LOG(SSH_LOG_RARE,\"Invalid state for SSH_MSG_KEXDH_INIT\");\ngoto error;\n}\nswitch(session->next_crypto->kex_type){\ncase SSH_KEX_DH_GROUP1_SHA1:\ncase SSH_KEX_DH_GROUP14_SHA1:\nrc=ssh_server_kexdh_init(session, packet);\nbreak;\n#ifdef HAVE_ECDH\ncase SSH_KEX_ECDH_SHA2_NISTP256:\nrc = ssh_server_ecdh_init(session, packet);\nbreak;\n#endif\n#ifdef HAVE_CURVE25519\ncase SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\nrc = ssh_server_curve25519_init(session, packet);\nbreak;\n#endif\ndefault:\nssh_set_error(session,SSH_FATAL,\"Wrong kex type in ssh_packet_kexdh_init\");\nrc = SSH_ERROR;\n}\nif (rc == SSH_ERROR)\nsession->session_state = SSH_SESSION_STATE_ERROR;\nerror:\nreturn SSH_PACKET_USED;\n}", "contrast": "SSH_PACKET_CALLBACK(ssh_packet_kexdh_init){\nint rc = SSH_ERROR;\n(void)type;\n(void)user;\nSSH_LOG(SSH_LOG_PACKET,\"Received SSH_MSG_KEXDH_INIT\");\nif(session->dh_handshake_state != DH_STATE_INIT){\nSSH_LOG(SSH_LOG_RARE,\"Invalid state for SSH_MSG_KEXDH_INIT\");\ngoto error;\n}\nswitch(session->next_crypto->kex_type){\ncase SSH_KEX_DH_GROUP1_SHA1:\ncase SSH_KEX_DH_GROUP14_SHA1:\nrc=ssh_server_kexdh_init(session, packet);\nbreak;\n#ifdef HAVE_ECDH\ncase SSH_KEX_ECDH_SHA2_NISTP256:\nrc = ssh_server_ecdh_init(session, packet);\nbreak;\n#endif\n#ifdef HAVE_CURVE25519\ncase SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\nrc = ssh_server_curve25519_init(session, packet);\nbreak;\n#endif\ndefault:\nssh_set_error(session,SSH_FATAL,\"Wrong kex type in ssh_packet_kexdh_init\");\nrc = SSH_ERROR;\n}\nerror:\nif (rc == SSH_ERROR) {\nsession->session_state = SSH_SESSION_STATE_ERROR;\n}\nreturn SSH_PACKET_USED;\n}", "label": 0}
{"index": 175077, "code": "static int ec_mul_consttime(const EC_GROUP *group, EC_POINT *r,\nconst BIGNUM *scalar, const EC_POINT *point,\nBN_CTX *ctx)\n{\nint i, cardinality_bits, group_top, kbit, pbit, Z_is_one;\nEC_POINT *s = NULL;\nBIGNUM *k = NULL;\nBIGNUM *lambda = NULL;\nBIGNUM *cardinality = NULL;\nBN_CTX *new_ctx = NULL;\nint ret = 0;\nif (ctx == NULL && (ctx = new_ctx = BN_CTX_secure_new()) == NULL)\nreturn 0;\nBN_CTX_start(ctx);\ns = EC_POINT_new(group);\nif (s == NULL)\ngoto err;\nif (point == NULL) {\nif (!EC_POINT_copy(s, group->generator))\ngoto err;\n} else {\nif (!EC_POINT_copy(s, point))\ngoto err;\n}\nEC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);\ncardinality = BN_CTX_get(ctx);\nlambda = BN_CTX_get(ctx);\nk = BN_CTX_get(ctx);\nif (k == NULL || !BN_mul(cardinality, group->order, group->cofactor, ctx))\ngoto err;\ncardinality_bits = BN_num_bits(cardinality);\ngroup_top = bn_get_top(cardinality);\nif ((bn_wexpand(k, group_top + 1) == NULL)\n|| (bn_wexpand(lambda, group_top + 1) == NULL))\ngoto err;\nif (!BN_copy(k, scalar))\ngoto err;\nBN_set_flags(k, BN_FLG_CONSTTIME);\nif ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {\nif (!BN_nnmod(k, k, cardinality, ctx))\ngoto err;\n}\nif (!BN_add(lambda, k, cardinality))\ngoto err;\nBN_set_flags(lambda, BN_FLG_CONSTTIME);\nif (!BN_add(k, lambda, cardinality))\ngoto err;\nkbit = BN_is_bit_set(lambda, cardinality_bits);\nBN_consttime_swap(kbit, k, lambda, group_top + 1);\ngroup_top = bn_get_top(group->field);\nif ((bn_wexpand(s->X, group_top) == NULL)\n|| (bn_wexpand(s->Y, group_top) == NULL)\n|| (bn_wexpand(s->Z, group_top) == NULL)\n|| (bn_wexpand(r->X, group_top) == NULL)\n|| (bn_wexpand(r->Y, group_top) == NULL)\n|| (bn_wexpand(r->Z, group_top) == NULL))\ngoto err;\nif (!ec_point_blind_coordinates(group, s, ctx))\ngoto err;\nif (!EC_POINT_copy(r, s))\ngoto err;\nEC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);\nif (!EC_POINT_dbl(group, s, s, ctx))\ngoto err;\npbit = 0;\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\nBN_consttime_swap(c, (a)->X, (b)->X, w);   \\\nBN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\\nBN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\\nt = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\\n(a)->Z_is_one ^= (t);                      \\\n(b)->Z_is_one ^= (t);                      \\\n} while(0)\nfor (i = cardinality_bits - 1; i >= 0; i--) {\nkbit = BN_is_bit_set(k, i) ^ pbit;\nEC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\nif (!EC_POINT_add(group, s, r, s, ctx))\ngoto err;\nif (!EC_POINT_dbl(group, r, r, ctx))\ngoto err;\npbit ^= kbit;\n}\nEC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\nret = 1;\nerr:\nEC_POINT_free(s);\nBN_CTX_end(ctx);\nBN_CTX_free(new_ctx);\nreturn ret;\n}", "contrast": "static int ec_mul_consttime(const EC_GROUP *group, EC_POINT *r,\nconst BIGNUM *scalar, const EC_POINT *point,\nBN_CTX *ctx)\n{\nint i, cardinality_bits, group_top, kbit, pbit, Z_is_one;\nEC_POINT *s = NULL;\nBIGNUM *k = NULL;\nBIGNUM *lambda = NULL;\nBIGNUM *cardinality = NULL;\nBN_CTX *new_ctx = NULL;\nint ret = 0;\nif (ctx == NULL && (ctx = new_ctx = BN_CTX_secure_new()) == NULL)\nreturn 0;\nBN_CTX_start(ctx);\ns = EC_POINT_new(group);\nif (s == NULL)\ngoto err;\nif (point == NULL) {\nif (!EC_POINT_copy(s, group->generator))\ngoto err;\n} else {\nif (!EC_POINT_copy(s, point))\ngoto err;\n}\nEC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);\ncardinality = BN_CTX_get(ctx);\nlambda = BN_CTX_get(ctx);\nk = BN_CTX_get(ctx);\nif (k == NULL || !BN_mul(cardinality, group->order, group->cofactor, ctx))\ngoto err;\ncardinality_bits = BN_num_bits(cardinality);\ngroup_top = bn_get_top(cardinality);\nif ((bn_wexpand(k, group_top + 2) == NULL)\n|| (bn_wexpand(lambda, group_top + 2) == NULL)) {\ngoto err;\nif (!BN_copy(k, scalar))\ngoto err;\nBN_set_flags(k, BN_FLG_CONSTTIME);\nif ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {\nif (!BN_nnmod(k, k, cardinality, ctx))\ngoto err;\n}\nif (!BN_add(lambda, k, cardinality))\ngoto err;\nBN_set_flags(lambda, BN_FLG_CONSTTIME);\nif (!BN_add(k, lambda, cardinality))\ngoto err;\nkbit = BN_is_bit_set(lambda, cardinality_bits);\nBN_consttime_swap(kbit, k, lambda, group_top + 2);\ngroup_top = bn_get_top(group->field);\nif ((bn_wexpand(s->X, group_top) == NULL)\n|| (bn_wexpand(s->Y, group_top) == NULL)\n|| (bn_wexpand(s->Z, group_top) == NULL)\n|| (bn_wexpand(r->X, group_top) == NULL)\n|| (bn_wexpand(r->Y, group_top) == NULL)\n|| (bn_wexpand(r->Z, group_top) == NULL))\ngoto err;\nif (!ec_point_blind_coordinates(group, s, ctx))\ngoto err;\nif (!EC_POINT_copy(r, s))\ngoto err;\nEC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);\nif (!EC_POINT_dbl(group, s, s, ctx))\ngoto err;\npbit = 0;\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\nBN_consttime_swap(c, (a)->X, (b)->X, w);   \\\nBN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\\nBN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\\nt = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\\n(a)->Z_is_one ^= (t);                      \\\n(b)->Z_is_one ^= (t);                      \\\n} while(0)\nfor (i = cardinality_bits - 1; i >= 0; i--) {\nkbit = BN_is_bit_set(k, i) ^ pbit;\nEC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\nif (!EC_POINT_add(group, s, r, s, ctx))\ngoto err;\nif (!EC_POINT_dbl(group, r, r, ctx))\ngoto err;\npbit ^= kbit;\n}\nEC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\nret = 1;\nerr:\nEC_POINT_free(s);\nBN_CTX_end(ctx);\nBN_CTX_free(new_ctx);\nreturn ret;\n}", "label": 0}
{"index": 175078, "code": "int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,\nconst BIGNUM *scalar, const EC_POINT *point,\nBN_CTX *ctx)\n{\nint i, cardinality_bits, group_top, kbit, pbit, Z_is_one;\nEC_POINT *p = NULL;\nEC_POINT *s = NULL;\nBIGNUM *k = NULL;\nBIGNUM *lambda = NULL;\nBIGNUM *cardinality = NULL;\nint ret = 0;\nif (point != NULL && EC_POINT_is_at_infinity(group, point))\nreturn EC_POINT_set_to_infinity(group, r);\nif (BN_is_zero(group->order)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_ORDER);\nreturn 0;\n}\nif (BN_is_zero(group->cofactor)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_COFACTOR);\nreturn 0;\n}\nBN_CTX_start(ctx);\nif (((p = EC_POINT_new(group)) == NULL)\n|| ((s = EC_POINT_new(group)) == NULL)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\ngoto err;\n}\nif (point == NULL) {\nif (!EC_POINT_copy(p, group->generator)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\ngoto err;\n}\n} else {\nif (!EC_POINT_copy(p, point)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\ngoto err;\n}\n}\nEC_POINT_BN_set_flags(p, BN_FLG_CONSTTIME);\nEC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);\nEC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);\ncardinality = BN_CTX_get(ctx);\nlambda = BN_CTX_get(ctx);\nk = BN_CTX_get(ctx);\nif (k == NULL) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\ngoto err;\n}\nif (!BN_mul(cardinality, group->order, group->cofactor, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\ncardinality_bits = BN_num_bits(cardinality);\ngroup_top = bn_get_top(cardinality);\nif ((bn_wexpand(k, group_top + 1) == NULL)\n|| (bn_wexpand(lambda, group_top + 1) == NULL)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nif (!BN_copy(k, scalar)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nBN_set_flags(k, BN_FLG_CONSTTIME);\nif ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {\nif (!BN_nnmod(k, k, cardinality, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\n}\nif (!BN_add(lambda, k, cardinality)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nBN_set_flags(lambda, BN_FLG_CONSTTIME);\nif (!BN_add(k, lambda, cardinality)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nkbit = BN_is_bit_set(lambda, cardinality_bits);\nBN_consttime_swap(kbit, k, lambda, group_top + 1);\ngroup_top = bn_get_top(group->field);\nif ((bn_wexpand(s->X, group_top) == NULL)\n|| (bn_wexpand(s->Y, group_top) == NULL)\n|| (bn_wexpand(s->Z, group_top) == NULL)\n|| (bn_wexpand(r->X, group_top) == NULL)\n|| (bn_wexpand(r->Y, group_top) == NULL)\n|| (bn_wexpand(r->Z, group_top) == NULL)\n|| (bn_wexpand(p->X, group_top) == NULL)\n|| (bn_wexpand(p->Y, group_top) == NULL)\n|| (bn_wexpand(p->Z, group_top) == NULL)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nif (!ec_point_blind_coordinates(group, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_POINT_COORDINATES_BLIND_FAILURE);\ngoto err;\n}\nif (!ec_point_ladder_pre(group, r, s, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE);\ngoto err;\n}\npbit = 1;\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\nBN_consttime_swap(c, (a)->X, (b)->X, w);   \\\nBN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\\nBN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\\nt = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\\n(a)->Z_is_one ^= (t);                      \\\n(b)->Z_is_one ^= (t);                      \\\n} while(0)\nfor (i = cardinality_bits - 1; i >= 0; i--) {\nkbit = BN_is_bit_set(k, i) ^ pbit;\nEC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\nif (!ec_point_ladder_step(group, r, s, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE);\ngoto err;\n}\npbit ^= kbit;\n}\nEC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\nif (!ec_point_ladder_post(group, r, s, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE);\ngoto err;\n}\nret = 1;\nerr:\nEC_POINT_free(p);\nEC_POINT_free(s);\nBN_CTX_end(ctx);\nreturn ret;\n}", "contrast": "int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,\nconst BIGNUM *scalar, const EC_POINT *point,\nBN_CTX *ctx)\n{\nint i, cardinality_bits, group_top, kbit, pbit, Z_is_one;\nEC_POINT *p = NULL;\nEC_POINT *s = NULL;\nBIGNUM *k = NULL;\nBIGNUM *lambda = NULL;\nBIGNUM *cardinality = NULL;\nint ret = 0;\nif (point != NULL && EC_POINT_is_at_infinity(group, point))\nreturn EC_POINT_set_to_infinity(group, r);\nif (BN_is_zero(group->order)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_ORDER);\nreturn 0;\n}\nif (BN_is_zero(group->cofactor)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_COFACTOR);\nreturn 0;\n}\nBN_CTX_start(ctx);\nif (((p = EC_POINT_new(group)) == NULL)\n|| ((s = EC_POINT_new(group)) == NULL)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\ngoto err;\n}\nif (point == NULL) {\nif (!EC_POINT_copy(p, group->generator)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\ngoto err;\n}\n} else {\nif (!EC_POINT_copy(p, point)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\ngoto err;\n}\n}\nEC_POINT_BN_set_flags(p, BN_FLG_CONSTTIME);\nEC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);\nEC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);\ncardinality = BN_CTX_get(ctx);\nlambda = BN_CTX_get(ctx);\nk = BN_CTX_get(ctx);\nif (k == NULL) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\ngoto err;\n}\nif (!BN_mul(cardinality, group->order, group->cofactor, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\ncardinality_bits = BN_num_bits(cardinality);\ngroup_top = bn_get_top(cardinality);\nif ((bn_wexpand(k, group_top + 2) == NULL)\n|| (bn_wexpand(lambda, group_top + 2) == NULL)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nif (!BN_copy(k, scalar)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nBN_set_flags(k, BN_FLG_CONSTTIME);\nif ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {\nif (!BN_nnmod(k, k, cardinality, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\n}\nif (!BN_add(lambda, k, cardinality)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nBN_set_flags(lambda, BN_FLG_CONSTTIME);\nif (!BN_add(k, lambda, cardinality)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nkbit = BN_is_bit_set(lambda, cardinality_bits);\nBN_consttime_swap(kbit, k, lambda, group_top + 2);\ngroup_top = bn_get_top(group->field);\nif ((bn_wexpand(s->X, group_top) == NULL)\n|| (bn_wexpand(s->Y, group_top) == NULL)\n|| (bn_wexpand(s->Z, group_top) == NULL)\n|| (bn_wexpand(r->X, group_top) == NULL)\n|| (bn_wexpand(r->Y, group_top) == NULL)\n|| (bn_wexpand(r->Z, group_top) == NULL)\n|| (bn_wexpand(p->X, group_top) == NULL)\n|| (bn_wexpand(p->Y, group_top) == NULL)\n|| (bn_wexpand(p->Z, group_top) == NULL)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\ngoto err;\n}\nif (!ec_point_blind_coordinates(group, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_POINT_COORDINATES_BLIND_FAILURE);\ngoto err;\n}\nif (!ec_point_ladder_pre(group, r, s, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE);\ngoto err;\n}\npbit = 1;\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\nBN_consttime_swap(c, (a)->X, (b)->X, w);   \\\nBN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\\nBN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\\nt = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\\n(a)->Z_is_one ^= (t);                      \\\n(b)->Z_is_one ^= (t);                      \\\n} while(0)\nfor (i = cardinality_bits - 1; i >= 0; i--) {\nkbit = BN_is_bit_set(k, i) ^ pbit;\nEC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\nif (!ec_point_ladder_step(group, r, s, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE);\ngoto err;\n}\npbit ^= kbit;\n}\nEC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\nif (!ec_point_ladder_post(group, r, s, p, ctx)) {\nECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE);\ngoto err;\n}\nret = 1;\nerr:\nEC_POINT_free(p);\nEC_POINT_free(s);\nBN_CTX_end(ctx);\nreturn ret;\n}", "label": 0}
{"index": 175079, "code": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\nBIGNUM **rp)\n{\nBN_CTX *ctx;\nBIGNUM k, kq, *K, *kinv = NULL, *r = NULL;\nBIGNUM l, m;\nint ret = 0;\nint q_bits;\nif (!dsa->p || !dsa->q || !dsa->g) {\nDSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\nreturn 0;\n}\nBN_init(&k);\nBN_init(&kq);\nBN_init(&l);\nBN_init(&m);\nif (ctx_in == NULL) {\nif ((ctx = BN_CTX_new()) == NULL)\ngoto err;\n} else\nctx = ctx_in;\nif ((r = BN_new()) == NULL)\ngoto err;\nq_bits = BN_num_bits(dsa->q);\nif (!BN_set_bit(&k, q_bits)\n|| !BN_set_bit(&l, q_bits)\n|| !BN_set_bit(&m, q_bits))\ngoto err;\ndo\nif (!BN_rand_range(&k, dsa->q))\ngoto err;\nwhile (BN_is_zero(&k));\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\nBN_set_flags(&k, BN_FLG_CONSTTIME);\n}\nif (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\nif (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\nCRYPTO_LOCK_DSA, dsa->p, ctx))\ngoto err;\n}\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\nif (!BN_add(&l, &k, dsa->q)\n|| !BN_add(&m, &l, dsa->q)\n|| !BN_copy(&kq, BN_num_bits(&l) > q_bits ? &l : &m))\ngoto err;\nBN_set_flags(&kq, BN_FLG_CONSTTIME);\nK = &kq;\n} else {\nK = &k;\n}\nDSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,\ndsa->method_mont_p);\nif (!BN_mod(r, r, dsa->q, ctx))\ngoto err;\nif ((kinv = BN_mod_inverse(NULL, &k, dsa->q, ctx)) == NULL)\ngoto err;\nif (*kinvp != NULL)\nBN_clear_free(*kinvp);\n*kinvp = kinv;\nkinv = NULL;\nif (*rp != NULL)\nBN_clear_free(*rp);\n*rp = r;\nret = 1;\nerr:\nif (!ret) {\nDSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\nif (r != NULL)\nBN_clear_free(r);\n}\nif (ctx_in == NULL)\nBN_CTX_free(ctx);\nBN_clear_free(&k);\nBN_clear_free(&kq);\nBN_clear_free(&l);\nBN_clear_free(&m);\nreturn ret;\n}", "contrast": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\nBIGNUM **rp)\n{\nBN_CTX *ctx;\nBIGNUM k, kq, *K, *kinv = NULL, *r = NULL;\nBIGNUM l, m;\nint ret = 0;\nint q_bits;\nif (!dsa->p || !dsa->q || !dsa->g) {\nDSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\nreturn 0;\n}\nBN_init(&k);\nBN_init(&kq);\nBN_init(&l);\nBN_init(&m);\nif (ctx_in == NULL) {\nif ((ctx = BN_CTX_new()) == NULL)\ngoto err;\n} else\nctx = ctx_in;\nif ((r = BN_new()) == NULL)\ngoto err;\nq_bits = BN_num_bits(dsa->q) + sizeof(dsa->q->d[0]) * 16;\nif (!BN_set_bit(&k, q_bits)\n|| !BN_set_bit(&l, q_bits)\n|| !BN_set_bit(&m, q_bits))\ngoto err;\ndo\nif (!BN_rand_range(&k, dsa->q))\ngoto err;\nwhile (BN_is_zero(&k));\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\nBN_set_flags(&k, BN_FLG_CONSTTIME);\n}\nif (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\nif (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\nCRYPTO_LOCK_DSA, dsa->p, ctx))\ngoto err;\n}\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\nif (!BN_add(&l, &k, dsa->q)\n|| !BN_add(&m, &l, dsa->q)\n|| !BN_copy(&kq, BN_num_bits(&l) > q_bits ? &l : &m))\ngoto err;\nBN_set_flags(&kq, BN_FLG_CONSTTIME);\nK = &kq;\n} else {\nK = &k;\n}\nDSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,\ndsa->method_mont_p);\nif (!BN_mod(r, r, dsa->q, ctx))\ngoto err;\nif ((kinv = BN_mod_inverse(NULL, &k, dsa->q, ctx)) == NULL)\ngoto err;\nif (*kinvp != NULL)\nBN_clear_free(*kinvp);\n*kinvp = kinv;\nkinv = NULL;\nif (*rp != NULL)\nBN_clear_free(*rp);\n*rp = r;\nret = 1;\nerr:\nif (!ret) {\nDSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\nif (r != NULL)\nBN_clear_free(r);\n}\nif (ctx_in == NULL)\nBN_CTX_free(ctx);\nBN_clear_free(&k);\nBN_clear_free(&kq);\nBN_clear_free(&l);\nBN_clear_free(&m);\nreturn ret;\n}", "label": 0}
{"index": 175146, "code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\nconst char *snapshot_id,\nconst char *name,\nError **errp)\n{\nint i, snapshot_index;\nBDRVQcowState *s = bs->opaque;\nQCowSnapshot *sn;\nuint64_t *new_l1_table;\nint new_l1_bytes;\nint ret;\nassert(bs->read_only);\nsnapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\nif (snapshot_index < 0) {\nerror_setg(errp,\n\"Can't find snapshot\");\nreturn -ENOENT;\n}\nsn = &s->snapshots[snapshot_index];\nnew_l1_bytes = s->l1_size * sizeof(uint64_t);\nnew_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\nret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes);\nif (ret < 0) {\nerror_setg(errp, \"Failed to read l1 table for snapshot\");\ng_free(new_l1_table);\nreturn ret;\n}\ng_free(s->l1_table);\ns->l1_size = sn->l1_size;\ns->l1_table_offset = sn->l1_table_offset;\ns->l1_table = new_l1_table;\nfor(i = 0;i < s->l1_size; i++) {\nbe64_to_cpus(&s->l1_table[i]);\n}\nreturn 0;\n}", "contrast": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\nconst char *snapshot_id,\nconst char *name,\nError **errp)\n{\nint i, snapshot_index;\nBDRVQcowState *s = bs->opaque;\nQCowSnapshot *sn;\nuint64_t *new_l1_table;\nint new_l1_bytes;\nint ret;\nassert(bs->read_only);\nsnapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\nif (snapshot_index < 0) {\nerror_setg(errp,\n\"Can't find snapshot\");\nreturn -ENOENT;\n}\nsn = &s->snapshots[snapshot_index];\nnew_l1_bytes = sn->l1_size * sizeof(uint64_t);\nnew_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\nret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes);\nif (ret < 0) {\nerror_setg(errp, \"Failed to read l1 table for snapshot\");\ng_free(new_l1_table);\nreturn ret;\n}\ng_free(s->l1_table);\ns->l1_size = sn->l1_size;\ns->l1_table_offset = sn->l1_table_offset;\ns->l1_table = new_l1_table;\nfor(i = 0;i < s->l1_size; i++) {\nbe64_to_cpus(&s->l1_table[i]);\n}\nreturn 0;\n}", "label": 0}
{"index": 175148, "code": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\nError **errp)\n{\nBDRVBochsState *s = bs->opaque;\nuint32_t i;\nstruct bochs_header bochs;\nint ret;\nbs->read_only = 1;\nret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\nif (ret < 0) {\nreturn ret;\n}\nif (strcmp(bochs.magic, HEADER_MAGIC) ||\nstrcmp(bochs.type, REDOLOG_TYPE) ||\nstrcmp(bochs.subtype, GROWING_TYPE) ||\n((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n(le32_to_cpu(bochs.version) != HEADER_V1))) {\nerror_setg(errp, \"Image not in Bochs format\");\nreturn -EINVAL;\n}\nif (le32_to_cpu(bochs.version) == HEADER_V1) {\nbs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n} else {\nbs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n}\ns->catalog_size = le32_to_cpu(bochs.catalog);\ns->catalog_bitmap = g_malloc(s->catalog_size * 4);\nret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\ns->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\ns->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\ns->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\ns->extent_size = le32_to_cpu(bochs.extent);\nqemu_co_mutex_init(&s->lock);\nreturn 0;\nfail:\ns->extent_size = le32_to_cpu(bochs.extent);\nqemu_co_mutex_init(&s->lock);\nreturn 0;\nextent_index = offset / s->extent_size;\nextent_offset = (offset % s->extent_size) / 512;\nif (s->catalog_bitmap[extent_index] == 0xffffffff) {\nreturn -1;\n}\nbitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n(s->extent_blocks + s->bitmap_blocks));\nif (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n&bitmap_entry, 1) != 1) {\nreturn -1;\n}\nif (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\nreturn -1;\n}\nreturn bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}", "contrast": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\nError **errp)\n{\nBDRVBochsState *s = bs->opaque;\nuint32_t i;\nstruct bochs_header bochs;\nint ret;\nbs->read_only = 1;\nret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\nif (ret < 0) {\nreturn ret;\n}\nif (strcmp(bochs.magic, HEADER_MAGIC) ||\nstrcmp(bochs.type, REDOLOG_TYPE) ||\nstrcmp(bochs.subtype, GROWING_TYPE) ||\n((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n(le32_to_cpu(bochs.version) != HEADER_V1))) {\nerror_setg(errp, \"Image not in Bochs format\");\nreturn -EINVAL;\n}\nif (le32_to_cpu(bochs.version) == HEADER_V1) {\nbs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n} else {\nbs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n}\ns->catalog_size = le32_to_cpu(bochs.catalog);\nif (s->catalog_size > 0x100000) {\nerror_setg(errp, \"Catalog size is too large\");\nreturn -EFBIG;\n}\ns->catalog_bitmap = g_malloc(s->catalog_size * 4);\nret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\ns->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\ns->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\ns->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\ns->extent_size = le32_to_cpu(bochs.extent);\nqemu_co_mutex_init(&s->lock);\nreturn 0;\nfail:\ns->extent_size = le32_to_cpu(bochs.extent);\nif (s->catalog_size < bs->total_sectors / s->extent_size) {\nerror_setg(errp, \"Catalog size is too small for this disk size\");\nret = -EINVAL;\ngoto fail;\n}\nqemu_co_mutex_init(&s->lock);\nreturn 0;\nextent_index = offset / s->extent_size;\nextent_offset = (offset % s->extent_size) / 512;\nif (s->catalog_bitmap[extent_index] == 0xffffffff) {\nreturn -1;\n}\nbitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n(s->extent_blocks + s->bitmap_blocks));\nif (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n&bitmap_entry, 1) != 1) {\nreturn -1;\n}\nif (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\nreturn -1;\n}\nreturn bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}", "label": 0}
{"index": 175171, "code": "ps_parser_skip_PS_token( PS_Parser  parser )\n{\nFT_Byte*  cur   = parser->cursor;\nFT_Byte*  limit = parser->limit;\nFT_Error  error = FT_Err_Ok;\nskip_spaces( &cur, limit );\nif ( cur >= limit )\ngoto Exit;\nif ( *cur == '[' || *cur == ']' )\n{\ncur++;\ngoto Exit;\n}\nif ( *cur == '{' )\n{\nerror = skip_procedure( &cur, limit );\ngoto Exit;\n}\nif ( *cur == '(' )\n{\nerror = skip_literal_string( &cur, limit );\ngoto Exit;\n}\nif ( *cur == '<' )\n{\nif ( cur + 1 < limit && *(cur + 1) == '<' )\n{\ncur++;\ncur++;\n}\nelse\nerror = skip_string( &cur, limit );\ngoto Exit;\n}\nif ( *cur == '>' )\n{\ncur++;\nif ( cur >= limit || *cur != '>' )\n{\nFT_ERROR(( \"ps_parser_skip_PS_token:\"\n\" unexpected closing delimiter `>'\\n\" ));\nerror = FT_THROW( Invalid_File_Format );\ngoto Exit;\n}\ncur++;\ngoto Exit;\n}\nif ( *cur == '/' )\ncur++;\nwhile ( cur < limit )\n{\nif ( IS_PS_DELIM( *cur ) )\nbreak;\ncur++;\n}\nExit:\nif ( cur < limit && cur == parser->cursor )\n{\nFT_ERROR(( \"ps_parser_skip_PS_token:\"\n\" current token is `%c' which is self-delimiting\\n\"\n\"                        \"\n\" but invalid at this point\\n\",\n*cur ));\nerror = FT_THROW( Invalid_File_Format );\n}\nparser->error  = error;\nparser->cursor = cur;\n}", "contrast": "ps_parser_skip_PS_token( PS_Parser  parser )\n{\nFT_Byte*  cur   = parser->cursor;\nFT_Byte*  limit = parser->limit;\nFT_Error  error = FT_Err_Ok;\nskip_spaces( &cur, limit );\nif ( cur >= limit )\ngoto Exit;\nif ( *cur == '[' || *cur == ']' )\n{\ncur++;\ngoto Exit;\n}\nif ( *cur == '{' )\n{\nerror = skip_procedure( &cur, limit );\ngoto Exit;\n}\nif ( *cur == '(' )\n{\nerror = skip_literal_string( &cur, limit );\ngoto Exit;\n}\nif ( *cur == '<' )\n{\nif ( cur + 1 < limit && *(cur + 1) == '<' )\n{\ncur++;\ncur++;\n}\nelse\nerror = skip_string( &cur, limit );\ngoto Exit;\n}\nif ( *cur == '>' )\n{\ncur++;\nif ( cur >= limit || *cur != '>' )\n{\nFT_ERROR(( \"ps_parser_skip_PS_token:\"\n\" unexpected closing delimiter `>'\\n\" ));\nerror = FT_THROW( Invalid_File_Format );\ngoto Exit;\n}\ncur++;\ngoto Exit;\n}\nif ( *cur == '/' )\ncur++;\nwhile ( cur < limit )\n{\nif ( IS_PS_DELIM( *cur ) )\nbreak;\ncur++;\n}\nExit:\nif ( cur < limit && cur == parser->cursor )\n{\nFT_ERROR(( \"ps_parser_skip_PS_token:\"\n\" current token is `%c' which is self-delimiting\\n\"\n\"                        \"\n\" but invalid at this point\\n\",\n*cur ));\nerror = FT_THROW( Invalid_File_Format );\n}\nif ( cur > limit )\ncur = limit;\nparser->error  = error;\nparser->cursor = cur;\n}", "label": 0}
{"index": 175215, "code": "IceGenerateMagicCookie (\nint len\n)\n{\nchar    *auth;\n#ifndef HAVE_ARC4RANDOM_BUF\nlong    ldata[2];\nint\t    seed;\nint\t    value;\nint\t    i;\n#endif\nif ((auth = malloc (len + 1)) == NULL)\nreturn (NULL);\n#ifdef HAVE_ARC4RANDOM_BUF\narc4random_buf(auth, len);\n#else\n#ifdef ITIMER_REAL\n{\nstruct timeval  now;\nint\t    i;\nldata[0] = now.tv_sec;\nldata[1] = now.tv_usec;\n}\n#else\n{\nlong    time ();\nldata[0] = time ((long *) 0);\nldata[1] = getpid ();\n}\n#endif\nseed = (ldata[0]) + (ldata[1] << 16);\nsrand (seed);\nfor (i = 0; i < len; i++)\nldata[1] = now.tv_usec;\nvalue = rand ();\nauth[i] = value & 0xff;\n}", "contrast": "IceGenerateMagicCookie (\nstatic void\nemulate_getrandom_buf (\nchar *auth,\nint len\n)\n{\nlong    ldata[2];\nint\t    seed;\nint\t    value;\nint\t    i;\n#ifdef ITIMER_REAL\n{\nstruct timeval  now;\nint\t    i;\nldata[0] = now.tv_sec;\nldata[1] = now.tv_usec;\n}\n#else\n{\nlong    time ();\nldata[0] = time ((long *) 0);\nldata[1] = getpid ();\n}\n#endif\nseed = (ldata[0]) + (ldata[1] << 16);\nsrand (seed);\nfor (i = 0; i < len; i++)\nldata[1] = now.tv_usec;\nvalue = rand ();\nauth[i] = value & 0xff;\n}", "label": 0}
{"index": 175219, "code": "jbig2_word_stream_buf_get_next_word(Jbig2WordStream *self, int offset, uint32_t *word)\n{\nJbig2WordStreamBuf *z = (Jbig2WordStreamBuf *) self;\nconst byte *data = z->data;\nuint32_t result;\nif (offset + 4 < z->size)\nresult = (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];\nelse if (offset > z->size)\nreturn -1;\nelse {\nint i;\nresult = 0;\nfor (i = 0; i < z->size - offset; i++)\nresult |= data[offset + i] << ((3 - i) << 3);\n}\n*word = result;\nreturn 0;\n}", "contrast": "jbig2_word_stream_buf_get_next_word(Jbig2WordStream *self, int offset, uint32_t *word)\njbig2_word_stream_buf_get_next_word(Jbig2WordStream *self, size_t offset, uint32_t *word)\n{\nJbig2WordStreamBuf *z = (Jbig2WordStreamBuf *) self;\nconst byte *data = z->data;\nuint32_t result;\nif (offset + 4 < z->size)\nresult = (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];\nelse if (offset > z->size)\nreturn -1;\nelse {\nsize_t i;\nresult = 0;\nfor (i = 0; i < z->size - offset; i++)\nresult |= data[offset + i] << ((3 - i) << 3);\n}\n*word = result;\nreturn 0;\n}", "label": 0}
{"index": 175220, "code": "jbig2_immediate_generic_region(Jbig2Ctx *ctx, Jbig2Segment *segment, const byte *segment_data)\n{\nJbig2RegionSegmentInfo rsi;\nbyte seg_flags;\nint8_t gbat[8];\nint offset;\nint gbat_bytes = 0;\nJbig2GenericRegionParams params;\nint code = 0;\nJbig2Image *image = NULL;\nJbig2WordStream *ws = NULL;\nJbig2ArithState *as = NULL;\nJbig2ArithCx *GB_stats = NULL;\nif (segment->data_length < 18)\nreturn jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Segment too short\");\njbig2_get_region_segment_info(&rsi, segment_data);\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"generic region: %d x %d @ (%d, %d), flags = %02x\", rsi.width, rsi.height, rsi.x, rsi.y, rsi.flags);\nseg_flags = segment_data[17];\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"segment flags = %02x\", seg_flags);\nif ((seg_flags & 1) && (seg_flags & 6))\njbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"MMR is 1, but GBTEMPLATE is not 0\");\nif (!(seg_flags & 1)) {\ngbat_bytes = (seg_flags & 6) ? 2 : 8;\nif (18 + gbat_bytes > segment->data_length)\nreturn jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Segment too short\");\nmemcpy(gbat, segment_data + 18, gbat_bytes);\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"gbat: %d, %d\", gbat[0], gbat[1]);\n}\noffset = 18 + gbat_bytes;\nparams.MMR = seg_flags & 1;\nparams.GBTEMPLATE = (seg_flags & 6) >> 1;\nparams.TPGDON = (seg_flags & 8) >> 3;\nparams.USESKIP = 0;\nmemcpy(params.gbat, gbat, gbat_bytes);\nimage = jbig2_image_new(ctx, rsi.width, rsi.height);\nif (image == NULL)\nreturn jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate generic image\");\njbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"allocated %d x %d image buffer for region decode results\", rsi.width, rsi.height);\nif (params.MMR) {\ncode = jbig2_decode_generic_mmr(ctx, segment, &params, segment_data + offset, segment->data_length - offset, image);\n} else {\nint stats_size = jbig2_generic_stats_size(ctx, params.GBTEMPLATE);\nGB_stats = jbig2_new(ctx, Jbig2ArithCx, stats_size);\nif (GB_stats == NULL) {\ncode = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate GB_stats in jbig2_immediate_generic_region\");\ngoto cleanup;\n}\nmemset(GB_stats, 0, stats_size);\nws = jbig2_word_stream_buf_new(ctx, segment_data + offset, segment->data_length - offset);\nif (ws == NULL) {\ncode = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate ws in jbig2_immediate_generic_region\");\ngoto cleanup;\n}\nas = jbig2_arith_new(ctx, ws);\nif (as == NULL) {\ncode = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate as in jbig2_immediate_generic_region\");\ngoto cleanup;\n}\ncode = jbig2_decode_generic_region(ctx, segment, &params, as, image, GB_stats);\n}\nif (code >= 0)\njbig2_page_add_result(ctx, &ctx->pages[ctx->current_page], image, rsi.x, rsi.y, rsi.op);\nelse\njbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error while decoding immediate_generic_region\");\ncleanup:\njbig2_free(ctx->allocator, as);\njbig2_word_stream_buf_free(ctx, ws);\njbig2_free(ctx->allocator, GB_stats);\njbig2_image_release(ctx, image);\nreturn code;\n}", "contrast": "jbig2_immediate_generic_region(Jbig2Ctx *ctx, Jbig2Segment *segment, const byte *segment_data)\n{\nJbig2RegionSegmentInfo rsi;\nbyte seg_flags;\nint8_t gbat[8];\nint offset;\nuint32_t gbat_bytes = 0;\nJbig2GenericRegionParams params;\nint code = 0;\nJbig2Image *image = NULL;\nJbig2WordStream *ws = NULL;\nJbig2ArithState *as = NULL;\nJbig2ArithCx *GB_stats = NULL;\nif (segment->data_length < 18)\nreturn jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Segment too short\");\njbig2_get_region_segment_info(&rsi, segment_data);\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"generic region: %d x %d @ (%d, %d), flags = %02x\", rsi.width, rsi.height, rsi.x, rsi.y, rsi.flags);\nseg_flags = segment_data[17];\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"segment flags = %02x\", seg_flags);\nif ((seg_flags & 1) && (seg_flags & 6))\njbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"MMR is 1, but GBTEMPLATE is not 0\");\nif (!(seg_flags & 1)) {\ngbat_bytes = (seg_flags & 6) ? 2 : 8;\nif (18 + gbat_bytes > segment->data_length)\nreturn jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Segment too short\");\nmemcpy(gbat, segment_data + 18, gbat_bytes);\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"gbat: %d, %d\", gbat[0], gbat[1]);\n}\noffset = 18 + gbat_bytes;\nparams.MMR = seg_flags & 1;\nparams.GBTEMPLATE = (seg_flags & 6) >> 1;\nparams.TPGDON = (seg_flags & 8) >> 3;\nparams.USESKIP = 0;\nmemcpy(params.gbat, gbat, gbat_bytes);\nimage = jbig2_image_new(ctx, rsi.width, rsi.height);\nif (image == NULL)\nreturn jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate generic image\");\njbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"allocated %d x %d image buffer for region decode results\", rsi.width, rsi.height);\nif (params.MMR) {\ncode = jbig2_decode_generic_mmr(ctx, segment, &params, segment_data + offset, segment->data_length - offset, image);\n} else {\nint stats_size = jbig2_generic_stats_size(ctx, params.GBTEMPLATE);\nGB_stats = jbig2_new(ctx, Jbig2ArithCx, stats_size);\nif (GB_stats == NULL) {\ncode = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate GB_stats in jbig2_immediate_generic_region\");\ngoto cleanup;\n}\nmemset(GB_stats, 0, stats_size);\nws = jbig2_word_stream_buf_new(ctx, segment_data + offset, segment->data_length - offset);\nif (ws == NULL) {\ncode = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate ws in jbig2_immediate_generic_region\");\ngoto cleanup;\n}\nas = jbig2_arith_new(ctx, ws);\nif (as == NULL) {\ncode = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to allocate as in jbig2_immediate_generic_region\");\ngoto cleanup;\n}\ncode = jbig2_decode_generic_region(ctx, segment, &params, as, image, GB_stats);\n}\nif (code >= 0)\njbig2_page_add_result(ctx, &ctx->pages[ctx->current_page], image, rsi.x, rsi.y, rsi.op);\nelse\njbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error while decoding immediate_generic_region\");\ncleanup:\njbig2_free(ctx->allocator, as);\njbig2_word_stream_buf_free(ctx, ws);\njbig2_free(ctx->allocator, GB_stats);\njbig2_image_release(ctx, image);\nreturn code;\n}", "label": 0}
{"index": 175227, "code": "jbig2_decode_mmr_init(Jbig2MmrCtx *mmr, int width, int height, const byte *data, size_t size)\n{\nint i;\nuint32_t word = 0;\nmmr->width = width;\nmmr->size = size;\nmmr->data_index = 0;\nmmr->bit_index = 0;\nfor (i = 0; i < size && i < 4; i++)\nword |= (data[i] << ((3 - i) << 3));\nmmr->word = word;\n}", "contrast": "jbig2_decode_mmr_init(Jbig2MmrCtx *mmr, int width, int height, const byte *data, size_t size)\n{\nsize_t i;\nuint32_t word = 0;\nmmr->width = width;\nmmr->size = size;\nmmr->data_index = 0;\nmmr->bit_index = 0;\nfor (i = 0; i < size && i < 4; i++)\nword |= (data[i] << ((3 - i) << 3));\nmmr->word = word;\n}", "label": 0}
{"index": 175229, "code": "jbig2_end_of_stripe(Jbig2Ctx *ctx, Jbig2Segment *segment, const uint8_t *segment_data)\n{\nJbig2Page page = ctx->pages[ctx->current_page];\nint end_row;\nend_row = jbig2_get_int32(segment_data);\nif (end_row < page.end_row) {\njbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number,\n\"end of stripe segment with non-positive end row advance\" \" (new end row %d vs current end row %d)\", end_row, page.end_row);\n} else {\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"end of stripe: advancing end row to %d\", end_row);\n}\npage.end_row = end_row;\nreturn 0;\n}", "contrast": "jbig2_end_of_stripe(Jbig2Ctx *ctx, Jbig2Segment *segment, const uint8_t *segment_data)\n{\nJbig2Page page = ctx->pages[ctx->current_page];\nuint32_t end_row;\nend_row = jbig2_get_uint32(segment_data);\nif (end_row < page.end_row) {\njbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number,\n\"end of stripe segment with non-positive end row advance\" \" (new end row %d vs current end row %d)\", end_row, page.end_row);\n} else {\njbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"end of stripe: advancing end row to %d\", end_row);\n}\npage.end_row = end_row;\nreturn 0;\n}", "label": 0}
{"index": 175234, "code": "jbig2_sd_count_referred(Jbig2Ctx *ctx, Jbig2Segment *segment)\n{\nint index;\nJbig2Segment *rsegment;\nint n_dicts = 0;\nfor (index = 0; index < segment->referred_to_segment_count; index++) {\nrsegment = jbig2_find_segment(ctx, segment->referred_to_segments[index]);\nif (rsegment && ((rsegment->flags & 63) == 0) &&\nrsegment->result && (((Jbig2SymbolDict *) rsegment->result)->n_symbols > 0) && ((*((Jbig2SymbolDict *) rsegment->result)->glyphs) != NULL))\nn_dicts++;\n}\nreturn (n_dicts);\n}", "contrast": "jbig2_sd_count_referred(Jbig2Ctx *ctx, Jbig2Segment *segment)\n{\nint index;\nJbig2Segment *rsegment;\nuint32_t n_dicts = 0;\nfor (index = 0; index < segment->referred_to_segment_count; index++) {\nrsegment = jbig2_find_segment(ctx, segment->referred_to_segments[index]);\nif (rsegment && ((rsegment->flags & 63) == 0) &&\nrsegment->result && (((Jbig2SymbolDict *) rsegment->result)->n_symbols > 0) && ((*((Jbig2SymbolDict *) rsegment->result)->glyphs) != NULL))\nn_dicts++;\n}\nreturn (n_dicts);\n}", "label": 0}
{"index": 175254, "code": "static void server_real_connect(SERVER_REC *server, IPADDR *ip,\nconst char *unix_socket)\n{\nGIOChannel *handle;\nIPADDR *own_ip = NULL;\nconst char *errmsg;\nchar *errmsg2;\nchar ipaddr[MAX_IP_LEN];\nint port;\ng_return_if_fail(ip != NULL || unix_socket != NULL);\nsignal_emit(\"server connecting\", 2, server, ip);\nif (server->connrec->no_connect)\nreturn;\nif (ip != NULL) {\nown_ip = ip == NULL ? NULL :\n(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\nserver->connrec->own_ip4);\nport = server->connrec->proxy != NULL ?\nserver->connrec->proxy_port : server->connrec->port;\nhandle = server->connrec->use_ssl ?\nnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\nnet_connect_ip(ip, port, own_ip);\n} else {\nhandle = net_connect_unix(unix_socket);\n}\nif (handle == NULL) {\nerrmsg = g_strerror(errno);\nerrmsg2 = NULL;\nif (errno == EADDRNOTAVAIL) {\nif (own_ip != NULL) {\nnet_ip2host(own_ip, ipaddr);\nerrmsg2 = g_strconcat(errmsg, \": \", ipaddr, NULL);\n}\nserver->no_reconnect = TRUE;\n}\nif (server->connrec->use_ssl && errno == ENOSYS)\nserver->no_reconnect = TRUE;\nserver->connection_lost = TRUE;\nserver_connect_failed(server, errmsg2 ? errmsg2 : errmsg);\ng_free(errmsg2);\n} else {\nserver->handle = net_sendbuffer_create(handle, 0);\n#ifdef HAVE_OPENSSL\nif (server->connrec->use_ssl)\nserver_connect_callback_init_ssl(server, handle);\nelse\n#endif\nserver->connect_tag =\ng_input_add(handle, G_INPUT_WRITE | G_INPUT_READ,\n(GInputFunction)\nserver_connect_callback_init,\nserver);\n}\n}", "contrast": "static void server_real_connect(SERVER_REC *server, IPADDR *ip,\nconst char *unix_socket)\n{\nGIOChannel *handle;\nIPADDR *own_ip = NULL;\nconst char *errmsg;\nchar *errmsg2;\nchar ipaddr[MAX_IP_LEN];\nint port;\ng_return_if_fail(ip != NULL || unix_socket != NULL);\nsignal_emit(\"server connecting\", 2, server, ip);\nif (server->connrec->no_connect)\nreturn;\nif (ip != NULL) {\nown_ip = ip == NULL ? NULL :\n(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\nserver->connrec->own_ip4);\nport = server->connrec->proxy != NULL ?\nserver->connrec->proxy_port : server->connrec->port;\nhandle = server->connrec->use_ssl ?\nnet_connect_ip_ssl(ip, port, server->connrec->address, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\nnet_connect_ip(ip, port, own_ip);\n} else {\nhandle = net_connect_unix(unix_socket);\n}\nif (handle == NULL) {\nerrmsg = g_strerror(errno);\nerrmsg2 = NULL;\nif (errno == EADDRNOTAVAIL) {\nif (own_ip != NULL) {\nnet_ip2host(own_ip, ipaddr);\nerrmsg2 = g_strconcat(errmsg, \": \", ipaddr, NULL);\n}\nserver->no_reconnect = TRUE;\n}\nif (server->connrec->use_ssl && errno == ENOSYS)\nserver->no_reconnect = TRUE;\nserver->connection_lost = TRUE;\nserver_connect_failed(server, errmsg2 ? errmsg2 : errmsg);\ng_free(errmsg2);\n} else {\nserver->handle = net_sendbuffer_create(handle, 0);\n#ifdef HAVE_OPENSSL\nif (server->connrec->use_ssl)\nserver_connect_callback_init_ssl(server, handle);\nelse\n#endif\nserver->connect_tag =\ng_input_add(handle, G_INPUT_WRITE | G_INPUT_READ,\n(GInputFunction)\nserver_connect_callback_init,\nserver);\n}\n}", "label": 0}
{"index": 175267, "code": "static int ext4_split_extent(handle_t *handle,\nstruct inode *inode,\nstruct ext4_ext_path *path,\nstruct ext4_map_blocks *map,\nint split_flag,\nint flags)\n{\next4_lblk_t ee_block;\nstruct ext4_extent *ex;\nunsigned int ee_len, depth;\nint err = 0;\nint uninitialized;\nint split_flag1, flags1;\ndepth = ext_depth(inode);\nex = path[depth].p_ext;\nee_block = le32_to_cpu(ex->ee_block);\nee_len = ext4_ext_get_actual_len(ex);\nuninitialized = ext4_ext_is_uninitialized(ex);\nif (map->m_lblk + map->m_len < ee_block + ee_len) {\nsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\nEXT4_EXT_MAY_ZEROOUT : 0;\nflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\nif (uninitialized)\nsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\nEXT4_EXT_MARK_UNINIT2;\nerr = ext4_split_extent_at(handle, inode, path,\nmap->m_lblk + map->m_len, split_flag1, flags1);\nif (err)\ngoto out;\n}\next4_ext_drop_refs(path);\npath = ext4_ext_find_extent(inode, map->m_lblk, path);\nif (IS_ERR(path))\nreturn PTR_ERR(path);\nif (map->m_lblk >= ee_block) {\nsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\nEXT4_EXT_MAY_ZEROOUT : 0;\nif (uninitialized)\nsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\nif (split_flag & EXT4_EXT_MARK_UNINIT2)\nsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\nerr = ext4_split_extent_at(handle, inode, path,\nmap->m_lblk, split_flag1, flags);\nif (err)\ngoto out;\n}\next4_ext_show_leaf(inode, path);\nout:\nreturn err ? err : map->m_len;\n}", "contrast": "static int ext4_split_extent(handle_t *handle,\nstruct inode *inode,\nstruct ext4_ext_path *path,\nstruct ext4_map_blocks *map,\nint split_flag,\nint flags)\n{\next4_lblk_t ee_block;\nstruct ext4_extent *ex;\nunsigned int ee_len, depth;\nint err = 0;\nint uninitialized;\nint split_flag1, flags1;\ndepth = ext_depth(inode);\nex = path[depth].p_ext;\nee_block = le32_to_cpu(ex->ee_block);\nee_len = ext4_ext_get_actual_len(ex);\nuninitialized = ext4_ext_is_uninitialized(ex);\nif (map->m_lblk + map->m_len < ee_block + ee_len) {\nsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT;\nflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\nif (uninitialized)\nsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\nEXT4_EXT_MARK_UNINIT2;\nif (split_flag & EXT4_EXT_DATA_VALID2)\nsplit_flag1 |= EXT4_EXT_DATA_VALID1;\nerr = ext4_split_extent_at(handle, inode, path,\nmap->m_lblk + map->m_len, split_flag1, flags1);\nif (err)\ngoto out;\n}\next4_ext_drop_refs(path);\npath = ext4_ext_find_extent(inode, map->m_lblk, path);\nif (IS_ERR(path))\nreturn PTR_ERR(path);\nif (map->m_lblk >= ee_block) {\nsplit_flag1 = split_flag & (EXT4_EXT_MAY_ZEROOUT |\nEXT4_EXT_DATA_VALID2);\nif (uninitialized)\nsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\nif (split_flag & EXT4_EXT_MARK_UNINIT2)\nsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\nerr = ext4_split_extent_at(handle, inode, path,\nmap->m_lblk, split_flag1, flags);\nif (err)\ngoto out;\n}\next4_ext_show_leaf(inode, path);\nout:\nreturn err ? err : map->m_len;\n}", "label": 0}
{"index": 175275, "code": "int inet_sk_rebuild_header(struct sock *sk)\n{\nstruct inet_sock *inet = inet_sk(sk);\nstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n__be32 daddr;\nint err;\nif (rt)\nreturn 0;\ndaddr = inet->inet_daddr;\nif (inet->opt && inet->opt->srr)\ndaddr = inet->opt->faddr;\nrt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\ninet->inet_dport, inet->inet_sport,\nsk->sk_protocol, RT_CONN_FLAGS(sk),\nsk->sk_bound_dev_if);\nif (!IS_ERR(rt)) {\nerr = 0;\nsk_setup_caps(sk, &rt->dst);\n} else {\nerr = PTR_ERR(rt);\nsk->sk_route_caps = 0;\nif (!sysctl_ip_dynaddr ||\nsk->sk_state != TCP_SYN_SENT ||\n(sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n(err = inet_sk_reselect_saddr(sk)) != 0)\nsk->sk_err_soft = -err;\n}\nreturn err;\n}", "contrast": "int inet_sk_rebuild_header(struct sock *sk)\n{\nstruct inet_sock *inet = inet_sk(sk);\nstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n__be32 daddr;\nstruct ip_options_rcu *inet_opt;\nint err;\nif (rt)\nreturn 0;\nrcu_read_lock();\ninet_opt = rcu_dereference(inet->inet_opt);\ndaddr = inet->inet_daddr;\nif (inet_opt && inet_opt->opt.srr)\ndaddr = inet_opt->opt.faddr;\nrcu_read_unlock();\nrt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\ninet->inet_dport, inet->inet_sport,\nsk->sk_protocol, RT_CONN_FLAGS(sk),\nsk->sk_bound_dev_if);\nif (!IS_ERR(rt)) {\nerr = 0;\nsk_setup_caps(sk, &rt->dst);\n} else {\nerr = PTR_ERR(rt);\nsk->sk_route_caps = 0;\nif (!sysctl_ip_dynaddr ||\nsk->sk_state != TCP_SYN_SENT ||\n(sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n(err = inet_sk_reselect_saddr(sk)) != 0)\nsk->sk_err_soft = -err;\n}\nreturn err;\n}", "label": 0}
{"index": 175279, "code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\nstruct ip_options *opt;\nstruct inet_request_sock *req_inet;\nreq_inet = inet_rsk(req);\nopt = req_inet->opt;\nif (opt == NULL || opt->cipso == 0)\nreturn;\ncipso_v4_delopt(&req_inet->opt);\n}", "contrast": "void cipso_v4_req_delattr(struct request_sock *req)\n{\nstruct ip_options_rcu *opt;\nstruct inet_request_sock *req_inet;\nreq_inet = inet_rsk(req);\nopt = req_inet->opt;\nif (opt == NULL || opt->opt.cipso == 0)\nreturn;\ncipso_v4_delopt(&req_inet->opt);\n}", "label": 0}
{"index": 175287, "code": "struct dst_entry *inet_csk_route_req(struct sock *sk,\nconst struct request_sock *req)\n{\nstruct rtable *rt;\nconst struct inet_request_sock *ireq = inet_rsk(req);\nstruct ip_options *opt = inet_rsk(req)->opt;\nstruct net *net = sock_net(sk);\nstruct flowi4 fl4;\nflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\nRT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\nsk->sk_protocol, inet_sk_flowi_flags(sk),\n(opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\nireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\nsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\nrt = ip_route_output_flow(net, &fl4, sk);\nif (IS_ERR(rt))\ngoto no_route;\nif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\ngoto route_err;\nreturn &rt->dst;\nroute_err:\nip_rt_put(rt);\nno_route:\nIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\nreturn NULL;\n}", "contrast": "struct dst_entry *inet_csk_route_req(struct sock *sk,\nconst struct request_sock *req)\n{\nstruct rtable *rt;\nconst struct inet_request_sock *ireq = inet_rsk(req);\nstruct ip_options_rcu *opt = inet_rsk(req)->opt;\nstruct net *net = sock_net(sk);\nstruct flowi4 fl4;\nflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\nRT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\nsk->sk_protocol, inet_sk_flowi_flags(sk),\n(opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr,\nireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\nsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\nrt = ip_route_output_flow(net, &fl4, sk);\nif (IS_ERR(rt))\ngoto no_route;\nif (opt && opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)\ngoto route_err;\nreturn &rt->dst;\nroute_err:\nip_rt_put(rt);\nno_route:\nIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\nreturn NULL;\n}", "label": 0}
{"index": 175315, "code": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\nsize_t size, int msg_flags)\n{\nstruct sock *sk = sock->sk;\nstruct rds_sock *rs = rds_sk_to_rs(sk);\nlong timeo;\nint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\nstruct sockaddr_in *sin;\nstruct rds_incoming *inc = NULL;\ntimeo = sock_rcvtimeo(sk, nonblock);\nrdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\nif (msg_flags & MSG_OOB)\ngoto out;\nwhile (1) {\nif (!list_empty(&rs->rs_notify_queue)) {\nret = rds_notify_queue_get(rs, msg);\nbreak;\n}\nif (rs->rs_cong_notify) {\nret = rds_notify_cong(rs, msg);\nbreak;\n}\nif (!rds_next_incoming(rs, &inc)) {\nif (nonblock) {\nret = -EAGAIN;\nbreak;\n}\ntimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n(!list_empty(&rs->rs_notify_queue) ||\nrs->rs_cong_notify ||\nrds_next_incoming(rs, &inc)), timeo);\nrdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\ntimeo);\nif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\ncontinue;\nret = timeo;\nif (ret == 0)\nret = -ETIMEDOUT;\nbreak;\n}\nrdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n&inc->i_conn->c_faddr,\nntohs(inc->i_hdr.h_sport));\nret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\nsize);\nif (ret < 0)\nbreak;\nif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\nrds_inc_put(inc);\ninc = NULL;\nrds_stats_inc(s_recv_deliver_raced);\ncontinue;\n}\nif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\nif (msg_flags & MSG_TRUNC)\nret = be32_to_cpu(inc->i_hdr.h_len);\nmsg->msg_flags |= MSG_TRUNC;\n}\nif (rds_cmsg_recv(inc, msg)) {\nret = -EFAULT;\ngoto out;\n}\nrds_stats_inc(s_recv_delivered);\nsin = (struct sockaddr_in *)msg->msg_name;\nif (sin) {\nsin->sin_family = AF_INET;\nsin->sin_port = inc->i_hdr.h_sport;\nsin->sin_addr.s_addr = inc->i_saddr;\nmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n}\nbreak;\n}\nif (inc)\nrds_inc_put(inc);\nout:\nreturn ret;\n}", "contrast": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\nsize_t size, int msg_flags)\n{\nstruct sock *sk = sock->sk;\nstruct rds_sock *rs = rds_sk_to_rs(sk);\nlong timeo;\nint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\nstruct sockaddr_in *sin;\nstruct rds_incoming *inc = NULL;\ntimeo = sock_rcvtimeo(sk, nonblock);\nrdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\nmsg->msg_namelen = 0;\nif (msg_flags & MSG_OOB)\ngoto out;\nwhile (1) {\nif (!list_empty(&rs->rs_notify_queue)) {\nret = rds_notify_queue_get(rs, msg);\nbreak;\n}\nif (rs->rs_cong_notify) {\nret = rds_notify_cong(rs, msg);\nbreak;\n}\nif (!rds_next_incoming(rs, &inc)) {\nif (nonblock) {\nret = -EAGAIN;\nbreak;\n}\ntimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n(!list_empty(&rs->rs_notify_queue) ||\nrs->rs_cong_notify ||\nrds_next_incoming(rs, &inc)), timeo);\nrdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\ntimeo);\nif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\ncontinue;\nret = timeo;\nif (ret == 0)\nret = -ETIMEDOUT;\nbreak;\n}\nrdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n&inc->i_conn->c_faddr,\nntohs(inc->i_hdr.h_sport));\nret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\nsize);\nif (ret < 0)\nbreak;\nif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\nrds_inc_put(inc);\ninc = NULL;\nrds_stats_inc(s_recv_deliver_raced);\ncontinue;\n}\nif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\nif (msg_flags & MSG_TRUNC)\nret = be32_to_cpu(inc->i_hdr.h_len);\nmsg->msg_flags |= MSG_TRUNC;\n}\nif (rds_cmsg_recv(inc, msg)) {\nret = -EFAULT;\ngoto out;\n}\nrds_stats_inc(s_recv_delivered);\nsin = (struct sockaddr_in *)msg->msg_name;\nif (sin) {\nsin->sin_family = AF_INET;\nsin->sin_port = inc->i_hdr.h_sport;\nsin->sin_addr.s_addr = inc->i_saddr;\nmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\nmsg->msg_namelen = sizeof(*sin);\n}\nbreak;\n}\nif (inc)\nrds_inc_put(inc);\nout:\nreturn ret;\n}", "label": 0}
{"index": 175334, "code": "void hugetlb_put_quota(struct address_space *mapping, long delta)\n{\nstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\nif (sbinfo->free_blocks > -1) {\nspin_lock(&sbinfo->stat_lock);\nsbinfo->free_blocks += delta;\nspin_unlock(&sbinfo->stat_lock);\n}\n}", "contrast": "void hugetlb_put_quota(struct address_space *mapping, long delta)", "label": 0}
{"index": 175343, "code": "static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\nstruct page *page, unsigned long address)\n{\nstruct hstate *h = hstate_vma(vma);\nstruct vm_area_struct *iter_vma;\nstruct address_space *mapping;\nstruct prio_tree_iter iter;\npgoff_t pgoff;\naddress = address & huge_page_mask(h);\npgoff = vma_hugecache_offset(h, vma, address);\nmapping = (struct address_space *)page_private(page);\nmutex_lock(&mapping->i_mmap_mutex);\nvma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {\nif (iter_vma == vma)\ncontinue;\nif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n__unmap_hugepage_range(iter_vma,\naddress, address + huge_page_size(h),\npage);\n}\nmutex_unlock(&mapping->i_mmap_mutex);\nreturn 1;\n}", "contrast": "static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\nstruct page *page, unsigned long address)\n{\nstruct hstate *h = hstate_vma(vma);\nstruct vm_area_struct *iter_vma;\nstruct address_space *mapping;\nstruct prio_tree_iter iter;\npgoff_t pgoff;\naddress = address & huge_page_mask(h);\npgoff = vma_hugecache_offset(h, vma, address);\nmapping = vma->vm_file->f_dentry->d_inode->i_mapping;\nmutex_lock(&mapping->i_mmap_mutex);\nvma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {\nif (iter_vma == vma)\ncontinue;\nif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n__unmap_hugepage_range(iter_vma,\naddress, address + huge_page_size(h),\npage);\n}\nmutex_unlock(&mapping->i_mmap_mutex);\nreturn 1;\n}", "label": 0}
{"index": 175351, "code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\nstruct ipv6hdr *iph = ipv6_hdr(skb);\n__be32 spi;\nspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\nreturn xfrm6_rcv_spi(skb, spi);\n}", "contrast": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\nstruct ipv6hdr *iph = ipv6_hdr(skb);\n__be32 spi;\nspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\nreturn xfrm6_rcv_spi(skb, spi) > 0 ? : 0;\n}", "label": 0}
{"index": 175356, "code": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\nunsigned long end, struct mm_walk *walk)\n{\nstruct vm_area_struct *vma = walk->private;\npte_t *pte, ptent;\nspinlock_t *ptl;\nstruct page *page;\nsplit_huge_page_pmd(walk->mm, pmd);\npte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\nfor (; addr != end; pte++, addr += PAGE_SIZE) {\nptent = *pte;\nif (!pte_present(ptent))\ncontinue;\npage = vm_normal_page(vma, addr, ptent);\nif (!page)\ncontinue;\nif (PageReserved(page))\ncontinue;\nptep_test_and_clear_young(vma, addr, pte);\nClearPageReferenced(page);\n}\npte_unmap_unlock(pte - 1, ptl);\ncond_resched();\nreturn 0;\n}", "contrast": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\nunsigned long end, struct mm_walk *walk)\n{\nstruct vm_area_struct *vma = walk->private;\npte_t *pte, ptent;\nspinlock_t *ptl;\nstruct page *page;\nsplit_huge_page_pmd(walk->mm, pmd);\nif (pmd_trans_unstable(pmd))\nreturn 0;\npte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\nfor (; addr != end; pte++, addr += PAGE_SIZE) {\nptent = *pte;\nif (!pte_present(ptent))\ncontinue;\npage = vm_normal_page(vma, addr, ptent);\nif (!page)\ncontinue;\nif (PageReserved(page))\ncontinue;\nptep_test_and_clear_young(vma, addr, pte);\nClearPageReferenced(page);\n}\npte_unmap_unlock(pte - 1, ptl);\ncond_resched();\nreturn 0;\n}", "label": 0}
{"index": 175357, "code": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\nunsigned long end, struct mm_walk *walk)\n{\nstruct numa_maps *md;\nspinlock_t *ptl;\npte_t *orig_pte;\npte_t *pte;\nmd = walk->private;\nspin_lock(&walk->mm->page_table_lock);\nif (pmd_trans_huge(*pmd)) {\nif (pmd_trans_splitting(*pmd)) {\nspin_unlock(&walk->mm->page_table_lock);\nwait_split_huge_page(md->vma->anon_vma, pmd);\n} else {\npte_t huge_pte = *(pte_t *)pmd;\nstruct page *page;\npage = can_gather_numa_stats(huge_pte, md->vma, addr);\nif (page)\ngather_stats(page, md, pte_dirty(huge_pte),\nHPAGE_PMD_SIZE/PAGE_SIZE);\nspin_unlock(&walk->mm->page_table_lock);\nreturn 0;\n}\n} else {\nspin_unlock(&walk->mm->page_table_lock);\n}\norig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\ndo {\nstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);\nif (!page)\ncontinue;\ngather_stats(page, md, pte_dirty(*pte), 1);\n} while (pte++, addr += PAGE_SIZE, addr != end);\npte_unmap_unlock(orig_pte, ptl);\nreturn 0;\n}", "contrast": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\nunsigned long end, struct mm_walk *walk)\n{\nstruct numa_maps *md;\nspinlock_t *ptl;\npte_t *orig_pte;\npte_t *pte;\nmd = walk->private;\nspin_lock(&walk->mm->page_table_lock);\nif (pmd_trans_huge(*pmd)) {\nif (pmd_trans_splitting(*pmd)) {\nspin_unlock(&walk->mm->page_table_lock);\nwait_split_huge_page(md->vma->anon_vma, pmd);\n} else {\npte_t huge_pte = *(pte_t *)pmd;\nstruct page *page;\npage = can_gather_numa_stats(huge_pte, md->vma, addr);\nif (page)\ngather_stats(page, md, pte_dirty(huge_pte),\nHPAGE_PMD_SIZE/PAGE_SIZE);\nspin_unlock(&walk->mm->page_table_lock);\nreturn 0;\n}\n} else {\nspin_unlock(&walk->mm->page_table_lock);\n}\nif (pmd_trans_unstable(pmd))\nreturn 0;\norig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\ndo {\nstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);\nif (!page)\ncontinue;\ngather_stats(page, md, pte_dirty(*pte), 1);\n} while (pte++, addr += PAGE_SIZE, addr != end);\npte_unmap_unlock(orig_pte, ptl);\nreturn 0;\n}", "label": 0}
{"index": 175384, "code": "raptor_libxml_resolveEntity(void* user_data,\nconst xmlChar *publicId, const xmlChar *systemId) {\nraptor_sax2* sax2 = (raptor_sax2*)user_data;\nreturn libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "contrast": "raptor_libxml_resolveEntity(void* user_data,\nconst xmlChar *publicId, const xmlChar *systemId)\n{\nraptor_sax2* sax2 = (raptor_sax2*)user_data;\nxmlParserCtxtPtr ctxt = sax2->xc;\nconst unsigned char *uri_string = NULL;\nxmlParserInputPtr entity_input;\nint load_entity = 0;\nif(ctxt->input)\nuri_string = RAPTOR_GOOD_CAST(const unsigned char *, ctxt->input->filename);\nif(!uri_string)\nuri_string = RAPTOR_GOOD_CAST(const unsigned char *, ctxt->directory);\nload_entity = RAPTOR_OPTIONS_GET_NUMERIC(sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES);\nif(load_entity)\nload_entity = raptor_sax2_check_load_uri_string(sax2, uri_string);\nif(load_entity) {\nentity_input = xmlLoadExternalEntity(RAPTOR_GOOD_CAST(const char*, uri_string),\nRAPTOR_GOOD_CAST(const char*, publicId),\nctxt);\n} else {\nRAPTOR_DEBUG4(\"Not loading entity URI %s by policy for publicId '%s' systemId '%s'\\n\", uri_string, publicId, systemId);\n}\nreturn entity_input;\n}", "label": 0}
{"index": 175390, "code": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\nint *olen)\n{\nint alloc = (length?length:(int)strlen(string))+1;\nchar *ns = malloc(alloc);\nunsigned char in;\nint strindex=0;\nunsigned long hex;\nCURLcode res;\nif(!ns)\nreturn NULL;\nwhile(--alloc > 0) {\nin = *string;\nif(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\nchar hexstr[3];\nchar *ptr;\nhexstr[0] = string[1];\nhexstr[1] = string[2];\nhexstr[2] = 0;\nhex = strtoul(hexstr, &ptr, 16);\nin = curlx_ultouc(hex);\nres = Curl_convert_from_network(handle, &in, 1);\nif(res) {\nfree(ns);\nreturn NULL;\n}\nstring+=2;\nalloc-=2;\n}\nns[strindex++] = in;\nstring++;\n}\nns[strindex]=0;\nif(olen)\n*olen = strindex;\nreturn ns;\n}", "contrast": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\nCURLcode Curl_urldecode(struct SessionHandle *data,\nconst char *string, size_t length,\nchar **ostring, size_t *olen,\nbool reject_ctrl)\n{\nsize_t alloc = (length?length:strlen(string))+1;\nchar *ns = malloc(alloc);\nunsigned char in;\nsize_t strindex=0;\nunsigned long hex;\nCURLcode res;\nif(!ns)\nreturn CURLE_OUT_OF_MEMORY;\nwhile(--alloc > 0) {\nin = *string;\nif(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\nchar hexstr[3];\nchar *ptr;\nhexstr[0] = string[1];\nhexstr[1] = string[2];\nhexstr[2] = 0;\nhex = strtoul(hexstr, &ptr, 16);\nin = curlx_ultouc(hex);\nres = Curl_convert_from_network(data, &in, 1);\nif(res) {\nfree(ns);\nreturn res;\n}\nstring+=2;\nalloc-=2;\n}\nif(reject_ctrl && (in < 0x20)) {\nfree(ns);\nreturn CURLE_URL_MALFORMAT;\n}\nns[strindex++] = in;\nstring++;\n}\nns[strindex]=0;\nif(olen)\n*olen = strindex;\nif(ostring)\n*ostring = ns;\nreturn CURLE_OK;\n}\nchar *curl_easy_unescape(CURL *handle, const char *string, int length,\nint *olen)\n{\nchar *str = NULL;\nsize_t inputlen = length;\nsize_t outputlen;\nCURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\nFALSE);\nif(res)\nreturn NULL;\nif(olen)\n*olen = curlx_uztosi(outputlen);\nreturn str;\n}", "label": 0}
{"index": 175391, "code": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\nstruct imap_conn *imapc = &conn->proto.imapc;\nstruct SessionHandle *data = conn->data;\nconst char *path = data->state.path;\nint len;\nif(!*path)\npath = \"INBOX\";\nimapc->mailbox = curl_easy_unescape(data, path, 0, &len);\nif(!imapc->mailbox)\nreturn CURLE_OUT_OF_MEMORY;\nreturn CURLE_OK;\n}", "contrast": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\nstruct imap_conn *imapc = &conn->proto.imapc;\nstruct SessionHandle *data = conn->data;\nconst char *path = data->state.path;\nif(!*path)\npath = \"INBOX\";\nreturn Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n}", "label": 0}
{"index": 175393, "code": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\nstruct completion *vfork_done = tsk->vfork_done;\ndeactivate_mm(tsk, mm);\nif (vfork_done) {\ntsk->vfork_done = NULL;\ncomplete(vfork_done);\n}\nif (tsk->clear_child_tid\n&& !(tsk->flags & PF_SIGNALED)\n&& atomic_read(&mm->mm_users) > 1) {\nu32 __user * tidptr = tsk->clear_child_tid;\ntsk->clear_child_tid = NULL;\nput_user(0, tidptr);\nsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n}\n}", "contrast": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\nstruct completion *vfork_done = tsk->vfork_done;\n#ifdef CONFIG_FUTEX\nif (unlikely(tsk->robust_list))\nexit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\nif (unlikely(tsk->compat_robust_list))\ncompat_exit_robust_list(tsk);\n#endif\n#endif\ndeactivate_mm(tsk, mm);\nif (vfork_done) {\ntsk->vfork_done = NULL;\ncomplete(vfork_done);\n}\nif (tsk->clear_child_tid\n&& !(tsk->flags & PF_SIGNALED)\n&& atomic_read(&mm->mm_users) > 1) {\nu32 __user * tidptr = tsk->clear_child_tid;\ntsk->clear_child_tid = NULL;\nput_user(0, tidptr);\nsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n}\n}", "label": 0}
{"index": 175424, "code": "static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\nstruct nfs4_state_owner *sp, int flags,\nconst struct iattr *attrs)\n{\nstruct dentry *parent = dget_parent(path->dentry);\nstruct inode *dir = parent->d_inode;\nstruct nfs_server *server = NFS_SERVER(dir);\nstruct nfs4_opendata *p;\np = kzalloc(sizeof(*p), GFP_KERNEL);\nif (p == NULL)\ngoto err;\np->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\nif (p->o_arg.seqid == NULL)\ngoto err_free;\np->path.mnt = mntget(path->mnt);\np->path.dentry = dget(path->dentry);\np->dir = parent;\np->owner = sp;\natomic_inc(&sp->so_count);\np->o_arg.fh = NFS_FH(dir);\np->o_arg.open_flags = flags,\np->o_arg.clientid = server->nfs_client->cl_clientid;\np->o_arg.id = sp->so_owner_id.id;\np->o_arg.name = &p->path.dentry->d_name;\np->o_arg.server = server;\np->o_arg.bitmask = server->attr_bitmask;\np->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\nif (flags & O_EXCL) {\nu32 *s = (u32 *) p->o_arg.u.verifier.data;\ns[0] = jiffies;\ns[1] = current->pid;\n} else if (flags & O_CREAT) {\np->o_arg.u.attrs = &p->attrs;\nmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n}\np->c_arg.fh = &p->o_res.fh;\np->c_arg.stateid = &p->o_res.stateid;\np->c_arg.seqid = p->o_arg.seqid;\nnfs4_init_opendata_res(p);\nkref_init(&p->kref);\nreturn p;\nerr_free:\nkfree(p);\nerr:\ndput(parent);\nreturn NULL;\n}", "contrast": "static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\nstruct nfs4_state_owner *sp, fmode_t fmode, int flags,\nconst struct iattr *attrs)\n{\nstruct dentry *parent = dget_parent(path->dentry);\nstruct inode *dir = parent->d_inode;\nstruct nfs_server *server = NFS_SERVER(dir);\nstruct nfs4_opendata *p;\np = kzalloc(sizeof(*p), GFP_KERNEL);\nif (p == NULL)\ngoto err;\np->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\nif (p->o_arg.seqid == NULL)\ngoto err_free;\np->path.mnt = mntget(path->mnt);\np->path.dentry = dget(path->dentry);\np->dir = parent;\np->owner = sp;\natomic_inc(&sp->so_count);\np->o_arg.fh = NFS_FH(dir);\np->o_arg.open_flags = flags;\np->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\np->o_arg.clientid = server->nfs_client->cl_clientid;\np->o_arg.id = sp->so_owner_id.id;\np->o_arg.name = &p->path.dentry->d_name;\np->o_arg.server = server;\np->o_arg.bitmask = server->attr_bitmask;\np->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\nif (flags & O_EXCL) {\nu32 *s = (u32 *) p->o_arg.u.verifier.data;\ns[0] = jiffies;\ns[1] = current->pid;\n} else if (flags & O_CREAT) {\np->o_arg.u.attrs = &p->attrs;\nmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n}\np->c_arg.fh = &p->o_res.fh;\np->c_arg.stateid = &p->o_res.stateid;\np->c_arg.seqid = p->o_arg.seqid;\nnfs4_init_opendata_res(p);\nkref_init(&p->kref);\nreturn p;\nerr_free:\nkfree(p);\nerr:\ndput(parent);\nreturn NULL;\n}", "label": 0}
{"index": 175429, "code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\nwrite_seqlock(&state->seqlock);\nnfs_set_open_stateid_locked(state, stateid, open_flags);\nwrite_sequnlock(&state->seqlock);\n}", "contrast": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\nstatic void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\nwrite_seqlock(&state->seqlock);\nnfs_set_open_stateid_locked(state, stateid, fmode);\nwrite_sequnlock(&state->seqlock);\n}", "label": 0}
{"index": 175433, "code": "static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\nstruct nfs4_state_owner *owner = state->owner;\nint call_close = 0;\nint newstate;\natomic_inc(&owner->so_count);\nspin_lock(&owner->so_lock);\nswitch (mode & (FMODE_READ | FMODE_WRITE)) {\ncase FMODE_READ:\nstate->n_rdonly--;\nbreak;\ncase FMODE_WRITE:\nstate->n_wronly--;\nbreak;\ncase FMODE_READ|FMODE_WRITE:\nstate->n_rdwr--;\n}\nnewstate = FMODE_READ|FMODE_WRITE;\nif (state->n_rdwr == 0) {\nif (state->n_rdonly == 0) {\nnewstate &= ~FMODE_READ;\ncall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\ncall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n}\nif (state->n_wronly == 0) {\nnewstate &= ~FMODE_WRITE;\ncall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\ncall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n}\nif (newstate == 0)\nclear_bit(NFS_DELEGATED_STATE, &state->flags);\n}\nnfs4_state_set_mode_locked(state, newstate);\nspin_unlock(&owner->so_lock);\nif (!call_close) {\nnfs4_put_open_state(state);\nnfs4_put_state_owner(owner);\n} else\nnfs4_do_close(path, state, wait);\n}", "contrast": "static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\nstatic void __nfs4_close(struct path *path, struct nfs4_state *state, fmode_t fmode, int wait)\n{\nstruct nfs4_state_owner *owner = state->owner;\nint call_close = 0;\nfmode_t newstate;\natomic_inc(&owner->so_count);\nspin_lock(&owner->so_lock);\nswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\ncase FMODE_READ:\nstate->n_rdonly--;\nbreak;\ncase FMODE_WRITE:\nstate->n_wronly--;\nbreak;\ncase FMODE_READ|FMODE_WRITE:\nstate->n_rdwr--;\n}\nnewstate = FMODE_READ|FMODE_WRITE;\nif (state->n_rdwr == 0) {\nif (state->n_rdonly == 0) {\nnewstate &= ~FMODE_READ;\ncall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\ncall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n}\nif (state->n_wronly == 0) {\nnewstate &= ~FMODE_WRITE;\ncall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\ncall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n}\nif (newstate == 0)\nclear_bit(NFS_DELEGATED_STATE, &state->flags);\n}\nnfs4_state_set_mode_locked(state, newstate);\nspin_unlock(&owner->so_lock);\nif (!call_close) {\nnfs4_put_open_state(state);\nnfs4_put_state_owner(owner);\n} else\nnfs4_do_close(path, state, wait);\n}", "label": 0}
{"index": 175435, "code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n__nfs4_close(path, state, mode, 1);\n}", "contrast": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\nvoid nfs4_close_sync(struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n__nfs4_close(path, state, fmode, 1);\n}", "label": 0}
{"index": 175459, "code": "void bnep_net_setup(struct net_device *dev)\n{\nmemset(dev->broadcast, 0xff, ETH_ALEN);\ndev->addr_len = ETH_ALEN;\nether_setup(dev);\ndev->netdev_ops = &bnep_netdev_ops;\ndev->watchdog_timeo  = HZ * 2;\n}", "contrast": "void bnep_net_setup(struct net_device *dev)\n{\nmemset(dev->broadcast, 0xff, ETH_ALEN);\ndev->addr_len = ETH_ALEN;\nether_setup(dev);\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\ndev->netdev_ops = &bnep_netdev_ops;\ndev->watchdog_timeo  = HZ * 2;\n}", "label": 0}
{"index": 175474, "code": "static int sgi_timer_set(struct k_itimer *timr, int flags,\nstruct itimerspec * new_setting,\nstruct itimerspec * old_setting)\n{\nunsigned long when, period, irqflags;\nint err = 0;\ncnodeid_t nodeid;\nstruct mmtimer *base;\nstruct rb_node *n;\nif (old_setting)\nsgi_timer_get(timr, old_setting);\nsgi_timer_del(timr);\nwhen = timespec_to_ns(new_setting->it_value);\nperiod = timespec_to_ns(new_setting->it_interval);\nif (when == 0)\nreturn 0;\nbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\nif (base == NULL)\nreturn -ENOMEM;\nif (flags & TIMER_ABSTIME) {\nstruct timespec n;\nunsigned long now;\ngetnstimeofday(&n);\nnow = timespec_to_ns(n);\nif (when > now)\nwhen -= now;\nelse\nwhen = 0;\n}\nwhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\nperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\npreempt_disable();\nnodeid =  cpu_to_node(smp_processor_id());\nspin_lock_irqsave(&timers[nodeid].lock, irqflags);\nbase->timer = timr;\nbase->cpu = smp_processor_id();\ntimr->it.mmtimer.clock = TIMER_SET;\ntimr->it.mmtimer.node = nodeid;\ntimr->it.mmtimer.incr = period;\ntimr->it.mmtimer.expires = when;\nn = timers[nodeid].next;\nmmtimer_add_list(base);\nif (timers[nodeid].next == n) {\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\npreempt_enable();\nreturn err;\n}\nif (n)\nmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\nmmtimer_set_next_timer(nodeid);\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\npreempt_enable();\nreturn err;\n}", "contrast": "static int sgi_timer_set(struct k_itimer *timr, int flags,\nstruct itimerspec * new_setting,\nstruct itimerspec * old_setting)\n{\nunsigned long when, period, irqflags;\nint err = 0;\ncnodeid_t nodeid;\nstruct mmtimer *base;\nstruct rb_node *n;\nif (old_setting)\nsgi_timer_get(timr, old_setting);\nsgi_timer_del(timr);\nwhen = timespec_to_ns(&new_setting->it_value);\nperiod = timespec_to_ns(&new_setting->it_interval);\nif (when == 0)\nreturn 0;\nbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\nif (base == NULL)\nreturn -ENOMEM;\nif (flags & TIMER_ABSTIME) {\nstruct timespec n;\nunsigned long now;\ngetnstimeofday(&n);\nnow = timespec_to_ns(&n);\nif (when > now)\nwhen -= now;\nelse\nwhen = 0;\n}\nwhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\nperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\npreempt_disable();\nnodeid =  cpu_to_node(smp_processor_id());\nspin_lock_irqsave(&timers[nodeid].lock, irqflags);\nbase->timer = timr;\nbase->cpu = smp_processor_id();\ntimr->it.mmtimer.clock = TIMER_SET;\ntimr->it.mmtimer.node = nodeid;\ntimr->it.mmtimer.incr = period;\ntimr->it.mmtimer.expires = when;\nn = timers[nodeid].next;\nmmtimer_add_list(base);\nif (timers[nodeid].next == n) {\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\npreempt_enable();\nreturn err;\n}\nif (n)\nmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\nmmtimer_set_next_timer(nodeid);\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\npreempt_enable();\nreturn err;\n}", "label": 0}
{"index": 175511, "code": "static int misaligned_store(struct pt_regs *regs,\n__u32 opcode,\nint displacement_not_indexed,\nint width_shift)\n{\nint error;\nint srcreg;\n__u64 address;\nerror = generate_and_check_address(regs, opcode,\ndisplacement_not_indexed, width_shift, &address);\nif (error < 0) {\nreturn error;\n}\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\nsrcreg = (opcode >> 4) & 0x3f;\nif (user_mode(regs)) {\n__u64 buffer;\nif (!access_ok(VERIFY_WRITE, (unsigned long) address, 1UL<<width_shift)) {\nreturn -1;\n}\nswitch (width_shift) {\ncase 1:\n*(__u16 *) &buffer = (__u16) regs->regs[srcreg];\nbreak;\ncase 2:\n*(__u32 *) &buffer = (__u32) regs->regs[srcreg];\nbreak;\ncase 3:\nbuffer = regs->regs[srcreg];\nbreak;\ndefault:\nprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\nwidth_shift, (unsigned long) regs->pc);\nbreak;\n}\nif (__copy_user((void *)(int)address, &buffer, (1 << width_shift)) > 0) {\nreturn -1;\n}\n} else {\n__u64 val = regs->regs[srcreg];\nswitch (width_shift) {\ncase 1:\nmisaligned_kernel_word_store(address, val);\nbreak;\ncase 2:\nasm (\"stlo.l %1, 0, %0\" : : \"r\" (val), \"r\" (address));\nasm (\"sthi.l %1, 3, %0\" : : \"r\" (val), \"r\" (address));\nbreak;\ncase 3:\nasm (\"stlo.q %1, 0, %0\" : : \"r\" (val), \"r\" (address));\nasm (\"sthi.q %1, 7, %0\" : : \"r\" (val), \"r\" (address));\nbreak;\ndefault:\nprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\nwidth_shift, (unsigned long) regs->pc);\nbreak;\n}\n}\nreturn 0;\n}", "contrast": "static int misaligned_store(struct pt_regs *regs,\n__u32 opcode,\nint displacement_not_indexed,\nint width_shift)\n{\nint error;\nint srcreg;\n__u64 address;\nerror = generate_and_check_address(regs, opcode,\ndisplacement_not_indexed, width_shift, &address);\nif (error < 0) {\nreturn error;\n}\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);\nsrcreg = (opcode >> 4) & 0x3f;\nif (user_mode(regs)) {\n__u64 buffer;\nif (!access_ok(VERIFY_WRITE, (unsigned long) address, 1UL<<width_shift)) {\nreturn -1;\n}\nswitch (width_shift) {\ncase 1:\n*(__u16 *) &buffer = (__u16) regs->regs[srcreg];\nbreak;\ncase 2:\n*(__u32 *) &buffer = (__u32) regs->regs[srcreg];\nbreak;\ncase 3:\nbuffer = regs->regs[srcreg];\nbreak;\ndefault:\nprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\nwidth_shift, (unsigned long) regs->pc);\nbreak;\n}\nif (__copy_user((void *)(int)address, &buffer, (1 << width_shift)) > 0) {\nreturn -1;\n}\n} else {\n__u64 val = regs->regs[srcreg];\nswitch (width_shift) {\ncase 1:\nmisaligned_kernel_word_store(address, val);\nbreak;\ncase 2:\nasm (\"stlo.l %1, 0, %0\" : : \"r\" (val), \"r\" (address));\nasm (\"sthi.l %1, 3, %0\" : : \"r\" (val), \"r\" (address));\nbreak;\ncase 3:\nasm (\"stlo.q %1, 0, %0\" : : \"r\" (val), \"r\" (address));\nasm (\"sthi.q %1, 7, %0\" : : \"r\" (val), \"r\" (address));\nbreak;\ndefault:\nprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\nwidth_shift, (unsigned long) regs->pc);\nbreak;\n}\n}\nreturn 0;\n}", "label": 0}
{"index": 175522, "code": "void handle_stdfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr)\n{\nunsigned long pc = regs->tpc;\nunsigned long tstate = regs->tstate;\nu32 insn;\nu64 value;\nu8 freg;\nint flag;\nstruct fpustate *f = FPUSTATE;\nif (tstate & TSTATE_PRIV)\ndie_if_kernel(\"stdfmna from kernel\", regs);\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, sfar);\nif (test_thread_flag(TIF_32BIT))\npc = (u32)pc;\nif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\nint asi = decode_asi(insn, regs);\nfreg = ((insn >> 25) & 0x1e) | ((insn >> 20) & 0x20);\nvalue = 0;\nflag = (freg < 32) ? FPRS_DL : FPRS_DU;\nif ((asi > ASI_SNFL) ||\n(asi < ASI_P))\ngoto daex;\nsave_and_clear_fpu();\nif (current_thread_info()->fpsaved[0] & flag)\nvalue = *(u64 *)&f->regs[freg];\nswitch (asi) {\ncase ASI_P:\ncase ASI_S: break;\ncase ASI_PL:\ncase ASI_SL:\nvalue = __swab64p(&value); break;\ndefault: goto daex;\n}\nif (put_user (value >> 32, (u32 __user *) sfar) ||\n__put_user ((u32)value, (u32 __user *)(sfar + 4)))\ngoto daex;\n} else {\ndaex:\nif (tlb_type == hypervisor)\nsun4v_data_access_exception(regs, sfar, sfsr);\nelse\nspitfire_data_access_exception(regs, sfsr, sfar);\nreturn;\n}\nadvance(regs);\n}", "contrast": "void handle_stdfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr)\n{\nunsigned long pc = regs->tpc;\nunsigned long tstate = regs->tstate;\nu32 insn;\nu64 value;\nu8 freg;\nint flag;\nstruct fpustate *f = FPUSTATE;\nif (tstate & TSTATE_PRIV)\ndie_if_kernel(\"stdfmna from kernel\", regs);\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, sfar);\nif (test_thread_flag(TIF_32BIT))\npc = (u32)pc;\nif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\nint asi = decode_asi(insn, regs);\nfreg = ((insn >> 25) & 0x1e) | ((insn >> 20) & 0x20);\nvalue = 0;\nflag = (freg < 32) ? FPRS_DL : FPRS_DU;\nif ((asi > ASI_SNFL) ||\n(asi < ASI_P))\ngoto daex;\nsave_and_clear_fpu();\nif (current_thread_info()->fpsaved[0] & flag)\nvalue = *(u64 *)&f->regs[freg];\nswitch (asi) {\ncase ASI_P:\ncase ASI_S: break;\ncase ASI_PL:\ncase ASI_SL:\nvalue = __swab64p(&value); break;\ndefault: goto daex;\n}\nif (put_user (value >> 32, (u32 __user *) sfar) ||\n__put_user ((u32)value, (u32 __user *)(sfar + 4)))\ngoto daex;\n} else {\ndaex:\nif (tlb_type == hypervisor)\nsun4v_data_access_exception(regs, sfar, sfsr);\nelse\nspitfire_data_access_exception(regs, sfsr, sfar);\nreturn;\n}\nadvance(regs);\n}", "label": 0}
{"index": 175523, "code": "asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\nenum direction dir = decode_direction(insn);\nint size = decode_access_size(regs, insn);\nint orig_asi, asi;\ncurrent_thread_info()->kern_una_regs = regs;\ncurrent_thread_info()->kern_una_insn = insn;\norig_asi = asi = decode_asi(insn, regs);\nif (asi == ASI_AIUS) {\nkernel_mna_trap_fault(0);\nreturn;\n}\nlog_unaligned(regs);\nif (!ok_for_kernel(insn) || dir == both) {\nprintk(\"Unsupported unaligned load/store trap for kernel \"\n\"at <%016lx>.\\n\", regs->tpc);\nunaligned_panic(\"Kernel does fpu/atomic \"\n\"unaligned load/store.\", regs);\nkernel_mna_trap_fault(0);\n} else {\nunsigned long addr, *reg_addr;\nint err;\naddr = compute_effective_address(regs, insn,\n((insn >> 25) & 0x1f));\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\nswitch (asi) {\ncase ASI_NL:\ncase ASI_AIUPL:\ncase ASI_AIUSL:\ncase ASI_PL:\ncase ASI_SL:\ncase ASI_PNFL:\ncase ASI_SNFL:\nasi &= ~0x08;\nbreak;\n}\nswitch (dir) {\ncase load:\nreg_addr = fetch_reg_addr(((insn>>25)&0x1f), regs);\nerr = do_int_load(reg_addr, size,\n(unsigned long *) addr,\ndecode_signedness(insn), asi);\nif (likely(!err) && unlikely(asi != orig_asi)) {\nunsigned long val_in = *reg_addr;\nswitch (size) {\ncase 2:\nval_in = swab16(val_in);\nbreak;\ncase 4:\nval_in = swab32(val_in);\nbreak;\ncase 8:\nval_in = swab64(val_in);\nbreak;\ncase 16:\ndefault:\nBUG();\nbreak;\n}\n*reg_addr = val_in;\n}\nbreak;\ncase store:\nerr = do_int_store(((insn>>25)&0x1f), size,\n(unsigned long *) addr, regs,\nasi, orig_asi);\nbreak;\ndefault:\npanic(\"Impossible kernel unaligned trap.\");\n}\nif (unlikely(err))\nkernel_mna_trap_fault(1);\nelse\nadvance(regs);\n}\n}", "contrast": "asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\nenum direction dir = decode_direction(insn);\nint size = decode_access_size(regs, insn);\nint orig_asi, asi;\ncurrent_thread_info()->kern_una_regs = regs;\ncurrent_thread_info()->kern_una_insn = insn;\norig_asi = asi = decode_asi(insn, regs);\nif (asi == ASI_AIUS) {\nkernel_mna_trap_fault(0);\nreturn;\n}\nlog_unaligned(regs);\nif (!ok_for_kernel(insn) || dir == both) {\nprintk(\"Unsupported unaligned load/store trap for kernel \"\n\"at <%016lx>.\\n\", regs->tpc);\nunaligned_panic(\"Kernel does fpu/atomic \"\n\"unaligned load/store.\", regs);\nkernel_mna_trap_fault(0);\n} else {\nunsigned long addr, *reg_addr;\nint err;\naddr = compute_effective_address(regs, insn,\n((insn >> 25) & 0x1f));\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\nswitch (asi) {\ncase ASI_NL:\ncase ASI_AIUPL:\ncase ASI_AIUSL:\ncase ASI_PL:\ncase ASI_SL:\ncase ASI_PNFL:\ncase ASI_SNFL:\nasi &= ~0x08;\nbreak;\n}\nswitch (dir) {\ncase load:\nreg_addr = fetch_reg_addr(((insn>>25)&0x1f), regs);\nerr = do_int_load(reg_addr, size,\n(unsigned long *) addr,\ndecode_signedness(insn), asi);\nif (likely(!err) && unlikely(asi != orig_asi)) {\nunsigned long val_in = *reg_addr;\nswitch (size) {\ncase 2:\nval_in = swab16(val_in);\nbreak;\ncase 4:\nval_in = swab32(val_in);\nbreak;\ncase 8:\nval_in = swab64(val_in);\nbreak;\ncase 16:\ndefault:\nBUG();\nbreak;\n}\n*reg_addr = val_in;\n}\nbreak;\ncase store:\nerr = do_int_store(((insn>>25)&0x1f), size,\n(unsigned long *) addr, regs,\nasi, orig_asi);\nbreak;\ndefault:\npanic(\"Impossible kernel unaligned trap.\");\n}\nif (unlikely(err))\nkernel_mna_trap_fault(1);\nelse\nadvance(regs);\n}\n}", "label": 0}
{"index": 175536, "code": "do_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\nstruct vm_area_struct *vma;\nstruct task_struct *tsk;\nunsigned long address;\nstruct mm_struct *mm;\nint fault;\nint write = error_code & PF_WRITE;\nunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |\n(write ? FAULT_FLAG_WRITE : 0);\ntsk = current;\nmm = tsk->mm;\naddress = read_cr2();\nif (kmemcheck_active(regs))\nkmemcheck_hide(regs);\nprefetchw(&mm->mmap_sem);\nif (unlikely(kmmio_fault(regs, address)))\nreturn;\nif (unlikely(fault_in_kernel_space(address))) {\nif (!(error_code & (PF_RSVD | PF_USER | PF_PROT))) {\nif (vmalloc_fault(address) >= 0)\nreturn;\nif (kmemcheck_fault(regs, address, error_code))\nreturn;\n}\nif (spurious_fault(error_code, address))\nreturn;\nif (notify_page_fault(regs))\nreturn;\nbad_area_nosemaphore(regs, error_code, address);\nreturn;\n}\nif (unlikely(notify_page_fault(regs)))\nreturn;\nif (user_mode_vm(regs)) {\nlocal_irq_enable();\nerror_code |= PF_USER;\n} else {\nif (regs->flags & X86_EFLAGS_IF)\nlocal_irq_enable();\n}\nif (unlikely(error_code & PF_RSVD))\npgtable_bad(regs, error_code, address);\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\nif (unlikely(in_atomic() || !mm)) {\nbad_area_nosemaphore(regs, error_code, address);\nreturn;\n}\nif (unlikely(!down_read_trylock(&mm->mmap_sem))) {\nif ((error_code & PF_USER) == 0 &&\n!search_exception_tables(regs->ip)) {\nbad_area_nosemaphore(regs, error_code, address);\nreturn;\n}\nretry:\ndown_read(&mm->mmap_sem);\n} else {\nmight_sleep();\n}\nvma = find_vma(mm, address);\nif (unlikely(!vma)) {\nbad_area(regs, error_code, address);\nreturn;\n}\nif (likely(vma->vm_start <= address))\ngoto good_area;\nif (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {\nbad_area(regs, error_code, address);\nreturn;\n}\nif (error_code & PF_USER) {\nif (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {\nbad_area(regs, error_code, address);\nreturn;\n}\n}\nif (unlikely(expand_stack(vma, address))) {\nbad_area(regs, error_code, address);\nreturn;\n}\ngood_area:\nif (unlikely(access_error(error_code, vma))) {\nbad_area_access_error(regs, error_code, address);\nreturn;\n}\nfault = handle_mm_fault(mm, vma, address, flags);\nif (unlikely(fault & (VM_FAULT_RETRY|VM_FAULT_ERROR))) {\nif (mm_fault_error(regs, error_code, address, fault))\nreturn;\n}\nif (flags & FAULT_FLAG_ALLOW_RETRY) {\nif (fault & VM_FAULT_MAJOR) {\ntsk->maj_flt++;\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\nregs, address);\n} else {\ntsk->min_flt++;\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\nregs, address);\n}\nif (fault & VM_FAULT_RETRY) {\nflags &= ~FAULT_FLAG_ALLOW_RETRY;\ngoto retry;\n}\n}\ncheck_v8086_mode(regs, address, tsk);\nup_read(&mm->mmap_sem);\n}", "contrast": "do_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\nstruct vm_area_struct *vma;\nstruct task_struct *tsk;\nunsigned long address;\nstruct mm_struct *mm;\nint fault;\nint write = error_code & PF_WRITE;\nunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |\n(write ? FAULT_FLAG_WRITE : 0);\ntsk = current;\nmm = tsk->mm;\naddress = read_cr2();\nif (kmemcheck_active(regs))\nkmemcheck_hide(regs);\nprefetchw(&mm->mmap_sem);\nif (unlikely(kmmio_fault(regs, address)))\nreturn;\nif (unlikely(fault_in_kernel_space(address))) {\nif (!(error_code & (PF_RSVD | PF_USER | PF_PROT))) {\nif (vmalloc_fault(address) >= 0)\nreturn;\nif (kmemcheck_fault(regs, address, error_code))\nreturn;\n}\nif (spurious_fault(error_code, address))\nreturn;\nif (notify_page_fault(regs))\nreturn;\nbad_area_nosemaphore(regs, error_code, address);\nreturn;\n}\nif (unlikely(notify_page_fault(regs)))\nreturn;\nif (user_mode_vm(regs)) {\nlocal_irq_enable();\nerror_code |= PF_USER;\n} else {\nif (regs->flags & X86_EFLAGS_IF)\nlocal_irq_enable();\n}\nif (unlikely(error_code & PF_RSVD))\npgtable_bad(regs, error_code, address);\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\nif (unlikely(in_atomic() || !mm)) {\nbad_area_nosemaphore(regs, error_code, address);\nreturn;\n}\nif (unlikely(!down_read_trylock(&mm->mmap_sem))) {\nif ((error_code & PF_USER) == 0 &&\n!search_exception_tables(regs->ip)) {\nbad_area_nosemaphore(regs, error_code, address);\nreturn;\n}\nretry:\ndown_read(&mm->mmap_sem);\n} else {\nmight_sleep();\n}\nvma = find_vma(mm, address);\nif (unlikely(!vma)) {\nbad_area(regs, error_code, address);\nreturn;\n}\nif (likely(vma->vm_start <= address))\ngoto good_area;\nif (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {\nbad_area(regs, error_code, address);\nreturn;\n}\nif (error_code & PF_USER) {\nif (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {\nbad_area(regs, error_code, address);\nreturn;\n}\n}\nif (unlikely(expand_stack(vma, address))) {\nbad_area(regs, error_code, address);\nreturn;\n}\ngood_area:\nif (unlikely(access_error(error_code, vma))) {\nbad_area_access_error(regs, error_code, address);\nreturn;\n}\nfault = handle_mm_fault(mm, vma, address, flags);\nif (unlikely(fault & (VM_FAULT_RETRY|VM_FAULT_ERROR))) {\nif (mm_fault_error(regs, error_code, address, fault))\nreturn;\n}\nif (flags & FAULT_FLAG_ALLOW_RETRY) {\nif (fault & VM_FAULT_MAJOR) {\ntsk->maj_flt++;\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\nregs, address);\n} else {\ntsk->min_flt++;\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\nregs, address);\n}\nif (fault & VM_FAULT_RETRY) {\nflags &= ~FAULT_FLAG_ALLOW_RETRY;\ngoto retry;\n}\n}\ncheck_v8086_mode(regs, address, tsk);\nup_read(&mm->mmap_sem);\n}", "label": 0}
{"index": 175542, "code": "static void perf_event_mmap_output(struct perf_event *event,\nstruct perf_mmap_event *mmap_event)\n{\nstruct perf_output_handle handle;\nstruct perf_sample_data sample;\nint size = mmap_event->event_id.header.size;\nint ret;\nperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\nret = perf_output_begin(&handle, event,\nmmap_event->event_id.header.size, 0, 0);\nif (ret)\ngoto out;\nmmap_event->event_id.pid = perf_event_pid(event, current);\nmmap_event->event_id.tid = perf_event_tid(event, current);\nperf_output_put(&handle, mmap_event->event_id);\n__output_copy(&handle, mmap_event->file_name,\nmmap_event->file_size);\nperf_event__output_id_sample(event, &handle, &sample);\nperf_output_end(&handle);\nout:\nmmap_event->event_id.header.size = size;\n}", "contrast": "static void perf_event_mmap_output(struct perf_event *event,\nstruct perf_mmap_event *mmap_event)\n{\nstruct perf_output_handle handle;\nstruct perf_sample_data sample;\nint size = mmap_event->event_id.header.size;\nint ret;\nperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\nret = perf_output_begin(&handle, event,\nmmap_event->event_id.header.size, 0);\nif (ret)\ngoto out;\nmmap_event->event_id.pid = perf_event_pid(event, current);\nmmap_event->event_id.tid = perf_event_tid(event, current);\nperf_output_put(&handle, mmap_event->event_id);\n__output_copy(&handle, mmap_event->file_name,\nmmap_event->file_size);\nperf_event__output_id_sample(event, &handle, &sample);\nperf_output_end(&handle);\nout:\nmmap_event->event_id.header.size = size;\n}", "label": 0}
{"index": 175544, "code": "int perf_event_overflow(struct perf_event *event, int nmi,\nstruct perf_sample_data *data,\nstruct pt_regs *regs)\n{\nreturn __perf_event_overflow(event, nmi, 1, data, regs);\n}", "contrast": "int perf_event_overflow(struct perf_event *event, int nmi,\nint perf_event_overflow(struct perf_event *event,\nstruct perf_sample_data *data,\nstruct pt_regs *regs)\n{\nreturn __perf_event_overflow(event, 1, data, regs);\n}", "label": 0}
{"index": 175552, "code": "int perf_output_begin(struct perf_output_handle *handle,\nstruct perf_event *event, unsigned int size,\nint nmi, int sample)\n{\nstruct ring_buffer *rb;\nunsigned long tail, offset, head;\nint have_lost;\nstruct perf_sample_data sample_data;\nstruct {\nstruct perf_event_header header;\nu64\t\t\t id;\nu64\t\t\t lost;\n} lost_event;\nrcu_read_lock();\nif (event->parent)\nevent = event->parent;\nrb = rcu_dereference(event->rb);\nif (!rb)\ngoto out;\nhandle->rb\t= rb;\nhandle->event\t= event;\nhandle->nmi\t= nmi;\nhandle->sample\t= sample;\nif (!rb->nr_pages)\ngoto out;\nhave_lost = local_read(&rb->lost);\nif (have_lost) {\nlost_event.header.size = sizeof(lost_event);\nperf_event_header__init_id(&lost_event.header, &sample_data,\nevent);\nsize += lost_event.header.size;\n}\nperf_output_get_handle(handle);\ndo {\ntail = ACCESS_ONCE(rb->user_page->data_tail);\nsmp_rmb();\noffset = head = local_read(&rb->head);\nhead += size;\nif (unlikely(!perf_output_space(rb, tail, offset, head)))\ngoto fail;\n} while (local_cmpxchg(&rb->head, offset, head) != offset);\nif (head - local_read(&rb->wakeup) > rb->watermark)\nlocal_add(rb->watermark, &rb->wakeup);\nhandle->page = offset >> (PAGE_SHIFT + page_order(rb));\nhandle->page &= rb->nr_pages - 1;\nhandle->size = offset & ((PAGE_SIZE << page_order(rb)) - 1);\nhandle->addr = rb->data_pages[handle->page];\nhandle->addr += handle->size;\nhandle->size = (PAGE_SIZE << page_order(rb)) - handle->size;\nif (have_lost) {\nlost_event.header.type = PERF_RECORD_LOST;\nlost_event.header.misc = 0;\nlost_event.id          = event->id;\nlost_event.lost        = local_xchg(&rb->lost, 0);\nperf_output_put(handle, lost_event);\nperf_event__output_id_sample(event, handle, &sample_data);\n}\nreturn 0;\nfail:\nlocal_inc(&rb->lost);\nperf_output_put_handle(handle);\nout:\nrcu_read_unlock();\nreturn -ENOSPC;\n}", "contrast": "int perf_output_begin(struct perf_output_handle *handle,\nstruct perf_event *event, unsigned int size,\nint sample)\n{\nstruct ring_buffer *rb;\nunsigned long tail, offset, head;\nint have_lost;\nstruct perf_sample_data sample_data;\nstruct {\nstruct perf_event_header header;\nu64\t\t\t id;\nu64\t\t\t lost;\n} lost_event;\nrcu_read_lock();\nif (event->parent)\nevent = event->parent;\nrb = rcu_dereference(event->rb);\nif (!rb)\ngoto out;\nhandle->rb\t= rb;\nhandle->event\t= event;\nhandle->sample\t= sample;\nif (!rb->nr_pages)\ngoto out;\nhave_lost = local_read(&rb->lost);\nif (have_lost) {\nlost_event.header.size = sizeof(lost_event);\nperf_event_header__init_id(&lost_event.header, &sample_data,\nevent);\nsize += lost_event.header.size;\n}\nperf_output_get_handle(handle);\ndo {\ntail = ACCESS_ONCE(rb->user_page->data_tail);\nsmp_rmb();\noffset = head = local_read(&rb->head);\nhead += size;\nif (unlikely(!perf_output_space(rb, tail, offset, head)))\ngoto fail;\n} while (local_cmpxchg(&rb->head, offset, head) != offset);\nif (head - local_read(&rb->wakeup) > rb->watermark)\nlocal_add(rb->watermark, &rb->wakeup);\nhandle->page = offset >> (PAGE_SHIFT + page_order(rb));\nhandle->page &= rb->nr_pages - 1;\nhandle->size = offset & ((PAGE_SIZE << page_order(rb)) - 1);\nhandle->addr = rb->data_pages[handle->page];\nhandle->addr += handle->size;\nhandle->size = (PAGE_SIZE << page_order(rb)) - handle->size;\nif (have_lost) {\nlost_event.header.type = PERF_RECORD_LOST;\nlost_event.header.misc = 0;\nlost_event.id          = event->id;\nlost_event.lost        = local_xchg(&rb->lost, 0);\nperf_output_put(handle, lost_event);\nperf_event__output_id_sample(event, handle, &sample_data);\n}\nreturn 0;\nfail:\nlocal_inc(&rb->lost);\nperf_output_put_handle(handle);\nout:\nrcu_read_unlock();\nreturn -ENOSPC;\n}", "label": 0}
{"index": 175568, "code": "static int nl80211_start_sched_scan(struct sk_buff *skb,\nstruct genl_info *info)\n{\nstruct cfg80211_sched_scan_request *request;\nstruct cfg80211_registered_device *rdev = info->user_ptr[0];\nstruct net_device *dev = info->user_ptr[1];\nstruct nlattr *attr;\nstruct wiphy *wiphy;\nint err, tmp, n_ssids = 0, n_channels, i;\nu32 interval;\nenum ieee80211_band band;\nsize_t ie_len;\nif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n!rdev->ops->sched_scan_start)\nreturn -EOPNOTSUPP;\nif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\nreturn -EINVAL;\nif (rdev->sched_scan_req)\nreturn -EINPROGRESS;\nif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\nreturn -EINVAL;\ninterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\nif (interval == 0)\nreturn -EINVAL;\nwiphy = &rdev->wiphy;\nif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\nn_channels = validate_scan_freqs(\ninfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\nif (!n_channels)\nreturn -EINVAL;\n} else {\nn_channels = 0;\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\nif (wiphy->bands[band])\nn_channels += wiphy->bands[band]->n_channels;\n}\nif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\nnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\ntmp)\nn_ssids++;\nif (n_ssids > wiphy->max_scan_ssids)\nreturn -EINVAL;\nif (info->attrs[NL80211_ATTR_IE])\nie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\nelse\nie_len = 0;\nif (ie_len > wiphy->max_scan_ie_len)\nreturn -EINVAL;\nrequest = kzalloc(sizeof(*request)\n+ sizeof(*request->ssids) * n_ssids\n+ sizeof(*request->channels) * n_channels\n+ ie_len, GFP_KERNEL);\nif (!request)\nreturn -ENOMEM;\nif (n_ssids)\nrequest->ssids = (void *)&request->channels[n_channels];\nrequest->n_ssids = n_ssids;\nif (ie_len) {\nif (request->ssids)\nrequest->ie = (void *)(request->ssids + n_ssids);\nelse\nrequest->ie = (void *)(request->channels + n_channels);\n}\ni = 0;\nif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\nnla_for_each_nested(attr,\ninfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\ntmp) {\nstruct ieee80211_channel *chan;\nchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\nif (!chan) {\nerr = -EINVAL;\ngoto out_free;\n}\nif (chan->flags & IEEE80211_CHAN_DISABLED)\ncontinue;\nrequest->channels[i] = chan;\ni++;\n}\n} else {\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\nint j;\nif (!wiphy->bands[band])\ncontinue;\nfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\nstruct ieee80211_channel *chan;\nchan = &wiphy->bands[band]->channels[j];\nif (chan->flags & IEEE80211_CHAN_DISABLED)\ncontinue;\nrequest->channels[i] = chan;\ni++;\n}\n}\n}\nif (!i) {\nerr = -EINVAL;\ngoto out_free;\n}\nrequest->n_channels = i;\ni = 0;\nif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\nnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\ntmp) {\nif (request->ssids[i].ssid_len >\nIEEE80211_MAX_SSID_LEN) {\nerr = -EINVAL;\ngoto out_free;\n}\nmemcpy(request->ssids[i].ssid, nla_data(attr),\nnla_len(attr));\nrequest->ssids[i].ssid_len = nla_len(attr);\ni++;\n}\n}\nif (info->attrs[NL80211_ATTR_IE]) {\nrequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\nmemcpy((void *)request->ie,\nnla_data(info->attrs[NL80211_ATTR_IE]),\nrequest->ie_len);\n}\nrequest->dev = dev;\nrequest->wiphy = &rdev->wiphy;\nrequest->interval = interval;\nerr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\nif (!err) {\nrdev->sched_scan_req = request;\nnl80211_send_sched_scan(rdev, dev,\nNL80211_CMD_START_SCHED_SCAN);\ngoto out;\n}\nout_free:\nkfree(request);\nout:\nreturn err;\n}", "contrast": "static int nl80211_start_sched_scan(struct sk_buff *skb,\nstruct genl_info *info)\n{\nstruct cfg80211_sched_scan_request *request;\nstruct cfg80211_registered_device *rdev = info->user_ptr[0];\nstruct net_device *dev = info->user_ptr[1];\nstruct nlattr *attr;\nstruct wiphy *wiphy;\nint err, tmp, n_ssids = 0, n_channels, i;\nu32 interval;\nenum ieee80211_band band;\nsize_t ie_len;\nif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n!rdev->ops->sched_scan_start)\nreturn -EOPNOTSUPP;\nif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\nreturn -EINVAL;\nif (rdev->sched_scan_req)\nreturn -EINPROGRESS;\nif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\nreturn -EINVAL;\ninterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\nif (interval == 0)\nreturn -EINVAL;\nwiphy = &rdev->wiphy;\nif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\nn_channels = validate_scan_freqs(\ninfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\nif (!n_channels)\nreturn -EINVAL;\n} else {\nn_channels = 0;\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\nif (wiphy->bands[band])\nn_channels += wiphy->bands[band]->n_channels;\n}\nif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\nnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\ntmp)\nn_ssids++;\nif (n_ssids > wiphy->max_scan_ssids)\nreturn -EINVAL;\nif (info->attrs[NL80211_ATTR_IE])\nie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\nelse\nie_len = 0;\nif (ie_len > wiphy->max_scan_ie_len)\nreturn -EINVAL;\nrequest = kzalloc(sizeof(*request)\n+ sizeof(*request->ssids) * n_ssids\n+ sizeof(*request->channels) * n_channels\n+ ie_len, GFP_KERNEL);\nif (!request)\nreturn -ENOMEM;\nif (n_ssids)\nrequest->ssids = (void *)&request->channels[n_channels];\nrequest->n_ssids = n_ssids;\nif (ie_len) {\nif (request->ssids)\nrequest->ie = (void *)(request->ssids + n_ssids);\nelse\nrequest->ie = (void *)(request->channels + n_channels);\n}\ni = 0;\nif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\nnla_for_each_nested(attr,\ninfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\ntmp) {\nstruct ieee80211_channel *chan;\nchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\nif (!chan) {\nerr = -EINVAL;\ngoto out_free;\n}\nif (chan->flags & IEEE80211_CHAN_DISABLED)\ncontinue;\nrequest->channels[i] = chan;\ni++;\n}\n} else {\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\nint j;\nif (!wiphy->bands[band])\ncontinue;\nfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\nstruct ieee80211_channel *chan;\nchan = &wiphy->bands[band]->channels[j];\nif (chan->flags & IEEE80211_CHAN_DISABLED)\ncontinue;\nrequest->channels[i] = chan;\ni++;\n}\n}\n}\nif (!i) {\nerr = -EINVAL;\ngoto out_free;\n}\nrequest->n_channels = i;\ni = 0;\nif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\nnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\ntmp) {\nrequest->ssids[i].ssid_len = nla_len(attr);\nif (request->ssids[i].ssid_len >\nIEEE80211_MAX_SSID_LEN) {\nerr = -EINVAL;\ngoto out_free;\n}\nmemcpy(request->ssids[i].ssid, nla_data(attr),\nnla_len(attr));\ni++;\n}\n}\nif (info->attrs[NL80211_ATTR_IE]) {\nrequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\nmemcpy((void *)request->ie,\nnla_data(info->attrs[NL80211_ATTR_IE]),\nrequest->ie_len);\n}\nrequest->dev = dev;\nrequest->wiphy = &rdev->wiphy;\nrequest->interval = interval;\nerr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\nif (!err) {\nrdev->sched_scan_req = request;\nnl80211_send_sched_scan(rdev, dev,\nNL80211_CMD_START_SCHED_SCAN);\ngoto out;\n}\nout_free:\nkfree(request);\nout:\nreturn err;\n}", "label": 0}
{"index": 175630, "code": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\nlong i;\n#if !HAVE_FAST_UNALIGNED\nif((long)src2 & (sizeof(long)-1)){\nfor(i=0; i+7<w; i+=8){\ndst[i+0] = src1[i+0]-src2[i+0];\ndst[i+1] = src1[i+1]-src2[i+1];\ndst[i+2] = src1[i+2]-src2[i+2];\ndst[i+3] = src1[i+3]-src2[i+3];\ndst[i+4] = src1[i+4]-src2[i+4];\ndst[i+5] = src1[i+5]-src2[i+5];\ndst[i+6] = src1[i+6]-src2[i+6];\ndst[i+7] = src1[i+7]-src2[i+7];\n}\n}else\n#endif\nfor(i=0; i<=w-sizeof(long); i+=sizeof(long)){\nlong a = *(long*)(src1+i);\nlong b = *(long*)(src2+i);\n*(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n}\nfor(; i<w; i++)\ndst[i+0] = src1[i+0]-src2[i+0];\n}", "contrast": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\nlong i;\n#if !HAVE_FAST_UNALIGNED\nif((long)src2 & (sizeof(long)-1)){\nfor(i=0; i+7<w; i+=8){\ndst[i+0] = src1[i+0]-src2[i+0];\ndst[i+1] = src1[i+1]-src2[i+1];\ndst[i+2] = src1[i+2]-src2[i+2];\ndst[i+3] = src1[i+3]-src2[i+3];\ndst[i+4] = src1[i+4]-src2[i+4];\ndst[i+5] = src1[i+5]-src2[i+5];\ndst[i+6] = src1[i+6]-src2[i+6];\ndst[i+7] = src1[i+7]-src2[i+7];\n}\n}else\n#endif\nfor(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\nlong a = *(long*)(src1+i);\nlong b = *(long*)(src2+i);\n*(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n}\nfor(; i<w; i++)\ndst[i+0] = src1[i+0]-src2[i+0];\n}", "label": 0}
{"index": 175652, "code": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\nnetdev_features_t features)\n{\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\nunsigned int mss;\nunsigned int unfrag_ip6hlen, unfrag_len;\nstruct frag_hdr *fptr;\nu8 *packet_start, *prevhdr;\nu8 nexthdr;\nu8 frag_hdr_sz = sizeof(struct frag_hdr);\nint offset;\n__wsum csum;\nint tnl_hlen;\nmss = skb_shinfo(skb)->gso_size;\nif (unlikely(skb->len <= mss))\ngoto out;\nif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\nint type = skb_shinfo(skb)->gso_type;\nif (unlikely(type & ~(SKB_GSO_UDP |\nSKB_GSO_DODGY |\nSKB_GSO_UDP_TUNNEL |\nSKB_GSO_GRE |\nSKB_GSO_IPIP |\nSKB_GSO_SIT |\nSKB_GSO_MPLS) ||\n!(type & (SKB_GSO_UDP))))\ngoto out;\nskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\nsegs = NULL;\ngoto out;\n}\nif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\nsegs = skb_udp_tunnel_segment(skb, features);\nelse {\noffset = skb_checksum_start_offset(skb);\ncsum = skb_checksum(skb, offset, skb->len - offset, 0);\noffset += skb->csum_offset;\n*(__sum16 *)(skb->data + offset) = csum_fold(csum);\nskb->ip_summed = CHECKSUM_NONE;\ntnl_hlen = skb_tnl_header_len(skb);\nif (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {\nif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\ngoto out;\n}\nunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\nnexthdr = *prevhdr;\n*prevhdr = NEXTHDR_FRAGMENT;\nunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\nunfrag_ip6hlen + tnl_hlen;\npacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\nmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\nSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\nskb->mac_header -= frag_hdr_sz;\nskb->network_header -= frag_hdr_sz;\nfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\nfptr->nexthdr = nexthdr;\nfptr->reserved = 0;\nipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\nsegs = skb_segment(skb, features);\n}\nout:\nreturn segs;\n}", "contrast": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\nnetdev_features_t features)\n{\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\nunsigned int mss;\nunsigned int unfrag_ip6hlen, unfrag_len;\nstruct frag_hdr *fptr;\nu8 *packet_start, *prevhdr;\nu8 nexthdr;\nu8 frag_hdr_sz = sizeof(struct frag_hdr);\nint offset;\n__wsum csum;\nint tnl_hlen;\nmss = skb_shinfo(skb)->gso_size;\nif (unlikely(skb->len <= mss))\ngoto out;\nif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\nint type = skb_shinfo(skb)->gso_type;\nif (unlikely(type & ~(SKB_GSO_UDP |\nSKB_GSO_DODGY |\nSKB_GSO_UDP_TUNNEL |\nSKB_GSO_GRE |\nSKB_GSO_IPIP |\nSKB_GSO_SIT |\nSKB_GSO_MPLS) ||\n!(type & (SKB_GSO_UDP))))\ngoto out;\nskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\nsegs = NULL;\ngoto out;\n}\nif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\nsegs = skb_udp_tunnel_segment(skb, features);\nelse {\noffset = skb_checksum_start_offset(skb);\ncsum = skb_checksum(skb, offset, skb->len - offset, 0);\noffset += skb->csum_offset;\n*(__sum16 *)(skb->data + offset) = csum_fold(csum);\nskb->ip_summed = CHECKSUM_NONE;\ntnl_hlen = skb_tnl_header_len(skb);\nif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\nif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\ngoto out;\n}\nunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\nnexthdr = *prevhdr;\n*prevhdr = NEXTHDR_FRAGMENT;\nunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\nunfrag_ip6hlen + tnl_hlen;\npacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\nmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\nSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\nskb->mac_header -= frag_hdr_sz;\nskb->network_header -= frag_hdr_sz;\nfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\nfptr->nexthdr = nexthdr;\nfptr->reserved = 0;\nipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\nsegs = skb_segment(skb, features);\n}\nout:\nreturn segs;\n}", "label": 0}
{"index": 175680, "code": "static inline int ip6_ufo_append_data(struct sock *sk,\nint getfrag(void *from, char *to, int offset, int len,\nint odd, struct sk_buff *skb),\nvoid *from, int length, int hh_len, int fragheaderlen,\nint transhdrlen, int mtu,unsigned int flags,\nstruct rt6_info *rt)\n{\nstruct sk_buff *skb;\nint err;\nif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\nskb = sock_alloc_send_skb(sk,\nhh_len + fragheaderlen + transhdrlen + 20,\n(flags & MSG_DONTWAIT), &err);\nif (skb == NULL)\nreturn err;\nskb_reserve(skb, hh_len);\nskb_put(skb,fragheaderlen + transhdrlen);\nskb_reset_network_header(skb);\nskb->transport_header = skb->network_header + fragheaderlen;\nskb->protocol = htons(ETH_P_IPV6);\nskb->ip_summed = CHECKSUM_PARTIAL;\nskb->csum = 0;\n}\nerr = skb_append_datato_frags(sk,skb, getfrag, from,\n(length - transhdrlen));\nif (!err) {\nstruct frag_hdr fhdr;\nskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\nsizeof(struct frag_hdr)) & ~7;\nskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\nipv6_select_ident(&fhdr, rt);\nskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n__skb_queue_tail(&sk->sk_write_queue, skb);\nreturn 0;\n}\nkfree_skb(skb);\nreturn err;\n}", "contrast": "static inline int ip6_ufo_append_data(struct sock *sk,\nint getfrag(void *from, char *to, int offset, int len,\nint odd, struct sk_buff *skb),\nvoid *from, int length, int hh_len, int fragheaderlen,\nint transhdrlen, int mtu,unsigned int flags,\nstruct rt6_info *rt)\n{\nstruct sk_buff *skb;\nint err;\nif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\nstruct frag_hdr fhdr;\nskb = sock_alloc_send_skb(sk,\nhh_len + fragheaderlen + transhdrlen + 20,\n(flags & MSG_DONTWAIT), &err);\nif (skb == NULL)\nreturn err;\nskb_reserve(skb, hh_len);\nskb_put(skb,fragheaderlen + transhdrlen);\nskb_reset_network_header(skb);\nskb->transport_header = skb->network_header + fragheaderlen;\nskb->protocol = htons(ETH_P_IPV6);\nskb->ip_summed = CHECKSUM_PARTIAL;\nskb->csum = 0;\nskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\nsizeof(struct frag_hdr)) & ~7;\nskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\nipv6_select_ident(&fhdr, rt);\nskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n__skb_queue_tail(&sk->sk_write_queue, skb);\n}\nreturn skb_append_datato_frags(sk, skb, getfrag, from,\n(length - transhdrlen));\n}", "label": 0}
{"index": 175707, "code": "static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\n{\nstruct socket *sock, *oldsock;\nstruct vhost_virtqueue *vq;\nstruct vhost_net_virtqueue *nvq;\nstruct vhost_net_ubuf_ref *ubufs, *oldubufs = NULL;\nint r;\nmutex_lock(&n->dev.mutex);\nr = vhost_dev_check_owner(&n->dev);\nif (r)\ngoto err;\nif (index >= VHOST_NET_VQ_MAX) {\nr = -ENOBUFS;\ngoto err;\n}\nvq = &n->vqs[index].vq;\nnvq = &n->vqs[index];\nmutex_lock(&vq->mutex);\nif (!vhost_vq_access_ok(vq)) {\nr = -EFAULT;\ngoto err_vq;\n}\nsock = get_socket(fd);\nif (IS_ERR(sock)) {\nr = PTR_ERR(sock);\ngoto err_vq;\n}\noldsock = rcu_dereference_protected(vq->private_data,\nlockdep_is_held(&vq->mutex));\nif (sock != oldsock) {\nubufs = vhost_net_ubuf_alloc(vq,\nsock && vhost_sock_zcopy(sock));\nif (IS_ERR(ubufs)) {\nr = PTR_ERR(ubufs);\ngoto err_ubufs;\n}\nvhost_net_disable_vq(n, vq);\nrcu_assign_pointer(vq->private_data, sock);\nr = vhost_init_used(vq);\nif (r)\ngoto err_used;\nr = vhost_net_enable_vq(n, vq);\nif (r)\ngoto err_used;\noldubufs = nvq->ubufs;\nnvq->ubufs = ubufs;\nn->tx_packets = 0;\nn->tx_zcopy_err = 0;\nn->tx_flush = false;\n}\nmutex_unlock(&vq->mutex);\nif (oldubufs) {\nvhost_net_ubuf_put_and_wait(oldubufs);\nmutex_lock(&vq->mutex);\nvhost_zerocopy_signal_used(n, vq);\nmutex_unlock(&vq->mutex);\n}\nif (oldsock) {\nvhost_net_flush_vq(n, index);\nfput(oldsock->file);\n}\nmutex_unlock(&n->dev.mutex);\nreturn 0;\nerr_used:\nrcu_assign_pointer(vq->private_data, oldsock);\nvhost_net_enable_vq(n, vq);\nif (ubufs)\nvhost_net_ubuf_put_and_wait(ubufs);\nerr_ubufs:\nfput(sock->file);\nerr_vq:\nmutex_unlock(&vq->mutex);\nerr:\nmutex_unlock(&n->dev.mutex);\nreturn r;\n}", "contrast": "static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\n{\nstruct socket *sock, *oldsock;\nstruct vhost_virtqueue *vq;\nstruct vhost_net_virtqueue *nvq;\nstruct vhost_net_ubuf_ref *ubufs, *oldubufs = NULL;\nint r;\nmutex_lock(&n->dev.mutex);\nr = vhost_dev_check_owner(&n->dev);\nif (r)\ngoto err;\nif (index >= VHOST_NET_VQ_MAX) {\nr = -ENOBUFS;\ngoto err;\n}\nvq = &n->vqs[index].vq;\nnvq = &n->vqs[index];\nmutex_lock(&vq->mutex);\nif (!vhost_vq_access_ok(vq)) {\nr = -EFAULT;\ngoto err_vq;\n}\nsock = get_socket(fd);\nif (IS_ERR(sock)) {\nr = PTR_ERR(sock);\ngoto err_vq;\n}\noldsock = rcu_dereference_protected(vq->private_data,\nlockdep_is_held(&vq->mutex));\nif (sock != oldsock) {\nubufs = vhost_net_ubuf_alloc(vq,\nsock && vhost_sock_zcopy(sock));\nif (IS_ERR(ubufs)) {\nr = PTR_ERR(ubufs);\ngoto err_ubufs;\n}\nvhost_net_disable_vq(n, vq);\nrcu_assign_pointer(vq->private_data, sock);\nr = vhost_init_used(vq);\nif (r)\ngoto err_used;\nr = vhost_net_enable_vq(n, vq);\nif (r)\ngoto err_used;\noldubufs = nvq->ubufs;\nnvq->ubufs = ubufs;\nn->tx_packets = 0;\nn->tx_zcopy_err = 0;\nn->tx_flush = false;\n}\nmutex_unlock(&vq->mutex);\nif (oldubufs) {\nvhost_net_ubuf_put_wait_and_free(oldubufs);\nmutex_lock(&vq->mutex);\nvhost_zerocopy_signal_used(n, vq);\nmutex_unlock(&vq->mutex);\n}\nif (oldsock) {\nvhost_net_flush_vq(n, index);\nfput(oldsock->file);\n}\nmutex_unlock(&n->dev.mutex);\nreturn 0;\nerr_used:\nrcu_assign_pointer(vq->private_data, oldsock);\nvhost_net_enable_vq(n, vq);\nif (ubufs)\nvhost_net_ubuf_put_wait_and_free(ubufs);\nerr_ubufs:\nfput(sock->file);\nerr_vq:\nmutex_unlock(&vq->mutex);\nerr:\nmutex_unlock(&n->dev.mutex);\nreturn r;\n}", "label": 0}
{"index": 175743, "code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\nstruct fb_info *info = file_fb_info(file);\nstruct fb_ops *fb;\nunsigned long off;\nunsigned long start;\nu32 len;\nif (!info)\nreturn -ENODEV;\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\nreturn -EINVAL;\noff = vma->vm_pgoff << PAGE_SHIFT;\nfb = info->fbops;\nif (!fb)\nreturn -ENODEV;\nmutex_lock(&info->mm_lock);\nif (fb->fb_mmap) {\nint res;\nres = fb->fb_mmap(info, vma);\nmutex_unlock(&info->mm_lock);\nreturn res;\n}\nstart = info->fix.smem_start;\nlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\nif (off >= len) {\noff -= len;\nif (info->var.accel_flags) {\nmutex_unlock(&info->mm_lock);\nreturn -EINVAL;\n}\nstart = info->fix.mmio_start;\nlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n}\nmutex_unlock(&info->mm_lock);\nstart &= PAGE_MASK;\nif ((vma->vm_end - vma->vm_start + off) > len)\nreturn -EINVAL;\noff += start;\nvma->vm_pgoff = off >> PAGE_SHIFT;\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\nfb_pgprotect(file, vma, off);\nif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\nvma->vm_end - vma->vm_start, vma->vm_page_prot))\nreturn -EAGAIN;\nreturn 0;\n}", "contrast": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\nstruct fb_info *info = file_fb_info(file);\nstruct fb_ops *fb;\nunsigned long mmio_pgoff;\nunsigned long start;\nu32 len;\nif (!info)\nreturn -ENODEV;\nfb = info->fbops;\nif (!fb)\nreturn -ENODEV;\nmutex_lock(&info->mm_lock);\nif (fb->fb_mmap) {\nint res;\nres = fb->fb_mmap(info, vma);\nmutex_unlock(&info->mm_lock);\nreturn res;\n}\nstart = info->fix.smem_start;\nlen = info->fix.smem_len;\nmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\nif (vma->vm_pgoff >= mmio_pgoff) {\nvma->vm_pgoff -= mmio_pgoff;\nstart = info->fix.mmio_start;\nlen = info->fix.mmio_len;\n}\nmutex_unlock(&info->mm_lock);\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\nfb_pgprotect(file, vma, start);\nreturn vm_iomap_memory(vma, start, len);\n}", "label": 0}
{"index": 175747, "code": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\nstruct crypto_report_aead raead;\nstruct aead_alg *aead = &alg->cra_aead;\nsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\nsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\nraead.blocksize = alg->cra_blocksize;\nraead.maxauthsize = aead->maxauthsize;\nraead.ivsize = aead->ivsize;\nif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\nsizeof(struct crypto_report_aead), &raead))\ngoto nla_put_failure;\nreturn 0;\nnla_put_failure:\nreturn -EMSGSIZE;\n}", "contrast": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\nstruct crypto_report_aead raead;\nstruct aead_alg *aead = &alg->cra_aead;\nstrncpy(raead.type, \"nivaead\", sizeof(raead.type));\nstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\nraead.blocksize = alg->cra_blocksize;\nraead.maxauthsize = aead->maxauthsize;\nraead.ivsize = aead->ivsize;\nif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\nsizeof(struct crypto_report_aead), &raead))\ngoto nla_put_failure;\nreturn 0;\nnla_put_failure:\nreturn -EMSGSIZE;\n}", "label": 0}
{"index": 175760, "code": "sctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,\nconst struct sctp_endpoint *ep,\nconst struct sctp_association *asoc,\nconst sctp_subtype_t type,\nvoid *arg,\nsctp_cmd_seq_t *commands)\n{\nsctp_disposition_t retval;\nstruct sctp_chunk *chunk = arg;\nstruct sctp_association *new_asoc;\nint error = 0;\nchar action;\nstruct sctp_chunk *err_chk_p;\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\ncommands);\nchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\nif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\nsizeof(sctp_chunkhdr_t)))\ngoto nomem;\nnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n&err_chk_p);\nif (!new_asoc) {\nswitch (error) {\ncase -SCTP_IERROR_NOMEM:\ngoto nomem;\ncase -SCTP_IERROR_STALE_COOKIE:\nsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\nerr_chk_p);\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\ncase -SCTP_IERROR_BAD_SIG:\ndefault:\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n}\naction = sctp_tietags_compare(new_asoc, asoc);\nswitch (action) {\ncase 'A':\nretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ncase 'B':\nretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ncase 'C':\nretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ncase 'D':\nretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ndefault:\nretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nbreak;\n}\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\nSCTP_ASOC((struct sctp_association *)asoc));\nreturn retval;\nnomem:\nreturn SCTP_DISPOSITION_NOMEM;\n}", "contrast": "sctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,\nconst struct sctp_endpoint *ep,\nconst struct sctp_association *asoc,\nconst sctp_subtype_t type,\nvoid *arg,\nsctp_cmd_seq_t *commands)\n{\nsctp_disposition_t retval;\nstruct sctp_chunk *chunk = arg;\nstruct sctp_association *new_asoc;\nint error = 0;\nchar action;\nstruct sctp_chunk *err_chk_p;\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\ncommands);\nchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\nif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\nsizeof(sctp_chunkhdr_t)))\ngoto nomem;\nnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n&err_chk_p);\nif (!new_asoc) {\nswitch (error) {\ncase -SCTP_IERROR_NOMEM:\ngoto nomem;\ncase -SCTP_IERROR_STALE_COOKIE:\nsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\nerr_chk_p);\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\ncase -SCTP_IERROR_BAD_SIG:\ndefault:\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n}\naction = sctp_tietags_compare(new_asoc, asoc);\nswitch (action) {\ncase 'A':\nretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ncase 'B':\nretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ncase 'C':\nretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ncase 'D':\nretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\nnew_asoc);\nbreak;\ndefault:\nretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nbreak;\n}\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\nSCTP_ASOC((struct sctp_association *)asoc));\nreturn retval;\nnomem:\nreturn SCTP_DISPOSITION_NOMEM;\n}", "label": 0}
{"index": 175764, "code": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\nsk_read_actor_t recv_actor)\n{\nstruct sk_buff *skb;\nstruct tcp_sock *tp = tcp_sk(sk);\nu32 seq = tp->copied_seq;\nu32 offset;\nint copied = 0;\nif (sk->sk_state == TCP_LISTEN)\nreturn -ENOTCONN;\nwhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\nif (offset < skb->len) {\nint used;\nsize_t len;\nlen = skb->len - offset;\nif (tp->urg_data) {\nu32 urg_offset = tp->urg_seq - seq;\nif (urg_offset < len)\nlen = urg_offset;\nif (!len)\nbreak;\n}\nused = recv_actor(desc, skb, offset, len);\nif (used < 0) {\nif (!copied)\ncopied = used;\nbreak;\n} else if (used <= len) {\nseq += used;\ncopied += used;\noffset += used;\n}\nskb = tcp_recv_skb(sk, seq-1, &offset);\nif (!skb || (offset+1 != skb->len))\nbreak;\n}\nif (tcp_hdr(skb)->fin) {\nsk_eat_skb(sk, skb, 0);\n++seq;\nbreak;\n}\nsk_eat_skb(sk, skb, 0);\nif (!desc->count)\nbreak;\n}\ntp->copied_seq = seq;\ntcp_rcv_space_adjust(sk);\nif (copied > 0)\ntcp_cleanup_rbuf(sk, copied);\nreturn copied;\n}", "contrast": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\nsk_read_actor_t recv_actor)\n{\nstruct sk_buff *skb;\nstruct tcp_sock *tp = tcp_sk(sk);\nu32 seq = tp->copied_seq;\nu32 offset;\nint copied = 0;\nif (sk->sk_state == TCP_LISTEN)\nreturn -ENOTCONN;\nwhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\nif (offset < skb->len) {\nint used;\nsize_t len;\nlen = skb->len - offset;\nif (tp->urg_data) {\nu32 urg_offset = tp->urg_seq - seq;\nif (urg_offset < len)\nlen = urg_offset;\nif (!len)\nbreak;\n}\nused = recv_actor(desc, skb, offset, len);\nif (used < 0) {\nif (!copied)\ncopied = used;\nbreak;\n} else if (used <= len) {\nseq += used;\ncopied += used;\noffset += used;\n}\nskb = tcp_recv_skb(sk, seq-1, &offset);\nif (!skb || (offset+1 != skb->len))\nbreak;\n}\nif (tcp_hdr(skb)->fin) {\nsk_eat_skb(sk, skb, 0);\n++seq;\nbreak;\n}\nsk_eat_skb(sk, skb, 0);\nif (!desc->count)\nbreak;\ntp->copied_seq = seq;\n}\ntp->copied_seq = seq;\ntcp_rcv_space_adjust(sk);\nif (copied > 0)\ntcp_cleanup_rbuf(sk, copied);\nreturn copied;\n}", "label": 0}
{"index": 175771, "code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\nconst struct cred *cred = current_cred();\nkuid_t uid = make_kuid(cred->user_ns, creds->uid);\nkgid_t gid = make_kgid(cred->user_ns, creds->gid);\nif (!uid_valid(uid) || !gid_valid(gid))\nreturn -EINVAL;\nif ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&\n((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\nuid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\ngid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\nreturn 0;\n}\nreturn -EPERM;\n}", "contrast": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\nconst struct cred *cred = current_cred();\nkuid_t uid = make_kuid(cred->user_ns, creds->uid);\nkgid_t gid = make_kgid(cred->user_ns, creds->gid);\nif (!uid_valid(uid) || !gid_valid(gid))\nreturn -EINVAL;\nif ((creds->pid == task_tgid_vnr(current) ||\nns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\nuid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\ngid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\nreturn 0;\n}\nreturn -EPERM;\n}", "label": 0}
{"index": 175779, "code": "static void wdm_in_callback(struct urb *urb)\n{\nstruct wdm_device *desc = urb->context;\nint status = urb->status;\nspin_lock(&desc->iuspin);\nclear_bit(WDM_RESPONDING, &desc->flags);\nif (status) {\nswitch (status) {\ncase -ENOENT:\ndev_dbg(&desc->intf->dev,\n\"nonzero urb status received: -ENOENT\");\ngoto skip_error;\ncase -ECONNRESET:\ndev_dbg(&desc->intf->dev,\n\"nonzero urb status received: -ECONNRESET\");\ngoto skip_error;\ncase -ESHUTDOWN:\ndev_dbg(&desc->intf->dev,\n\"nonzero urb status received: -ESHUTDOWN\");\ngoto skip_error;\ncase -EPIPE:\ndev_err(&desc->intf->dev,\n\"nonzero urb status received: -EPIPE\\n\");\nbreak;\ndefault:\ndev_err(&desc->intf->dev,\n\"Unexpected error %d\\n\", status);\nbreak;\n}\n}\ndesc->rerr = status;\ndesc->reslength = urb->actual_length;\nmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\ndesc->length += desc->reslength;\nskip_error:\nwake_up(&desc->wait);\nset_bit(WDM_READ, &desc->flags);\nspin_unlock(&desc->iuspin);\n}", "contrast": "static void wdm_in_callback(struct urb *urb)\n{\nstruct wdm_device *desc = urb->context;\nint status = urb->status;\nint length = urb->actual_length;\nspin_lock(&desc->iuspin);\nclear_bit(WDM_RESPONDING, &desc->flags);\nif (status) {\nswitch (status) {\ncase -ENOENT:\ndev_dbg(&desc->intf->dev,\n\"nonzero urb status received: -ENOENT\");\ngoto skip_error;\ncase -ECONNRESET:\ndev_dbg(&desc->intf->dev,\n\"nonzero urb status received: -ECONNRESET\");\ngoto skip_error;\ncase -ESHUTDOWN:\ndev_dbg(&desc->intf->dev,\n\"nonzero urb status received: -ESHUTDOWN\");\ngoto skip_error;\ncase -EPIPE:\ndev_err(&desc->intf->dev,\n\"nonzero urb status received: -EPIPE\\n\");\nbreak;\ndefault:\ndev_err(&desc->intf->dev,\n\"Unexpected error %d\\n\", status);\nbreak;\n}\n}\ndesc->rerr = status;\nif (length + desc->length > desc->wMaxCommand) {\nset_bit(WDM_OVERFLOW, &desc->flags);\n} else {\nif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\nmemmove(desc->ubuf + desc->length, desc->inbuf, length);\ndesc->length += length;\ndesc->reslength = length;\n}\n}\nskip_error:\nwake_up(&desc->wait);\nset_bit(WDM_READ, &desc->flags);\nspin_unlock(&desc->iuspin);\n}", "label": 0}
{"index": 175796, "code": "xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\nint *longlen, int *outlen, int escape, int utf8,\nstruct nls_table *nls)\n{\nconst unsigned char *ip;\nunsigned char nc;\nunsigned char *op;\nunsigned int ec;\nint i, k, fill;\nint charlen;\nif (utf8) {\n*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);\nif (*outlen < 0)\nreturn *outlen;\nelse if (*outlen > FAT_LFN_LEN)\nreturn -ENAMETOOLONG;\nop = &outname[*outlen * sizeof(wchar_t)];\n} else {\nif (nls) {\nfor (i = 0, ip = name, op = outname, *outlen = 0;\ni < len && *outlen <= FAT_LFN_LEN;\n*outlen += 1)\n{\nif (escape && (*ip == ':')) {\nif (i > len - 5)\nreturn -EINVAL;\nec = 0;\nfor (k = 1; k < 5; k++) {\nnc = ip[k];\nec <<= 4;\nif (nc >= '0' && nc <= '9') {\nec |= nc - '0';\ncontinue;\n}\nif (nc >= 'a' && nc <= 'f') {\nec |= nc - ('a' - 10);\ncontinue;\n}\nif (nc >= 'A' && nc <= 'F') {\nec |= nc - ('A' - 10);\ncontinue;\n}\nreturn -EINVAL;\n}\n*op++ = ec & 0xFF;\n*op++ = ec >> 8;\nip += 5;\ni += 5;\n} else {\nif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\nreturn -EINVAL;\nip += charlen;\ni += charlen;\nop += 2;\n}\n}\nif (i < len)\nreturn -ENAMETOOLONG;\n} else {\nfor (i = 0, ip = name, op = outname, *outlen = 0;\ni < len && *outlen <= FAT_LFN_LEN;\ni++, *outlen += 1)\n{\n*op++ = *ip++;\n*op++ = 0;\n}\nif (i < len)\nreturn -ENAMETOOLONG;\n}\n}\n*longlen = *outlen;\nif (*outlen % 13) {\n*op++ = 0;\n*op++ = 0;\n*outlen += 1;\nif (*outlen % 13) {\nfill = 13 - (*outlen % 13);\nfor (i = 0; i < fill; i++) {\n*op++ = 0xff;\n*op++ = 0xff;\n}\n*outlen += fill;\n}\n}\nreturn 0;\n}", "contrast": "xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\nint *longlen, int *outlen, int escape, int utf8,\nstruct nls_table *nls)\n{\nconst unsigned char *ip;\nunsigned char nc;\nunsigned char *op;\nunsigned int ec;\nint i, k, fill;\nint charlen;\nif (utf8) {\n*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n(wchar_t *) outname, FAT_LFN_LEN + 2);\nif (*outlen < 0)\nreturn *outlen;\nelse if (*outlen > FAT_LFN_LEN)\nreturn -ENAMETOOLONG;\nop = &outname[*outlen * sizeof(wchar_t)];\n} else {\nif (nls) {\nfor (i = 0, ip = name, op = outname, *outlen = 0;\ni < len && *outlen <= FAT_LFN_LEN;\n*outlen += 1)\n{\nif (escape && (*ip == ':')) {\nif (i > len - 5)\nreturn -EINVAL;\nec = 0;\nfor (k = 1; k < 5; k++) {\nnc = ip[k];\nec <<= 4;\nif (nc >= '0' && nc <= '9') {\nec |= nc - '0';\ncontinue;\n}\nif (nc >= 'a' && nc <= 'f') {\nec |= nc - ('a' - 10);\ncontinue;\n}\nif (nc >= 'A' && nc <= 'F') {\nec |= nc - ('A' - 10);\ncontinue;\n}\nreturn -EINVAL;\n}\n*op++ = ec & 0xFF;\n*op++ = ec >> 8;\nip += 5;\ni += 5;\n} else {\nif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\nreturn -EINVAL;\nip += charlen;\ni += charlen;\nop += 2;\n}\n}\nif (i < len)\nreturn -ENAMETOOLONG;\n} else {\nfor (i = 0, ip = name, op = outname, *outlen = 0;\ni < len && *outlen <= FAT_LFN_LEN;\ni++, *outlen += 1)\n{\n*op++ = *ip++;\n*op++ = 0;\n}\nif (i < len)\nreturn -ENAMETOOLONG;\n}\n}\n*longlen = *outlen;\nif (*outlen % 13) {\n*op++ = 0;\n*op++ = 0;\n*outlen += 1;\nif (*outlen % 13) {\nfill = 13 - (*outlen % 13);\nfor (i = 0; i < fill; i++) {\n*op++ = 0xff;\n*op++ = 0xff;\n}\n*outlen += fill;\n}\n}\nreturn 0;\n}", "label": 0}
{"index": 175808, "code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\nint ret = -ESRCH;\nread_lock(&tasklist_lock);\nif ((child->ptrace & PT_PTRACED) && child->parent == current) {\nspin_lock_irq(&child->sighand->siglock);\nWARN_ON_ONCE(task_is_stopped(child));\nif (ignore_state || (task_is_traced(child) &&\n!(child->jobctl & JOBCTL_LISTENING)))\nret = 0;\nspin_unlock_irq(&child->sighand->siglock);\n}\nread_unlock(&tasklist_lock);\nif (!ret && !ignore_state)\nret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\nreturn ret;\n}", "contrast": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\nint ret = -ESRCH;\nread_lock(&tasklist_lock);\nif (child->ptrace && child->parent == current) {\nWARN_ON(child->state == __TASK_TRACED);\nif (ignore_state || ptrace_freeze_traced(child))\nret = 0;\n}\nread_unlock(&tasklist_lock);\nif (!ret && !ignore_state) {\nif (!wait_task_inactive(child, __TASK_TRACED)) {\nWARN_ON(child->state == __TASK_TRACED);\nret = -ESRCH;\n}\n}\nreturn ret;\n}", "label": 0}
{"index": 175831, "code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\nif (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\ncib_send_tls(session, msg);\n#else\nCRM_ASSERT(encrypted == FALSE);\n#endif\n} else {\ncib_send_plaintext(GPOINTER_TO_INT(session), msg);\n}\n}", "contrast": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\nstatic int\ncrm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n{\nint rc = -1;\nif (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\nrc = crm_send_tls(session, buf, len);\n#else\nCRM_ASSERT(encrypted == FALSE);\n#endif\n} else {\nrc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n}\nreturn rc;\n}", "label": 0}
{"index": 175840, "code": "isofs_export_encode_fh(struct inode *inode,\n__u32 *fh32,\nint *max_len,\nstruct inode *parent)\n{\nstruct iso_inode_info * ei = ISOFS_I(inode);\nint len = *max_len;\nint type = 1;\n__u16 *fh16 = (__u16*)fh32;\nif (parent && (len < 5)) {\n*max_len = 5;\nreturn 255;\n} else if (len < 3) {\n*max_len = 3;\nreturn 255;\n}\nlen = 3;\nfh32[0] = ei->i_iget5_block;\nfh16[2] = (__u16)ei->i_iget5_offset;\nfh32[2] = inode->i_generation;\nif (parent) {\nstruct iso_inode_info *eparent;\neparent = ISOFS_I(parent);\nfh32[3] = eparent->i_iget5_block;\nfh16[3] = (__u16)eparent->i_iget5_offset;\nfh32[4] = parent->i_generation;\nlen = 5;\ntype = 2;\n}\n*max_len = len;\nreturn type;\n}", "contrast": "isofs_export_encode_fh(struct inode *inode,\n__u32 *fh32,\nint *max_len,\nstruct inode *parent)\n{\nstruct iso_inode_info * ei = ISOFS_I(inode);\nint len = *max_len;\nint type = 1;\n__u16 *fh16 = (__u16*)fh32;\nif (parent && (len < 5)) {\n*max_len = 5;\nreturn 255;\n} else if (len < 3) {\n*max_len = 3;\nreturn 255;\n}\nlen = 3;\nfh32[0] = ei->i_iget5_block;\nfh16[2] = (__u16)ei->i_iget5_offset;\nfh16[3] = 0;\nfh32[2] = inode->i_generation;\nif (parent) {\nstruct iso_inode_info *eparent;\neparent = ISOFS_I(parent);\nfh32[3] = eparent->i_iget5_block;\nfh16[3] = (__u16)eparent->i_iget5_offset;\nfh32[4] = parent->i_generation;\nlen = 5;\ntype = 2;\n}\n*max_len = len;\nreturn type;\n}", "label": 0}
{"index": 175850, "code": "static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\nstruct inode *new_dir, struct dentry *new_dentry)\n{\nstruct btrfs_trans_handle *trans;\nstruct btrfs_root *root = BTRFS_I(old_dir)->root;\nstruct btrfs_root *dest = BTRFS_I(new_dir)->root;\nstruct inode *new_inode = new_dentry->d_inode;\nstruct inode *old_inode = old_dentry->d_inode;\nstruct timespec ctime = CURRENT_TIME;\nu64 index = 0;\nu64 root_objectid;\nint ret;\nu64 old_ino = btrfs_ino(old_inode);\nif (btrfs_ino(new_dir) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)\nreturn -EPERM;\nif (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)\nreturn -EXDEV;\nif (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||\n(new_inode && btrfs_ino(new_inode) == BTRFS_FIRST_FREE_OBJECTID))\nreturn -ENOTEMPTY;\nif (S_ISDIR(old_inode->i_mode) && new_inode &&\nnew_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\nreturn -ENOTEMPTY;\nif (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&\nold_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)\nfilemap_flush(old_inode->i_mapping);\nif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\ndown_read(&root->fs_info->subvol_sem);\ntrans = btrfs_start_transaction(root, 20);\nif (IS_ERR(trans)) {\nret = PTR_ERR(trans);\ngoto out_notrans;\n}\nif (dest != root)\nbtrfs_record_root_in_trans(trans, dest);\nret = btrfs_set_inode_index(new_dir, &index);\nif (ret)\ngoto out_fail;\nif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\nroot->fs_info->last_trans_log_full_commit = trans->transid;\n} else {\nret = btrfs_insert_inode_ref(trans, dest,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len,\nold_ino,\nbtrfs_ino(new_dir), index);\nif (ret)\ngoto out_fail;\nbtrfs_pin_log_trans(root);\n}\nif (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))\nbtrfs_add_ordered_operation(trans, root, old_inode);\ninode_inc_iversion(old_dir);\ninode_inc_iversion(new_dir);\ninode_inc_iversion(old_inode);\nold_dir->i_ctime = old_dir->i_mtime = ctime;\nnew_dir->i_ctime = new_dir->i_mtime = ctime;\nold_inode->i_ctime = ctime;\nif (old_dentry->d_parent != new_dentry->d_parent)\nbtrfs_record_unlink_dir(trans, old_dir, old_inode, 1);\nif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\nroot_objectid = BTRFS_I(old_inode)->root->root_key.objectid;\nret = btrfs_unlink_subvol(trans, root, old_dir, root_objectid,\nold_dentry->d_name.name,\nold_dentry->d_name.len);\n} else {\nret = __btrfs_unlink_inode(trans, root, old_dir,\nold_dentry->d_inode,\nold_dentry->d_name.name,\nold_dentry->d_name.len);\nif (!ret)\nret = btrfs_update_inode(trans, root, old_inode);\n}\nif (ret) {\nbtrfs_abort_transaction(trans, root, ret);\ngoto out_fail;\n}\nif (new_inode) {\ninode_inc_iversion(new_inode);\nnew_inode->i_ctime = CURRENT_TIME;\nif (unlikely(btrfs_ino(new_inode) ==\nBTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {\nroot_objectid = BTRFS_I(new_inode)->location.objectid;\nret = btrfs_unlink_subvol(trans, dest, new_dir,\nroot_objectid,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len);\nBUG_ON(new_inode->i_nlink == 0);\n} else {\nret = btrfs_unlink_inode(trans, dest, new_dir,\nnew_dentry->d_inode,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len);\n}\nif (!ret && new_inode->i_nlink == 0) {\nret = btrfs_orphan_add(trans, new_dentry->d_inode);\nBUG_ON(ret);\n}\nif (ret) {\nbtrfs_abort_transaction(trans, root, ret);\ngoto out_fail;\n}\n}\nfixup_inode_flags(new_dir, old_inode);\nret = btrfs_add_link(trans, new_dir, old_inode,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len, 0, index);\nif (ret) {\nbtrfs_abort_transaction(trans, root, ret);\ngoto out_fail;\n}\nif (old_ino != BTRFS_FIRST_FREE_OBJECTID) {\nstruct dentry *parent = new_dentry->d_parent;\nbtrfs_log_new_name(trans, old_inode, old_dir, parent);\nbtrfs_end_log_trans(root);\n}\nout_fail:\nbtrfs_end_transaction(trans, root);\nout_notrans:\nif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\nup_read(&root->fs_info->subvol_sem);\nreturn ret;\n}", "contrast": "static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\nstruct inode *new_dir, struct dentry *new_dentry)\n{\nstruct btrfs_trans_handle *trans;\nstruct btrfs_root *root = BTRFS_I(old_dir)->root;\nstruct btrfs_root *dest = BTRFS_I(new_dir)->root;\nstruct inode *new_inode = new_dentry->d_inode;\nstruct inode *old_inode = old_dentry->d_inode;\nstruct timespec ctime = CURRENT_TIME;\nu64 index = 0;\nu64 root_objectid;\nint ret;\nu64 old_ino = btrfs_ino(old_inode);\nif (btrfs_ino(new_dir) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)\nreturn -EPERM;\nif (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)\nreturn -EXDEV;\nif (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||\n(new_inode && btrfs_ino(new_inode) == BTRFS_FIRST_FREE_OBJECTID))\nreturn -ENOTEMPTY;\nif (S_ISDIR(old_inode->i_mode) && new_inode &&\nnew_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\nreturn -ENOTEMPTY;\nret = btrfs_check_dir_item_collision(root, new_dir->i_ino,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len);\nif (ret) {\nif (ret == -EEXIST) {\nif (!new_inode) {\nWARN_ON(1);\nreturn ret;\n}\n} else {\nreturn ret;\n}\n}\nret = 0;\nif (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&\nold_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)\nfilemap_flush(old_inode->i_mapping);\nif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\ndown_read(&root->fs_info->subvol_sem);\ntrans = btrfs_start_transaction(root, 20);\nif (IS_ERR(trans)) {\nret = PTR_ERR(trans);\ngoto out_notrans;\n}\nif (dest != root)\nbtrfs_record_root_in_trans(trans, dest);\nret = btrfs_set_inode_index(new_dir, &index);\nif (ret)\ngoto out_fail;\nif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\nroot->fs_info->last_trans_log_full_commit = trans->transid;\n} else {\nret = btrfs_insert_inode_ref(trans, dest,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len,\nold_ino,\nbtrfs_ino(new_dir), index);\nif (ret)\ngoto out_fail;\nbtrfs_pin_log_trans(root);\n}\nif (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))\nbtrfs_add_ordered_operation(trans, root, old_inode);\ninode_inc_iversion(old_dir);\ninode_inc_iversion(new_dir);\ninode_inc_iversion(old_inode);\nold_dir->i_ctime = old_dir->i_mtime = ctime;\nnew_dir->i_ctime = new_dir->i_mtime = ctime;\nold_inode->i_ctime = ctime;\nif (old_dentry->d_parent != new_dentry->d_parent)\nbtrfs_record_unlink_dir(trans, old_dir, old_inode, 1);\nif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\nroot_objectid = BTRFS_I(old_inode)->root->root_key.objectid;\nret = btrfs_unlink_subvol(trans, root, old_dir, root_objectid,\nold_dentry->d_name.name,\nold_dentry->d_name.len);\n} else {\nret = __btrfs_unlink_inode(trans, root, old_dir,\nold_dentry->d_inode,\nold_dentry->d_name.name,\nold_dentry->d_name.len);\nif (!ret)\nret = btrfs_update_inode(trans, root, old_inode);\n}\nif (ret) {\nbtrfs_abort_transaction(trans, root, ret);\ngoto out_fail;\n}\nif (new_inode) {\ninode_inc_iversion(new_inode);\nnew_inode->i_ctime = CURRENT_TIME;\nif (unlikely(btrfs_ino(new_inode) ==\nBTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {\nroot_objectid = BTRFS_I(new_inode)->location.objectid;\nret = btrfs_unlink_subvol(trans, dest, new_dir,\nroot_objectid,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len);\nBUG_ON(new_inode->i_nlink == 0);\n} else {\nret = btrfs_unlink_inode(trans, dest, new_dir,\nnew_dentry->d_inode,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len);\n}\nif (!ret && new_inode->i_nlink == 0) {\nret = btrfs_orphan_add(trans, new_dentry->d_inode);\nBUG_ON(ret);\n}\nif (ret) {\nbtrfs_abort_transaction(trans, root, ret);\ngoto out_fail;\n}\n}\nfixup_inode_flags(new_dir, old_inode);\nret = btrfs_add_link(trans, new_dir, old_inode,\nnew_dentry->d_name.name,\nnew_dentry->d_name.len, 0, index);\nif (ret) {\nbtrfs_abort_transaction(trans, root, ret);\ngoto out_fail;\n}\nif (old_ino != BTRFS_FIRST_FREE_OBJECTID) {\nstruct dentry *parent = new_dentry->d_parent;\nbtrfs_log_new_name(trans, old_inode, old_dir, parent);\nbtrfs_end_log_trans(root);\n}\nout_fail:\nbtrfs_end_transaction(trans, root);\nout_notrans:\nif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\nup_read(&root->fs_info->subvol_sem);\nreturn ret;\n}", "label": 0}
{"index": 175858, "code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\nstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n__u8 *data)\n{\nnfcb_poll->sensb_res_len = *data++;\npr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\nmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\ndata += nfcb_poll->sensb_res_len;\nreturn data;\n}", "contrast": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\nstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n__u8 *data)\n{\nnfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);\npr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\nmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\ndata += nfcb_poll->sensb_res_len;\nreturn data;\n}", "label": 0}
{"index": 175861, "code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\nint offset, size_t count)\n{\nint len = iov_length(from, count) - offset;\nint copy = skb_headlen(skb);\nint size, offset1 = 0;\nint i = 0;\nwhile (count && (offset >= from->iov_len)) {\noffset -= from->iov_len;\n++from;\n--count;\n}\nwhile (count && (copy > 0)) {\nsize = min_t(unsigned int, copy, from->iov_len - offset);\nif (copy_from_user(skb->data + offset1, from->iov_base + offset,\nsize))\nreturn -EFAULT;\nif (copy > size) {\n++from;\n--count;\noffset = 0;\n} else\noffset += size;\ncopy -= size;\noffset1 += size;\n}\nif (len == offset1)\nreturn 0;\nwhile (count--) {\nstruct page *page[MAX_SKB_FRAGS];\nint num_pages;\nunsigned long base;\nunsigned long truesize;\nlen = from->iov_len - offset;\nif (!len) {\noffset = 0;\n++from;\ncontinue;\n}\nbase = (unsigned long)from->iov_base + offset;\nsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\nnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\nif ((num_pages != size) ||\n(num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\nfor (i = 0; i < num_pages; i++)\nput_page(page[i]);\nreturn -EFAULT;\n}\ntruesize = size * PAGE_SIZE;\nskb->data_len += len;\nskb->len += len;\nskb->truesize += truesize;\natomic_add(truesize, &skb->sk->sk_wmem_alloc);\nwhile (len) {\nint off = base & ~PAGE_MASK;\nint size = min_t(int, len, PAGE_SIZE - off);\n__skb_fill_page_desc(skb, i, page[i], off, size);\nskb_shinfo(skb)->nr_frags++;\nbase += size;\nlen -= size;\ni++;\n}\noffset = 0;\n++from;\n}\nreturn 0;\n}", "contrast": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\nint offset, size_t count)\n{\nint len = iov_length(from, count) - offset;\nint copy = skb_headlen(skb);\nint size, offset1 = 0;\nint i = 0;\nwhile (count && (offset >= from->iov_len)) {\noffset -= from->iov_len;\n++from;\n--count;\n}\nwhile (count && (copy > 0)) {\nsize = min_t(unsigned int, copy, from->iov_len - offset);\nif (copy_from_user(skb->data + offset1, from->iov_base + offset,\nsize))\nreturn -EFAULT;\nif (copy > size) {\n++from;\n--count;\noffset = 0;\n} else\noffset += size;\ncopy -= size;\noffset1 += size;\n}\nif (len == offset1)\nreturn 0;\nwhile (count--) {\nstruct page *page[MAX_SKB_FRAGS];\nint num_pages;\nunsigned long base;\nunsigned long truesize;\nlen = from->iov_len - offset;\nif (!len) {\noffset = 0;\n++from;\ncontinue;\n}\nbase = (unsigned long)from->iov_base + offset;\nsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\nif (i + size > MAX_SKB_FRAGS)\nreturn -EMSGSIZE;\nnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\nif (num_pages != size) {\nfor (i = 0; i < num_pages; i++)\nput_page(page[i]);\nreturn -EFAULT;\n}\ntruesize = size * PAGE_SIZE;\nskb->data_len += len;\nskb->len += len;\nskb->truesize += truesize;\natomic_add(truesize, &skb->sk->sk_wmem_alloc);\nwhile (len) {\nint off = base & ~PAGE_MASK;\nint size = min_t(int, len, PAGE_SIZE - off);\n__skb_fill_page_desc(skb, i, page[i], off, size);\nskb_shinfo(skb)->nr_frags++;\nbase += size;\nlen -= size;\ni++;\n}\noffset = 0;\n++from;\n}\nreturn 0;\n}", "label": 0}
{"index": 175865, "code": "static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\nstruct kvm_assigned_pci_dev *assigned_dev)\n{\nint r = 0, idx;\nstruct kvm_assigned_dev_kernel *match;\nstruct pci_dev *dev;\nif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\nreturn -EINVAL;\nmutex_lock(&kvm->lock);\nidx = srcu_read_lock(&kvm->srcu);\nmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\nassigned_dev->assigned_dev_id);\nif (match) {\nr = -EEXIST;\ngoto out;\n}\nmatch = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);\nif (match == NULL) {\nprintk(KERN_INFO \"%s: Couldn't allocate memory\\n\",\n__func__);\nr = -ENOMEM;\ngoto out;\n}\ndev = pci_get_domain_bus_and_slot(assigned_dev->segnr,\nassigned_dev->busnr,\nassigned_dev->devfn);\nif (!dev) {\nprintk(KERN_INFO \"%s: host device not found\\n\", __func__);\nr = -EINVAL;\ngoto out_free;\n}\nif (pci_enable_device(dev)) {\nprintk(KERN_INFO \"%s: Could not enable PCI device\\n\", __func__);\nr = -EBUSY;\ngoto out_put;\n}\nr = pci_request_regions(dev, \"kvm_assigned_device\");\nif (r) {\nprintk(KERN_INFO \"%s: Could not get access to device regions\\n\",\n__func__);\ngoto out_disable;\n}\npci_reset_function(dev);\npci_save_state(dev);\nmatch->pci_saved_state = pci_store_saved_state(dev);\nif (!match->pci_saved_state)\nprintk(KERN_DEBUG \"%s: Couldn't store %s saved state\\n\",\n__func__, dev_name(&dev->dev));\nmatch->assigned_dev_id = assigned_dev->assigned_dev_id;\nmatch->host_segnr = assigned_dev->segnr;\nmatch->host_busnr = assigned_dev->busnr;\nmatch->host_devfn = assigned_dev->devfn;\nmatch->flags = assigned_dev->flags;\nmatch->dev = dev;\nspin_lock_init(&match->intx_lock);\nmatch->irq_source_id = -1;\nmatch->kvm = kvm;\nmatch->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;\nlist_add(&match->list, &kvm->arch.assigned_dev_head);\nif (!kvm->arch.iommu_domain) {\nr = kvm_iommu_map_guest(kvm);\nif (r)\ngoto out_list_del;\n}\nr = kvm_assign_device(kvm, match);\nif (r)\ngoto out_list_del;\nout:\nsrcu_read_unlock(&kvm->srcu, idx);\nmutex_unlock(&kvm->lock);\nreturn r;\nout_list_del:\nif (pci_load_and_free_saved_state(dev, &match->pci_saved_state))\nprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n__func__, dev_name(&dev->dev));\nlist_del(&match->list);\npci_release_regions(dev);\nout_disable:\npci_disable_device(dev);\nout_put:\npci_dev_put(dev);\nout_free:\nkfree(match);\nsrcu_read_unlock(&kvm->srcu, idx);\nmutex_unlock(&kvm->lock);\nreturn r;\n}", "contrast": "static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\nstruct kvm_assigned_pci_dev *assigned_dev)\n{\nint r = 0, idx;\nstruct kvm_assigned_dev_kernel *match;\nstruct pci_dev *dev;\nu8 header_type;\nif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\nreturn -EINVAL;\nmutex_lock(&kvm->lock);\nidx = srcu_read_lock(&kvm->srcu);\nmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\nassigned_dev->assigned_dev_id);\nif (match) {\nr = -EEXIST;\ngoto out;\n}\nmatch = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);\nif (match == NULL) {\nprintk(KERN_INFO \"%s: Couldn't allocate memory\\n\",\n__func__);\nr = -ENOMEM;\ngoto out;\n}\ndev = pci_get_domain_bus_and_slot(assigned_dev->segnr,\nassigned_dev->busnr,\nassigned_dev->devfn);\nif (!dev) {\nprintk(KERN_INFO \"%s: host device not found\\n\", __func__);\nr = -EINVAL;\ngoto out_free;\n}\npci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\nif ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {\nr = -EPERM;\ngoto out_put;\n}\nr = probe_sysfs_permissions(dev);\nif (r)\ngoto out_put;\nif (pci_enable_device(dev)) {\nprintk(KERN_INFO \"%s: Could not enable PCI device\\n\", __func__);\nr = -EBUSY;\ngoto out_put;\n}\nr = pci_request_regions(dev, \"kvm_assigned_device\");\nif (r) {\nprintk(KERN_INFO \"%s: Could not get access to device regions\\n\",\n__func__);\ngoto out_disable;\n}\npci_reset_function(dev);\npci_save_state(dev);\nmatch->pci_saved_state = pci_store_saved_state(dev);\nif (!match->pci_saved_state)\nprintk(KERN_DEBUG \"%s: Couldn't store %s saved state\\n\",\n__func__, dev_name(&dev->dev));\nmatch->assigned_dev_id = assigned_dev->assigned_dev_id;\nmatch->host_segnr = assigned_dev->segnr;\nmatch->host_busnr = assigned_dev->busnr;\nmatch->host_devfn = assigned_dev->devfn;\nmatch->flags = assigned_dev->flags;\nmatch->dev = dev;\nspin_lock_init(&match->intx_lock);\nmatch->irq_source_id = -1;\nmatch->kvm = kvm;\nmatch->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;\nlist_add(&match->list, &kvm->arch.assigned_dev_head);\nif (!kvm->arch.iommu_domain) {\nr = kvm_iommu_map_guest(kvm);\nif (r)\ngoto out_list_del;\n}\nr = kvm_assign_device(kvm, match);\nif (r)\ngoto out_list_del;\nout:\nsrcu_read_unlock(&kvm->srcu, idx);\nmutex_unlock(&kvm->lock);\nreturn r;\nout_list_del:\nif (pci_load_and_free_saved_state(dev, &match->pci_saved_state))\nprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n__func__, dev_name(&dev->dev));\nlist_del(&match->list);\npci_release_regions(dev);\nout_disable:\npci_disable_device(dev);\nout_put:\npci_dev_put(dev);\nout_free:\nkfree(match);\nsrcu_read_unlock(&kvm->srcu, idx);\nmutex_unlock(&kvm->lock);\nreturn r;\n}", "label": 0}
{"index": 175867, "code": "static int empty_write_end(struct page *page, unsigned from,\nunsigned to, int mode)\n{\nstruct inode *inode = page->mapping->host;\nstruct gfs2_inode *ip = GFS2_I(inode);\nstruct buffer_head *bh;\nunsigned offset, blksize = 1 << inode->i_blkbits;\npgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\nzero_user(page, from, to-from);\nmark_page_accessed(page);\nif (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {\nif (!gfs2_is_writeback(ip))\ngfs2_page_add_databufs(ip, page, from, to);\nblock_commit_write(page, from, to);\nreturn 0;\n}\noffset = 0;\nbh = page_buffers(page);\nwhile (offset < to) {\nif (offset >= from) {\nset_buffer_uptodate(bh);\nmark_buffer_dirty(bh);\nclear_buffer_new(bh);\nwrite_dirty_buffer(bh, WRITE);\n}\noffset += blksize;\nbh = bh->b_this_page;\n}\noffset = 0;\nbh = page_buffers(page);\nwhile (offset < to) {\nif (offset >= from) {\nwait_on_buffer(bh);\nif (!buffer_uptodate(bh))\nreturn -EIO;\n}\noffset += blksize;\nbh = bh->b_this_page;\n}\nreturn 0;\n}", "contrast": "static int empty_write_end(struct page *page, unsigned from,", "label": 0}
{"index": 175869, "code": "static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\nloff_t len)\n{\nstruct inode *inode = file->f_path.dentry->d_inode;\nstruct gfs2_sbd *sdp = GFS2_SB(inode);\nstruct gfs2_inode *ip = GFS2_I(inode);\nunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\nloff_t bytes, max_bytes;\nstruct gfs2_alloc *al;\nint error;\nloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\nloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\nnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\nif (mode & ~FALLOC_FL_KEEP_SIZE)\nreturn -EOPNOTSUPP;\noffset &= bsize_mask;\nlen = next - offset;\nbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\nif (!bytes)\nbytes = UINT_MAX;\nbytes &= bsize_mask;\nif (bytes == 0)\nbytes = sdp->sd_sb.sb_bsize;\ngfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\nerror = gfs2_glock_nq(&ip->i_gh);\nif (unlikely(error))\ngoto out_uninit;\nif (!gfs2_write_alloc_required(ip, offset, len))\ngoto out_unlock;\nwhile (len > 0) {\nif (len < bytes)\nbytes = len;\nal = gfs2_alloc_get(ip);\nif (!al) {\nerror = -ENOMEM;\ngoto out_unlock;\n}\nerror = gfs2_quota_lock_check(ip);\nif (error)\ngoto out_alloc_put;\nretry:\ngfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\nal->al_requested = data_blocks + ind_blocks;\nerror = gfs2_inplace_reserve(ip);\nif (error) {\nif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\nbytes >>= 1;\nbytes &= bsize_mask;\nif (bytes == 0)\nbytes = sdp->sd_sb.sb_bsize;\ngoto retry;\n}\ngoto out_qunlock;\n}\nmax_bytes = bytes;\ncalc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);\nal->al_requested = data_blocks + ind_blocks;\nrblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\nRES_RG_HDR + gfs2_rg_blocks(ip);\nif (gfs2_is_jdata(ip))\nrblocks += data_blocks ? data_blocks : 1;\nerror = gfs2_trans_begin(sdp, rblocks,\nPAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\nif (error)\ngoto out_trans_fail;\nerror = fallocate_chunk(inode, offset, max_bytes, mode);\ngfs2_trans_end(sdp);\nif (error)\ngoto out_trans_fail;\nlen -= max_bytes;\noffset += max_bytes;\ngfs2_inplace_release(ip);\ngfs2_quota_unlock(ip);\ngfs2_alloc_put(ip);\n}\ngoto out_unlock;\nout_trans_fail:\ngfs2_inplace_release(ip);\nout_qunlock:\ngfs2_quota_unlock(ip);\nout_alloc_put:\ngfs2_alloc_put(ip);\nout_unlock:\ngfs2_glock_dq(&ip->i_gh);\nout_uninit:\ngfs2_holder_uninit(&ip->i_gh);\nreturn error;\n}", "contrast": "static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\nloff_t len)\n{\nstruct inode *inode = file->f_path.dentry->d_inode;\nstruct gfs2_sbd *sdp = GFS2_SB(inode);\nstruct gfs2_inode *ip = GFS2_I(inode);\nunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\nloff_t bytes, max_bytes;\nstruct gfs2_alloc *al;\nint error;\nloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\nloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\nloff_t max_chunk_size = UINT_MAX & bsize_mask;\nnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\nif (mode & ~FALLOC_FL_KEEP_SIZE)\nreturn -EOPNOTSUPP;\noffset &= bsize_mask;\nlen = next - offset;\nbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\nif (!bytes)\nbytes = UINT_MAX;\nbytes &= bsize_mask;\nif (bytes == 0)\nbytes = sdp->sd_sb.sb_bsize;\ngfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\nerror = gfs2_glock_nq(&ip->i_gh);\nif (unlikely(error))\ngoto out_uninit;\nif (!gfs2_write_alloc_required(ip, offset, len))\ngoto out_unlock;\nwhile (len > 0) {\nif (len < bytes)\nbytes = len;\nal = gfs2_alloc_get(ip);\nif (!al) {\nerror = -ENOMEM;\ngoto out_unlock;\n}\nerror = gfs2_quota_lock_check(ip);\nif (error)\ngoto out_alloc_put;\nretry:\ngfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\nal->al_requested = data_blocks + ind_blocks;\nerror = gfs2_inplace_reserve(ip);\nif (error) {\nif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\nbytes >>= 1;\nbytes &= bsize_mask;\nif (bytes == 0)\nbytes = sdp->sd_sb.sb_bsize;\ngoto retry;\n}\ngoto out_qunlock;\n}\nmax_bytes = bytes;\ncalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n&max_bytes, &data_blocks, &ind_blocks);\nal->al_requested = data_blocks + ind_blocks;\nrblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\nRES_RG_HDR + gfs2_rg_blocks(ip);\nif (gfs2_is_jdata(ip))\nrblocks += data_blocks ? data_blocks : 1;\nerror = gfs2_trans_begin(sdp, rblocks,\nPAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\nif (error)\ngoto out_trans_fail;\nerror = fallocate_chunk(inode, offset, max_bytes, mode);\ngfs2_trans_end(sdp);\nif (error)\ngoto out_trans_fail;\nlen -= max_bytes;\noffset += max_bytes;\ngfs2_inplace_release(ip);\ngfs2_quota_unlock(ip);\ngfs2_alloc_put(ip);\n}\ngoto out_unlock;\nout_trans_fail:\ngfs2_inplace_release(ip);\nout_qunlock:\ngfs2_quota_unlock(ip);\nout_alloc_put:\ngfs2_alloc_put(ip);\nout_unlock:\ngfs2_glock_dq(&ip->i_gh);\nout_uninit:\ngfs2_holder_uninit(&ip->i_gh);\nreturn error;\n}", "label": 0}
{"index": 175874, "code": "static int ext4_split_unwritten_extents(handle_t *handle,\nstruct inode *inode,\nstruct ext4_map_blocks *map,\nstruct ext4_ext_path *path,\nint flags)\n{\nstruct ext4_extent *ex, newex, orig_ex;\nstruct ext4_extent *ex1 = NULL;\nstruct ext4_extent *ex2 = NULL;\nstruct ext4_extent *ex3 = NULL;\next4_lblk_t ee_block, eof_block;\nunsigned int allocated, ee_len, depth;\next4_fsblk_t newblock;\nint err = 0;\nint may_zeroout;\next_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\"block %llu, max_blocks %u\\n\", inode->i_ino,\n(unsigned long long)map->m_lblk, map->m_len);\neof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\ninode->i_sb->s_blocksize_bits;\nif (eof_block < map->m_lblk + map->m_len)\neof_block = map->m_lblk + map->m_len;\ndepth = ext_depth(inode);\nex = path[depth].p_ext;\nee_block = le32_to_cpu(ex->ee_block);\nee_len = ext4_ext_get_actual_len(ex);\nallocated = ee_len - (map->m_lblk - ee_block);\nnewblock = map->m_lblk - ee_block + ext4_ext_pblock(ex);\nex2 = ex;\norig_ex.ee_block = ex->ee_block;\norig_ex.ee_len   = cpu_to_le16(ee_len);\next4_ext_store_pblock(&orig_ex, ext4_ext_pblock(ex));\nmay_zeroout = ee_block + ee_len <= eof_block;\nif ((map->m_lblk == ee_block) && (allocated <= map->m_len))\nreturn allocated;\nerr = ext4_ext_get_access(handle, inode, path + depth);\nif (err)\ngoto out;\nif (map->m_lblk > ee_block) {\nex1 = ex;\nex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);\next4_ext_mark_uninitialized(ex1);\nex2 = &newex;\n}\nif (!ex1 && allocated > map->m_len)\nex2->ee_len = cpu_to_le16(map->m_len);\nif (allocated > map->m_len) {\nunsigned int newdepth;\nex3 = &newex;\nex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);\next4_ext_store_pblock(ex3, newblock + map->m_len);\nex3->ee_len = cpu_to_le16(allocated - map->m_len);\next4_ext_mark_uninitialized(ex3);\nerr = ext4_ext_insert_extent(handle, inode, path, ex3, flags);\nif (err == -ENOSPC && may_zeroout) {\nerr =  ext4_ext_zeroout(inode, &orig_ex);\nif (err)\ngoto fix_extent_len;\nex->ee_block = orig_ex.ee_block;\nex->ee_len   = orig_ex.ee_len;\next4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\next4_ext_dirty(handle, inode, path + depth);\nreturn allocated;\n} else if (err)\ngoto fix_extent_len;\nnewdepth = ext_depth(inode);\nee_len -= ext4_ext_get_actual_len(ex3);\norig_ex.ee_len = cpu_to_le16(ee_len);\nmay_zeroout = ee_block + ee_len <= eof_block;\ndepth = newdepth;\next4_ext_drop_refs(path);\npath = ext4_ext_find_extent(inode, map->m_lblk, path);\nif (IS_ERR(path)) {\nerr = PTR_ERR(path);\ngoto out;\n}\nex = path[depth].p_ext;\nif (ex2 != &newex)\nex2 = ex;\nerr = ext4_ext_get_access(handle, inode, path + depth);\nif (err)\ngoto out;\nallocated = map->m_len;\n}\nif (ex1 && ex1 != ex) {\nex1 = ex;\nex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);\next4_ext_mark_uninitialized(ex1);\nex2 = &newex;\n}\nex2->ee_block = cpu_to_le32(map->m_lblk);\next4_ext_store_pblock(ex2, newblock);\nex2->ee_len = cpu_to_le16(allocated);\next4_ext_mark_uninitialized(ex2);\nif (ex2 != ex)\ngoto insert;\nerr = ext4_ext_dirty(handle, inode, path + depth);\next_debug(\"out here\\n\");\ngoto out;\ninsert:\nerr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\nif (err == -ENOSPC && may_zeroout) {\nerr =  ext4_ext_zeroout(inode, &orig_ex);\nif (err)\ngoto fix_extent_len;\nex->ee_block = orig_ex.ee_block;\nex->ee_len   = orig_ex.ee_len;\next4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\next4_ext_dirty(handle, inode, path + depth);\nreturn allocated;\n} else if (err)\ngoto fix_extent_len;\nout:\next4_ext_show_leaf(inode, path);\nreturn err ? err : allocated;\nfix_extent_len:\nex->ee_block = orig_ex.ee_block;\nex->ee_len   = orig_ex.ee_len;\next4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\next4_ext_mark_uninitialized(ex);\next4_ext_dirty(handle, inode, path + depth);\nreturn err;\n}", "contrast": "static int ext4_split_unwritten_extents(handle_t *handle,\nstruct inode *inode,\nstruct ext4_map_blocks *map,\nstruct ext4_ext_path *path,\nint flags)\n{\next4_lblk_t eof_block;\next4_lblk_t ee_block;\nstruct ext4_extent *ex;\nunsigned int ee_len;\nint split_flag = 0, depth;\next_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\"block %llu, max_blocks %u\\n\", inode->i_ino,\n(unsigned long long)map->m_lblk, map->m_len);\neof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\ninode->i_sb->s_blocksize_bits;\nif (eof_block < map->m_lblk + map->m_len)\neof_block = map->m_lblk + map->m_len;\ndepth = ext_depth(inode);\nex = path[depth].p_ext;\nee_block = le32_to_cpu(ex->ee_block);\nee_len = ext4_ext_get_actual_len(ex);\nsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\nsplit_flag |= EXT4_EXT_MARK_UNINIT2;\nflags |= EXT4_GET_BLOCKS_PRE_IO;\nreturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}", "label": 0}
{"index": 175876, "code": "int perf_config(config_fn_t fn, void *data)\n{\nint ret = 0, found = 0;\nchar *repo_config = NULL;\nconst char *home = NULL;\nif (config_exclusive_filename)\nreturn perf_config_from_file(fn, config_exclusive_filename, data);\nif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\nret += perf_config_from_file(fn, perf_etc_perfconfig(),\ndata);\nfound += 1;\n}\nhome = getenv(\"HOME\");\nif (perf_config_global() && home) {\nchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\nif (!access(user_config, R_OK)) {\nret += perf_config_from_file(fn, user_config, data);\nfound += 1;\n}\nfree(user_config);\n}\nrepo_config = perf_pathdup(\"config\");\nif (!access(repo_config, R_OK)) {\nret += perf_config_from_file(fn, repo_config, data);\nfound += 1;\n}\nfree(repo_config);\nif (found == 0)\nreturn -1;\nreturn ret;\n}", "contrast": "int perf_config(config_fn_t fn, void *data)\n{\nint ret = 0, found = 0;\nconst char *home = NULL;\nif (config_exclusive_filename)\nreturn perf_config_from_file(fn, config_exclusive_filename, data);\nif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\nret += perf_config_from_file(fn, perf_etc_perfconfig(),\ndata);\nfound += 1;\n}\nhome = getenv(\"HOME\");\nif (perf_config_global() && home) {\nchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\nif (!access(user_config, R_OK)) {\nret += perf_config_from_file(fn, user_config, data);\nfound += 1;\n}\nfree(user_config);\n}\nif (found == 0)\nreturn -1;\nreturn ret;\n}", "label": 0}
{"index": 175901, "code": "static const char *lua_authz_parse(cmd_parms *cmd, const char *require_line,\nconst void **parsed_require_line)\n{\nconst char *provider_name;\nlua_authz_provider_spec *spec;\napr_pool_userdata_get((void**)&provider_name, AUTHZ_PROVIDER_NAME_NOTE,\ncmd->temp_pool);\nap_assert(provider_name != NULL);\nspec = apr_hash_get(lua_authz_providers, provider_name, APR_HASH_KEY_STRING);\nap_assert(spec != NULL);\nif (require_line && *require_line) {\nconst char *arg;\nspec->args = apr_array_make(cmd->pool, 2, sizeof(const char *));\nwhile ((arg = ap_getword_conf(cmd->pool, &require_line)) && *arg) {\nAPR_ARRAY_PUSH(spec->args, const char *) = arg;\n}\n}\n*parsed_require_line = spec;\nreturn NULL;\n}", "contrast": "static const char *lua_authz_parse(cmd_parms *cmd, const char *require_line,\nconst void **parsed_require_line)\n{\nconst char *provider_name;\nlua_authz_provider_spec *spec;\nlua_authz_provider_func *func = apr_pcalloc(cmd->pool, sizeof(lua_authz_provider_func));\napr_pool_userdata_get((void**)&provider_name, AUTHZ_PROVIDER_NAME_NOTE,\ncmd->temp_pool);\nap_assert(provider_name != NULL);\nspec = apr_hash_get(lua_authz_providers, provider_name, APR_HASH_KEY_STRING);\nap_assert(spec != NULL);\nfunc->spec = spec;\nif (require_line && *require_line) {\nconst char *arg;\nfunc->args = apr_array_make(cmd->pool, 2, sizeof(const char *));\nwhile ((arg = ap_getword_conf(cmd->pool, &require_line)) && *arg) {\nAPR_ARRAY_PUSH(func->args, const char *) = arg;\n}\n}\n*parsed_require_line = func;\nreturn NULL;\n}", "label": 0}
{"index": 175902, "code": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\nstruct trace_array *tr = data;\nstruct ftrace_event_file *ftrace_file;\nstruct syscall_trace_enter *entry;\nstruct syscall_metadata *sys_data;\nstruct ring_buffer_event *event;\nstruct ring_buffer *buffer;\nunsigned long irq_flags;\nint pc;\nint syscall_nr;\nint size;\nsyscall_nr = trace_get_syscall_nr(current, regs);\nif (syscall_nr < 0)\nreturn;\nftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\nif (!ftrace_file)\nreturn;\nif (ftrace_trigger_soft_disabled(ftrace_file))\nreturn;\nsys_data = syscall_nr_to_meta(syscall_nr);\nif (!sys_data)\nreturn;\nsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\nlocal_save_flags(irq_flags);\npc = preempt_count();\nbuffer = tr->trace_buffer.buffer;\nevent = trace_buffer_lock_reserve(buffer,\nsys_data->enter_event->event.type, size, irq_flags, pc);\nif (!event)\nreturn;\nentry = ring_buffer_event_data(event);\nentry->nr = syscall_nr;\nsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\nevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\nirq_flags, pc);\n}", "contrast": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\nstruct trace_array *tr = data;\nstruct ftrace_event_file *ftrace_file;\nstruct syscall_trace_enter *entry;\nstruct syscall_metadata *sys_data;\nstruct ring_buffer_event *event;\nstruct ring_buffer *buffer;\nunsigned long irq_flags;\nint pc;\nint syscall_nr;\nint size;\nsyscall_nr = trace_get_syscall_nr(current, regs);\nif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\nreturn;\nftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\nif (!ftrace_file)\nreturn;\nif (ftrace_trigger_soft_disabled(ftrace_file))\nreturn;\nsys_data = syscall_nr_to_meta(syscall_nr);\nif (!sys_data)\nreturn;\nsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\nlocal_save_flags(irq_flags);\npc = preempt_count();\nbuffer = tr->trace_buffer.buffer;\nevent = trace_buffer_lock_reserve(buffer,\nsys_data->enter_event->event.type, size, irq_flags, pc);\nif (!event)\nreturn;\nentry = ring_buffer_event_data(event);\nentry->nr = syscall_nr;\nsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\nevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\nirq_flags, pc);\n}", "label": 0}
{"index": 175925, "code": "void mk_request_free(struct session_request *sr)\n{\nif (sr->fd_file > 0) {\nmk_vhost_close(sr);\n}\nif (sr->headers.location) {\nmk_mem_free(sr->headers.location);\n}\nif (sr->uri_processed.data != sr->uri.data) {\nmk_ptr_free(&sr->uri_processed);\n}\nif (sr->real_path.data != sr->real_path_static) {\nmk_ptr_free(&sr->real_path);\n}\n}", "contrast": "void mk_request_free(struct session_request *sr)\n{\nif (sr->fd_file > 0) {\nif (sr->fd_is_fdt == MK_TRUE) {\nmk_vhost_close(sr);\n}\nelse {\nclose(sr->fd_file);\n}\n}\nif (sr->headers.location) {\nmk_mem_free(sr->headers.location);\n}\nif (sr->uri_processed.data != sr->uri.data) {\nmk_ptr_free(&sr->uri_processed);\n}\nif (sr->real_path.data != sr->real_path_static) {\nmk_ptr_free(&sr->real_path);\n}\n}", "label": 0}
{"index": 175958, "code": "fep_client_open (const char *address)\n{\nFepClient *client;\nstruct sockaddr_un sun;\nssize_t sun_len;\nint retval;\nif (!address)\naddress = getenv (\"LIBFEP_CONTROL_SOCK\");\nif (!address)\nreturn NULL;\nif (strlen (address) + 1 >= sizeof(sun.sun_path))\n{\nfep_log (FEP_LOG_LEVEL_WARNING,\n\"unix domain socket path too long: %d + 1 >= %d\",\nstrlen (address),\nsizeof (sun.sun_path));\nfree (address);\nreturn NULL;\n}\nclient = xzalloc (sizeof(FepClient));\nclient->filter_running = false;\nclient->messages = NULL;\nmemset (&sun, 0, sizeof(struct sockaddr_un));\nsun.sun_family = AF_UNIX;\n#ifdef __linux__\nsun.sun_path[0] = '\\0';\nmemcpy (sun.sun_path + 1, address, strlen (address));\nsun_len = offsetof (struct sockaddr_un, sun_path) + strlen (address) + 1;\n#else\nmemcpy (sun.sun_path, address, strlen (address));\nsun_len = sizeof (struct sockaddr_un);\n#endif\nclient->control = socket (AF_UNIX, SOCK_STREAM, 0);\nif (client->control < 0)\n{\nfree (client);\nreturn NULL;\n}\nretval = connect (client->control,\n(const struct sockaddr *) &sun,\nsun_len);\nif (retval < 0)\n{\nclose (client->control);\nfree (client);\nreturn NULL;\n}\nreturn client;\n}", "contrast": "fep_client_open (const char *address)\n{\nFepClient *client;\nstruct sockaddr_un sun;\nssize_t sun_len;\nint retval;\nif (!address)\naddress = getenv (\"LIBFEP_CONTROL_SOCK\");\nif (!address)\nreturn NULL;\nif (strlen (address) + 1 >= sizeof(sun.sun_path))\n{\nfep_log (FEP_LOG_LEVEL_WARNING,\n\"unix domain socket path too long: %d + 1 >= %d\",\nstrlen (address),\nsizeof (sun.sun_path));\nfree (address);\nreturn NULL;\n}\nclient = xzalloc (sizeof(FepClient));\nclient->filter_running = false;\nclient->messages = NULL;\nmemset (&sun, 0, sizeof(struct sockaddr_un));\nsun.sun_family = AF_UNIX;\nmemcpy (sun.sun_path, address, strlen (address));\nsun_len = sizeof (struct sockaddr_un);\nclient->control = socket (AF_UNIX, SOCK_STREAM, 0);\nif (client->control < 0)\n{\nfree (client);\nreturn NULL;\n}\nretval = connect (client->control,\n(const struct sockaddr *) &sun,\nsun_len);\nif (retval < 0)\n{\nclose (client->control);\nfree (client);\nreturn NULL;\n}\nreturn client;\n}", "label": 0}
{"index": 175964, "code": "static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\nu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\nstruct vcpu_vmx *vmx = to_vmx(vcpu);\nstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\nu32 exit_reason = vmx->exit_reason;\nif (vmx->nested.nested_run_pending)\nreturn 0;\nif (unlikely(vmx->fail)) {\npr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\nvmcs_read32(VM_INSTRUCTION_ERROR));\nreturn 1;\n}\nswitch (exit_reason) {\ncase EXIT_REASON_EXCEPTION_NMI:\nif (!is_exception(intr_info))\nreturn 0;\nelse if (is_page_fault(intr_info))\nreturn enable_ept;\nreturn vmcs12->exception_bitmap &\n(1u << (intr_info & INTR_INFO_VECTOR_MASK));\ncase EXIT_REASON_EXTERNAL_INTERRUPT:\nreturn 0;\ncase EXIT_REASON_TRIPLE_FAULT:\nreturn 1;\ncase EXIT_REASON_PENDING_INTERRUPT:\nreturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\ncase EXIT_REASON_NMI_WINDOW:\nreturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\ncase EXIT_REASON_TASK_SWITCH:\nreturn 1;\ncase EXIT_REASON_CPUID:\nreturn 1;\ncase EXIT_REASON_HLT:\nreturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\ncase EXIT_REASON_INVD:\nreturn 1;\ncase EXIT_REASON_INVLPG:\nreturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\ncase EXIT_REASON_RDPMC:\nreturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\ncase EXIT_REASON_RDTSC:\nreturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\ncase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\ncase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\ncase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\ncase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\ncase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\nreturn 1;\ncase EXIT_REASON_CR_ACCESS:\nreturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\ncase EXIT_REASON_DR_ACCESS:\nreturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\ncase EXIT_REASON_IO_INSTRUCTION:\nreturn nested_vmx_exit_handled_io(vcpu, vmcs12);\ncase EXIT_REASON_MSR_READ:\ncase EXIT_REASON_MSR_WRITE:\nreturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\ncase EXIT_REASON_INVALID_STATE:\nreturn 1;\ncase EXIT_REASON_MWAIT_INSTRUCTION:\nreturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\ncase EXIT_REASON_MONITOR_INSTRUCTION:\nreturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\ncase EXIT_REASON_PAUSE_INSTRUCTION:\nreturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\nnested_cpu_has2(vmcs12,\nSECONDARY_EXEC_PAUSE_LOOP_EXITING);\ncase EXIT_REASON_MCE_DURING_VMENTRY:\nreturn 0;\ncase EXIT_REASON_TPR_BELOW_THRESHOLD:\nreturn 1;\ncase EXIT_REASON_APIC_ACCESS:\nreturn nested_cpu_has2(vmcs12,\nSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\ncase EXIT_REASON_EPT_VIOLATION:\ncase EXIT_REASON_EPT_MISCONFIG:\nreturn 0;\ncase EXIT_REASON_PREEMPTION_TIMER:\nreturn vmcs12->pin_based_vm_exec_control &\nPIN_BASED_VMX_PREEMPTION_TIMER;\ncase EXIT_REASON_WBINVD:\nreturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\ncase EXIT_REASON_XSETBV:\nreturn 1;\ndefault:\nreturn 1;\n}\n}", "contrast": "static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\nu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\nstruct vcpu_vmx *vmx = to_vmx(vcpu);\nstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\nu32 exit_reason = vmx->exit_reason;\nif (vmx->nested.nested_run_pending)\nreturn 0;\nif (unlikely(vmx->fail)) {\npr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\nvmcs_read32(VM_INSTRUCTION_ERROR));\nreturn 1;\n}\nswitch (exit_reason) {\ncase EXIT_REASON_EXCEPTION_NMI:\nif (!is_exception(intr_info))\nreturn 0;\nelse if (is_page_fault(intr_info))\nreturn enable_ept;\nreturn vmcs12->exception_bitmap &\n(1u << (intr_info & INTR_INFO_VECTOR_MASK));\ncase EXIT_REASON_EXTERNAL_INTERRUPT:\nreturn 0;\ncase EXIT_REASON_TRIPLE_FAULT:\nreturn 1;\ncase EXIT_REASON_PENDING_INTERRUPT:\nreturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\ncase EXIT_REASON_NMI_WINDOW:\nreturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\ncase EXIT_REASON_TASK_SWITCH:\nreturn 1;\ncase EXIT_REASON_CPUID:\nreturn 1;\ncase EXIT_REASON_HLT:\nreturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\ncase EXIT_REASON_INVD:\nreturn 1;\ncase EXIT_REASON_INVLPG:\nreturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\ncase EXIT_REASON_RDPMC:\nreturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\ncase EXIT_REASON_RDTSC:\nreturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\ncase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\ncase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\ncase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\ncase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\ncase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\ncase EXIT_REASON_INVEPT:\nreturn 1;\ncase EXIT_REASON_CR_ACCESS:\nreturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\ncase EXIT_REASON_DR_ACCESS:\nreturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\ncase EXIT_REASON_IO_INSTRUCTION:\nreturn nested_vmx_exit_handled_io(vcpu, vmcs12);\ncase EXIT_REASON_MSR_READ:\ncase EXIT_REASON_MSR_WRITE:\nreturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\ncase EXIT_REASON_INVALID_STATE:\nreturn 1;\ncase EXIT_REASON_MWAIT_INSTRUCTION:\nreturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\ncase EXIT_REASON_MONITOR_INSTRUCTION:\nreturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\ncase EXIT_REASON_PAUSE_INSTRUCTION:\nreturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\nnested_cpu_has2(vmcs12,\nSECONDARY_EXEC_PAUSE_LOOP_EXITING);\ncase EXIT_REASON_MCE_DURING_VMENTRY:\nreturn 0;\ncase EXIT_REASON_TPR_BELOW_THRESHOLD:\nreturn 1;\ncase EXIT_REASON_APIC_ACCESS:\nreturn nested_cpu_has2(vmcs12,\nSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\ncase EXIT_REASON_EPT_VIOLATION:\ncase EXIT_REASON_EPT_MISCONFIG:\nreturn 0;\ncase EXIT_REASON_PREEMPTION_TIMER:\nreturn vmcs12->pin_based_vm_exec_control &\nPIN_BASED_VMX_PREEMPTION_TIMER;\ncase EXIT_REASON_WBINVD:\nreturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\ncase EXIT_REASON_XSETBV:\nreturn 1;\ndefault:\nreturn 1;\n}\n}", "label": 0}
{"index": 175965, "code": "int assoc_array_gc(struct assoc_array *array,\nconst struct assoc_array_ops *ops,\nbool (*iterator)(void *object, void *iterator_data),\nvoid *iterator_data)\n{\nstruct assoc_array_shortcut *shortcut, *new_s;\nstruct assoc_array_node *node, *new_n;\nstruct assoc_array_edit *edit;\nstruct assoc_array_ptr *cursor, *ptr;\nstruct assoc_array_ptr *new_root, *new_parent, **new_ptr_pp;\nunsigned long nr_leaves_on_tree;\nint keylen, slot, nr_free, next_slot, i;\npr_devel(\"-->%s()\\n\", __func__);\nif (!array->root)\nreturn 0;\nedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\nif (!edit)\nreturn -ENOMEM;\nedit->array = array;\nedit->ops = ops;\nedit->ops_for_excised_subtree = ops;\nedit->set[0].ptr = &array->root;\nedit->excised_subtree = array->root;\nnew_root = new_parent = NULL;\nnew_ptr_pp = &new_root;\ncursor = array->root;\ndescend:\nif (assoc_array_ptr_is_shortcut(cursor)) {\nshortcut = assoc_array_ptr_to_shortcut(cursor);\nkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\nkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\nnew_s = kmalloc(sizeof(struct assoc_array_shortcut) +\nkeylen * sizeof(unsigned long), GFP_KERNEL);\nif (!new_s)\ngoto enomem;\npr_devel(\"dup shortcut %p -> %p\\n\", shortcut, new_s);\nmemcpy(new_s, shortcut, (sizeof(struct assoc_array_shortcut) +\nkeylen * sizeof(unsigned long)));\nnew_s->back_pointer = new_parent;\nnew_s->parent_slot = shortcut->parent_slot;\n*new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr(new_s);\nnew_ptr_pp = &new_s->next_node;\ncursor = shortcut->next_node;\n}\nnode = assoc_array_ptr_to_node(cursor);\nnew_n = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\nif (!new_n)\ngoto enomem;\npr_devel(\"dup node %p -> %p\\n\", node, new_n);\nnew_n->back_pointer = new_parent;\nnew_n->parent_slot = node->parent_slot;\n*new_ptr_pp = new_parent = assoc_array_node_to_ptr(new_n);\nnew_ptr_pp = NULL;\nslot = 0;\ncontinue_node:\nfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\nptr = node->slots[slot];\nif (!ptr)\ncontinue;\nif (assoc_array_ptr_is_leaf(ptr)) {\nif (iterator(assoc_array_ptr_to_leaf(ptr),\niterator_data))\nnew_n->slots[slot] = ptr;\ncontinue;\n}\nnew_ptr_pp = &new_n->slots[slot];\ncursor = ptr;\ngoto descend;\n}\npr_devel(\"-- compress node %p --\\n\", new_n);\nnew_n->nr_leaves_on_branch = 0;\nnr_free = 0;\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\nptr = new_n->slots[slot];\nif (!ptr)\nnr_free++;\nelse if (assoc_array_ptr_is_leaf(ptr))\nnew_n->nr_leaves_on_branch++;\n}\npr_devel(\"free=%d, leaves=%lu\\n\", nr_free, new_n->nr_leaves_on_branch);\nnext_slot = 0;\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\nstruct assoc_array_shortcut *s;\nstruct assoc_array_node *child;\nptr = new_n->slots[slot];\nif (!ptr || assoc_array_ptr_is_leaf(ptr))\ncontinue;\ns = NULL;\nif (assoc_array_ptr_is_shortcut(ptr)) {\ns = assoc_array_ptr_to_shortcut(ptr);\nptr = s->next_node;\n}\nchild = assoc_array_ptr_to_node(ptr);\nnew_n->nr_leaves_on_branch += child->nr_leaves_on_branch;\nif (child->nr_leaves_on_branch <= nr_free + 1) {\npr_devel(\"[%d] fold node %lu/%d [nx %d]\\n\",\nslot, child->nr_leaves_on_branch, nr_free + 1,\nnext_slot);\nBUG_ON(s);\nnew_n->slots[slot] = NULL;\nnr_free++;\nif (slot < next_slot)\nnext_slot = slot;\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\nstruct assoc_array_ptr *p = child->slots[i];\nif (!p)\ncontinue;\nBUG_ON(assoc_array_ptr_is_meta(p));\nwhile (new_n->slots[next_slot])\nnext_slot++;\nBUG_ON(next_slot >= ASSOC_ARRAY_FAN_OUT);\nnew_n->slots[next_slot++] = p;\nnr_free--;\n}\nkfree(child);\n} else {\npr_devel(\"[%d] retain node %lu/%d [nx %d]\\n\",\nslot, child->nr_leaves_on_branch, nr_free + 1,\nnext_slot);\n}\n}\npr_devel(\"after: %lu\\n\", new_n->nr_leaves_on_branch);\nnr_leaves_on_tree = new_n->nr_leaves_on_branch;\nif (nr_free == ASSOC_ARRAY_FAN_OUT - 1) {\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++)\nif ((ptr = new_n->slots[slot]))\nbreak;\nif (assoc_array_ptr_is_meta(ptr) &&\nassoc_array_ptr_is_shortcut(ptr)) {\npr_devel(\"excise node %p with 1 shortcut\\n\", new_n);\nnew_s = assoc_array_ptr_to_shortcut(ptr);\nnew_parent = new_n->back_pointer;\nslot = new_n->parent_slot;\nkfree(new_n);\nif (!new_parent) {\nnew_s->back_pointer = NULL;\nnew_s->parent_slot = 0;\nnew_root = ptr;\ngoto gc_complete;\n}\nif (assoc_array_ptr_is_shortcut(new_parent)) {\nstruct assoc_array_shortcut *s =\nassoc_array_ptr_to_shortcut(new_parent);\npr_devel(\"excise preceding shortcut\\n\");\nnew_parent = new_s->back_pointer = s->back_pointer;\nslot = new_s->parent_slot = s->parent_slot;\nkfree(s);\nif (!new_parent) {\nnew_s->back_pointer = NULL;\nnew_s->parent_slot = 0;\nnew_root = ptr;\ngoto gc_complete;\n}\n}\nnew_s->back_pointer = new_parent;\nnew_s->parent_slot = slot;\nnew_n = assoc_array_ptr_to_node(new_parent);\nnew_n->slots[slot] = ptr;\ngoto ascend_old_tree;\n}\n}\nptr = new_n->back_pointer;\nif (!ptr)\ngoto gc_complete;\nif (assoc_array_ptr_is_shortcut(ptr)) {\nnew_s = assoc_array_ptr_to_shortcut(ptr);\nnew_parent = new_s->back_pointer;\nslot = new_s->parent_slot;\nif (new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {\nstruct assoc_array_node *n;\npr_devel(\"excise shortcut\\n\");\nnew_n->back_pointer = new_parent;\nnew_n->parent_slot = slot;\nkfree(new_s);\nif (!new_parent) {\nnew_root = assoc_array_node_to_ptr(new_n);\ngoto gc_complete;\n}\nn = assoc_array_ptr_to_node(new_parent);\nn->slots[slot] = assoc_array_node_to_ptr(new_n);\n}\n} else {\nnew_parent = ptr;\n}\nnew_n = assoc_array_ptr_to_node(new_parent);\nascend_old_tree:\nptr = node->back_pointer;\nif (assoc_array_ptr_is_shortcut(ptr)) {\nshortcut = assoc_array_ptr_to_shortcut(ptr);\nslot = shortcut->parent_slot;\ncursor = shortcut->back_pointer;\n} else {\nslot = node->parent_slot;\ncursor = ptr;\n}\nBUG_ON(!ptr);\nnode = assoc_array_ptr_to_node(cursor);\nslot++;\ngoto continue_node;\ngc_complete:\nedit->set[0].to = new_root;\nassoc_array_apply_edit(edit);\narray->nr_leaves_on_tree = nr_leaves_on_tree;\nreturn 0;\nenomem:\npr_devel(\"enomem\\n\");\nassoc_array_destroy_subtree(new_root, edit->ops);\nkfree(edit);\nreturn -ENOMEM;\n}", "contrast": "int assoc_array_gc(struct assoc_array *array,\nconst struct assoc_array_ops *ops,\nbool (*iterator)(void *object, void *iterator_data),\nvoid *iterator_data)\n{\nstruct assoc_array_shortcut *shortcut, *new_s;\nstruct assoc_array_node *node, *new_n;\nstruct assoc_array_edit *edit;\nstruct assoc_array_ptr *cursor, *ptr;\nstruct assoc_array_ptr *new_root, *new_parent, **new_ptr_pp;\nunsigned long nr_leaves_on_tree;\nint keylen, slot, nr_free, next_slot, i;\npr_devel(\"-->%s()\\n\", __func__);\nif (!array->root)\nreturn 0;\nedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\nif (!edit)\nreturn -ENOMEM;\nedit->array = array;\nedit->ops = ops;\nedit->ops_for_excised_subtree = ops;\nedit->set[0].ptr = &array->root;\nedit->excised_subtree = array->root;\nnew_root = new_parent = NULL;\nnew_ptr_pp = &new_root;\ncursor = array->root;\ndescend:\nif (assoc_array_ptr_is_shortcut(cursor)) {\nshortcut = assoc_array_ptr_to_shortcut(cursor);\nkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\nkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\nnew_s = kmalloc(sizeof(struct assoc_array_shortcut) +\nkeylen * sizeof(unsigned long), GFP_KERNEL);\nif (!new_s)\ngoto enomem;\npr_devel(\"dup shortcut %p -> %p\\n\", shortcut, new_s);\nmemcpy(new_s, shortcut, (sizeof(struct assoc_array_shortcut) +\nkeylen * sizeof(unsigned long)));\nnew_s->back_pointer = new_parent;\nnew_s->parent_slot = shortcut->parent_slot;\n*new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr(new_s);\nnew_ptr_pp = &new_s->next_node;\ncursor = shortcut->next_node;\n}\nnode = assoc_array_ptr_to_node(cursor);\nnew_n = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\nif (!new_n)\ngoto enomem;\npr_devel(\"dup node %p -> %p\\n\", node, new_n);\nnew_n->back_pointer = new_parent;\nnew_n->parent_slot = node->parent_slot;\n*new_ptr_pp = new_parent = assoc_array_node_to_ptr(new_n);\nnew_ptr_pp = NULL;\nslot = 0;\ncontinue_node:\nfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\nptr = node->slots[slot];\nif (!ptr)\ncontinue;\nif (assoc_array_ptr_is_leaf(ptr)) {\nif (iterator(assoc_array_ptr_to_leaf(ptr),\niterator_data))\nnew_n->slots[slot] = ptr;\ncontinue;\n}\nnew_ptr_pp = &new_n->slots[slot];\ncursor = ptr;\ngoto descend;\n}\npr_devel(\"-- compress node %p --\\n\", new_n);\nnew_n->nr_leaves_on_branch = 0;\nnr_free = 0;\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\nptr = new_n->slots[slot];\nif (!ptr)\nnr_free++;\nelse if (assoc_array_ptr_is_leaf(ptr))\nnew_n->nr_leaves_on_branch++;\n}\npr_devel(\"free=%d, leaves=%lu\\n\", nr_free, new_n->nr_leaves_on_branch);\nnext_slot = 0;\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\nstruct assoc_array_shortcut *s;\nstruct assoc_array_node *child;\nptr = new_n->slots[slot];\nif (!ptr || assoc_array_ptr_is_leaf(ptr))\ncontinue;\ns = NULL;\nif (assoc_array_ptr_is_shortcut(ptr)) {\ns = assoc_array_ptr_to_shortcut(ptr);\nptr = s->next_node;\n}\nchild = assoc_array_ptr_to_node(ptr);\nnew_n->nr_leaves_on_branch += child->nr_leaves_on_branch;\nif (child->nr_leaves_on_branch <= nr_free + 1) {\npr_devel(\"[%d] fold node %lu/%d [nx %d]\\n\",\nslot, child->nr_leaves_on_branch, nr_free + 1,\nnext_slot);\nBUG_ON(s);\nnew_n->slots[slot] = NULL;\nnr_free++;\nif (slot < next_slot)\nnext_slot = slot;\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\nstruct assoc_array_ptr *p = child->slots[i];\nif (!p)\ncontinue;\nBUG_ON(assoc_array_ptr_is_meta(p));\nwhile (new_n->slots[next_slot])\nnext_slot++;\nBUG_ON(next_slot >= ASSOC_ARRAY_FAN_OUT);\nnew_n->slots[next_slot++] = p;\nnr_free--;\n}\nkfree(child);\n} else {\npr_devel(\"[%d] retain node %lu/%d [nx %d]\\n\",\nslot, child->nr_leaves_on_branch, nr_free + 1,\nnext_slot);\n}\n}\npr_devel(\"after: %lu\\n\", new_n->nr_leaves_on_branch);\nnr_leaves_on_tree = new_n->nr_leaves_on_branch;\nif (nr_free == ASSOC_ARRAY_FAN_OUT - 1) {\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++)\nif ((ptr = new_n->slots[slot]))\nbreak;\nif (assoc_array_ptr_is_meta(ptr) &&\nassoc_array_ptr_is_shortcut(ptr)) {\npr_devel(\"excise node %p with 1 shortcut\\n\", new_n);\nnew_s = assoc_array_ptr_to_shortcut(ptr);\nnew_parent = new_n->back_pointer;\nslot = new_n->parent_slot;\nkfree(new_n);\nif (!new_parent) {\nnew_s->back_pointer = NULL;\nnew_s->parent_slot = 0;\nnew_root = ptr;\ngoto gc_complete;\n}\nif (assoc_array_ptr_is_shortcut(new_parent)) {\nstruct assoc_array_shortcut *s =\nassoc_array_ptr_to_shortcut(new_parent);\npr_devel(\"excise preceding shortcut\\n\");\nnew_parent = new_s->back_pointer = s->back_pointer;\nslot = new_s->parent_slot = s->parent_slot;\nkfree(s);\nif (!new_parent) {\nnew_s->back_pointer = NULL;\nnew_s->parent_slot = 0;\nnew_root = ptr;\ngoto gc_complete;\n}\n}\nnew_s->back_pointer = new_parent;\nnew_s->parent_slot = slot;\nnew_n = assoc_array_ptr_to_node(new_parent);\nnew_n->slots[slot] = ptr;\ngoto ascend_old_tree;\n}\n}\nptr = new_n->back_pointer;\nif (!ptr)\ngoto gc_complete;\nif (assoc_array_ptr_is_shortcut(ptr)) {\nnew_s = assoc_array_ptr_to_shortcut(ptr);\nnew_parent = new_s->back_pointer;\nslot = new_s->parent_slot;\nif (new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {\nstruct assoc_array_node *n;\npr_devel(\"excise shortcut\\n\");\nnew_n->back_pointer = new_parent;\nnew_n->parent_slot = slot;\nkfree(new_s);\nif (!new_parent) {\nnew_root = assoc_array_node_to_ptr(new_n);\ngoto gc_complete;\n}\nn = assoc_array_ptr_to_node(new_parent);\nn->slots[slot] = assoc_array_node_to_ptr(new_n);\n}\n} else {\nnew_parent = ptr;\n}\nnew_n = assoc_array_ptr_to_node(new_parent);\nascend_old_tree:\nptr = node->back_pointer;\nif (assoc_array_ptr_is_shortcut(ptr)) {\nshortcut = assoc_array_ptr_to_shortcut(ptr);\nslot = shortcut->parent_slot;\ncursor = shortcut->back_pointer;\nif (!cursor)\ngoto gc_complete;\n} else {\nslot = node->parent_slot;\ncursor = ptr;\n}\nBUG_ON(!cursor);\nnode = assoc_array_ptr_to_node(cursor);\nslot++;\ngoto continue_node;\ngc_complete:\nedit->set[0].to = new_root;\nassoc_array_apply_edit(edit);\narray->nr_leaves_on_tree = nr_leaves_on_tree;\nreturn 0;\nenomem:\npr_devel(\"enomem\\n\");\nassoc_array_destroy_subtree(new_root, edit->ops);\nkfree(edit);\nreturn -ENOMEM;\n}", "label": 0}
{"index": 175967, "code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\nstruct msr_data msr;\nu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\nu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\nmsr.data = data;\nmsr.index = ecx;\nmsr.host_initiated = false;\nsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\nif (svm_set_msr(&svm->vcpu, &msr)) {\ntrace_kvm_msr_write_ex(ecx, data);\nkvm_inject_gp(&svm->vcpu, 0);\n} else {\ntrace_kvm_msr_write(ecx, data);\nskip_emulated_instruction(&svm->vcpu);\n}\nreturn 1;\n}", "contrast": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\nstruct msr_data msr;\nu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\nu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\nmsr.data = data;\nmsr.index = ecx;\nmsr.host_initiated = false;\nsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\nif (kvm_set_msr(&svm->vcpu, &msr)) {\ntrace_kvm_msr_write_ex(ecx, data);\nkvm_inject_gp(&svm->vcpu, 0);\n} else {\ntrace_kvm_msr_write(ecx, data);\nskip_emulated_instruction(&svm->vcpu);\n}\nreturn 1;\n}", "label": 0}
{"index": 175976, "code": "static int picolcd_raw_event(struct hid_device *hdev,\nstruct hid_report *report, u8 *raw_data, int size)\n{\nstruct picolcd_data *data = hid_get_drvdata(hdev);\nunsigned long flags;\nint ret = 0;\nif (!data)\nreturn 1;\nif (report->id == REPORT_KEY_STATE) {\nif (data->input_keys)\nret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n} else if (report->id == REPORT_IR_DATA) {\nret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n} else {\nspin_lock_irqsave(&data->lock, flags);\nif (data->pending) {\nmemcpy(data->pending->raw_data, raw_data+1, size-1);\ndata->pending->raw_size  = size-1;\ndata->pending->in_report = report;\ncomplete(&data->pending->ready);\n}\nspin_unlock_irqrestore(&data->lock, flags);\n}\npicolcd_debug_raw_event(data, hdev, report, raw_data, size);\nreturn 1;\n}", "contrast": "static int picolcd_raw_event(struct hid_device *hdev,\nstruct hid_report *report, u8 *raw_data, int size)\n{\nstruct picolcd_data *data = hid_get_drvdata(hdev);\nunsigned long flags;\nint ret = 0;\nif (!data)\nreturn 1;\nif (size > 64) {\nhid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\nsize);\nreturn 0;\n}\nif (report->id == REPORT_KEY_STATE) {\nif (data->input_keys)\nret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n} else if (report->id == REPORT_IR_DATA) {\nret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n} else {\nspin_lock_irqsave(&data->lock, flags);\nif (data->pending) {\nmemcpy(data->pending->raw_data, raw_data+1, size-1);\ndata->pending->raw_size  = size-1;\ndata->pending->in_report = report;\ncomplete(&data->pending->ready);\n}\nspin_unlock_irqrestore(&data->lock, flags);\n}\npicolcd_debug_raw_event(data, hdev, report, raw_data, size);\nreturn 1;\n}", "label": 0}
{"index": 175996, "code": "struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\nconst u8 *addr, gfp_t gfp)\n{\nstruct ieee80211_local *local = sdata->local;\nstruct sta_info *sta;\nstruct timespec uptime;\nstruct ieee80211_tx_latency_bin_ranges *tx_latency;\nint i;\nsta = kzalloc(sizeof(*sta) + local->hw.sta_data_size, gfp);\nif (!sta)\nreturn NULL;\nrcu_read_lock();\ntx_latency = rcu_dereference(local->tx_latency);\nif (tx_latency) {\nsta->tx_lat = kzalloc(IEEE80211_NUM_TIDS *\nsizeof(struct ieee80211_tx_latency_stat),\nGFP_ATOMIC);\nif (!sta->tx_lat) {\nrcu_read_unlock();\ngoto free;\n}\nif (tx_latency->n_ranges) {\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\nsta->tx_lat[i].bin_count =\ntx_latency->n_ranges + 1;\nsta->tx_lat[i].bins =\nkcalloc(sta->tx_lat[i].bin_count,\nsizeof(u32), GFP_ATOMIC);\nif (!sta->tx_lat[i].bins) {\nrcu_read_unlock();\ngoto free;\n}\n}\n}\n}\nrcu_read_unlock();\nspin_lock_init(&sta->lock);\nINIT_WORK(&sta->drv_unblock_wk, sta_unblock);\nINIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);\nmutex_init(&sta->ampdu_mlme.mtx);\n#ifdef CONFIG_MAC80211_MESH\nif (ieee80211_vif_is_mesh(&sdata->vif) &&\n!sdata->u.mesh.user_mpm)\ninit_timer(&sta->plink_timer);\nsta->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\n#endif\nmemcpy(sta->sta.addr, addr, ETH_ALEN);\nsta->local = local;\nsta->sdata = sdata;\nsta->last_rx = jiffies;\nsta->sta_state = IEEE80211_STA_NONE;\ndo_posix_clock_monotonic_gettime(&uptime);\nsta->last_connected = uptime.tv_sec;\newma_init(&sta->avg_signal, 1024, 8);\nfor (i = 0; i < ARRAY_SIZE(sta->chain_signal_avg); i++)\newma_init(&sta->chain_signal_avg[i], 1024, 8);\nif (sta_prepare_rate_control(local, sta, gfp))\ngoto free;\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\nsta->timer_to_tid[i] = i;\n}\nfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\nskb_queue_head_init(&sta->ps_tx_buf[i]);\nskb_queue_head_init(&sta->tx_filtered[i]);\n}\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\nsta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\nsta->sta.smps_mode = IEEE80211_SMPS_OFF;\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\nstruct ieee80211_supported_band *sband =\nlocal->hw.wiphy->bands[ieee80211_get_sdata_band(sdata)];\nu8 smps = (sband->ht_cap.cap & IEEE80211_HT_CAP_SM_PS) >>\nIEEE80211_HT_CAP_SM_PS_SHIFT;\nswitch (smps) {\ncase WLAN_HT_SMPS_CONTROL_DISABLED:\nsta->known_smps_mode = IEEE80211_SMPS_OFF;\nbreak;\ncase WLAN_HT_SMPS_CONTROL_STATIC:\nsta->known_smps_mode = IEEE80211_SMPS_STATIC;\nbreak;\ncase WLAN_HT_SMPS_CONTROL_DYNAMIC:\nsta->known_smps_mode = IEEE80211_SMPS_DYNAMIC;\nbreak;\ndefault:\nWARN_ON(1);\n}\n}\nsta_dbg(sdata, \"Allocated STA %pM\\n\", sta->sta.addr);\nreturn sta;\nfree:\nif (sta->tx_lat) {\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\nkfree(sta->tx_lat[i].bins);\nkfree(sta->tx_lat);\n}\nkfree(sta);\nreturn NULL;\n}", "contrast": "struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\nconst u8 *addr, gfp_t gfp)\n{\nstruct ieee80211_local *local = sdata->local;\nstruct sta_info *sta;\nstruct timespec uptime;\nstruct ieee80211_tx_latency_bin_ranges *tx_latency;\nint i;\nsta = kzalloc(sizeof(*sta) + local->hw.sta_data_size, gfp);\nif (!sta)\nreturn NULL;\nrcu_read_lock();\ntx_latency = rcu_dereference(local->tx_latency);\nif (tx_latency) {\nsta->tx_lat = kzalloc(IEEE80211_NUM_TIDS *\nsizeof(struct ieee80211_tx_latency_stat),\nGFP_ATOMIC);\nif (!sta->tx_lat) {\nrcu_read_unlock();\ngoto free;\n}\nif (tx_latency->n_ranges) {\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\nsta->tx_lat[i].bin_count =\ntx_latency->n_ranges + 1;\nsta->tx_lat[i].bins =\nkcalloc(sta->tx_lat[i].bin_count,\nsizeof(u32), GFP_ATOMIC);\nif (!sta->tx_lat[i].bins) {\nrcu_read_unlock();\ngoto free;\n}\n}\n}\n}\nrcu_read_unlock();\nspin_lock_init(&sta->lock);\nspin_lock_init(&sta->ps_lock);\nINIT_WORK(&sta->drv_unblock_wk, sta_unblock);\nINIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);\nmutex_init(&sta->ampdu_mlme.mtx);\n#ifdef CONFIG_MAC80211_MESH\nif (ieee80211_vif_is_mesh(&sdata->vif) &&\n!sdata->u.mesh.user_mpm)\ninit_timer(&sta->plink_timer);\nsta->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\n#endif\nmemcpy(sta->sta.addr, addr, ETH_ALEN);\nsta->local = local;\nsta->sdata = sdata;\nsta->last_rx = jiffies;\nsta->sta_state = IEEE80211_STA_NONE;\ndo_posix_clock_monotonic_gettime(&uptime);\nsta->last_connected = uptime.tv_sec;\newma_init(&sta->avg_signal, 1024, 8);\nfor (i = 0; i < ARRAY_SIZE(sta->chain_signal_avg); i++)\newma_init(&sta->chain_signal_avg[i], 1024, 8);\nif (sta_prepare_rate_control(local, sta, gfp))\ngoto free;\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\nsta->timer_to_tid[i] = i;\n}\nfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\nskb_queue_head_init(&sta->ps_tx_buf[i]);\nskb_queue_head_init(&sta->tx_filtered[i]);\n}\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\nsta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\nsta->sta.smps_mode = IEEE80211_SMPS_OFF;\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\nstruct ieee80211_supported_band *sband =\nlocal->hw.wiphy->bands[ieee80211_get_sdata_band(sdata)];\nu8 smps = (sband->ht_cap.cap & IEEE80211_HT_CAP_SM_PS) >>\nIEEE80211_HT_CAP_SM_PS_SHIFT;\nswitch (smps) {\ncase WLAN_HT_SMPS_CONTROL_DISABLED:\nsta->known_smps_mode = IEEE80211_SMPS_OFF;\nbreak;\ncase WLAN_HT_SMPS_CONTROL_STATIC:\nsta->known_smps_mode = IEEE80211_SMPS_STATIC;\nbreak;\ncase WLAN_HT_SMPS_CONTROL_DYNAMIC:\nsta->known_smps_mode = IEEE80211_SMPS_DYNAMIC;\nbreak;\ndefault:\nWARN_ON(1);\n}\n}\nsta_dbg(sdata, \"Allocated STA %pM\\n\", sta->sta.addr);\nreturn sta;\nfree:\nif (sta->tx_lat) {\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\nkfree(sta->tx_lat[i].bins);\nkfree(sta->tx_lat);\n}\nkfree(sta);\nreturn NULL;\n}", "label": 0}
{"index": 176021, "code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\nunsigned int dataoff, unsigned int *timeouts)\n{\nstruct net *net = nf_ct_net(ct);\nstruct dccp_net *dn;\nstruct dccp_hdr _dh, *dh;\nconst char *msg;\nu_int8_t state;\ndh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\nBUG_ON(dh == NULL);\nstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\nswitch (state) {\ndefault:\ndn = dccp_pernet(net);\nif (dn->dccp_loose == 0) {\nmsg = \"nf_ct_dccp: not picking up existing connection \";\ngoto out_invalid;\n}\ncase CT_DCCP_REQUEST:\nbreak;\ncase CT_DCCP_INVALID:\nmsg = \"nf_ct_dccp: invalid state transition \";\ngoto out_invalid;\n}\nct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\nct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\nct->proto.dccp.state = CT_DCCP_NONE;\nct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\nct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\nct->proto.dccp.handshake_seq = 0;\nreturn true;\nout_invalid:\nif (LOG_INVALID(net, IPPROTO_DCCP))\nnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\nNULL, \"%s\", msg);\nreturn false;\n}", "contrast": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\nunsigned int dataoff, unsigned int *timeouts)\n{\nstruct net *net = nf_ct_net(ct);\nstruct dccp_net *dn;\nstruct dccp_hdr _dh, *dh;\nconst char *msg;\nu_int8_t state;\ndh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\nBUG_ON(dh == NULL);\nstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\nswitch (state) {\ndefault:\ndn = dccp_pernet(net);\nif (dn->dccp_loose == 0) {\nmsg = \"nf_ct_dccp: not picking up existing connection \";\ngoto out_invalid;\n}\ncase CT_DCCP_REQUEST:\nbreak;\ncase CT_DCCP_INVALID:\nmsg = \"nf_ct_dccp: invalid state transition \";\ngoto out_invalid;\n}\nct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\nct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\nct->proto.dccp.state = CT_DCCP_NONE;\nct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\nct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\nct->proto.dccp.handshake_seq = 0;\nreturn true;\nout_invalid:\nif (LOG_INVALID(net, IPPROTO_DCCP))\nnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\nNULL, \"%s\", msg);\nreturn false;\n}", "label": 0}
{"index": 176028, "code": "PHP_FUNCTION(imageaffinematrixget)\n{\ndouble affine[6];\nlong type;\nzval *options;\nzval **tmp;\nint res = GD_FALSE, i;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &type, &options) == FAILURE)  {\nreturn;\n}\nswitch((gdAffineStandardMatrix)type) {\ncase GD_AFFINE_TRANSLATE:\ncase GD_AFFINE_SCALE: {\ndouble x, y;\nif (Z_TYPE_P(options) != IS_ARRAY) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n}\nif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\nconvert_to_double_ex(tmp);\nx = Z_DVAL_PP(tmp);\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\nRETURN_FALSE;\n}\nif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\nconvert_to_double_ex(tmp);\ny = Z_DVAL_PP(tmp);\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\nRETURN_FALSE;\n}\nif (type == GD_AFFINE_TRANSLATE) {\nres = gdAffineTranslate(affine, x, y);\n} else {\nres = gdAffineScale(affine, x, y);\n}\nbreak;\n}\ncase GD_AFFINE_ROTATE:\ncase GD_AFFINE_SHEAR_HORIZONTAL:\ncase GD_AFFINE_SHEAR_VERTICAL: {\ndouble angle;\nconvert_to_double_ex(&options);\nangle = Z_DVAL_P(options);\nif (type == GD_AFFINE_SHEAR_HORIZONTAL) {\nres = gdAffineShearHorizontal(affine, angle);\n} else if (type == GD_AFFINE_SHEAR_VERTICAL) {\nres = gdAffineShearVertical(affine, angle);\n} else {\nres = gdAffineRotate(affine, angle);\n}\nbreak;\n}\ndefault:\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %li\", type);\nRETURN_FALSE;\n}\nif (res == GD_FALSE) {\nRETURN_FALSE;\n} else {\narray_init(return_value);\nfor (i = 0; i < 6; i++) {\nadd_index_double(return_value, i, affine[i]);\n}\n}\n}", "contrast": "PHP_FUNCTION(imageaffinematrixget)\n{\ndouble affine[6];\nlong type;\nzval *options;\nzval **tmp;\nint res = GD_FALSE, i;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &type, &options) == FAILURE)  {\nreturn;\n}\nswitch((gdAffineStandardMatrix)type) {\ncase GD_AFFINE_TRANSLATE:\ncase GD_AFFINE_SCALE: {\ndouble x, y;\nif (Z_TYPE_P(options) != IS_ARRAY) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n}\nif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\nif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\nzval dval;\ndval = **tmp;\nzval_copy_ctor(&dval);\nconvert_to_double(&dval);\nx = Z_DVAL(dval);\n} else {\nx = Z_DVAL_PP(tmp);\n}\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\nRETURN_FALSE;\n}\nif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\nif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\nzval dval;\ndval = **tmp;\nzval_copy_ctor(&dval);\nconvert_to_double(&dval);\ny = Z_DVAL(dval);\n} else {\ny = Z_DVAL_PP(tmp);\n}\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\nRETURN_FALSE;\n}\nif (type == GD_AFFINE_TRANSLATE) {\nres = gdAffineTranslate(affine, x, y);\n} else {\nres = gdAffineScale(affine, x, y);\n}\nbreak;\n}\ncase GD_AFFINE_ROTATE:\ncase GD_AFFINE_SHEAR_HORIZONTAL:\ncase GD_AFFINE_SHEAR_VERTICAL: {\ndouble angle;\nconvert_to_double_ex(&options);\nangle = Z_DVAL_P(options);\nif (type == GD_AFFINE_SHEAR_HORIZONTAL) {\nres = gdAffineShearHorizontal(affine, angle);\n} else if (type == GD_AFFINE_SHEAR_VERTICAL) {\nres = gdAffineShearVertical(affine, angle);\n} else {\nres = gdAffineRotate(affine, angle);\n}\nbreak;\n}\ndefault:\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %li\", type);\nRETURN_FALSE;\n}\nif (res == GD_FALSE) {\nRETURN_FALSE;\n} else {\narray_init(return_value);\nfor (i = 0; i < 6; i++) {\nadd_index_double(return_value, i, affine[i]);\n}\n}\n}", "label": 0}
{"index": 176034, "code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\nconst size_t size = sizeof(sync_serial_settings);\nsync_serial_settings line;\nport_t *port = dev_to_port(dev);\nif (cmd != SIOCWANDEV)\nreturn hdlc_ioctl(dev, ifr, cmd);\nswitch (ifr->ifr_settings.type) {\ncase IF_GET_IFACE:\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\nif (ifr->ifr_settings.size < size) {\nifr->ifr_settings.size = size;\nreturn -ENOBUFS;\n}\nline.clock_type = get_status(port)->clocking;\nline.clock_rate = 0;\nline.loopback = 0;\nif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\nreturn -EFAULT;\nreturn 0;\ncase IF_IFACE_SYNC_SERIAL:\nif (!capable(CAP_NET_ADMIN))\nreturn -EPERM;\nif (dev->flags & IFF_UP)\nreturn -EBUSY;\nif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\nsize))\nreturn -EFAULT;\nif (line.clock_type != CLOCK_EXT &&\nline.clock_type != CLOCK_TXFROMRX)\nreturn -EINVAL;\nif (line.loopback != 0)\nreturn -EINVAL;\nget_status(port)->clocking = line.clock_type;\nreturn 0;\ndefault:\nreturn hdlc_ioctl(dev, ifr, cmd);\n}\n}", "contrast": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\nconst size_t size = sizeof(sync_serial_settings);\nsync_serial_settings line;\nport_t *port = dev_to_port(dev);\nif (cmd != SIOCWANDEV)\nreturn hdlc_ioctl(dev, ifr, cmd);\nswitch (ifr->ifr_settings.type) {\ncase IF_GET_IFACE:\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\nif (ifr->ifr_settings.size < size) {\nifr->ifr_settings.size = size;\nreturn -ENOBUFS;\n}\nmemset(&line, 0, sizeof(line));\nline.clock_type = get_status(port)->clocking;\nline.clock_rate = 0;\nline.loopback = 0;\nif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\nreturn -EFAULT;\nreturn 0;\ncase IF_IFACE_SYNC_SERIAL:\nif (!capable(CAP_NET_ADMIN))\nreturn -EPERM;\nif (dev->flags & IFF_UP)\nreturn -EBUSY;\nif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\nsize))\nreturn -EFAULT;\nif (line.clock_type != CLOCK_EXT &&\nline.clock_type != CLOCK_TXFROMRX)\nreturn -EINVAL;\nif (line.loopback != 0)\nreturn -EINVAL;\nget_status(port)->clocking = line.clock_type;\nreturn 0;\ndefault:\nreturn hdlc_ioctl(dev, ifr, cmd);\n}\n}", "label": 0}
{"index": 176039, "code": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\nsize_t count, const uint64_t clsid[2])\n{\nsize_t i;\ncdf_timestamp_t tp;\nstruct timespec ts;\nchar buf[64];\nconst char *str = NULL;\nconst char *s;\nint len;\nif (!NOTMIME(ms))\nstr = cdf_clsid_to_mime(clsid, clsid2mime);\nfor (i = 0; i < count; i++) {\ncdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\nswitch (info[i].pi_type) {\ncase CDF_NULL:\nbreak;\ncase CDF_SIGNED16:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\ninfo[i].pi_s16) == -1)\nreturn -1;\nbreak;\ncase CDF_SIGNED32:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\ninfo[i].pi_s32) == -1)\nreturn -1;\nbreak;\ncase CDF_UNSIGNED32:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\ninfo[i].pi_u32) == -1)\nreturn -1;\nbreak;\ncase CDF_FLOAT:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\ninfo[i].pi_f) == -1)\nreturn -1;\nbreak;\ncase CDF_DOUBLE:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\ninfo[i].pi_d) == -1)\nreturn -1;\nbreak;\ncase CDF_LENGTH32_STRING:\ncase CDF_LENGTH32_WSTRING:\nlen = info[i].pi_str.s_len;\nif (len > 1) {\nchar vbuf[1024];\nsize_t j, k = 1;\nif (info[i].pi_type == CDF_LENGTH32_WSTRING)\nk++;\ns = info[i].pi_str.s_buf;\nfor (j = 0; j < sizeof(vbuf) && len--;\nj++, s += k) {\nif (*s == '\\0')\nbreak;\nif (isprint((unsigned char)*s))\nvbuf[j] = *s;\n}\nif (j == sizeof(vbuf))\n--j;\nvbuf[j] = '\\0';\nif (NOTMIME(ms)) {\nif (vbuf[0]) {\nif (file_printf(ms, \", %s: %s\",\nbuf, vbuf) == -1)\nreturn -1;\n}\n} else if (str == NULL && info[i].pi_id ==\nCDF_PROPERTY_NAME_OF_APPLICATION) {\nstr = cdf_app_to_mime(vbuf, app2mime);\n}\n}\nbreak;\ncase CDF_FILETIME:\ntp = info[i].pi_tp;\nif (tp != 0) {\nchar tbuf[64];\nif (tp < 1000000000000000LL) {\ncdf_print_elapsed_time(tbuf,\nsizeof(tbuf), tp);\nif (NOTMIME(ms) && file_printf(ms,\n\", %s: %s\", buf, tbuf) == -1)\nreturn -1;\n} else {\nchar *c, *ec;\ncdf_timestamp_to_timespec(&ts, tp);\nc = cdf_ctime(&ts.tv_sec, tbuf);\nif (c != NULL &&\n(ec = strchr(c, '\\n')) != NULL)\n*ec = '\\0';\nif (NOTMIME(ms) && file_printf(ms,\n\", %s: %s\", buf, c) == -1)\nreturn -1;\n}\n}\nbreak;\ncase CDF_CLIPBOARD:\nbreak;\ndefault:\nreturn -1;\n}\n}\nif (!NOTMIME(ms)) {\nif (str == NULL)\nreturn 0;\nif (file_printf(ms, \"application/%s\", str) == -1)\nreturn -1;\n}\nreturn 1;\n}", "contrast": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\nsize_t count, const cdf_directory_t *root_storage)\n{\nsize_t i;\ncdf_timestamp_t tp;\nstruct timespec ts;\nchar buf[64];\nconst char *str = NULL;\nconst char *s;\nint len;\nif (!NOTMIME(ms) && root_storage)\nstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);\nfor (i = 0; i < count; i++) {\ncdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\nswitch (info[i].pi_type) {\ncase CDF_NULL:\nbreak;\ncase CDF_SIGNED16:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\ninfo[i].pi_s16) == -1)\nreturn -1;\nbreak;\ncase CDF_SIGNED32:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\ninfo[i].pi_s32) == -1)\nreturn -1;\nbreak;\ncase CDF_UNSIGNED32:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\ninfo[i].pi_u32) == -1)\nreturn -1;\nbreak;\ncase CDF_FLOAT:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\ninfo[i].pi_f) == -1)\nreturn -1;\nbreak;\ncase CDF_DOUBLE:\nif (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\ninfo[i].pi_d) == -1)\nreturn -1;\nbreak;\ncase CDF_LENGTH32_STRING:\ncase CDF_LENGTH32_WSTRING:\nlen = info[i].pi_str.s_len;\nif (len > 1) {\nchar vbuf[1024];\nsize_t j, k = 1;\nif (info[i].pi_type == CDF_LENGTH32_WSTRING)\nk++;\ns = info[i].pi_str.s_buf;\nfor (j = 0; j < sizeof(vbuf) && len--;\nj++, s += k) {\nif (*s == '\\0')\nbreak;\nif (isprint((unsigned char)*s))\nvbuf[j] = *s;\n}\nif (j == sizeof(vbuf))\n--j;\nvbuf[j] = '\\0';\nif (NOTMIME(ms)) {\nif (vbuf[0]) {\nif (file_printf(ms, \", %s: %s\",\nbuf, vbuf) == -1)\nreturn -1;\n}\n} else if (str == NULL && info[i].pi_id ==\nCDF_PROPERTY_NAME_OF_APPLICATION) {\nstr = cdf_app_to_mime(vbuf, app2mime);\n}\n}\nbreak;\ncase CDF_FILETIME:\ntp = info[i].pi_tp;\nif (tp != 0) {\nchar tbuf[64];\nif (tp < 1000000000000000LL) {\ncdf_print_elapsed_time(tbuf,\nsizeof(tbuf), tp);\nif (NOTMIME(ms) && file_printf(ms,\n\", %s: %s\", buf, tbuf) == -1)\nreturn -1;\n} else {\nchar *c, *ec;\ncdf_timestamp_to_timespec(&ts, tp);\nc = cdf_ctime(&ts.tv_sec, tbuf);\nif (c != NULL &&\n(ec = strchr(c, '\\n')) != NULL)\n*ec = '\\0';\nif (NOTMIME(ms) && file_printf(ms,\n\", %s: %s\", buf, c) == -1)\nreturn -1;\n}\n}\nbreak;\ncase CDF_CLIPBOARD:\nbreak;\ndefault:\nreturn -1;\n}\n}\nif (!NOTMIME(ms)) {\nif (str == NULL)\nreturn 0;\nif (file_printf(ms, \"application/%s\", str) == -1)\nreturn -1;\n}\nreturn 1;\n}", "label": 0}
{"index": 176051, "code": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\nnetdev_features_t features)\n{\nstruct sk_buff *segs = NULL;\nstruct sk_buff *tail = NULL;\nstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\nskb_frag_t *frag = skb_shinfo(head_skb)->frags;\nunsigned int mss = skb_shinfo(head_skb)->gso_size;\nunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\nunsigned int offset = doffset;\nunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\nunsigned int headroom;\nunsigned int len;\n__be16 proto;\nbool csum;\nint sg = !!(features & NETIF_F_SG);\nint nfrags = skb_shinfo(head_skb)->nr_frags;\nint err = -ENOMEM;\nint i = 0;\nint pos;\nproto = skb_network_protocol(head_skb);\nif (unlikely(!proto))\nreturn ERR_PTR(-EINVAL);\ncsum = !!can_checksum_protocol(features, proto);\n__skb_push(head_skb, doffset);\nheadroom = skb_headroom(head_skb);\npos = skb_headlen(head_skb);\ndo {\nstruct sk_buff *nskb;\nskb_frag_t *nskb_frag;\nint hsize;\nint size;\nlen = head_skb->len - offset;\nif (len > mss)\nlen = mss;\nhsize = skb_headlen(head_skb) - offset;\nif (hsize < 0)\nhsize = 0;\nif (hsize > len || !sg)\nhsize = len;\nif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n(skb_headlen(list_skb) == len || sg)) {\nBUG_ON(skb_headlen(list_skb) > len);\ni = 0;\nnfrags = skb_shinfo(list_skb)->nr_frags;\nfrag = skb_shinfo(list_skb)->frags;\npos += skb_headlen(list_skb);\nwhile (pos < offset + len) {\nBUG_ON(i >= nfrags);\nsize = skb_frag_size(frag);\nif (pos + size > offset + len)\nbreak;\ni++;\npos += size;\nfrag++;\n}\nnskb = skb_clone(list_skb, GFP_ATOMIC);\nlist_skb = list_skb->next;\nif (unlikely(!nskb))\ngoto err;\nif (unlikely(pskb_trim(nskb, len))) {\nkfree_skb(nskb);\ngoto err;\n}\nhsize = skb_end_offset(nskb);\nif (skb_cow_head(nskb, doffset + headroom)) {\nkfree_skb(nskb);\ngoto err;\n}\nnskb->truesize += skb_end_offset(nskb) - hsize;\nskb_release_head_state(nskb);\n__skb_push(nskb, doffset);\n} else {\nnskb = __alloc_skb(hsize + doffset + headroom,\nGFP_ATOMIC, skb_alloc_rx_flag(head_skb),\nNUMA_NO_NODE);\nif (unlikely(!nskb))\ngoto err;\nskb_reserve(nskb, headroom);\n__skb_put(nskb, doffset);\n}\nif (segs)\ntail->next = nskb;\nelse\nsegs = nskb;\ntail = nskb;\n__copy_skb_header(nskb, head_skb);\nnskb->mac_len = head_skb->mac_len;\nskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\nskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\nnskb->data - tnl_hlen,\ndoffset + tnl_hlen);\nif (nskb->len == len + doffset)\ngoto perform_csum_check;\nif (!sg) {\nnskb->ip_summed = CHECKSUM_NONE;\nnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\nskb_put(nskb, len),\nlen, 0);\ncontinue;\n}\nnskb_frag = skb_shinfo(nskb)->frags;\nskb_copy_from_linear_data_offset(head_skb, offset,\nskb_put(nskb, hsize), hsize);\nskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\nSKBTX_SHARED_FRAG;\nwhile (pos < offset + len) {\nif (i >= nfrags) {\nBUG_ON(skb_headlen(list_skb));\ni = 0;\nnfrags = skb_shinfo(list_skb)->nr_frags;\nfrag = skb_shinfo(list_skb)->frags;\nBUG_ON(!nfrags);\nlist_skb = list_skb->next;\n}\nif (unlikely(skb_shinfo(nskb)->nr_frags >=\nMAX_SKB_FRAGS)) {\nnet_warn_ratelimited(\n\"skb_segment: too many frags: %u %u\\n\",\npos, mss);\ngoto err;\n}\n*nskb_frag = *frag;\n__skb_frag_ref(nskb_frag);\nsize = skb_frag_size(nskb_frag);\nif (pos < offset) {\nnskb_frag->page_offset += offset - pos;\nskb_frag_size_sub(nskb_frag, offset - pos);\n}\nskb_shinfo(nskb)->nr_frags++;\nif (pos + size <= offset + len) {\ni++;\nfrag++;\npos += size;\n} else {\nskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\ngoto skip_fraglist;\n}\nnskb_frag++;\n}\nskip_fraglist:\nnskb->data_len = len - hsize;\nnskb->len += nskb->data_len;\nnskb->truesize += nskb->data_len;\nperform_csum_check:\nif (!csum) {\nnskb->csum = skb_checksum(nskb, doffset,\nnskb->len - doffset, 0);\nnskb->ip_summed = CHECKSUM_NONE;\n}\n} while ((offset += len) < head_skb->len);\nreturn segs;\nerr:\nkfree_skb_list(segs);\nreturn ERR_PTR(err);\n}", "contrast": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\nnetdev_features_t features)\n{\nstruct sk_buff *segs = NULL;\nstruct sk_buff *tail = NULL;\nstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\nskb_frag_t *frag = skb_shinfo(head_skb)->frags;\nunsigned int mss = skb_shinfo(head_skb)->gso_size;\nunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\nstruct sk_buff *frag_skb = head_skb;\nunsigned int offset = doffset;\nunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\nunsigned int headroom;\nunsigned int len;\n__be16 proto;\nbool csum;\nint sg = !!(features & NETIF_F_SG);\nint nfrags = skb_shinfo(head_skb)->nr_frags;\nint err = -ENOMEM;\nint i = 0;\nint pos;\nproto = skb_network_protocol(head_skb);\nif (unlikely(!proto))\nreturn ERR_PTR(-EINVAL);\ncsum = !!can_checksum_protocol(features, proto);\n__skb_push(head_skb, doffset);\nheadroom = skb_headroom(head_skb);\npos = skb_headlen(head_skb);\ndo {\nstruct sk_buff *nskb;\nskb_frag_t *nskb_frag;\nint hsize;\nint size;\nlen = head_skb->len - offset;\nif (len > mss)\nlen = mss;\nhsize = skb_headlen(head_skb) - offset;\nif (hsize < 0)\nhsize = 0;\nif (hsize > len || !sg)\nhsize = len;\nif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n(skb_headlen(list_skb) == len || sg)) {\nBUG_ON(skb_headlen(list_skb) > len);\ni = 0;\nnfrags = skb_shinfo(list_skb)->nr_frags;\nfrag = skb_shinfo(list_skb)->frags;\nfrag_skb = list_skb;\npos += skb_headlen(list_skb);\nwhile (pos < offset + len) {\nBUG_ON(i >= nfrags);\nsize = skb_frag_size(frag);\nif (pos + size > offset + len)\nbreak;\ni++;\npos += size;\nfrag++;\n}\nnskb = skb_clone(list_skb, GFP_ATOMIC);\nlist_skb = list_skb->next;\nif (unlikely(!nskb))\ngoto err;\nif (unlikely(pskb_trim(nskb, len))) {\nkfree_skb(nskb);\ngoto err;\n}\nhsize = skb_end_offset(nskb);\nif (skb_cow_head(nskb, doffset + headroom)) {\nkfree_skb(nskb);\ngoto err;\n}\nnskb->truesize += skb_end_offset(nskb) - hsize;\nskb_release_head_state(nskb);\n__skb_push(nskb, doffset);\n} else {\nnskb = __alloc_skb(hsize + doffset + headroom,\nGFP_ATOMIC, skb_alloc_rx_flag(head_skb),\nNUMA_NO_NODE);\nif (unlikely(!nskb))\ngoto err;\nskb_reserve(nskb, headroom);\n__skb_put(nskb, doffset);\n}\nif (segs)\ntail->next = nskb;\nelse\nsegs = nskb;\ntail = nskb;\n__copy_skb_header(nskb, head_skb);\nnskb->mac_len = head_skb->mac_len;\nskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\nskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\nnskb->data - tnl_hlen,\ndoffset + tnl_hlen);\nif (nskb->len == len + doffset)\ngoto perform_csum_check;\nif (!sg) {\nnskb->ip_summed = CHECKSUM_NONE;\nnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\nskb_put(nskb, len),\nlen, 0);\ncontinue;\n}\nnskb_frag = skb_shinfo(nskb)->frags;\nskb_copy_from_linear_data_offset(head_skb, offset,\nskb_put(nskb, hsize), hsize);\nskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\nSKBTX_SHARED_FRAG;\nwhile (pos < offset + len) {\nif (i >= nfrags) {\nBUG_ON(skb_headlen(list_skb));\ni = 0;\nnfrags = skb_shinfo(list_skb)->nr_frags;\nfrag = skb_shinfo(list_skb)->frags;\nfrag_skb = list_skb;\nBUG_ON(!nfrags);\nlist_skb = list_skb->next;\n}\nif (unlikely(skb_shinfo(nskb)->nr_frags >=\nMAX_SKB_FRAGS)) {\nnet_warn_ratelimited(\n\"skb_segment: too many frags: %u %u\\n\",\npos, mss);\ngoto err;\n}\nif (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))\ngoto err;\n*nskb_frag = *frag;\n__skb_frag_ref(nskb_frag);\nsize = skb_frag_size(nskb_frag);\nif (pos < offset) {\nnskb_frag->page_offset += offset - pos;\nskb_frag_size_sub(nskb_frag, offset - pos);\n}\nskb_shinfo(nskb)->nr_frags++;\nif (pos + size <= offset + len) {\ni++;\nfrag++;\npos += size;\n} else {\nskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\ngoto skip_fraglist;\n}\nnskb_frag++;\n}\nskip_fraglist:\nnskb->data_len = len - hsize;\nnskb->len += nskb->data_len;\nnskb->truesize += nskb->data_len;\nperform_csum_check:\nif (!csum) {\nnskb->csum = skb_checksum(nskb, doffset,\nnskb->len - doffset, 0);\nnskb->ip_summed = CHECKSUM_NONE;\n}\n} while ((offset += len) < head_skb->len);\nreturn segs;\nerr:\nkfree_skb_list(segs);\nreturn ERR_PTR(err);\n}", "label": 0}
{"index": 176052, "code": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\nconst struct sctp_endpoint *ep,\nconst struct sctp_association *asoc,\nconst sctp_subtype_t type, void *arg,\nsctp_cmd_seq_t *commands)\n{\nstruct sctp_chunk *chunk = arg;\nstruct sctp_association *new_asoc;\nsctp_init_chunk_t *peer_init;\nstruct sctp_chunk *repl;\nstruct sctp_ulpevent *ev, *ai_ev = NULL;\nint error = 0;\nstruct sctp_chunk *err_chk_p;\nstruct sock *sk;\nif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nsk = ep->base.sk;\nif (!sctp_sstate(sk, LISTENING) ||\n(sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\nchunk->subh.cookie_hdr =\n(struct sctp_signed_cookie *)chunk->skb->data;\nif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\nsizeof(sctp_chunkhdr_t)))\ngoto nomem;\nnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n&err_chk_p);\nif (!new_asoc) {\nswitch (error) {\ncase -SCTP_IERROR_NOMEM:\ngoto nomem;\ncase -SCTP_IERROR_STALE_COOKIE:\nsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\nerr_chk_p);\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\ncase -SCTP_IERROR_BAD_SIG:\ndefault:\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n}\npeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\nif (!sctp_process_init(new_asoc, chunk,\n&chunk->subh.cookie_hdr->c.peer_addr,\npeer_init, GFP_ATOMIC))\ngoto nomem_init;\nerror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\nif (error)\ngoto nomem_init;\nif (chunk->auth_chunk) {\nstruct sctp_chunk auth;\nsctp_ierror_t ret;\nauth.skb = chunk->auth_chunk;\nauth.asoc = chunk->asoc;\nauth.sctp_hdr = chunk->sctp_hdr;\nauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\nsizeof(sctp_chunkhdr_t));\nskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\nauth.transport = chunk->transport;\nret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\nkfree_skb(chunk->auth_chunk);\nif (ret != SCTP_IERROR_NO_ERROR) {\nsctp_association_free(new_asoc);\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n}\nrepl = sctp_make_cookie_ack(new_asoc, chunk);\nif (!repl)\ngoto nomem_init;\nev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\nnew_asoc->c.sinit_num_ostreams,\nnew_asoc->c.sinit_max_instreams,\nNULL, GFP_ATOMIC);\nif (!ev)\ngoto nomem_ev;\nif (new_asoc->peer.adaptation_ind) {\nai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\nGFP_ATOMIC);\nif (!ai_ev)\ngoto nomem_aiev;\n}\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\nSCTP_STATE(SCTP_STATE_ESTABLISHED));\nSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\nSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\nif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\nif (ai_ev)\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\nSCTP_ULPEVENT(ai_ev));\nreturn SCTP_DISPOSITION_CONSUME;\nnomem_aiev:\nsctp_ulpevent_free(ev);\nnomem_ev:\nsctp_chunk_free(repl);\nnomem_init:\nsctp_association_free(new_asoc);\nnomem:\nreturn SCTP_DISPOSITION_NOMEM;\n}", "contrast": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\nconst struct sctp_endpoint *ep,\nconst struct sctp_association *asoc,\nconst sctp_subtype_t type, void *arg,\nsctp_cmd_seq_t *commands)\n{\nstruct sctp_chunk *chunk = arg;\nstruct sctp_association *new_asoc;\nsctp_init_chunk_t *peer_init;\nstruct sctp_chunk *repl;\nstruct sctp_ulpevent *ev, *ai_ev = NULL;\nint error = 0;\nstruct sctp_chunk *err_chk_p;\nstruct sock *sk;\nif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nsk = ep->base.sk;\nif (!sctp_sstate(sk, LISTENING) ||\n(sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\nchunk->subh.cookie_hdr =\n(struct sctp_signed_cookie *)chunk->skb->data;\nif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\nsizeof(sctp_chunkhdr_t)))\ngoto nomem;\nnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n&err_chk_p);\nif (!new_asoc) {\nswitch (error) {\ncase -SCTP_IERROR_NOMEM:\ngoto nomem;\ncase -SCTP_IERROR_STALE_COOKIE:\nsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\nerr_chk_p);\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\ncase -SCTP_IERROR_BAD_SIG:\ndefault:\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n}\npeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\nif (!sctp_process_init(new_asoc, chunk,\n&chunk->subh.cookie_hdr->c.peer_addr,\npeer_init, GFP_ATOMIC))\ngoto nomem_init;\nerror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\nif (error)\ngoto nomem_init;\nif (chunk->auth_chunk) {\nstruct sctp_chunk auth;\nsctp_ierror_t ret;\nif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\nkfree_skb(chunk->auth_chunk);\nsctp_association_free(new_asoc);\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\nauth.skb = chunk->auth_chunk;\nauth.asoc = chunk->asoc;\nauth.sctp_hdr = chunk->sctp_hdr;\nauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\nsizeof(sctp_chunkhdr_t));\nskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\nauth.transport = chunk->transport;\nret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\nkfree_skb(chunk->auth_chunk);\nif (ret != SCTP_IERROR_NO_ERROR) {\nsctp_association_free(new_asoc);\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n}\nrepl = sctp_make_cookie_ack(new_asoc, chunk);\nif (!repl)\ngoto nomem_init;\nev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\nnew_asoc->c.sinit_num_ostreams,\nnew_asoc->c.sinit_max_instreams,\nNULL, GFP_ATOMIC);\nif (!ev)\ngoto nomem_ev;\nif (new_asoc->peer.adaptation_ind) {\nai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\nGFP_ATOMIC);\nif (!ai_ev)\ngoto nomem_aiev;\n}\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\nSCTP_STATE(SCTP_STATE_ESTABLISHED));\nSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\nSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\nif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\nif (ai_ev)\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\nSCTP_ULPEVENT(ai_ev));\nreturn SCTP_DISPOSITION_CONSUME;\nnomem_aiev:\nsctp_ulpevent_free(ev);\nnomem_ev:\nsctp_chunk_free(repl);\nnomem_init:\nsctp_association_free(new_asoc);\nnomem:\nreturn SCTP_DISPOSITION_NOMEM;\n}", "label": 0}
{"index": 176054, "code": "cifs_iovec_write(struct file *file, const struct iovec *iov,\nunsigned long nr_segs, loff_t *poffset)\n{\nunsigned long nr_pages, i;\nsize_t copied, len, cur_len;\nssize_t total_written = 0;\nloff_t offset;\nstruct iov_iter it;\nstruct cifsFileInfo *open_file;\nstruct cifs_tcon *tcon;\nstruct cifs_sb_info *cifs_sb;\nstruct cifs_writedata *wdata, *tmp;\nstruct list_head wdata_list;\nint rc;\npid_t pid;\nlen = iov_length(iov, nr_segs);\nif (!len)\nreturn 0;\nrc = generic_write_checks(file, poffset, &len, 0);\nif (rc)\nreturn rc;\nINIT_LIST_HEAD(&wdata_list);\ncifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\nopen_file = file->private_data;\ntcon = tlink_tcon(open_file->tlink);\nif (!tcon->ses->server->ops->async_writev)\nreturn -ENOSYS;\noffset = *poffset;\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\npid = open_file->pid;\nelse\npid = current->tgid;\niov_iter_init(&it, iov, nr_segs, len, 0);\ndo {\nsize_t save_len;\nnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\nwdata = cifs_writedata_alloc(nr_pages,\ncifs_uncached_writev_complete);\nif (!wdata) {\nrc = -ENOMEM;\nbreak;\n}\nrc = cifs_write_allocate_pages(wdata->pages, nr_pages);\nif (rc) {\nkfree(wdata);\nbreak;\n}\nsave_len = cur_len;\nfor (i = 0; i < nr_pages; i++) {\ncopied = min_t(const size_t, cur_len, PAGE_SIZE);\ncopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n0, copied);\ncur_len -= copied;\niov_iter_advance(&it, copied);\n}\ncur_len = save_len - cur_len;\nwdata->sync_mode = WB_SYNC_ALL;\nwdata->nr_pages = nr_pages;\nwdata->offset = (__u64)offset;\nwdata->cfile = cifsFileInfo_get(open_file);\nwdata->pid = pid;\nwdata->bytes = cur_len;\nwdata->pagesz = PAGE_SIZE;\nwdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\nrc = cifs_uncached_retry_writev(wdata);\nif (rc) {\nkref_put(&wdata->refcount,\ncifs_uncached_writedata_release);\nbreak;\n}\nlist_add_tail(&wdata->list, &wdata_list);\noffset += cur_len;\nlen -= cur_len;\n} while (len > 0);\nif (!list_empty(&wdata_list))\nrc = 0;\nrestart_loop:\nlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\nif (!rc) {\nrc = wait_for_completion_killable(&wdata->done);\nif (rc)\nrc = -EINTR;\nelse if (wdata->result)\nrc = wdata->result;\nelse\ntotal_written += wdata->bytes;\nif (rc == -EAGAIN) {\nrc = cifs_uncached_retry_writev(wdata);\ngoto restart_loop;\n}\n}\nlist_del_init(&wdata->list);\nkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n}\nif (total_written > 0)\n*poffset += total_written;\ncifs_stats_bytes_written(tcon, total_written);\nreturn total_written ? total_written : (ssize_t)rc;\n}", "contrast": "cifs_iovec_write(struct file *file, const struct iovec *iov,\nunsigned long nr_segs, loff_t *poffset)\n{\nunsigned long nr_pages, i;\nsize_t bytes, copied, len, cur_len;\nssize_t total_written = 0;\nloff_t offset;\nstruct iov_iter it;\nstruct cifsFileInfo *open_file;\nstruct cifs_tcon *tcon;\nstruct cifs_sb_info *cifs_sb;\nstruct cifs_writedata *wdata, *tmp;\nstruct list_head wdata_list;\nint rc;\npid_t pid;\nlen = iov_length(iov, nr_segs);\nif (!len)\nreturn 0;\nrc = generic_write_checks(file, poffset, &len, 0);\nif (rc)\nreturn rc;\nINIT_LIST_HEAD(&wdata_list);\ncifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\nopen_file = file->private_data;\ntcon = tlink_tcon(open_file->tlink);\nif (!tcon->ses->server->ops->async_writev)\nreturn -ENOSYS;\noffset = *poffset;\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\npid = open_file->pid;\nelse\npid = current->tgid;\niov_iter_init(&it, iov, nr_segs, len, 0);\ndo {\nsize_t save_len;\nnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\nwdata = cifs_writedata_alloc(nr_pages,\ncifs_uncached_writev_complete);\nif (!wdata) {\nrc = -ENOMEM;\nbreak;\n}\nrc = cifs_write_allocate_pages(wdata->pages, nr_pages);\nif (rc) {\nkfree(wdata);\nbreak;\n}\nsave_len = cur_len;\nfor (i = 0; i < nr_pages; i++) {\nbytes = min_t(const size_t, cur_len, PAGE_SIZE);\ncopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n0, bytes);\ncur_len -= copied;\niov_iter_advance(&it, copied);\nif (copied < bytes)\nbreak;\n}\ncur_len = save_len - cur_len;\nif (!cur_len) {\nfor (i = 0; i < nr_pages; i++)\nput_page(wdata->pages[i]);\nkfree(wdata);\nrc = -EFAULT;\nbreak;\n}\nfor ( ; nr_pages > i + 1; nr_pages--)\nput_page(wdata->pages[nr_pages - 1]);\nwdata->sync_mode = WB_SYNC_ALL;\nwdata->nr_pages = nr_pages;\nwdata->offset = (__u64)offset;\nwdata->cfile = cifsFileInfo_get(open_file);\nwdata->pid = pid;\nwdata->bytes = cur_len;\nwdata->pagesz = PAGE_SIZE;\nwdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\nrc = cifs_uncached_retry_writev(wdata);\nif (rc) {\nkref_put(&wdata->refcount,\ncifs_uncached_writedata_release);\nbreak;\n}\nlist_add_tail(&wdata->list, &wdata_list);\noffset += cur_len;\nlen -= cur_len;\n} while (len > 0);\nif (!list_empty(&wdata_list))\nrc = 0;\nrestart_loop:\nlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\nif (!rc) {\nrc = wait_for_completion_killable(&wdata->done);\nif (rc)\nrc = -EINTR;\nelse if (wdata->result)\nrc = wdata->result;\nelse\ntotal_written += wdata->bytes;\nif (rc == -EAGAIN) {\nrc = cifs_uncached_retry_writev(wdata);\ngoto restart_loop;\n}\n}\nlist_del_init(&wdata->list);\nkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n}\nif (total_written > 0)\n*poffset += total_written;\ncifs_stats_bytes_written(tcon, total_written);\nreturn total_written ? total_written : (ssize_t)rc;\n}", "label": 0}
{"index": 176093, "code": "static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\nstruct msghdr *msg, size_t len, int flags)\n{\nint noblock = flags & MSG_DONTWAIT;\nstruct sock *sk = sock->sk;\nunsigned int copied, rlen;\nstruct sk_buff *skb, *cskb;\nint err = 0;\npr_debug(\"%p %zu\\n\", sk, len);\nmsg->msg_namelen = 0;\nlock_sock(sk);\nif (sk->sk_state == LLCP_CLOSED &&\nskb_queue_empty(&sk->sk_receive_queue)) {\nrelease_sock(sk);\nreturn 0;\n}\nrelease_sock(sk);\nif (flags & (MSG_OOB))\nreturn -EOPNOTSUPP;\nskb = skb_recv_datagram(sk, flags, noblock, &err);\nif (!skb) {\npr_err(\"Recv datagram failed state %d %d %d\",\nsk->sk_state, err, sock_error(sk));\nif (sk->sk_shutdown & RCV_SHUTDOWN)\nreturn 0;\nreturn err;\n}\nrlen = skb->len;\ncopied = min_t(unsigned int, rlen, len);\ncskb = skb;\nif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {\nif (!(flags & MSG_PEEK))\nskb_queue_head(&sk->sk_receive_queue, skb);\nreturn -EFAULT;\n}\nsock_recv_timestamp(msg, sk, skb);\nif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\nstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\nstruct sockaddr_nfc_llcp *sockaddr =\n(struct sockaddr_nfc_llcp *) msg->msg_name;\nmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\npr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\nmemset(sockaddr, 0, sizeof(*sockaddr));\nsockaddr->sa_family = AF_NFC;\nsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\nsockaddr->dsap = ui_cb->dsap;\nsockaddr->ssap = ui_cb->ssap;\n}\nif (!(flags & MSG_PEEK)) {\nif (sk->sk_type == SOCK_STREAM ||\nsk->sk_type == SOCK_DGRAM ||\nsk->sk_type == SOCK_RAW) {\nskb_pull(skb, copied);\nif (skb->len) {\nskb_queue_head(&sk->sk_receive_queue, skb);\ngoto done;\n}\n}\nkfree_skb(skb);\n}\ndone:\nif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\ncopied = rlen;\nreturn copied;\n}", "contrast": "static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\nstruct msghdr *msg, size_t len, int flags)\n{\nint noblock = flags & MSG_DONTWAIT;\nstruct sock *sk = sock->sk;\nunsigned int copied, rlen;\nstruct sk_buff *skb, *cskb;\nint err = 0;\npr_debug(\"%p %zu\\n\", sk, len);\nlock_sock(sk);\nif (sk->sk_state == LLCP_CLOSED &&\nskb_queue_empty(&sk->sk_receive_queue)) {\nrelease_sock(sk);\nreturn 0;\n}\nrelease_sock(sk);\nif (flags & (MSG_OOB))\nreturn -EOPNOTSUPP;\nskb = skb_recv_datagram(sk, flags, noblock, &err);\nif (!skb) {\npr_err(\"Recv datagram failed state %d %d %d\",\nsk->sk_state, err, sock_error(sk));\nif (sk->sk_shutdown & RCV_SHUTDOWN)\nreturn 0;\nreturn err;\n}\nrlen = skb->len;\ncopied = min_t(unsigned int, rlen, len);\ncskb = skb;\nif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {\nif (!(flags & MSG_PEEK))\nskb_queue_head(&sk->sk_receive_queue, skb);\nreturn -EFAULT;\n}\nsock_recv_timestamp(msg, sk, skb);\nif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\nstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\nstruct sockaddr_nfc_llcp *sockaddr =\n(struct sockaddr_nfc_llcp *) msg->msg_name;\nmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\npr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\nmemset(sockaddr, 0, sizeof(*sockaddr));\nsockaddr->sa_family = AF_NFC;\nsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\nsockaddr->dsap = ui_cb->dsap;\nsockaddr->ssap = ui_cb->ssap;\n}\nif (!(flags & MSG_PEEK)) {\nif (sk->sk_type == SOCK_STREAM ||\nsk->sk_type == SOCK_DGRAM ||\nsk->sk_type == SOCK_RAW) {\nskb_pull(skb, copied);\nif (skb->len) {\nskb_queue_head(&sk->sk_receive_queue, skb);\ngoto done;\n}\n}\nkfree_skb(skb);\n}\ndone:\nif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\ncopied = rlen;\nreturn copied;\n}", "label": 0}
{"index": 176100, "code": "static int recv_msg(struct kiocb *iocb, struct socket *sock,\nstruct msghdr *m, size_t buf_len, int flags)\n{\nstruct sock *sk = sock->sk;\nstruct tipc_port *tport = tipc_sk_port(sk);\nstruct sk_buff *buf;\nstruct tipc_msg *msg;\nlong timeout;\nunsigned int sz;\nu32 err;\nint res;\nif (unlikely(!buf_len))\nreturn -EINVAL;\nlock_sock(sk);\nif (unlikely(sock->state == SS_UNCONNECTED)) {\nres = -ENOTCONN;\ngoto exit;\n}\nm->msg_namelen = 0;\ntimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\nrestart:\nwhile (skb_queue_empty(&sk->sk_receive_queue)) {\nif (sock->state == SS_DISCONNECTING) {\nres = -ENOTCONN;\ngoto exit;\n}\nif (timeout <= 0L) {\nres = timeout ? timeout : -EWOULDBLOCK;\ngoto exit;\n}\nrelease_sock(sk);\ntimeout = wait_event_interruptible_timeout(*sk_sleep(sk),\ntipc_rx_ready(sock),\ntimeout);\nlock_sock(sk);\n}\nbuf = skb_peek(&sk->sk_receive_queue);\nmsg = buf_msg(buf);\nsz = msg_data_sz(msg);\nerr = msg_errcode(msg);\nif ((!sz) && (!err)) {\nadvance_rx_queue(sk);\ngoto restart;\n}\nset_orig_addr(m, msg);\nres = anc_data_recv(m, msg, tport);\nif (res)\ngoto exit;\nif (!err) {\nif (unlikely(buf_len < sz)) {\nsz = buf_len;\nm->msg_flags |= MSG_TRUNC;\n}\nres = skb_copy_datagram_iovec(buf, msg_hdr_sz(msg),\nm->msg_iov, sz);\nif (res)\ngoto exit;\nres = sz;\n} else {\nif ((sock->state == SS_READY) ||\n((err == TIPC_CONN_SHUTDOWN) || m->msg_control))\nres = 0;\nelse\nres = -ECONNRESET;\n}\nif (likely(!(flags & MSG_PEEK))) {\nif ((sock->state != SS_READY) &&\n(++tport->conn_unacked >= TIPC_FLOW_CONTROL_WIN))\ntipc_acknowledge(tport->ref, tport->conn_unacked);\nadvance_rx_queue(sk);\n}\nexit:\nrelease_sock(sk);\nreturn res;\n}", "contrast": "static int recv_msg(struct kiocb *iocb, struct socket *sock,\nstruct msghdr *m, size_t buf_len, int flags)\n{\nstruct sock *sk = sock->sk;\nstruct tipc_port *tport = tipc_sk_port(sk);\nstruct sk_buff *buf;\nstruct tipc_msg *msg;\nlong timeout;\nunsigned int sz;\nu32 err;\nint res;\nif (unlikely(!buf_len))\nreturn -EINVAL;\nlock_sock(sk);\nif (unlikely(sock->state == SS_UNCONNECTED)) {\nres = -ENOTCONN;\ngoto exit;\n}\ntimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\nrestart:\nwhile (skb_queue_empty(&sk->sk_receive_queue)) {\nif (sock->state == SS_DISCONNECTING) {\nres = -ENOTCONN;\ngoto exit;\n}\nif (timeout <= 0L) {\nres = timeout ? timeout : -EWOULDBLOCK;\ngoto exit;\n}\nrelease_sock(sk);\ntimeout = wait_event_interruptible_timeout(*sk_sleep(sk),\ntipc_rx_ready(sock),\ntimeout);\nlock_sock(sk);\n}\nbuf = skb_peek(&sk->sk_receive_queue);\nmsg = buf_msg(buf);\nsz = msg_data_sz(msg);\nerr = msg_errcode(msg);\nif ((!sz) && (!err)) {\nadvance_rx_queue(sk);\ngoto restart;\n}\nset_orig_addr(m, msg);\nres = anc_data_recv(m, msg, tport);\nif (res)\ngoto exit;\nif (!err) {\nif (unlikely(buf_len < sz)) {\nsz = buf_len;\nm->msg_flags |= MSG_TRUNC;\n}\nres = skb_copy_datagram_iovec(buf, msg_hdr_sz(msg),\nm->msg_iov, sz);\nif (res)\ngoto exit;\nres = sz;\n} else {\nif ((sock->state == SS_READY) ||\n((err == TIPC_CONN_SHUTDOWN) || m->msg_control))\nres = 0;\nelse\nres = -ECONNRESET;\n}\nif (likely(!(flags & MSG_PEEK))) {\nif ((sock->state != SS_READY) &&\n(++tport->conn_unacked >= TIPC_FLOW_CONTROL_WIN))\ntipc_acknowledge(tport->ref, tport->conn_unacked);\nadvance_rx_queue(sk);\n}\nexit:\nrelease_sock(sk);\nreturn res;\n}", "label": 0}
{"index": 176105, "code": "static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\nstruct vsock_sock *vsk,\nstruct msghdr *msg, size_t len,\nint flags)\n{\nint err;\nint noblock;\nstruct vmci_datagram *dg;\nsize_t payload_len;\nstruct sk_buff *skb;\nnoblock = flags & MSG_DONTWAIT;\nif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\nreturn -EOPNOTSUPP;\nmsg->msg_namelen = 0;\nerr = 0;\nskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\nif (err)\nreturn err;\nif (!skb)\nreturn -EAGAIN;\ndg = (struct vmci_datagram *)skb->data;\nif (!dg)\ngoto out;\npayload_len = dg->payload_size;\nif (payload_len != skb->len - sizeof(*dg)) {\nerr = -EINVAL;\ngoto out;\n}\nif (payload_len > len) {\npayload_len = len;\nmsg->msg_flags |= MSG_TRUNC;\n}\nerr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\npayload_len);\nif (err)\ngoto out;\nif (msg->msg_name) {\nstruct sockaddr_vm *vm_addr;\nvm_addr = (struct sockaddr_vm *)msg->msg_name;\nvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\nmsg->msg_namelen = sizeof(*vm_addr);\n}\nerr = payload_len;\nout:\nskb_free_datagram(&vsk->sk, skb);\nreturn err;\n}", "contrast": "static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\nstruct vsock_sock *vsk,\nstruct msghdr *msg, size_t len,\nint flags)\n{\nint err;\nint noblock;\nstruct vmci_datagram *dg;\nsize_t payload_len;\nstruct sk_buff *skb;\nnoblock = flags & MSG_DONTWAIT;\nif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\nreturn -EOPNOTSUPP;\nerr = 0;\nskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\nif (err)\nreturn err;\nif (!skb)\nreturn -EAGAIN;\ndg = (struct vmci_datagram *)skb->data;\nif (!dg)\ngoto out;\npayload_len = dg->payload_size;\nif (payload_len != skb->len - sizeof(*dg)) {\nerr = -EINVAL;\ngoto out;\n}\nif (payload_len > len) {\npayload_len = len;\nmsg->msg_flags |= MSG_TRUNC;\n}\nerr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\npayload_len);\nif (err)\ngoto out;\nif (msg->msg_name) {\nstruct sockaddr_vm *vm_addr;\nvm_addr = (struct sockaddr_vm *)msg->msg_name;\nvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\nmsg->msg_namelen = sizeof(*vm_addr);\n}\nerr = payload_len;\nout:\nskb_free_datagram(&vsk->sk, skb);\nreturn err;\n}", "label": 0}
{"index": 176106, "code": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\nstruct msghdr *msg, size_t size,\nint flags)\n{\nstruct sock *sk = sock->sk;\nstruct x25_sock *x25 = x25_sk(sk);\nstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\nsize_t copied;\nint qbit, header_len;\nstruct sk_buff *skb;\nunsigned char *asmptr;\nint rc = -ENOTCONN;\nlock_sock(sk);\nif (x25->neighbour == NULL)\ngoto out;\nheader_len = x25->neighbour->extended ?\nX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\nif (sk->sk_state != TCP_ESTABLISHED)\ngoto out;\nif (flags & MSG_OOB) {\nrc = -EINVAL;\nif (sock_flag(sk, SOCK_URGINLINE) ||\n!skb_peek(&x25->interrupt_in_queue))\ngoto out;\nskb = skb_dequeue(&x25->interrupt_in_queue);\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\ngoto out_free_dgram;\nskb_pull(skb, X25_STD_MIN_LEN);\nif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\nasmptr  = skb_push(skb, 1);\n*asmptr = 0x00;\n}\nmsg->msg_flags |= MSG_OOB;\n} else {\nrelease_sock(sk);\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\nflags & MSG_DONTWAIT, &rc);\nlock_sock(sk);\nif (!skb)\ngoto out;\nif (!pskb_may_pull(skb, header_len))\ngoto out_free_dgram;\nqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\nskb_pull(skb, header_len);\nif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\nasmptr  = skb_push(skb, 1);\n*asmptr = qbit;\n}\n}\nskb_reset_transport_header(skb);\ncopied = skb->len;\nif (copied > size) {\ncopied = size;\nmsg->msg_flags |= MSG_TRUNC;\n}\nmsg->msg_flags |= MSG_EOR;\nrc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\nif (rc)\ngoto out_free_dgram;\nif (sx25) {\nsx25->sx25_family = AF_X25;\nsx25->sx25_addr   = x25->dest_addr;\n}\nmsg->msg_namelen = sizeof(struct sockaddr_x25);\nx25_check_rbuf(sk);\nrc = copied;\nout_free_dgram:\nskb_free_datagram(sk, skb);\nout:\nrelease_sock(sk);\nreturn rc;\n}", "contrast": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\nstruct msghdr *msg, size_t size,\nint flags)\n{\nstruct sock *sk = sock->sk;\nstruct x25_sock *x25 = x25_sk(sk);\nstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\nsize_t copied;\nint qbit, header_len;\nstruct sk_buff *skb;\nunsigned char *asmptr;\nint rc = -ENOTCONN;\nlock_sock(sk);\nif (x25->neighbour == NULL)\ngoto out;\nheader_len = x25->neighbour->extended ?\nX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\nif (sk->sk_state != TCP_ESTABLISHED)\ngoto out;\nif (flags & MSG_OOB) {\nrc = -EINVAL;\nif (sock_flag(sk, SOCK_URGINLINE) ||\n!skb_peek(&x25->interrupt_in_queue))\ngoto out;\nskb = skb_dequeue(&x25->interrupt_in_queue);\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\ngoto out_free_dgram;\nskb_pull(skb, X25_STD_MIN_LEN);\nif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\nasmptr  = skb_push(skb, 1);\n*asmptr = 0x00;\n}\nmsg->msg_flags |= MSG_OOB;\n} else {\nrelease_sock(sk);\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\nflags & MSG_DONTWAIT, &rc);\nlock_sock(sk);\nif (!skb)\ngoto out;\nif (!pskb_may_pull(skb, header_len))\ngoto out_free_dgram;\nqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\nskb_pull(skb, header_len);\nif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\nasmptr  = skb_push(skb, 1);\n*asmptr = qbit;\n}\n}\nskb_reset_transport_header(skb);\ncopied = skb->len;\nif (copied > size) {\ncopied = size;\nmsg->msg_flags |= MSG_TRUNC;\n}\nmsg->msg_flags |= MSG_EOR;\nrc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\nif (rc)\ngoto out_free_dgram;\nif (sx25) {\nsx25->sx25_family = AF_X25;\nsx25->sx25_addr   = x25->dest_addr;\nmsg->msg_namelen = sizeof(*sx25);\n}\nx25_check_rbuf(sk);\nrc = copied;\nout_free_dgram:\nskb_free_datagram(sk, skb);\nout:\nrelease_sock(sk);\nreturn rc;\n}", "label": 0}
{"index": 176108, "code": "static size_t hash_str(const void *ptr)\n{\nconst char *str = (const char *)ptr;\nsize_t hash = 5381;\nsize_t c;\nwhile((c = (size_t)*str))\n{\nhash = ((hash << 5) + hash) + c;\nstr++;\n}\nreturn hash;\n}", "contrast": "static size_t hash_str(const void *ptr)\nextern volatile uint32_t hashtable_seed;\n#include \"lookup3.h\"", "label": 0}
{"index": 176117, "code": "json_t *json_object(void)\n{\njson_object_t *object = jsonp_malloc(sizeof(json_object_t));\nif(!object)\nreturn NULL;\njson_init(&object->json, JSON_OBJECT);\nif(hashtable_init(&object->hashtable))\n{\njsonp_free(object);\nreturn NULL;\n}\nobject->serial = 0;\nobject->visited = 0;\nreturn &object->json;\n}", "contrast": "json_t *json_object(void)\n{\njson_object_t *object = jsonp_malloc(sizeof(json_object_t));\nif(!object)\nreturn NULL;\nif (!hashtable_seed) {\njson_object_seed(0);\n}\njson_init(&object->json, JSON_OBJECT);\nif(hashtable_init(&object->hashtable))\n{\njsonp_free(object);\nreturn NULL;\n}\nobject->serial = 0;\nobject->visited = 0;\nreturn &object->json;\n}", "label": 0}
{"index": 176128, "code": "static int init_nss_hash(struct crypto_instance *instance)\n{\nPK11SlotInfo*\thash_slot = NULL;\nSECItem\t\thash_param;\nif (!hash_to_nss[instance->crypto_hash_type]) {\nreturn 0;\n}\nhash_param.type = siBuffer;\nhash_param.data = 0;\nhash_param.len = 0;\nhash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\nif (hash_slot == NULL) {\nlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\nPR_GetError());\nreturn -1;\n}\ninstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\nhash_to_nss[instance->crypto_hash_type],\nPK11_OriginUnwrap, CKA_SIGN,\n&hash_param, NULL);\nif (instance->nss_sym_key_sign == NULL) {\nlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\nPR_GetError());\nreturn -1;\n}\nPK11_FreeSlot(hash_slot);\nreturn 0;\n}", "contrast": "static int init_nss_hash(struct crypto_instance *instance)\n{\nPK11SlotInfo*\thash_slot = NULL;\nSECItem\t\thash_param;\nif (!hash_to_nss[instance->crypto_hash_type]) {\nreturn 0;\n}\nhash_param.type = siBuffer;\nhash_param.data = instance->private_key;\nhash_param.len = instance->private_key_len;\nhash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\nif (hash_slot == NULL) {\nlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\nPR_GetError());\nreturn -1;\n}\ninstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\nhash_to_nss[instance->crypto_hash_type],\nPK11_OriginUnwrap, CKA_SIGN,\n&hash_param, NULL);\nif (instance->nss_sym_key_sign == NULL) {\nlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\nPR_GetError());\nreturn -1;\n}\nPK11_FreeSlot(hash_slot);\nreturn 0;\n}", "label": 0}
{"index": 176136, "code": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\nint sockaddr_len)\n{\nstruct sock *sk = sock->sk;\nstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\nstruct pppox_sock *po = pppox_sk(sk);\nstruct pptp_opt *opt = &po->proto.pptp;\nint error = 0;\nlock_sock(sk);\nopt->src_addr = sp->sa_addr.pptp;\nif (add_chan(po))\nerror = -EBUSY;\nrelease_sock(sk);\nreturn error;\n}", "contrast": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\nint sockaddr_len)\n{\nstruct sock *sk = sock->sk;\nstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\nstruct pppox_sock *po = pppox_sk(sk);\nstruct pptp_opt *opt = &po->proto.pptp;\nint error = 0;\nif (sockaddr_len < sizeof(struct sockaddr_pppox))\nreturn -EINVAL;\nlock_sock(sk);\nopt->src_addr = sp->sa_addr.pptp;\nif (add_chan(po))\nerror = -EBUSY;\nrelease_sock(sk);\nreturn error;\n}", "label": 0}
{"index": 176163, "code": "void IGDstartelt(void * d, const char * name, int l)\n{\nstruct IGDdatas * datas = (struct IGDdatas *)d;\nmemcpy( datas->cureltname, name, l);\ndatas->cureltname[l] = '\\0';\ndatas->level++;\nif( (l==7) && !memcmp(name, \"service\", l) ) {\ndatas->tmp.controlurl[0] = '\\0';\ndatas->tmp.eventsuburl[0] = '\\0';\ndatas->tmp.scpdurl[0] = '\\0';\ndatas->tmp.servicetype[0] = '\\0';\n}\n}", "contrast": "void IGDstartelt(void * d, const char * name, int l)\n{\nstruct IGDdatas * datas = (struct IGDdatas *)d;\nif(l >= MINIUPNPC_URL_MAXSIZE)\nl = MINIUPNPC_URL_MAXSIZE-1;\nmemcpy(datas->cureltname, name, l);\ndatas->cureltname[l] = '\\0';\ndatas->level++;\nif( (l==7) && !memcmp(name, \"service\", l) ) {\ndatas->tmp.controlurl[0] = '\\0';\ndatas->tmp.eventsuburl[0] = '\\0';\ndatas->tmp.scpdurl[0] = '\\0';\ndatas->tmp.servicetype[0] = '\\0';\n}\n}", "label": 0}
{"index": 176168, "code": "int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\nint noblock, int flags, int *addr_len)\n{\nstruct ipv6_pinfo *np = inet6_sk(sk);\nstruct inet_sock *inet = inet_sk(sk);\nstruct sk_buff *skb;\nunsigned int ulen, copied;\nint peeked, off = 0;\nint err;\nint is_udplite = IS_UDPLITE(sk);\nint is_udp4;\nbool slow;\nif (flags & MSG_ERRQUEUE)\nreturn ipv6_recv_error(sk, msg, len, addr_len);\nif (np->rxpmtu && np->rxopt.bits.rxpmtu)\nreturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\ntry_again:\nskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n&peeked, &off, &err);\nif (!skb)\ngoto out;\nulen = skb->len - sizeof(struct udphdr);\ncopied = len;\nif (copied > ulen)\ncopied = ulen;\nelse if (copied < ulen)\nmsg->msg_flags |= MSG_TRUNC;\nis_udp4 = (skb->protocol == htons(ETH_P_IP));\nif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\nif (udp_lib_checksum_complete(skb))\ngoto csum_copy_err;\n}\nif (skb_csum_unnecessary(skb))\nerr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\nmsg, copied);\nelse {\nerr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);\nif (err == -EINVAL)\ngoto csum_copy_err;\n}\nif (unlikely(err)) {\ntrace_kfree_skb(skb, udpv6_recvmsg);\nif (!peeked) {\natomic_inc(&sk->sk_drops);\nif (is_udp4)\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS,\nis_udplite);\nelse\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS,\nis_udplite);\n}\ngoto out_free;\n}\nif (!peeked) {\nif (is_udp4)\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INDATAGRAMS, is_udplite);\nelse\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INDATAGRAMS, is_udplite);\n}\nsock_recv_ts_and_drops(msg, sk, skb);\nif (msg->msg_name) {\nDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\nsin6->sin6_family = AF_INET6;\nsin6->sin6_port = udp_hdr(skb)->source;\nsin6->sin6_flowinfo = 0;\nif (is_udp4) {\nipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n&sin6->sin6_addr);\nsin6->sin6_scope_id = 0;\n} else {\nsin6->sin6_addr = ipv6_hdr(skb)->saddr;\nsin6->sin6_scope_id =\nipv6_iface_scope_id(&sin6->sin6_addr,\ninet6_iif(skb));\n}\n*addr_len = sizeof(*sin6);\n}\nif (np->rxopt.all)\nip6_datagram_recv_common_ctl(sk, msg, skb);\nif (is_udp4) {\nif (inet->cmsg_flags)\nip_cmsg_recv(msg, skb);\n} else {\nif (np->rxopt.all)\nip6_datagram_recv_specific_ctl(sk, msg, skb);\n}\nerr = copied;\nif (flags & MSG_TRUNC)\nerr = ulen;\nout_free:\nskb_free_datagram_locked(sk, skb);\nout:\nreturn err;\ncsum_copy_err:\nslow = lock_sock_fast(sk);\nif (!skb_kill_datagram(sk, skb, flags)) {\nif (is_udp4) {\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_CSUMERRORS, is_udplite);\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS, is_udplite);\n} else {\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_CSUMERRORS, is_udplite);\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS, is_udplite);\n}\n}\nunlock_sock_fast(sk, slow);\nif (noblock)\nreturn -EAGAIN;\nmsg->msg_flags &= ~MSG_TRUNC;\ngoto try_again;\n}", "contrast": "int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\nint noblock, int flags, int *addr_len)\n{\nstruct ipv6_pinfo *np = inet6_sk(sk);\nstruct inet_sock *inet = inet_sk(sk);\nstruct sk_buff *skb;\nunsigned int ulen, copied;\nint peeked, off = 0;\nint err;\nint is_udplite = IS_UDPLITE(sk);\nint is_udp4;\nbool slow;\nif (flags & MSG_ERRQUEUE)\nreturn ipv6_recv_error(sk, msg, len, addr_len);\nif (np->rxpmtu && np->rxopt.bits.rxpmtu)\nreturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\ntry_again:\nskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n&peeked, &off, &err);\nif (!skb)\ngoto out;\nulen = skb->len - sizeof(struct udphdr);\ncopied = len;\nif (copied > ulen)\ncopied = ulen;\nelse if (copied < ulen)\nmsg->msg_flags |= MSG_TRUNC;\nis_udp4 = (skb->protocol == htons(ETH_P_IP));\nif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\nif (udp_lib_checksum_complete(skb))\ngoto csum_copy_err;\n}\nif (skb_csum_unnecessary(skb))\nerr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\nmsg, copied);\nelse {\nerr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);\nif (err == -EINVAL)\ngoto csum_copy_err;\n}\nif (unlikely(err)) {\ntrace_kfree_skb(skb, udpv6_recvmsg);\nif (!peeked) {\natomic_inc(&sk->sk_drops);\nif (is_udp4)\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS,\nis_udplite);\nelse\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS,\nis_udplite);\n}\ngoto out_free;\n}\nif (!peeked) {\nif (is_udp4)\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INDATAGRAMS, is_udplite);\nelse\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INDATAGRAMS, is_udplite);\n}\nsock_recv_ts_and_drops(msg, sk, skb);\nif (msg->msg_name) {\nDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\nsin6->sin6_family = AF_INET6;\nsin6->sin6_port = udp_hdr(skb)->source;\nsin6->sin6_flowinfo = 0;\nif (is_udp4) {\nipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n&sin6->sin6_addr);\nsin6->sin6_scope_id = 0;\n} else {\nsin6->sin6_addr = ipv6_hdr(skb)->saddr;\nsin6->sin6_scope_id =\nipv6_iface_scope_id(&sin6->sin6_addr,\ninet6_iif(skb));\n}\n*addr_len = sizeof(*sin6);\n}\nif (np->rxopt.all)\nip6_datagram_recv_common_ctl(sk, msg, skb);\nif (is_udp4) {\nif (inet->cmsg_flags)\nip_cmsg_recv(msg, skb);\n} else {\nif (np->rxopt.all)\nip6_datagram_recv_specific_ctl(sk, msg, skb);\n}\nerr = copied;\nif (flags & MSG_TRUNC)\nerr = ulen;\nout_free:\nskb_free_datagram_locked(sk, skb);\nout:\nreturn err;\ncsum_copy_err:\nslow = lock_sock_fast(sk);\nif (!skb_kill_datagram(sk, skb, flags)) {\nif (is_udp4) {\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_CSUMERRORS, is_udplite);\nUDP_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS, is_udplite);\n} else {\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_CSUMERRORS, is_udplite);\nUDP6_INC_STATS_USER(sock_net(sk),\nUDP_MIB_INERRORS, is_udplite);\n}\n}\nunlock_sock_fast(sk, slow);\ncond_resched();\nmsg->msg_flags &= ~MSG_TRUNC;\ngoto try_again;\n}", "label": 0}
{"index": 176180, "code": "static int virtnet_probe(struct virtio_device *vdev)\n{\nint i, err;\nstruct net_device *dev;\nstruct virtnet_info *vi;\nu16 max_queue_pairs;\nif (!vdev->config->get) {\ndev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n__func__);\nreturn -EINVAL;\n}\nif (!virtnet_validate_features(vdev))\nreturn -EINVAL;\nerr = virtio_cread_feature(vdev, VIRTIO_NET_F_MQ,\nstruct virtio_net_config,\nmax_virtqueue_pairs, &max_queue_pairs);\nif (err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\nmax_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n!virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\nmax_queue_pairs = 1;\ndev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\nif (!dev)\nreturn -ENOMEM;\ndev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\ndev->netdev_ops = &virtnet_netdev;\ndev->features = NETIF_F_HIGHDMA;\ndev->ethtool_ops = &virtnet_ethtool_ops;\nSET_NETDEV_DEV(dev, &vdev->dev);\nif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\ndev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\nif (csum)\ndev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\ndev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n}\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\ndev->hw_features |= NETIF_F_TSO;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\ndev->hw_features |= NETIF_F_TSO6;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_ECN))\ndev->hw_features |= NETIF_F_TSO_ECN;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_UFO))\ndev->hw_features |= NETIF_F_UFO;\ndev->features |= NETIF_F_GSO_ROBUST;\nif (gso)\ndev->features |= dev->hw_features & (NETIF_F_ALL_TSO|NETIF_F_UFO);\n}\nif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_CSUM))\ndev->features |= NETIF_F_RXCSUM;\ndev->vlan_features = dev->features;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_MAC))\nvirtio_cread_bytes(vdev,\noffsetof(struct virtio_net_config, mac),\ndev->dev_addr, dev->addr_len);\nelse\neth_hw_addr_random(dev);\nvi = netdev_priv(dev);\nvi->dev = dev;\nvi->vdev = vdev;\nvdev->priv = vi;\nvi->stats = alloc_percpu(struct virtnet_stats);\nerr = -ENOMEM;\nif (vi->stats == NULL)\ngoto free;\nfor_each_possible_cpu(i) {\nstruct virtnet_stats *virtnet_stats;\nvirtnet_stats = per_cpu_ptr(vi->stats, i);\nu64_stats_init(&virtnet_stats->tx_syncp);\nu64_stats_init(&virtnet_stats->rx_syncp);\n}\nINIT_WORK(&vi->config_work, virtnet_config_changed_work);\nif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO4) ||\nvirtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6) ||\nvirtio_has_feature(vdev, VIRTIO_NET_F_GUEST_ECN) ||\nvirtio_has_feature(vdev, VIRTIO_NET_F_GUEST_UFO))\nvi->big_packets = true;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\nvi->mergeable_rx_bufs = true;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF) ||\nvirtio_has_feature(vdev, VIRTIO_F_VERSION_1))\nvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\nelse\nvi->hdr_len = sizeof(struct virtio_net_hdr);\nif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT) ||\nvirtio_has_feature(vdev, VIRTIO_F_VERSION_1))\nvi->any_header_sg = true;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\nvi->has_cvq = true;\nif (vi->any_header_sg)\ndev->needed_headroom = vi->hdr_len;\nvi->curr_queue_pairs = 1;\nvi->max_queue_pairs = max_queue_pairs;\nerr = init_vqs(vi);\nif (err)\ngoto free_stats;\n#ifdef CONFIG_SYSFS\nif (vi->mergeable_rx_bufs)\ndev->sysfs_rx_queue_group = &virtio_net_mrg_rx_group;\n#endif\nnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\nnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\nerr = register_netdev(dev);\nif (err) {\npr_debug(\"virtio_net: registering device failed\\n\");\ngoto free_vqs;\n}\nvirtio_device_ready(vdev);\nfor (i = 0; i < vi->curr_queue_pairs; i++) {\ntry_fill_recv(vi, &vi->rq[i], GFP_KERNEL);\nif (vi->rq[i].vq->num_free ==\nvirtqueue_get_vring_size(vi->rq[i].vq)) {\nfree_unused_bufs(vi);\nerr = -ENOMEM;\ngoto free_recv_bufs;\n}\n}\nvi->nb.notifier_call = &virtnet_cpu_callback;\nerr = register_hotcpu_notifier(&vi->nb);\nif (err) {\npr_debug(\"virtio_net: registering cpu notifier failed\\n\");\ngoto free_recv_bufs;\n}\nif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {\nnetif_carrier_off(dev);\nschedule_work(&vi->config_work);\n} else {\nvi->status = VIRTIO_NET_S_LINK_UP;\nnetif_carrier_on(dev);\n}\npr_debug(\"virtnet: registered device %s with %d RX and TX vq's\\n\",\ndev->name, max_queue_pairs);\nreturn 0;\nfree_recv_bufs:\nvi->vdev->config->reset(vdev);\nfree_receive_bufs(vi);\nunregister_netdev(dev);\nfree_vqs:\ncancel_delayed_work_sync(&vi->refill);\nfree_receive_page_frags(vi);\nvirtnet_del_vqs(vi);\nfree_stats:\nfree_percpu(vi->stats);\nfree:\nfree_netdev(dev);\nreturn err;\n}", "contrast": "static int virtnet_probe(struct virtio_device *vdev)\n{\nint i, err;\nstruct net_device *dev;\nstruct virtnet_info *vi;\nu16 max_queue_pairs;\nif (!vdev->config->get) {\ndev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n__func__);\nreturn -EINVAL;\n}\nif (!virtnet_validate_features(vdev))\nreturn -EINVAL;\nerr = virtio_cread_feature(vdev, VIRTIO_NET_F_MQ,\nstruct virtio_net_config,\nmax_virtqueue_pairs, &max_queue_pairs);\nif (err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\nmax_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n!virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\nmax_queue_pairs = 1;\ndev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\nif (!dev)\nreturn -ENOMEM;\ndev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\ndev->netdev_ops = &virtnet_netdev;\ndev->features = NETIF_F_HIGHDMA;\ndev->ethtool_ops = &virtnet_ethtool_ops;\nSET_NETDEV_DEV(dev, &vdev->dev);\nif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\ndev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\nif (csum)\ndev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\ndev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n}\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\ndev->hw_features |= NETIF_F_TSO;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\ndev->hw_features |= NETIF_F_TSO6;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_ECN))\ndev->hw_features |= NETIF_F_TSO_ECN;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_UFO))\ndev->hw_features |= NETIF_F_UFO;\ndev->features |= NETIF_F_GSO_ROBUST;\nif (gso)\ndev->features |= dev->hw_features & (NETIF_F_ALL_TSO|NETIF_F_UFO);\n}\nif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_CSUM))\ndev->features |= NETIF_F_RXCSUM;\ndev->vlan_features = dev->features;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_MAC))\nvirtio_cread_bytes(vdev,\noffsetof(struct virtio_net_config, mac),\ndev->dev_addr, dev->addr_len);\nelse\neth_hw_addr_random(dev);\nvi = netdev_priv(dev);\nvi->dev = dev;\nvi->vdev = vdev;\nvdev->priv = vi;\nvi->stats = alloc_percpu(struct virtnet_stats);\nerr = -ENOMEM;\nif (vi->stats == NULL)\ngoto free;\nfor_each_possible_cpu(i) {\nstruct virtnet_stats *virtnet_stats;\nvirtnet_stats = per_cpu_ptr(vi->stats, i);\nu64_stats_init(&virtnet_stats->tx_syncp);\nu64_stats_init(&virtnet_stats->rx_syncp);\n}\nINIT_WORK(&vi->config_work, virtnet_config_changed_work);\nif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO4) ||\nvirtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6) ||\nvirtio_has_feature(vdev, VIRTIO_NET_F_GUEST_ECN) ||\nvirtio_has_feature(vdev, VIRTIO_NET_F_GUEST_UFO))\nvi->big_packets = true;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\nvi->mergeable_rx_bufs = true;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF) ||\nvirtio_has_feature(vdev, VIRTIO_F_VERSION_1))\nvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\nelse\nvi->hdr_len = sizeof(struct virtio_net_hdr);\nif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT) ||\nvirtio_has_feature(vdev, VIRTIO_F_VERSION_1))\nvi->any_header_sg = true;\nif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\nvi->has_cvq = true;\nif (vi->any_header_sg)\ndev->needed_headroom = vi->hdr_len;\nvi->curr_queue_pairs = 1;\nvi->max_queue_pairs = max_queue_pairs;\nerr = init_vqs(vi);\nif (err)\ngoto free_stats;\n#ifdef CONFIG_SYSFS\nif (vi->mergeable_rx_bufs)\ndev->sysfs_rx_queue_group = &virtio_net_mrg_rx_group;\n#endif\nnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\nnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\nerr = register_netdev(dev);\nif (err) {\npr_debug(\"virtio_net: registering device failed\\n\");\ngoto free_vqs;\n}\nvirtio_device_ready(vdev);\nfor (i = 0; i < vi->curr_queue_pairs; i++) {\ntry_fill_recv(vi, &vi->rq[i], GFP_KERNEL);\nif (vi->rq[i].vq->num_free ==\nvirtqueue_get_vring_size(vi->rq[i].vq)) {\nfree_unused_bufs(vi);\nerr = -ENOMEM;\ngoto free_recv_bufs;\n}\n}\nvi->nb.notifier_call = &virtnet_cpu_callback;\nerr = register_hotcpu_notifier(&vi->nb);\nif (err) {\npr_debug(\"virtio_net: registering cpu notifier failed\\n\");\ngoto free_recv_bufs;\n}\nif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {\nnetif_carrier_off(dev);\nschedule_work(&vi->config_work);\n} else {\nvi->status = VIRTIO_NET_S_LINK_UP;\nnetif_carrier_on(dev);\n}\npr_debug(\"virtnet: registered device %s with %d RX and TX vq's\\n\",\ndev->name, max_queue_pairs);\nreturn 0;\nfree_recv_bufs:\nvi->vdev->config->reset(vdev);\nfree_receive_bufs(vi);\nunregister_netdev(dev);\nfree_vqs:\ncancel_delayed_work_sync(&vi->refill);\nfree_receive_page_frags(vi);\nvirtnet_del_vqs(vi);\nfree_stats:\nfree_percpu(vi->stats);\nfree:\nfree_netdev(dev);\nreturn err;\n}", "label": 0}
{"index": 176182, "code": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\nregister unsigned int bit_buffer;\nregister int bits_left, i=0;\nunsigned char *i_ptr, *i_end;\nregister unsigned short sym;\nint match_length, length_footer, extra, verbatim_bits, bytes_todo;\nint this_run, main_element, aligned_bits, j;\nunsigned char *window, *runsrc, *rundest, buf[12];\nunsigned int frame_size=0, end_frame, match_offset, window_posn;\nunsigned int R0, R1, R2;\nif (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\nif (lzx->error) return lzx->error;\ni = lzx->o_end - lzx->o_ptr;\nif ((off_t) i > out_bytes) i = (int) out_bytes;\nif (i) {\nif (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\nreturn lzx->error = MSPACK_ERR_WRITE;\n}\nlzx->o_ptr  += i;\nlzx->offset += i;\nout_bytes   -= i;\n}\nif (out_bytes == 0) return MSPACK_ERR_OK;\nRESTORE_BITS;\nwindow = lzx->window;\nwindow_posn = lzx->window_posn;\nR0 = lzx->R0;\nR1 = lzx->R1;\nR2 = lzx->R2;\nend_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\nwhile (lzx->frame < end_frame) {\nif (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\nif (lzx->block_remaining) {\nD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nlzxd_reset_state(lzx);\nR0 = lzx->R0;\nR1 = lzx->R1;\nR2 = lzx->R2;\n}\nif (lzx->is_delta) {\nENSURE_BITS(16);\nREMOVE_BITS(16);\n}\nif (!lzx->header_read) {\nj = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\nlzx->intel_filesize = (i << 16) | j;\nlzx->header_read = 1;\n}\nframe_size = LZX_FRAME_SIZE;\nif (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\nframe_size = lzx->length - lzx->offset;\n}\nbytes_todo = lzx->frame_posn + frame_size - window_posn;\nwhile (bytes_todo > 0) {\nif (lzx->block_remaining == 0) {\nif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n(lzx->block_length & 1))\n{\nREAD_IF_NEEDED;\ni_ptr++;\n}\nREAD_BITS(lzx->block_type, 3);\nREAD_BITS(i, 16); READ_BITS(j, 8);\nlzx->block_remaining = lzx->block_length = (i << 8) | j;\nswitch (lzx->block_type) {\ncase LZX_BLOCKTYPE_ALIGNED:\nfor (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\nBUILD_TABLE(ALIGNED);\ncase LZX_BLOCKTYPE_VERBATIM:\nREAD_LENGTHS(MAINTREE, 0, 256);\nREAD_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\nBUILD_TABLE(MAINTREE);\nif (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\nREAD_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\nBUILD_TABLE_MAYBE_EMPTY(LENGTH);\nbreak;\ncase LZX_BLOCKTYPE_UNCOMPRESSED:\nlzx->intel_started = 1;\nENSURE_BITS(16);\nif (bits_left > 16) i_ptr -= 2;\nbits_left = 0; bit_buffer = 0;\nfor (rundest = &buf[0], i = 0; i < 12; i++) {\nREAD_IF_NEEDED;\n*rundest++ = *i_ptr++;\n}\nR0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\nR1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\nR2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\nbreak;\ndefault:\nD((\"bad block type\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\n}\nthis_run = lzx->block_remaining;\nif (this_run > bytes_todo) this_run = bytes_todo;\nbytes_todo           -= this_run;\nlzx->block_remaining -= this_run;\nswitch (lzx->block_type) {\ncase LZX_BLOCKTYPE_VERBATIM:\nwhile (this_run > 0) {\nREAD_HUFFSYM(MAINTREE, main_element);\nif (main_element < LZX_NUM_CHARS) {\nwindow[window_posn++] = main_element;\nthis_run--;\n}\nelse {\nmain_element -= LZX_NUM_CHARS;\nmatch_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\nif (match_length == LZX_NUM_PRIMARY_LENGTHS) {\nif (lzx->LENGTH_empty) {\nD((\"LENGTH symbol needed but tree is empty\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nREAD_HUFFSYM(LENGTH, length_footer);\nmatch_length += length_footer;\n}\nmatch_length += LZX_MIN_MATCH;\nswitch ((match_offset = (main_element >> 3))) {\ncase 0: match_offset = R0;                                  break;\ncase 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\ncase 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\ncase 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\ndefault:\nextra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\nREAD_BITS(verbatim_bits, extra);\nmatch_offset = position_base[match_offset] - 2 + verbatim_bits;\nR2 = R1; R1 = R0; R0 = match_offset;\n}\nif (match_length == LZX_MAX_MATCH && lzx->is_delta) {\nint extra_len = 0;\nENSURE_BITS(3);\nif (PEEK_BITS(1) == 0) {\nREMOVE_BITS(1);\nREAD_BITS(extra_len, 8);\n}\nelse if (PEEK_BITS(2) == 2) {\nREMOVE_BITS(2);\nREAD_BITS(extra_len, 10);\nextra_len += 0x100;\n}\nelse if (PEEK_BITS(3) == 6) {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 12);\nextra_len += 0x500;\n}\nelse {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 15);\n}\nmatch_length += extra_len;\n}\nif ((window_posn + match_length) > lzx->window_size) {\nD((\"match ran over window wrap\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrundest = &window[window_posn];\ni = match_length;\nif (match_offset > window_posn) {\nif (match_offset > lzx->offset &&\n(match_offset - window_posn) > lzx->ref_data_size)\n{\nD((\"match offset beyond LZX stream\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nj = match_offset - window_posn;\nif (j > (int) lzx->window_size) {\nD((\"match offset beyond window boundaries\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrunsrc = &window[lzx->window_size - j];\nif (j < i) {\ni -= j; while (j-- > 0) *rundest++ = *runsrc++;\nrunsrc = window;\n}\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nelse {\nrunsrc = rundest - match_offset;\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nthis_run    -= match_length;\nwindow_posn += match_length;\n}\n}\nbreak;\ncase LZX_BLOCKTYPE_ALIGNED:\nwhile (this_run > 0) {\nREAD_HUFFSYM(MAINTREE, main_element);\nif (main_element < LZX_NUM_CHARS) {\nwindow[window_posn++] = main_element;\nthis_run--;\n}\nelse {\nmain_element -= LZX_NUM_CHARS;\nmatch_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\nif (match_length == LZX_NUM_PRIMARY_LENGTHS) {\nif (lzx->LENGTH_empty) {\nD((\"LENGTH symbol needed but tree is empty\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nREAD_HUFFSYM(LENGTH, length_footer);\nmatch_length += length_footer;\n}\nmatch_length += LZX_MIN_MATCH;\nswitch ((match_offset = (main_element >> 3))) {\ncase 0: match_offset = R0;                             break;\ncase 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\ncase 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\ndefault:\nextra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\nmatch_offset = position_base[match_offset] - 2;\nif (extra > 3) {\nextra -= 3;\nREAD_BITS(verbatim_bits, extra);\nmatch_offset += (verbatim_bits << 3);\nREAD_HUFFSYM(ALIGNED, aligned_bits);\nmatch_offset += aligned_bits;\n}\nelse if (extra == 3) {\nREAD_HUFFSYM(ALIGNED, aligned_bits);\nmatch_offset += aligned_bits;\n}\nelse if (extra > 0) {\nREAD_BITS(verbatim_bits, extra);\nmatch_offset += verbatim_bits;\n}\nelse   {\nmatch_offset = 1;\n}\nR2 = R1; R1 = R0; R0 = match_offset;\n}\nif (match_length == LZX_MAX_MATCH && lzx->is_delta) {\nint extra_len = 0;\nENSURE_BITS(3);\nif (PEEK_BITS(1) == 0) {\nREMOVE_BITS(1);\nREAD_BITS(extra_len, 8);\n}\nelse if (PEEK_BITS(2) == 2) {\nREMOVE_BITS(2);\nREAD_BITS(extra_len, 10);\nextra_len += 0x100;\n}\nelse if (PEEK_BITS(3) == 6) {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 12);\nextra_len += 0x500;\n}\nelse {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 15);\n}\nmatch_length += extra_len;\n}\nif ((window_posn + match_length) > lzx->window_size) {\nD((\"match ran over window wrap\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrundest = &window[window_posn];\ni = match_length;\nif (match_offset > window_posn) {\nif (match_offset > lzx->offset &&\n(match_offset - window_posn) > lzx->ref_data_size)\n{\nD((\"match offset beyond LZX stream\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nj = match_offset - window_posn;\nif (j > (int) lzx->window_size) {\nD((\"match offset beyond window boundaries\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrunsrc = &window[lzx->window_size - j];\nif (j < i) {\ni -= j; while (j-- > 0) *rundest++ = *runsrc++;\nrunsrc = window;\n}\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nelse {\nrunsrc = rundest - match_offset;\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nthis_run    -= match_length;\nwindow_posn += match_length;\n}\n}\nbreak;\ncase LZX_BLOCKTYPE_UNCOMPRESSED:\nrundest = &window[window_posn];\nwindow_posn += this_run;\nwhile (this_run > 0) {\nif ((i = i_end - i_ptr) == 0) {\nREAD_IF_NEEDED;\n}\nelse {\nif (i > this_run) i = this_run;\nlzx->sys->copy(i_ptr, rundest, (size_t) i);\nrundest  += i;\ni_ptr    += i;\nthis_run -= i;\n}\n}\nbreak;\ndefault:\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nif (this_run < 0) {\nif ((unsigned int)(-this_run) > lzx->block_remaining) {\nD((\"overrun went past end of block by %d (%d remaining)\",\n-this_run, lzx->block_remaining ))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nlzx->block_remaining -= -this_run;\n}\n}\nif ((window_posn - lzx->frame_posn) != frame_size) {\nD((\"decode beyond output frame limits! %d != %d\",\nwindow_posn - lzx->frame_posn, frame_size))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nif (bits_left > 0) ENSURE_BITS(16);\nif (bits_left & 15) REMOVE_BITS(bits_left & 15);\nif (lzx->o_ptr != lzx->o_end) {\nD((\"%ld avail bytes, new %d frame\",\n(long)(lzx->o_end - lzx->o_ptr), frame_size))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nif (lzx->intel_started && lzx->intel_filesize &&\n(lzx->frame <= 32768) && (frame_size > 10))\n{\nunsigned char *data    = &lzx->e8_buf[0];\nunsigned char *dataend = &lzx->e8_buf[frame_size - 10];\nsigned int curpos      = lzx->intel_curpos;\nsigned int filesize    = lzx->intel_filesize;\nsigned int abs_off, rel_off;\nlzx->o_ptr = data;\nlzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\nwhile (data < dataend) {\nif (*data++ != 0xE8) { curpos++; continue; }\nabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\nif ((abs_off >= -curpos) && (abs_off < filesize)) {\nrel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\ndata[0] = (unsigned char) rel_off;\ndata[1] = (unsigned char) (rel_off >> 8);\ndata[2] = (unsigned char) (rel_off >> 16);\ndata[3] = (unsigned char) (rel_off >> 24);\n}\ndata += 4;\ncurpos += 5;\n}\nlzx->intel_curpos += frame_size;\n}\nelse {\nlzx->o_ptr = &lzx->window[lzx->frame_posn];\nif (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n}\nlzx->o_end = &lzx->o_ptr[frame_size];\ni = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\nif (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\nreturn lzx->error = MSPACK_ERR_WRITE;\n}\nlzx->o_ptr  += i;\nlzx->offset += i;\nout_bytes   -= i;\nlzx->frame_posn += frame_size;\nlzx->frame++;\nif (window_posn == lzx->window_size)     window_posn = 0;\nif (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n}\nif (out_bytes) {\nD((\"bytes left to output\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nSTORE_BITS;\nlzx->window_posn = window_posn;\nlzx->R0 = R0;\nlzx->R1 = R1;\nlzx->R2 = R2;\nreturn MSPACK_ERR_OK;\n}", "contrast": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\nregister unsigned int bit_buffer;\nregister int bits_left, i=0;\nunsigned char *i_ptr, *i_end;\nregister unsigned short sym;\nint match_length, length_footer, extra, verbatim_bits, bytes_todo;\nint this_run, main_element, aligned_bits, j;\nunsigned char *window, *runsrc, *rundest, buf[12];\nunsigned int frame_size=0, end_frame, match_offset, window_posn;\nunsigned int R0, R1, R2;\nif (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\nif (lzx->error) return lzx->error;\ni = lzx->o_end - lzx->o_ptr;\nif ((off_t) i > out_bytes) i = (int) out_bytes;\nif (i) {\nif (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\nreturn lzx->error = MSPACK_ERR_WRITE;\n}\nlzx->o_ptr  += i;\nlzx->offset += i;\nout_bytes   -= i;\n}\nif (out_bytes == 0) return MSPACK_ERR_OK;\nRESTORE_BITS;\nwindow = lzx->window;\nwindow_posn = lzx->window_posn;\nR0 = lzx->R0;\nR1 = lzx->R1;\nR2 = lzx->R2;\nend_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\nwhile (lzx->frame < end_frame) {\nif (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\nif (lzx->block_remaining) {\nD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nlzxd_reset_state(lzx);\nR0 = lzx->R0;\nR1 = lzx->R1;\nR2 = lzx->R2;\n}\nif (lzx->is_delta) {\nENSURE_BITS(16);\nREMOVE_BITS(16);\n}\nif (!lzx->header_read) {\nj = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\nlzx->intel_filesize = (i << 16) | j;\nlzx->header_read = 1;\n}\nframe_size = LZX_FRAME_SIZE;\nif (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\nframe_size = lzx->length - lzx->offset;\n}\nbytes_todo = lzx->frame_posn + frame_size - window_posn;\nwhile (bytes_todo > 0) {\nif (lzx->block_remaining == 0) {\nif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n(lzx->block_length & 1))\n{\nREAD_IF_NEEDED;\ni_ptr++;\n}\nREAD_BITS(lzx->block_type, 3);\nREAD_BITS(i, 16); READ_BITS(j, 8);\nlzx->block_remaining = lzx->block_length = (i << 8) | j;\nswitch (lzx->block_type) {\ncase LZX_BLOCKTYPE_ALIGNED:\nfor (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\nBUILD_TABLE(ALIGNED);\ncase LZX_BLOCKTYPE_VERBATIM:\nREAD_LENGTHS(MAINTREE, 0, 256);\nREAD_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\nBUILD_TABLE(MAINTREE);\nif (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\nREAD_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\nBUILD_TABLE_MAYBE_EMPTY(LENGTH);\nbreak;\ncase LZX_BLOCKTYPE_UNCOMPRESSED:\nlzx->intel_started = 1;\nif (bits_left == 0) ENSURE_BITS(16);\nbits_left = 0; bit_buffer = 0;\nfor (rundest = &buf[0], i = 0; i < 12; i++) {\nREAD_IF_NEEDED;\n*rundest++ = *i_ptr++;\n}\nR0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\nR1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\nR2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\nbreak;\ndefault:\nD((\"bad block type\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\n}\nthis_run = lzx->block_remaining;\nif (this_run > bytes_todo) this_run = bytes_todo;\nbytes_todo           -= this_run;\nlzx->block_remaining -= this_run;\nswitch (lzx->block_type) {\ncase LZX_BLOCKTYPE_VERBATIM:\nwhile (this_run > 0) {\nREAD_HUFFSYM(MAINTREE, main_element);\nif (main_element < LZX_NUM_CHARS) {\nwindow[window_posn++] = main_element;\nthis_run--;\n}\nelse {\nmain_element -= LZX_NUM_CHARS;\nmatch_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\nif (match_length == LZX_NUM_PRIMARY_LENGTHS) {\nif (lzx->LENGTH_empty) {\nD((\"LENGTH symbol needed but tree is empty\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nREAD_HUFFSYM(LENGTH, length_footer);\nmatch_length += length_footer;\n}\nmatch_length += LZX_MIN_MATCH;\nswitch ((match_offset = (main_element >> 3))) {\ncase 0: match_offset = R0;                                  break;\ncase 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\ncase 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\ncase 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\ndefault:\nextra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\nREAD_BITS(verbatim_bits, extra);\nmatch_offset = position_base[match_offset] - 2 + verbatim_bits;\nR2 = R1; R1 = R0; R0 = match_offset;\n}\nif (match_length == LZX_MAX_MATCH && lzx->is_delta) {\nint extra_len = 0;\nENSURE_BITS(3);\nif (PEEK_BITS(1) == 0) {\nREMOVE_BITS(1);\nREAD_BITS(extra_len, 8);\n}\nelse if (PEEK_BITS(2) == 2) {\nREMOVE_BITS(2);\nREAD_BITS(extra_len, 10);\nextra_len += 0x100;\n}\nelse if (PEEK_BITS(3) == 6) {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 12);\nextra_len += 0x500;\n}\nelse {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 15);\n}\nmatch_length += extra_len;\n}\nif ((window_posn + match_length) > lzx->window_size) {\nD((\"match ran over window wrap\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrundest = &window[window_posn];\ni = match_length;\nif (match_offset > window_posn) {\nif (match_offset > lzx->offset &&\n(match_offset - window_posn) > lzx->ref_data_size)\n{\nD((\"match offset beyond LZX stream\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nj = match_offset - window_posn;\nif (j > (int) lzx->window_size) {\nD((\"match offset beyond window boundaries\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrunsrc = &window[lzx->window_size - j];\nif (j < i) {\ni -= j; while (j-- > 0) *rundest++ = *runsrc++;\nrunsrc = window;\n}\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nelse {\nrunsrc = rundest - match_offset;\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nthis_run    -= match_length;\nwindow_posn += match_length;\n}\n}\nbreak;\ncase LZX_BLOCKTYPE_ALIGNED:\nwhile (this_run > 0) {\nREAD_HUFFSYM(MAINTREE, main_element);\nif (main_element < LZX_NUM_CHARS) {\nwindow[window_posn++] = main_element;\nthis_run--;\n}\nelse {\nmain_element -= LZX_NUM_CHARS;\nmatch_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\nif (match_length == LZX_NUM_PRIMARY_LENGTHS) {\nif (lzx->LENGTH_empty) {\nD((\"LENGTH symbol needed but tree is empty\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nREAD_HUFFSYM(LENGTH, length_footer);\nmatch_length += length_footer;\n}\nmatch_length += LZX_MIN_MATCH;\nswitch ((match_offset = (main_element >> 3))) {\ncase 0: match_offset = R0;                             break;\ncase 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\ncase 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\ndefault:\nextra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\nmatch_offset = position_base[match_offset] - 2;\nif (extra > 3) {\nextra -= 3;\nREAD_BITS(verbatim_bits, extra);\nmatch_offset += (verbatim_bits << 3);\nREAD_HUFFSYM(ALIGNED, aligned_bits);\nmatch_offset += aligned_bits;\n}\nelse if (extra == 3) {\nREAD_HUFFSYM(ALIGNED, aligned_bits);\nmatch_offset += aligned_bits;\n}\nelse if (extra > 0) {\nREAD_BITS(verbatim_bits, extra);\nmatch_offset += verbatim_bits;\n}\nelse   {\nmatch_offset = 1;\n}\nR2 = R1; R1 = R0; R0 = match_offset;\n}\nif (match_length == LZX_MAX_MATCH && lzx->is_delta) {\nint extra_len = 0;\nENSURE_BITS(3);\nif (PEEK_BITS(1) == 0) {\nREMOVE_BITS(1);\nREAD_BITS(extra_len, 8);\n}\nelse if (PEEK_BITS(2) == 2) {\nREMOVE_BITS(2);\nREAD_BITS(extra_len, 10);\nextra_len += 0x100;\n}\nelse if (PEEK_BITS(3) == 6) {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 12);\nextra_len += 0x500;\n}\nelse {\nREMOVE_BITS(3);\nREAD_BITS(extra_len, 15);\n}\nmatch_length += extra_len;\n}\nif ((window_posn + match_length) > lzx->window_size) {\nD((\"match ran over window wrap\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrundest = &window[window_posn];\ni = match_length;\nif (match_offset > window_posn) {\nif (match_offset > lzx->offset &&\n(match_offset - window_posn) > lzx->ref_data_size)\n{\nD((\"match offset beyond LZX stream\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nj = match_offset - window_posn;\nif (j > (int) lzx->window_size) {\nD((\"match offset beyond window boundaries\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nrunsrc = &window[lzx->window_size - j];\nif (j < i) {\ni -= j; while (j-- > 0) *rundest++ = *runsrc++;\nrunsrc = window;\n}\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nelse {\nrunsrc = rundest - match_offset;\nwhile (i-- > 0) *rundest++ = *runsrc++;\n}\nthis_run    -= match_length;\nwindow_posn += match_length;\n}\n}\nbreak;\ncase LZX_BLOCKTYPE_UNCOMPRESSED:\nrundest = &window[window_posn];\nwindow_posn += this_run;\nwhile (this_run > 0) {\nif ((i = i_end - i_ptr) == 0) {\nREAD_IF_NEEDED;\n}\nelse {\nif (i > this_run) i = this_run;\nlzx->sys->copy(i_ptr, rundest, (size_t) i);\nrundest  += i;\ni_ptr    += i;\nthis_run -= i;\n}\n}\nbreak;\ndefault:\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nif (this_run < 0) {\nif ((unsigned int)(-this_run) > lzx->block_remaining) {\nD((\"overrun went past end of block by %d (%d remaining)\",\n-this_run, lzx->block_remaining ))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nlzx->block_remaining -= -this_run;\n}\n}\nif ((window_posn - lzx->frame_posn) != frame_size) {\nD((\"decode beyond output frame limits! %d != %d\",\nwindow_posn - lzx->frame_posn, frame_size))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nif (bits_left > 0) ENSURE_BITS(16);\nif (bits_left & 15) REMOVE_BITS(bits_left & 15);\nif (lzx->o_ptr != lzx->o_end) {\nD((\"%ld avail bytes, new %d frame\",\n(long)(lzx->o_end - lzx->o_ptr), frame_size))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nif (lzx->intel_started && lzx->intel_filesize &&\n(lzx->frame <= 32768) && (frame_size > 10))\n{\nunsigned char *data    = &lzx->e8_buf[0];\nunsigned char *dataend = &lzx->e8_buf[frame_size - 10];\nsigned int curpos      = lzx->intel_curpos;\nsigned int filesize    = lzx->intel_filesize;\nsigned int abs_off, rel_off;\nlzx->o_ptr = data;\nlzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\nwhile (data < dataend) {\nif (*data++ != 0xE8) { curpos++; continue; }\nabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\nif ((abs_off >= -curpos) && (abs_off < filesize)) {\nrel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\ndata[0] = (unsigned char) rel_off;\ndata[1] = (unsigned char) (rel_off >> 8);\ndata[2] = (unsigned char) (rel_off >> 16);\ndata[3] = (unsigned char) (rel_off >> 24);\n}\ndata += 4;\ncurpos += 5;\n}\nlzx->intel_curpos += frame_size;\n}\nelse {\nlzx->o_ptr = &lzx->window[lzx->frame_posn];\nif (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n}\nlzx->o_end = &lzx->o_ptr[frame_size];\ni = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\nif (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\nreturn lzx->error = MSPACK_ERR_WRITE;\n}\nlzx->o_ptr  += i;\nlzx->offset += i;\nout_bytes   -= i;\nlzx->frame_posn += frame_size;\nlzx->frame++;\nif (window_posn == lzx->window_size)     window_posn = 0;\nif (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n}\nif (out_bytes) {\nD((\"bytes left to output\"))\nreturn lzx->error = MSPACK_ERR_DECRUNCH;\n}\nSTORE_BITS;\nlzx->window_posn = window_posn;\nlzx->R0 = R0;\nlzx->R1 = R1;\nlzx->R2 = R2;\nreturn MSPACK_ERR_OK;\n}", "label": 0}
{"index": 176196, "code": "static void sctp_close(struct sock *sk, long timeout)\n{\nstruct net *net = sock_net(sk);\nstruct sctp_endpoint *ep;\nstruct sctp_association *asoc;\nstruct list_head *pos, *temp;\nunsigned int data_was_unread;\npr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\nlock_sock(sk);\nsk->sk_shutdown = SHUTDOWN_MASK;\nsk->sk_state = SCTP_SS_CLOSING;\nep = sctp_sk(sk)->ep;\ndata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\ndata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\nlist_for_each_safe(pos, temp, &ep->asocs) {\nasoc = list_entry(pos, struct sctp_association, asocs);\nif (sctp_style(sk, TCP)) {\nif (sctp_state(asoc, CLOSED)) {\nsctp_unhash_established(asoc);\nsctp_association_free(asoc);\ncontinue;\n}\n}\nif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n!skb_queue_empty(&asoc->ulpq.reasm) ||\n(sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\nstruct sctp_chunk *chunk;\nchunk = sctp_make_abort_user(asoc, NULL, 0);\nif (chunk)\nsctp_primitive_ABORT(net, asoc, chunk);\n} else\nsctp_primitive_SHUTDOWN(net, asoc, NULL);\n}\nif (sctp_style(sk, TCP) && timeout)\nsctp_wait_for_close(sk, timeout);\nrelease_sock(sk);\nlocal_bh_disable();\nbh_lock_sock(sk);\nsock_hold(sk);\nsk_common_release(sk);\nbh_unlock_sock(sk);\nlocal_bh_enable();\nsock_put(sk);\nSCTP_DBG_OBJCNT_DEC(sock);\n}", "contrast": "static void sctp_close(struct sock *sk, long timeout)\n{\nstruct net *net = sock_net(sk);\nstruct sctp_endpoint *ep;\nstruct sctp_association *asoc;\nstruct list_head *pos, *temp;\nunsigned int data_was_unread;\npr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\nlock_sock(sk);\nsk->sk_shutdown = SHUTDOWN_MASK;\nsk->sk_state = SCTP_SS_CLOSING;\nep = sctp_sk(sk)->ep;\ndata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\ndata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\nlist_for_each_safe(pos, temp, &ep->asocs) {\nasoc = list_entry(pos, struct sctp_association, asocs);\nif (sctp_style(sk, TCP)) {\nif (sctp_state(asoc, CLOSED)) {\nsctp_unhash_established(asoc);\nsctp_association_free(asoc);\ncontinue;\n}\n}\nif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n!skb_queue_empty(&asoc->ulpq.reasm) ||\n(sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\nstruct sctp_chunk *chunk;\nchunk = sctp_make_abort_user(asoc, NULL, 0);\nif (chunk)\nsctp_primitive_ABORT(net, asoc, chunk);\n} else\nsctp_primitive_SHUTDOWN(net, asoc, NULL);\n}\nif (sctp_style(sk, TCP) && timeout)\nsctp_wait_for_close(sk, timeout);\nrelease_sock(sk);\nspin_lock_bh(&net->sctp.addr_wq_lock);\nbh_lock_sock(sk);\nsock_hold(sk);\nsk_common_release(sk);\nbh_unlock_sock(sk);\nspin_unlock_bh(&net->sctp.addr_wq_lock);\nsock_put(sk);\nSCTP_DBG_OBJCNT_DEC(sock);\n}", "label": 0}
{"index": 176200, "code": "apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,\nap_input_mode_t mode, apr_read_type_e block, apr_off_t readbytes)\n{\ncore_server_config *conf;\napr_bucket *e;\nhttp_ctx_t *ctx = f->ctx;\napr_status_t rv;\napr_off_t totalread;\nint again;\nconf = (core_server_config *)\nap_get_module_config(f->r->server->module_config, &core_module);\nif (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\nreturn ap_get_brigade(f->next, b, mode, block, readbytes);\n}\nif (!ctx) {\nconst char *tenc, *lenp;\nf->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\nctx->state = BODY_NONE;\nif (!f->r->proxyreq) {\nctx->limit = ap_get_limit_req_body(f->r);\n}\nelse {\nctx->limit = 0;\n}\ntenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\nlenp = apr_table_get(f->r->headers_in, \"Content-Length\");\nif (tenc) {\nif (strcasecmp(tenc, \"chunked\") == 0\n|| ap_find_last_token(f->r->pool, tenc, \"chunked\")) {\nctx->state = BODY_CHUNK;\n}\nelse if (f->r->proxyreq == PROXYREQ_RESPONSE) {\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n\"Unknown Transfer-Encoding: %s;\"\n\" using read-until-close\", tenc);\ntenc = NULL;\n}\nelse {\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n\"Unknown Transfer-Encoding: %s\", tenc);\nreturn APR_EGENERAL;\n}\nlenp = NULL;\n}\nif (lenp) {\nchar *endstr;\nctx->state = BODY_LENGTH;\nif (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n|| endstr == lenp || *endstr || ctx->remaining < 0) {\nctx->remaining = 0;\nap_log_rerror(\nAPLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n\"Invalid Content-Length\");\nreturn APR_ENOSPC;\n}\nif (ctx->limit && ctx->limit < ctx->remaining) {\nap_log_rerror(\nAPLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n\"Requested content-length of %\" APR_OFF_T_FMT\n\" is larger than the configured limit\"\n\" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\nreturn APR_ENOSPC;\n}\n}\nif (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\ne = apr_bucket_eos_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(b, e);\nctx->eos_sent = 1;\nreturn APR_SUCCESS;\n}\nif ((ctx->state == BODY_CHUNK\n|| (ctx->state == BODY_LENGTH && ctx->remaining > 0))\n&& f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)\n&& !(f->r->eos_sent || f->r->bytes_sent)) {\nif (!ap_is_HTTP_SUCCESS(f->r->status)) {\nctx->state = BODY_NONE;\nctx->eos_sent = 1;\n}\nelse {\nchar *tmp;\nint len;\napr_bucket_brigade *bb;\nbb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\nf->r->expecting_100 = 0;\ntmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL \" \",\nap_get_status_line(HTTP_CONTINUE), CRLF CRLF, NULL);\nlen = strlen(tmp);\nap_xlate_proto_to_ascii(tmp, len);\ne = apr_bucket_pool_create(tmp, len, f->r->pool,\nf->c->bucket_alloc);\nAPR_BRIGADE_INSERT_HEAD(bb, e);\ne = apr_bucket_flush_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(bb, e);\nrv = ap_pass_brigade(f->c->output_filters, bb);\nif (rv != APR_SUCCESS) {\nreturn AP_FILTER_ERROR;\n}\n}\n}\n}\nif (ctx->eos_sent) {\ne = apr_bucket_eos_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(b, e);\nreturn APR_SUCCESS;\n}\ndo {\napr_brigade_cleanup(b);\nagain = 0;\nswitch (ctx->state) {\ncase BODY_CHUNK:\ncase BODY_CHUNK_PART:\ncase BODY_CHUNK_EXT:\ncase BODY_CHUNK_END: {\nrv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\nif (block == APR_NONBLOCK_READ\n&& ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n|| (APR_STATUS_IS_EAGAIN(rv)))) {\nreturn APR_EAGAIN;\n}\nif (rv == APR_EOF) {\nreturn APR_INCOMPLETE;\n}\nif (rv != APR_SUCCESS) {\nreturn rv;\n}\ne = APR_BRIGADE_FIRST(b);\nwhile (e != APR_BRIGADE_SENTINEL(b)) {\nconst char *buffer;\napr_size_t len;\nif (!APR_BUCKET_IS_METADATA(e)) {\nrv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);\nif (rv == APR_SUCCESS) {\nrv = parse_chunk_size(ctx, buffer, len,\nf->r->server->limit_req_fieldsize);\n}\nif (rv != APR_SUCCESS) {\nap_log_rerror(\nAPLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590) \"Error reading chunk %s \", (APR_ENOSPC == rv) ? \"(overflow)\" : \"\");\nreturn rv;\n}\n}\napr_bucket_delete(e);\ne = APR_BRIGADE_FIRST(b);\n}\nagain = 1;\nif (ctx->state == BODY_CHUNK_TRAILER) {\nint merge_trailers =\nconf->merge_trailers == AP_MERGE_TRAILERS_ENABLE;\nreturn read_chunked_trailers(ctx, f, b, merge_trailers);\n}\nbreak;\n}\ncase BODY_NONE:\ncase BODY_LENGTH:\ncase BODY_CHUNK_DATA: {\nif (ctx->state != BODY_NONE && ctx->remaining < readbytes) {\nreadbytes = ctx->remaining;\n}\nif (readbytes > 0) {\nrv = ap_get_brigade(f->next, b, mode, block, readbytes);\nif (block == APR_NONBLOCK_READ\n&& ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n|| (APR_STATUS_IS_EAGAIN(rv)))) {\nreturn APR_EAGAIN;\n}\nif (rv == APR_EOF && ctx->state != BODY_NONE\n&& ctx->remaining > 0) {\nreturn APR_INCOMPLETE;\n}\nif (rv != APR_SUCCESS) {\nreturn rv;\n}\napr_brigade_length(b, 0, &totalread);\nAP_DEBUG_ASSERT(totalread >= 0);\nif (ctx->state != BODY_NONE) {\nctx->remaining -= totalread;\nif (ctx->remaining > 0) {\ne = APR_BRIGADE_LAST(b);\nif (APR_BUCKET_IS_EOS(e)) {\napr_bucket_delete(e);\nreturn APR_INCOMPLETE;\n}\n}\nelse if (ctx->state == BODY_CHUNK_DATA) {\nctx->state = BODY_CHUNK_END;\nctx->chunk_used = 0;\n}\n}\n}\nif (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\ne = apr_bucket_eos_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(b, e);\nctx->eos_sent = 1;\n}\nif (ctx->limit) {\nctx->limit_used += totalread;\nif (ctx->limit < ctx->limit_used) {\nap_log_rerror(\nAPLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01591) \"Read content-length of %\" APR_OFF_T_FMT \" is larger than the configured limit\"\n\" of %\" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);\nreturn APR_ENOSPC;\n}\n}\nbreak;\n}\ncase BODY_CHUNK_TRAILER: {\nrv = ap_get_brigade(f->next, b, mode, block, readbytes);\nif (block == APR_NONBLOCK_READ\n&& ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n|| (APR_STATUS_IS_EAGAIN(rv)))) {\nreturn APR_EAGAIN;\n}\nif (rv != APR_SUCCESS) {\nreturn rv;\n}\nbreak;\n}\ndefault: {\nbreak;\n}\n}\n} while (again);\nreturn APR_SUCCESS;\n}", "contrast": "apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,\nap_input_mode_t mode, apr_read_type_e block,\napr_off_t readbytes)\n{\ncore_server_config *conf;\napr_bucket *e;\nhttp_ctx_t *ctx = f->ctx;\napr_status_t rv;\napr_off_t totalread;\nint again;\nconf = (core_server_config *)\nap_get_module_config(f->r->server->module_config, &core_module);\nif (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\nreturn ap_get_brigade(f->next, b, mode, block, readbytes);\n}\nif (!ctx) {\nconst char *tenc, *lenp;\nf->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\nctx->state = BODY_NONE;\nif (!f->r->proxyreq) {\nctx->limit = ap_get_limit_req_body(f->r);\n}\nelse {\nctx->limit = 0;\n}\ntenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\nlenp = apr_table_get(f->r->headers_in, \"Content-Length\");\nif (tenc) {\nif (strcasecmp(tenc, \"chunked\") == 0\n|| ap_find_last_token(f->r->pool, tenc, \"chunked\")) {\nctx->state = BODY_CHUNK;\n}\nelse if (f->r->proxyreq == PROXYREQ_RESPONSE) {\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n\"Unknown Transfer-Encoding: %s; \"\n\"using read-until-close\", tenc);\ntenc = NULL;\n}\nelse {\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n\"Unknown Transfer-Encoding: %s\", tenc);\nreturn APR_EGENERAL;\n}\nlenp = NULL;\n}\nif (lenp) {\nchar *endstr;\nctx->state = BODY_LENGTH;\nif (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n|| endstr == lenp || *endstr || ctx->remaining < 0) {\nctx->remaining = 0;\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n\"Invalid Content-Length\");\nreturn APR_EINVAL;\n}\nif (ctx->limit && ctx->limit < ctx->remaining) {\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n\"Requested content-length of %\" APR_OFF_T_FMT\n\" is larger than the configured limit\"\n\" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\nreturn APR_ENOSPC;\n}\n}\nif (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\ne = apr_bucket_eos_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(b, e);\nctx->eos_sent = 1;\nreturn APR_SUCCESS;\n}\nif ((ctx->state == BODY_CHUNK\n|| (ctx->state == BODY_LENGTH && ctx->remaining > 0))\n&& f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)\n&& !(f->r->eos_sent || f->r->bytes_sent)) {\nif (!ap_is_HTTP_SUCCESS(f->r->status)) {\nctx->state = BODY_NONE;\nctx->eos_sent = 1;\n}\nelse {\nchar *tmp;\nint len;\napr_bucket_brigade *bb;\nbb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\nf->r->expecting_100 = 0;\ntmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL \" \",\nap_get_status_line(HTTP_CONTINUE), CRLF CRLF, NULL);\nlen = strlen(tmp);\nap_xlate_proto_to_ascii(tmp, len);\ne = apr_bucket_pool_create(tmp, len, f->r->pool,\nf->c->bucket_alloc);\nAPR_BRIGADE_INSERT_HEAD(bb, e);\ne = apr_bucket_flush_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(bb, e);\nrv = ap_pass_brigade(f->c->output_filters, bb);\napr_brigade_cleanup(bb);\nif (rv != APR_SUCCESS) {\nreturn AP_FILTER_ERROR;\n}\n}\n}\n}\nif (ctx->eos_sent) {\ne = apr_bucket_eos_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(b, e);\nreturn APR_SUCCESS;\n}\ndo {\napr_brigade_cleanup(b);\nagain = 0;\nswitch (ctx->state) {\ncase BODY_CHUNK:\ncase BODY_CHUNK_PART:\ncase BODY_CHUNK_EXT:\ncase BODY_CHUNK_LF:\ncase BODY_CHUNK_END:\ncase BODY_CHUNK_END_LF: {\nrv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\nif (block == APR_NONBLOCK_READ\n&& ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n|| (APR_STATUS_IS_EAGAIN(rv)))) {\nreturn APR_EAGAIN;\n}\nif (rv == APR_EOF) {\nreturn APR_INCOMPLETE;\n}\nif (rv != APR_SUCCESS) {\nreturn rv;\n}\ne = APR_BRIGADE_FIRST(b);\nwhile (e != APR_BRIGADE_SENTINEL(b)) {\nconst char *buffer;\napr_size_t len;\nif (!APR_BUCKET_IS_METADATA(e)) {\nrv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);\nif (rv == APR_SUCCESS) {\nrv = parse_chunk_size(ctx, buffer, len,\nf->r->server->limit_req_fieldsize);\n}\nif (rv != APR_SUCCESS) {\nap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)\n\"Error reading chunk %s \",\n(APR_ENOSPC == rv) ? \"(overflow)\" : \"\");\nreturn rv;\n}\n}\napr_bucket_delete(e);\ne = APR_BRIGADE_FIRST(b);\n}\nagain = 1;\nif (ctx->state == BODY_CHUNK_TRAILER) {\nreturn read_chunked_trailers(ctx, f, b,\nconf->merge_trailers == AP_MERGE_TRAILERS_ENABLE);\n}\nbreak;\n}\ncase BODY_NONE:\ncase BODY_LENGTH:\ncase BODY_CHUNK_DATA: {\nif (ctx->state != BODY_NONE && ctx->remaining < readbytes) {\nreadbytes = ctx->remaining;\n}\nif (readbytes > 0) {\nrv = ap_get_brigade(f->next, b, mode, block, readbytes);\nif (block == APR_NONBLOCK_READ\n&& ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n|| (APR_STATUS_IS_EAGAIN(rv)))) {\nreturn APR_EAGAIN;\n}\nif (rv == APR_EOF && ctx->state != BODY_NONE\n&& ctx->remaining > 0) {\nreturn APR_INCOMPLETE;\n}\nif (rv != APR_SUCCESS) {\nreturn rv;\n}\napr_brigade_length(b, 0, &totalread);\nAP_DEBUG_ASSERT(totalread >= 0);\nif (ctx->state != BODY_NONE) {\nctx->remaining -= totalread;\nif (ctx->remaining > 0) {\ne = APR_BRIGADE_LAST(b);\nif (APR_BUCKET_IS_EOS(e)) {\napr_bucket_delete(e);\nreturn APR_INCOMPLETE;\n}\n}\nelse if (ctx->state == BODY_CHUNK_DATA) {\nctx->state = BODY_CHUNK_END;\nctx->chunk_used = 0;\n}\n}\n}\nif (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\ne = apr_bucket_eos_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(b, e);\nctx->eos_sent = 1;\n}\nif (ctx->limit) {\nctx->limit_used += totalread;\nif (ctx->limit < ctx->limit_used) {\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01591)\n\"Read content-length of %\" APR_OFF_T_FMT\n\" is larger than the configured limit\"\n\" of %\" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);\nreturn APR_ENOSPC;\n}\n}\nbreak;\n}\ncase BODY_CHUNK_TRAILER: {\nrv = ap_get_brigade(f->next, b, mode, block, readbytes);\nif (block == APR_NONBLOCK_READ\n&& ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n|| (APR_STATUS_IS_EAGAIN(rv)))) {\nreturn APR_EAGAIN;\n}\nif (rv != APR_SUCCESS) {\nreturn rv;\n}\nbreak;\n}\ndefault: {\nap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(02901)\n\"Unexpected body state (%i)\", (int)ctx->state);\nreturn APR_EGENERAL;\n}\n}\n} while (again);\nreturn APR_SUCCESS;\n}", "label": 0}
{"index": 176232, "code": "int ip_forward(struct sk_buff *skb)\n{\nu32 mtu;\nstruct iphdr *iph;\nstruct rtable *rt;\nstruct ip_options *opt\t= &(IPCB(skb)->opt);\nif (skb->pkt_type != PACKET_HOST)\ngoto drop;\nif (skb_warn_if_lro(skb))\ngoto drop;\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))\ngoto drop;\nif (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))\nreturn NET_RX_SUCCESS;\nskb_forward_csum(skb);\nif (ip_hdr(skb)->ttl <= 1)\ngoto too_many_hops;\nif (!xfrm4_route_forward(skb))\ngoto drop;\nrt = skb_rtable(skb);\nif (opt->is_strictroute && rt->rt_uses_gateway)\ngoto sr_failed;\nIPCB(skb)->flags |= IPSKB_FORWARDED;\nmtu = ip_dst_mtu_maybe_forward(&rt->dst, true);\nif (!ip_may_fragment(skb) && ip_exceeds_mtu(skb, mtu)) {\nIP_INC_STATS(dev_net(rt->dst.dev), IPSTATS_MIB_FRAGFAILS);\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\nhtonl(mtu));\ngoto drop;\n}\nif (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))\ngoto drop;\niph = ip_hdr(skb);\nip_decrease_ttl(iph);\nif (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))\nip_rt_send_redirect(skb);\nskb->priority = rt_tos2priority(iph->tos);\nreturn NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,\nrt->dst.dev, ip_forward_finish);\nsr_failed:\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);\ngoto drop;\ntoo_many_hops:\nIP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_INHDRERRORS);\nicmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);\ndrop:\nkfree_skb(skb);\nreturn NET_RX_DROP;\n}", "contrast": "int ip_forward(struct sk_buff *skb)\n{\nu32 mtu;\nstruct iphdr *iph;\nstruct rtable *rt;\nstruct ip_options *opt\t= &(IPCB(skb)->opt);\nif (skb->pkt_type != PACKET_HOST)\ngoto drop;\nif (skb_warn_if_lro(skb))\ngoto drop;\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))\ngoto drop;\nif (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))\nreturn NET_RX_SUCCESS;\nskb_forward_csum(skb);\nif (ip_hdr(skb)->ttl <= 1)\ngoto too_many_hops;\nif (!xfrm4_route_forward(skb))\ngoto drop;\nrt = skb_rtable(skb);\nif (opt->is_strictroute && rt->rt_uses_gateway)\ngoto sr_failed;\nIPCB(skb)->flags |= IPSKB_FORWARDED;\nmtu = ip_dst_mtu_maybe_forward(&rt->dst, true);\nif (!ip_may_fragment(skb) && ip_exceeds_mtu(skb, mtu)) {\nIP_INC_STATS(dev_net(rt->dst.dev), IPSTATS_MIB_FRAGFAILS);\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\nhtonl(mtu));\ngoto drop;\n}\nif (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))\ngoto drop;\niph = ip_hdr(skb);\nip_decrease_ttl(iph);\nif (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&\n!skb_sec_path(skb))\nip_rt_send_redirect(skb);\nskb->priority = rt_tos2priority(iph->tos);\nreturn NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,\nrt->dst.dev, ip_forward_finish);\nsr_failed:\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);\ngoto drop;\ntoo_many_hops:\nIP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_INHDRERRORS);\nicmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);\ndrop:\nkfree_skb(skb);\nreturn NET_RX_DROP;\n}", "label": 0}
{"index": 176265, "code": "xfs_attr_node_addname(xfs_da_args_t *args)\n{\nxfs_da_state_t *state;\nxfs_da_state_blk_t *blk;\nxfs_inode_t *dp;\nxfs_mount_t *mp;\nint committed, retval, error;\ntrace_xfs_attr_node_addname(args);\ndp = args->dp;\nmp = dp->i_mount;\nrestart:\nstate = xfs_da_state_alloc();\nstate->args = args;\nstate->mp = mp;\nstate->blocksize = state->mp->m_sb.sb_blocksize;\nstate->node_ents = state->mp->m_attr_node_ents;\nerror = xfs_da3_node_lookup_int(state, &retval);\nif (error)\ngoto out;\nblk = &state->path.blk[ state->path.active-1 ];\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\nif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\ngoto out;\n} else if (retval == EEXIST) {\nif (args->flags & ATTR_CREATE)\ngoto out;\ntrace_xfs_attr_node_replace(args);\nargs->op_flags |= XFS_DA_OP_RENAME;\nargs->blkno2 = args->blkno;\nargs->index2 = args->index;\nargs->rmtblkno2 = args->rmtblkno;\nargs->rmtblkcnt2 = args->rmtblkcnt;\nargs->rmtblkno = 0;\nargs->rmtblkcnt = 0;\n}\nretval = xfs_attr3_leaf_add(blk->bp, state->args);\nif (retval == ENOSPC) {\nif (state->path.active == 1) {\nxfs_da_state_free(state);\nstate = NULL;\nxfs_bmap_init(args->flist, args->firstblock);\nerror = xfs_attr3_leaf_to_node(args);\nif (!error) {\nerror = xfs_bmap_finish(&args->trans,\nargs->flist,\n&committed);\n}\nif (error) {\nASSERT(committed);\nargs->trans = NULL;\nxfs_bmap_cancel(args->flist);\ngoto out;\n}\nif (committed)\nxfs_trans_ijoin(args->trans, dp, 0);\nerror = xfs_trans_roll(&args->trans, dp);\nif (error)\ngoto out;\ngoto restart;\n}\nxfs_bmap_init(args->flist, args->firstblock);\nerror = xfs_da3_split(state);\nif (!error) {\nerror = xfs_bmap_finish(&args->trans, args->flist,\n&committed);\n}\nif (error) {\nASSERT(committed);\nargs->trans = NULL;\nxfs_bmap_cancel(args->flist);\ngoto out;\n}\nif (committed)\nxfs_trans_ijoin(args->trans, dp, 0);\n} else {\nxfs_da3_fixhashpath(state, &state->path);\n}\nxfs_da_state_free(state);\nstate = NULL;\nerror = xfs_trans_roll(&args->trans, dp);\nif (error)\ngoto out;\nif (args->rmtblkno > 0) {\nerror = xfs_attr_rmtval_set(args);\nif (error)\nreturn(error);\n}\nif (args->op_flags & XFS_DA_OP_RENAME) {\nerror = xfs_attr3_leaf_flipflags(args);\nif (error)\ngoto out;\nargs->index = args->index2;\nargs->blkno = args->blkno2;\nargs->rmtblkno = args->rmtblkno2;\nargs->rmtblkcnt = args->rmtblkcnt2;\nif (args->rmtblkno) {\nerror = xfs_attr_rmtval_remove(args);\nif (error)\nreturn(error);\n}\nargs->flags |= XFS_ATTR_INCOMPLETE;\nstate = xfs_da_state_alloc();\nstate->args = args;\nstate->mp = mp;\nstate->blocksize = state->mp->m_sb.sb_blocksize;\nstate->node_ents = state->mp->m_attr_node_ents;\nstate->inleaf = 0;\nerror = xfs_da3_node_lookup_int(state, &retval);\nif (error)\ngoto out;\nblk = &state->path.blk[ state->path.active-1 ];\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\nerror = xfs_attr3_leaf_remove(blk->bp, args);\nxfs_da3_fixhashpath(state, &state->path);\nif (retval && (state->path.active > 1)) {\nxfs_bmap_init(args->flist, args->firstblock);\nerror = xfs_da3_join(state);\nif (!error) {\nerror = xfs_bmap_finish(&args->trans,\nargs->flist,\n&committed);\n}\nif (error) {\nASSERT(committed);\nargs->trans = NULL;\nxfs_bmap_cancel(args->flist);\ngoto out;\n}\nif (committed)\nxfs_trans_ijoin(args->trans, dp, 0);\n}\nerror = xfs_trans_roll(&args->trans, dp);\nif (error)\ngoto out;\n} else if (args->rmtblkno > 0) {\nerror = xfs_attr3_leaf_clearflag(args);\nif (error)\ngoto out;\n}\nretval = error = 0;\nout:\nif (state)\nxfs_da_state_free(state);\nif (error)\nreturn(error);\nreturn(retval);\n}", "contrast": "xfs_attr_node_addname(xfs_da_args_t *args)\n{\nxfs_da_state_t *state;\nxfs_da_state_blk_t *blk;\nxfs_inode_t *dp;\nxfs_mount_t *mp;\nint committed, retval, error;\ntrace_xfs_attr_node_addname(args);\ndp = args->dp;\nmp = dp->i_mount;\nrestart:\nstate = xfs_da_state_alloc();\nstate->args = args;\nstate->mp = mp;\nstate->blocksize = state->mp->m_sb.sb_blocksize;\nstate->node_ents = state->mp->m_attr_node_ents;\nerror = xfs_da3_node_lookup_int(state, &retval);\nif (error)\ngoto out;\nblk = &state->path.blk[ state->path.active-1 ];\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\nif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\ngoto out;\n} else if (retval == EEXIST) {\nif (args->flags & ATTR_CREATE)\ngoto out;\ntrace_xfs_attr_node_replace(args);\nargs->op_flags |= XFS_DA_OP_RENAME;\nargs->blkno2 = args->blkno;\nargs->index2 = args->index;\nargs->rmtblkno2 = args->rmtblkno;\nargs->rmtblkcnt2 = args->rmtblkcnt;\nargs->rmtvaluelen2 = args->rmtvaluelen;\nargs->rmtblkno = 0;\nargs->rmtblkcnt = 0;\nargs->rmtvaluelen = 0;\n}\nretval = xfs_attr3_leaf_add(blk->bp, state->args);\nif (retval == ENOSPC) {\nif (state->path.active == 1) {\nxfs_da_state_free(state);\nstate = NULL;\nxfs_bmap_init(args->flist, args->firstblock);\nerror = xfs_attr3_leaf_to_node(args);\nif (!error) {\nerror = xfs_bmap_finish(&args->trans,\nargs->flist,\n&committed);\n}\nif (error) {\nASSERT(committed);\nargs->trans = NULL;\nxfs_bmap_cancel(args->flist);\ngoto out;\n}\nif (committed)\nxfs_trans_ijoin(args->trans, dp, 0);\nerror = xfs_trans_roll(&args->trans, dp);\nif (error)\ngoto out;\ngoto restart;\n}\nxfs_bmap_init(args->flist, args->firstblock);\nerror = xfs_da3_split(state);\nif (!error) {\nerror = xfs_bmap_finish(&args->trans, args->flist,\n&committed);\n}\nif (error) {\nASSERT(committed);\nargs->trans = NULL;\nxfs_bmap_cancel(args->flist);\ngoto out;\n}\nif (committed)\nxfs_trans_ijoin(args->trans, dp, 0);\n} else {\nxfs_da3_fixhashpath(state, &state->path);\n}\nxfs_da_state_free(state);\nstate = NULL;\nerror = xfs_trans_roll(&args->trans, dp);\nif (error)\ngoto out;\nif (args->rmtblkno > 0) {\nerror = xfs_attr_rmtval_set(args);\nif (error)\nreturn(error);\n}\nif (args->op_flags & XFS_DA_OP_RENAME) {\nerror = xfs_attr3_leaf_flipflags(args);\nif (error)\ngoto out;\nargs->index = args->index2;\nargs->blkno = args->blkno2;\nargs->rmtblkno = args->rmtblkno2;\nargs->rmtblkcnt = args->rmtblkcnt2;\nargs->rmtvaluelen = args->rmtvaluelen2;\nif (args->rmtblkno) {\nerror = xfs_attr_rmtval_remove(args);\nif (error)\nreturn(error);\n}\nargs->flags |= XFS_ATTR_INCOMPLETE;\nstate = xfs_da_state_alloc();\nstate->args = args;\nstate->mp = mp;\nstate->blocksize = state->mp->m_sb.sb_blocksize;\nstate->node_ents = state->mp->m_attr_node_ents;\nstate->inleaf = 0;\nerror = xfs_da3_node_lookup_int(state, &retval);\nif (error)\ngoto out;\nblk = &state->path.blk[ state->path.active-1 ];\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\nerror = xfs_attr3_leaf_remove(blk->bp, args);\nxfs_da3_fixhashpath(state, &state->path);\nif (retval && (state->path.active > 1)) {\nxfs_bmap_init(args->flist, args->firstblock);\nerror = xfs_da3_join(state);\nif (!error) {\nerror = xfs_bmap_finish(&args->trans,\nargs->flist,\n&committed);\n}\nif (error) {\nASSERT(committed);\nargs->trans = NULL;\nxfs_bmap_cancel(args->flist);\ngoto out;\n}\nif (committed)\nxfs_trans_ijoin(args->trans, dp, 0);\n}\nerror = xfs_trans_roll(&args->trans, dp);\nif (error)\ngoto out;\n} else if (args->rmtblkno > 0) {\nerror = xfs_attr3_leaf_clearflag(args);\nif (error)\ngoto out;\n}\nretval = error = 0;\nout:\nif (state)\nxfs_da_state_free(state);\nif (error)\nreturn(error);\nreturn(retval);\n}", "label": 0}
{"index": 176289, "code": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n*root, struct btrfs_key *key, struct btrfs_path *p, int\nins_len, int cow)\n{\nstruct extent_buffer *b;\nint slot;\nint ret;\nint err;\nint level;\nint lowest_unlock = 1;\nint root_lock;\nint write_lock_level = 0;\nu8 lowest_level = 0;\nint min_write_lock_level;\nint prev_cmp;\nlowest_level = p->lowest_level;\nWARN_ON(lowest_level && ins_len > 0);\nWARN_ON(p->nodes[0] != NULL);\nBUG_ON(!cow && ins_len);\nif (ins_len < 0) {\nlowest_unlock = 2;\nwrite_lock_level = 2;\n} else if (ins_len > 0) {\nwrite_lock_level = 1;\n}\nif (!cow)\nwrite_lock_level = -1;\nif (cow && (p->keep_locks || p->lowest_level))\nwrite_lock_level = BTRFS_MAX_LEVEL;\nmin_write_lock_level = write_lock_level;\nagain:\nprev_cmp = -1;\nroot_lock = BTRFS_READ_LOCK;\nlevel = 0;\nif (p->search_commit_root) {\nif (p->need_commit_sem)\ndown_read(&root->fs_info->commit_root_sem);\nb = root->commit_root;\nextent_buffer_get(b);\nlevel = btrfs_header_level(b);\nif (p->need_commit_sem)\nup_read(&root->fs_info->commit_root_sem);\nif (!p->skip_locking)\nbtrfs_tree_read_lock(b);\n} else {\nif (p->skip_locking) {\nb = btrfs_root_node(root);\nlevel = btrfs_header_level(b);\n} else {\nb = btrfs_read_lock_root_node(root);\nlevel = btrfs_header_level(b);\nif (level <= write_lock_level) {\nbtrfs_tree_read_unlock(b);\nfree_extent_buffer(b);\nb = btrfs_lock_root_node(root);\nroot_lock = BTRFS_WRITE_LOCK;\nlevel = btrfs_header_level(b);\n}\n}\n}\np->nodes[level] = b;\nif (!p->skip_locking)\np->locks[level] = root_lock;\nwhile (b) {\nlevel = btrfs_header_level(b);\nif (cow) {\nif (!should_cow_block(trans, root, b))\ngoto cow_done;\nif (level > write_lock_level ||\n(level + 1 > write_lock_level &&\nlevel + 1 < BTRFS_MAX_LEVEL &&\np->nodes[level + 1])) {\nwrite_lock_level = level + 1;\nbtrfs_release_path(p);\ngoto again;\n}\nbtrfs_set_path_blocking(p);\nerr = btrfs_cow_block(trans, root, b,\np->nodes[level + 1],\np->slots[level + 1], &b);\nif (err) {\nret = err;\ngoto done;\n}\n}\ncow_done:\np->nodes[level] = b;\nbtrfs_clear_path_blocking(p, NULL, 0);\nif (!ins_len && !p->keep_locks) {\nint u = level + 1;\nif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\nbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\np->locks[u] = 0;\n}\n}\nret = key_search(b, key, level, &prev_cmp, &slot);\nif (level != 0) {\nint dec = 0;\nif (ret && slot > 0) {\ndec = 1;\nslot -= 1;\n}\np->slots[level] = slot;\nerr = setup_nodes_for_search(trans, root, p, b, level,\nins_len, &write_lock_level);\nif (err == -EAGAIN)\ngoto again;\nif (err) {\nret = err;\ngoto done;\n}\nb = p->nodes[level];\nslot = p->slots[level];\nif (slot == 0 && ins_len &&\nwrite_lock_level < level + 1) {\nwrite_lock_level = level + 1;\nbtrfs_release_path(p);\ngoto again;\n}\nunlock_up(p, level, lowest_unlock,\nmin_write_lock_level, &write_lock_level);\nif (level == lowest_level) {\nif (dec)\np->slots[level]++;\ngoto done;\n}\nerr = read_block_for_search(trans, root, p,\n&b, level, slot, key, 0);\nif (err == -EAGAIN)\ngoto again;\nif (err) {\nret = err;\ngoto done;\n}\nif (!p->skip_locking) {\nlevel = btrfs_header_level(b);\nif (level <= write_lock_level) {\nerr = btrfs_try_tree_write_lock(b);\nif (!err) {\nbtrfs_set_path_blocking(p);\nbtrfs_tree_lock(b);\nbtrfs_clear_path_blocking(p, b,\nBTRFS_WRITE_LOCK);\n}\np->locks[level] = BTRFS_WRITE_LOCK;\n} else {\nerr = btrfs_try_tree_read_lock(b);\nif (!err) {\nbtrfs_set_path_blocking(p);\nbtrfs_tree_read_lock(b);\nbtrfs_clear_path_blocking(p, b,\nBTRFS_READ_LOCK);\n}\np->locks[level] = BTRFS_READ_LOCK;\n}\np->nodes[level] = b;\n}\n} else {\np->slots[level] = slot;\nif (ins_len > 0 &&\nbtrfs_leaf_free_space(root, b) < ins_len) {\nif (write_lock_level < 1) {\nwrite_lock_level = 1;\nbtrfs_release_path(p);\ngoto again;\n}\nbtrfs_set_path_blocking(p);\nerr = split_leaf(trans, root, key,\np, ins_len, ret == 0);\nbtrfs_clear_path_blocking(p, NULL, 0);\nBUG_ON(err > 0);\nif (err) {\nret = err;\ngoto done;\n}\n}\nif (!p->search_for_split)\nunlock_up(p, level, lowest_unlock,\nmin_write_lock_level, &write_lock_level);\ngoto done;\n}\n}\nret = 1;\ndone:\nif (!p->leave_spinning)\nbtrfs_set_path_blocking(p);\nif (ret < 0)\nbtrfs_release_path(p);\nreturn ret;\n}", "contrast": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n*root, struct btrfs_key *key, struct btrfs_path *p, int\nins_len, int cow)\n{\nstruct extent_buffer *b;\nint slot;\nint ret;\nint err;\nint level;\nint lowest_unlock = 1;\nint root_lock;\nint write_lock_level = 0;\nu8 lowest_level = 0;\nint min_write_lock_level;\nint prev_cmp;\nlowest_level = p->lowest_level;\nWARN_ON(lowest_level && ins_len > 0);\nWARN_ON(p->nodes[0] != NULL);\nBUG_ON(!cow && ins_len);\nif (ins_len < 0) {\nlowest_unlock = 2;\nwrite_lock_level = 2;\n} else if (ins_len > 0) {\nwrite_lock_level = 1;\n}\nif (!cow)\nwrite_lock_level = -1;\nif (cow && (p->keep_locks || p->lowest_level))\nwrite_lock_level = BTRFS_MAX_LEVEL;\nmin_write_lock_level = write_lock_level;\nagain:\nprev_cmp = -1;\nroot_lock = BTRFS_READ_LOCK;\nlevel = 0;\nif (p->search_commit_root) {\nif (p->need_commit_sem)\ndown_read(&root->fs_info->commit_root_sem);\nb = root->commit_root;\nextent_buffer_get(b);\nlevel = btrfs_header_level(b);\nif (p->need_commit_sem)\nup_read(&root->fs_info->commit_root_sem);\nif (!p->skip_locking)\nbtrfs_tree_read_lock(b);\n} else {\nif (p->skip_locking) {\nb = btrfs_root_node(root);\nlevel = btrfs_header_level(b);\n} else {\nb = btrfs_read_lock_root_node(root);\nlevel = btrfs_header_level(b);\nif (level <= write_lock_level) {\nbtrfs_tree_read_unlock(b);\nfree_extent_buffer(b);\nb = btrfs_lock_root_node(root);\nroot_lock = BTRFS_WRITE_LOCK;\nlevel = btrfs_header_level(b);\n}\n}\n}\np->nodes[level] = b;\nif (!p->skip_locking)\np->locks[level] = root_lock;\nwhile (b) {\nlevel = btrfs_header_level(b);\nif (cow) {\nif (!should_cow_block(trans, root, b))\ngoto cow_done;\nif (level > write_lock_level ||\n(level + 1 > write_lock_level &&\nlevel + 1 < BTRFS_MAX_LEVEL &&\np->nodes[level + 1])) {\nwrite_lock_level = level + 1;\nbtrfs_release_path(p);\ngoto again;\n}\nbtrfs_set_path_blocking(p);\nerr = btrfs_cow_block(trans, root, b,\np->nodes[level + 1],\np->slots[level + 1], &b);\nif (err) {\nret = err;\ngoto done;\n}\n}\ncow_done:\np->nodes[level] = b;\nbtrfs_clear_path_blocking(p, NULL, 0);\nif (!ins_len && !p->keep_locks) {\nint u = level + 1;\nif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\nbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\np->locks[u] = 0;\n}\n}\nret = key_search(b, key, level, &prev_cmp, &slot);\nif (level != 0) {\nint dec = 0;\nif (ret && slot > 0) {\ndec = 1;\nslot -= 1;\n}\np->slots[level] = slot;\nerr = setup_nodes_for_search(trans, root, p, b, level,\nins_len, &write_lock_level);\nif (err == -EAGAIN)\ngoto again;\nif (err) {\nret = err;\ngoto done;\n}\nb = p->nodes[level];\nslot = p->slots[level];\nif (slot == 0 && ins_len &&\nwrite_lock_level < level + 1) {\nwrite_lock_level = level + 1;\nbtrfs_release_path(p);\ngoto again;\n}\nunlock_up(p, level, lowest_unlock,\nmin_write_lock_level, &write_lock_level);\nif (level == lowest_level) {\nif (dec)\np->slots[level]++;\ngoto done;\n}\nerr = read_block_for_search(trans, root, p,\n&b, level, slot, key, 0);\nif (err == -EAGAIN)\ngoto again;\nif (err) {\nret = err;\ngoto done;\n}\nif (!p->skip_locking) {\nlevel = btrfs_header_level(b);\nif (level <= write_lock_level) {\nerr = btrfs_try_tree_write_lock(b);\nif (!err) {\nbtrfs_set_path_blocking(p);\nbtrfs_tree_lock(b);\nbtrfs_clear_path_blocking(p, b,\nBTRFS_WRITE_LOCK);\n}\np->locks[level] = BTRFS_WRITE_LOCK;\n} else {\nerr = btrfs_try_tree_read_lock(b);\nif (!err) {\nbtrfs_set_path_blocking(p);\nbtrfs_tree_read_lock(b);\nbtrfs_clear_path_blocking(p, b,\nBTRFS_READ_LOCK);\n}\np->locks[level] = BTRFS_READ_LOCK;\n}\np->nodes[level] = b;\n}\n} else {\np->slots[level] = slot;\nif (ins_len > 0 &&\nbtrfs_leaf_free_space(root, b) < ins_len) {\nif (write_lock_level < 1) {\nwrite_lock_level = 1;\nbtrfs_release_path(p);\ngoto again;\n}\nbtrfs_set_path_blocking(p);\nerr = split_leaf(trans, root, key,\np, ins_len, ret == 0);\nbtrfs_clear_path_blocking(p, NULL, 0);\nBUG_ON(err > 0);\nif (err) {\nret = err;\ngoto done;\n}\n}\nif (!p->search_for_split)\nunlock_up(p, level, lowest_unlock,\nmin_write_lock_level, &write_lock_level);\ngoto done;\n}\n}\nret = 1;\ndone:\nif (!p->leave_spinning)\nbtrfs_set_path_blocking(p);\nif (ret < 0 && !p->skip_release_on_error)\nbtrfs_release_path(p);\nreturn ret;\n}", "label": 0}
{"index": 176296, "code": "mconvert(struct magic_set *ms, struct magic *m, int flip)\n{\nunion VALUETYPE *p = &ms->ms_value;\nuint8_t type;\nswitch (type = cvt_flip(m->type, flip)) {\ncase FILE_BYTE:\ncvt_8(p, m);\nreturn 1;\ncase FILE_SHORT:\ncvt_16(p, m);\nreturn 1;\ncase FILE_LONG:\ncase FILE_DATE:\ncase FILE_LDATE:\ncvt_32(p, m);\nreturn 1;\ncase FILE_QUAD:\ncase FILE_QDATE:\ncase FILE_QLDATE:\ncase FILE_QWDATE:\ncvt_64(p, m);\nreturn 1;\ncase FILE_STRING:\ncase FILE_BESTRING16:\ncase FILE_LESTRING16: {\np->s[sizeof(p->s) - 1] = '\\0';\nreturn 1;\n}\ncase FILE_PSTRING: {\nsize_t sz = file_pstring_length_size(m);\nchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\nsize_t len = file_pstring_get_length(m, ptr1);\nif (len >= sizeof(p->s)) {\nlen = sizeof(p->s) - sz;\n}\nwhile (len--)\n*ptr1++ = *ptr2++;\n*ptr1 = '\\0';\nreturn 1;\n}\ncase FILE_BESHORT:\np->h = (short)((p->hs[0]<<8)|(p->hs[1]));\ncvt_16(p, m);\nreturn 1;\ncase FILE_BELONG:\ncase FILE_BEDATE:\ncase FILE_BELDATE:\np->l = (int32_t)\n((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\nif (type == FILE_BELONG)\ncvt_32(p, m);\nreturn 1;\ncase FILE_BEQUAD:\ncase FILE_BEQDATE:\ncase FILE_BEQLDATE:\ncase FILE_BEQWDATE:\np->q = (uint64_t)\n(((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\nif (type == FILE_BEQUAD)\ncvt_64(p, m);\nreturn 1;\ncase FILE_LESHORT:\np->h = (short)((p->hs[1]<<8)|(p->hs[0]));\ncvt_16(p, m);\nreturn 1;\ncase FILE_LELONG:\ncase FILE_LEDATE:\ncase FILE_LELDATE:\np->l = (int32_t)\n((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\nif (type == FILE_LELONG)\ncvt_32(p, m);\nreturn 1;\ncase FILE_LEQUAD:\ncase FILE_LEQDATE:\ncase FILE_LEQLDATE:\ncase FILE_LEQWDATE:\np->q = (uint64_t)\n(((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\nif (type == FILE_LEQUAD)\ncvt_64(p, m);\nreturn 1;\ncase FILE_MELONG:\ncase FILE_MEDATE:\ncase FILE_MELDATE:\np->l = (int32_t)\n((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\nif (type == FILE_MELONG)\ncvt_32(p, m);\nreturn 1;\ncase FILE_FLOAT:\ncvt_float(p, m);\nreturn 1;\ncase FILE_BEFLOAT:\np->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\ncvt_float(p, m);\nreturn 1;\ncase FILE_LEFLOAT:\np->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\ncvt_float(p, m);\nreturn 1;\ncase FILE_DOUBLE:\ncvt_double(p, m);\nreturn 1;\ncase FILE_BEDOUBLE:\np->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\ncvt_double(p, m);\nreturn 1;\ncase FILE_LEDOUBLE:\np->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\ncvt_double(p, m);\nreturn 1;\ncase FILE_REGEX:\ncase FILE_SEARCH:\ncase FILE_DEFAULT:\ncase FILE_CLEAR:\ncase FILE_NAME:\ncase FILE_USE:\nreturn 1;\ndefault:\nfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\nreturn 0;\n}\n}", "contrast": "mconvert(struct magic_set *ms, struct magic *m, int flip)\n{\nunion VALUETYPE *p = &ms->ms_value;\nuint8_t type;\nswitch (type = cvt_flip(m->type, flip)) {\ncase FILE_BYTE:\ncvt_8(p, m);\nreturn 1;\ncase FILE_SHORT:\ncvt_16(p, m);\nreturn 1;\ncase FILE_LONG:\ncase FILE_DATE:\ncase FILE_LDATE:\ncvt_32(p, m);\nreturn 1;\ncase FILE_QUAD:\ncase FILE_QDATE:\ncase FILE_QLDATE:\ncase FILE_QWDATE:\ncvt_64(p, m);\nreturn 1;\ncase FILE_STRING:\ncase FILE_BESTRING16:\ncase FILE_LESTRING16: {\np->s[sizeof(p->s) - 1] = '\\0';\nreturn 1;\n}\ncase FILE_PSTRING: {\nsize_t sz = file_pstring_length_size(m);\nchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\nsize_t len = file_pstring_get_length(m, ptr1);\nsz = sizeof(p->s) - sz;\nif (len >= sz) {\nlen = sz;\n}\nwhile (len--)\n*ptr1++ = *ptr2++;\n*ptr1 = '\\0';\nreturn 1;\n}\ncase FILE_BESHORT:\np->h = (short)((p->hs[0]<<8)|(p->hs[1]));\ncvt_16(p, m);\nreturn 1;\ncase FILE_BELONG:\ncase FILE_BEDATE:\ncase FILE_BELDATE:\np->l = (int32_t)\n((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\nif (type == FILE_BELONG)\ncvt_32(p, m);\nreturn 1;\ncase FILE_BEQUAD:\ncase FILE_BEQDATE:\ncase FILE_BEQLDATE:\ncase FILE_BEQWDATE:\np->q = (uint64_t)\n(((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\nif (type == FILE_BEQUAD)\ncvt_64(p, m);\nreturn 1;\ncase FILE_LESHORT:\np->h = (short)((p->hs[1]<<8)|(p->hs[0]));\ncvt_16(p, m);\nreturn 1;\ncase FILE_LELONG:\ncase FILE_LEDATE:\ncase FILE_LELDATE:\np->l = (int32_t)\n((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\nif (type == FILE_LELONG)\ncvt_32(p, m);\nreturn 1;\ncase FILE_LEQUAD:\ncase FILE_LEQDATE:\ncase FILE_LEQLDATE:\ncase FILE_LEQWDATE:\np->q = (uint64_t)\n(((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\nif (type == FILE_LEQUAD)\ncvt_64(p, m);\nreturn 1;\ncase FILE_MELONG:\ncase FILE_MEDATE:\ncase FILE_MELDATE:\np->l = (int32_t)\n((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\nif (type == FILE_MELONG)\ncvt_32(p, m);\nreturn 1;\ncase FILE_FLOAT:\ncvt_float(p, m);\nreturn 1;\ncase FILE_BEFLOAT:\np->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\ncvt_float(p, m);\nreturn 1;\ncase FILE_LEFLOAT:\np->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\ncvt_float(p, m);\nreturn 1;\ncase FILE_DOUBLE:\ncvt_double(p, m);\nreturn 1;\ncase FILE_BEDOUBLE:\np->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\ncvt_double(p, m);\nreturn 1;\ncase FILE_LEDOUBLE:\np->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\ncvt_double(p, m);\nreturn 1;\ncase FILE_REGEX:\ncase FILE_SEARCH:\ncase FILE_DEFAULT:\ncase FILE_CLEAR:\ncase FILE_NAME:\ncase FILE_USE:\nreturn 1;\ndefault:\nfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\nreturn 0;\n}\n}", "label": 0}
{"index": 176300, "code": "magic_getparam(struct magic_set *ms, int param, void *val)\n{\nswitch (param) {\ncase MAGIC_PARAM_INDIR_MAX:\n*(size_t *)val = ms->indir_max;\nreturn 0;\ncase MAGIC_PARAM_NAME_MAX:\n*(size_t *)val = ms->name_max;\nreturn 0;\ncase MAGIC_PARAM_ELF_PHNUM_MAX:\n*(size_t *)val = ms->elf_phnum_max;\nreturn 0;\ncase MAGIC_PARAM_ELF_SHNUM_MAX:\n*(size_t *)val = ms->elf_shnum_max;\nreturn 0;\ndefault:\nerrno = EINVAL;\nreturn -1;\n}\n}", "contrast": "magic_getparam(struct magic_set *ms, int param, void *val)\n{\nswitch (param) {\ncase MAGIC_PARAM_INDIR_MAX:\n*(size_t *)val = ms->indir_max;\nreturn 0;\ncase MAGIC_PARAM_NAME_MAX:\n*(size_t *)val = ms->name_max;\nreturn 0;\ncase MAGIC_PARAM_ELF_PHNUM_MAX:\n*(size_t *)val = ms->elf_phnum_max;\nreturn 0;\ncase MAGIC_PARAM_ELF_SHNUM_MAX:\n*(size_t *)val = ms->elf_shnum_max;\nreturn 0;\ncase MAGIC_PARAM_ELF_NOTES_MAX:\n*(size_t *)val = ms->elf_notes_max;\nreturn 0;\ndefault:\nerrno = EINVAL;\nreturn -1;\n}\n}", "label": 0}
{"index": 176304, "code": "doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\nsize_t size, off_t fsize, int *flags, int mach, int strtab)\n{\nElf32_Shdr sh32;\nElf64_Shdr sh64;\nint stripped = 1;\nsize_t nbadcap = 0;\nvoid *nbuf;\noff_t noff, coff, name_off;\nuint64_t cap_hw1 = 0;\nuint64_t cap_sf1 = 0;\nchar name[50];\nssize_t namesize;\nif (size != xsh_sizeof) {\nif (file_printf(ms, \", corrupted section header size\") == -1)\nreturn -1;\nreturn 0;\n}\nif (pread(fd, xsh_addr, xsh_sizeof, off + size * strtab) < (ssize_t)xsh_sizeof) {\nfile_badread(ms);\nreturn -1;\n}\nname_off = xsh_offset;\nfor ( ; num; num--) {\nif ((namesize = pread(fd, name, sizeof(name) - 1, name_off + xsh_name)) == -1) {\nfile_badread(ms);\nreturn -1;\n}\nname[namesize] = '\\0';\nif (strcmp(name, \".debug_info\") == 0)\nstripped = 0;\nif (pread(fd, xsh_addr, xsh_sizeof, off) < (ssize_t)xsh_sizeof) {\nfile_badread(ms);\nreturn -1;\n}\noff += size;\nswitch (xsh_type) {\ncase SHT_SYMTAB:\n#if 0\ncase SHT_DYNSYM:\n#endif\nstripped = 0;\nbreak;\ndefault:\nif (fsize != SIZE_UNKNOWN && xsh_offset > fsize) {\ncontinue;\n}\nbreak;\n}\nswitch (xsh_type) {\ncase SHT_NOTE:\nif ((nbuf = malloc(xsh_size)) == NULL) {\nfile_error(ms, errno, \"Cannot allocate memory\"\n\" for note\");\nreturn -1;\n}\nif (pread(fd, nbuf, xsh_size, xsh_offset) < (ssize_t)xsh_size) {\nfile_badread(ms);\nfree(nbuf);\nreturn -1;\n}\nnoff = 0;\nfor (;;) {\nif (noff >= (off_t)xsh_size)\nbreak;\nnoff = donote(ms, nbuf, (size_t)noff,\nxsh_size, clazz, swap, 4, flags);\nif (noff == 0)\nbreak;\n}\nfree(nbuf);\nbreak;\ncase SHT_SUNW_cap:\nswitch (mach) {\ncase EM_SPARC:\ncase EM_SPARCV9:\ncase EM_IA_64:\ncase EM_386:\ncase EM_AMD64:\nbreak;\ndefault:\ngoto skip;\n}\nif (nbadcap > 5)\nbreak;\nif (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {\nfile_badseek(ms);\nreturn -1;\n}\ncoff = 0;\nfor (;;) {\nElf32_Cap cap32;\nElf64_Cap cap64;\nchar cbuf[\nMAX(sizeof cap32, sizeof cap64)];\nif ((coff += xcap_sizeof) > (off_t)xsh_size)\nbreak;\nif (read(fd, cbuf, (size_t)xcap_sizeof) !=\n(ssize_t)xcap_sizeof) {\nfile_badread(ms);\nreturn -1;\n}\nif (cbuf[0] == 'A') {\n#ifdef notyet\nchar *p = cbuf + 1;\nuint32_t len, tag;\nmemcpy(&len, p, sizeof(len));\np += 4;\nlen = getu32(swap, len);\nif (memcmp(\"gnu\", p, 3) != 0) {\nif (file_printf(ms,\n\", unknown capability %.3s\", p)\n== -1)\nreturn -1;\nbreak;\n}\np += strlen(p) + 1;\ntag = *p++;\nmemcpy(&len, p, sizeof(len));\np += 4;\nlen = getu32(swap, len);\nif (tag != 1) {\nif (file_printf(ms, \", unknown gnu\"\n\" capability tag %d\", tag)\n== -1)\nreturn -1;\nbreak;\n}\n#endif\nbreak;\n}\n(void)memcpy(xcap_addr, cbuf, xcap_sizeof);\nswitch (xcap_tag) {\ncase CA_SUNW_NULL:\nbreak;\ncase CA_SUNW_HW_1:\ncap_hw1 |= xcap_val;\nbreak;\ncase CA_SUNW_SF_1:\ncap_sf1 |= xcap_val;\nbreak;\ndefault:\nif (file_printf(ms,\n\", with unknown capability \"\n\"0x%\" INT64_T_FORMAT \"x = 0x%\"\nINT64_T_FORMAT \"x\",\n(unsigned long long)xcap_tag,\n(unsigned long long)xcap_val) == -1)\nreturn -1;\nif (nbadcap++ > 2)\ncoff = xsh_size;\nbreak;\n}\n}\nskip:\ndefault:\nbreak;\n}\n}\nif (file_printf(ms, \", %sstripped\", stripped ? \"\" : \"not \") == -1)\nreturn -1;\nif (cap_hw1) {\nconst cap_desc_t *cdp;\nswitch (mach) {\ncase EM_SPARC:\ncase EM_SPARC32PLUS:\ncase EM_SPARCV9:\ncdp = cap_desc_sparc;\nbreak;\ncase EM_386:\ncase EM_IA_64:\ncase EM_AMD64:\ncdp = cap_desc_386;\nbreak;\ndefault:\ncdp = NULL;\nbreak;\n}\nif (file_printf(ms, \", uses\") == -1)\nreturn -1;\nif (cdp) {\nwhile (cdp->cd_name) {\nif (cap_hw1 & cdp->cd_mask) {\nif (file_printf(ms,\n\" %s\", cdp->cd_name) == -1)\nreturn -1;\ncap_hw1 &= ~cdp->cd_mask;\n}\n++cdp;\n}\nif (cap_hw1)\nif (file_printf(ms,\n\" unknown hardware capability 0x%\"\nINT64_T_FORMAT \"x\",\n(unsigned long long)cap_hw1) == -1)\nreturn -1;\n} else {\nif (file_printf(ms,\n\" hardware capability 0x%\" INT64_T_FORMAT \"x\",\n(unsigned long long)cap_hw1) == -1)\nreturn -1;\n}\n}\nif (cap_sf1) {\nif (cap_sf1 & SF1_SUNW_FPUSED) {\nif (file_printf(ms,\n(cap_sf1 & SF1_SUNW_FPKNWN)\n? \", uses frame pointer\"\n: \", not known to use frame pointer\") == -1)\nreturn -1;\n}\ncap_sf1 &= ~SF1_SUNW_MASK;\nif (cap_sf1)\nif (file_printf(ms,\n\", with unknown software capability 0x%\"\nINT64_T_FORMAT \"x\",\n(unsigned long long)cap_sf1) == -1)\nreturn -1;\n}\nreturn 0;\n}", "contrast": "doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\nsize_t size, off_t fsize, int mach, int strtab, int *flags,\nuint16_t *notecount)\n{\nElf32_Shdr sh32;\nElf64_Shdr sh64;\nint stripped = 1;\nsize_t nbadcap = 0;\nvoid *nbuf;\noff_t noff, coff, name_off;\nuint64_t cap_hw1 = 0;\nuint64_t cap_sf1 = 0;\nchar name[50];\nssize_t namesize;\nif (size != xsh_sizeof) {\nif (file_printf(ms, \", corrupted section header size\") == -1)\nreturn -1;\nreturn 0;\n}\nif (pread(fd, xsh_addr, xsh_sizeof, off + size * strtab) < (ssize_t)xsh_sizeof) {\nfile_badread(ms);\nreturn -1;\n}\nname_off = xsh_offset;\nfor ( ; num; num--) {\nif ((namesize = pread(fd, name, sizeof(name) - 1, name_off + xsh_name)) == -1) {\nfile_badread(ms);\nreturn -1;\n}\nname[namesize] = '\\0';\nif (strcmp(name, \".debug_info\") == 0)\nstripped = 0;\nif (pread(fd, xsh_addr, xsh_sizeof, off) < (ssize_t)xsh_sizeof) {\nfile_badread(ms);\nreturn -1;\n}\noff += size;\nswitch (xsh_type) {\ncase SHT_SYMTAB:\n#if 0\ncase SHT_DYNSYM:\n#endif\nstripped = 0;\nbreak;\ndefault:\nif (fsize != SIZE_UNKNOWN && xsh_offset > fsize) {\ncontinue;\n}\nbreak;\n}\nswitch (xsh_type) {\ncase SHT_NOTE:\nif ((nbuf = malloc(xsh_size)) == NULL) {\nfile_error(ms, errno, \"Cannot allocate memory\"\n\" for note\");\nreturn -1;\n}\nif (pread(fd, nbuf, xsh_size, xsh_offset) < (ssize_t)xsh_size) {\nfile_badread(ms);\nfree(nbuf);\nreturn -1;\n}\nnoff = 0;\nfor (;;) {\nif (noff >= (off_t)xsh_size)\nbreak;\nnoff = donote(ms, nbuf, (size_t)noff,\nxsh_size, clazz, swap, 4, flags, notecount);\nif (noff == 0)\nbreak;\n}\nfree(nbuf);\nbreak;\ncase SHT_SUNW_cap:\nswitch (mach) {\ncase EM_SPARC:\ncase EM_SPARCV9:\ncase EM_IA_64:\ncase EM_386:\ncase EM_AMD64:\nbreak;\ndefault:\ngoto skip;\n}\nif (nbadcap > 5)\nbreak;\nif (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {\nfile_badseek(ms);\nreturn -1;\n}\ncoff = 0;\nfor (;;) {\nElf32_Cap cap32;\nElf64_Cap cap64;\nchar cbuf[\nMAX(sizeof cap32, sizeof cap64)];\nif ((coff += xcap_sizeof) > (off_t)xsh_size)\nbreak;\nif (read(fd, cbuf, (size_t)xcap_sizeof) !=\n(ssize_t)xcap_sizeof) {\nfile_badread(ms);\nreturn -1;\n}\nif (cbuf[0] == 'A') {\n#ifdef notyet\nchar *p = cbuf + 1;\nuint32_t len, tag;\nmemcpy(&len, p, sizeof(len));\np += 4;\nlen = getu32(swap, len);\nif (memcmp(\"gnu\", p, 3) != 0) {\nif (file_printf(ms,\n\", unknown capability %.3s\", p)\n== -1)\nreturn -1;\nbreak;\n}\np += strlen(p) + 1;\ntag = *p++;\nmemcpy(&len, p, sizeof(len));\np += 4;\nlen = getu32(swap, len);\nif (tag != 1) {\nif (file_printf(ms, \", unknown gnu\"\n\" capability tag %d\", tag)\n== -1)\nreturn -1;\nbreak;\n}\n#endif\nbreak;\n}\n(void)memcpy(xcap_addr, cbuf, xcap_sizeof);\nswitch (xcap_tag) {\ncase CA_SUNW_NULL:\nbreak;\ncase CA_SUNW_HW_1:\ncap_hw1 |= xcap_val;\nbreak;\ncase CA_SUNW_SF_1:\ncap_sf1 |= xcap_val;\nbreak;\ndefault:\nif (file_printf(ms,\n\", with unknown capability \"\n\"0x%\" INT64_T_FORMAT \"x = 0x%\"\nINT64_T_FORMAT \"x\",\n(unsigned long long)xcap_tag,\n(unsigned long long)xcap_val) == -1)\nreturn -1;\nif (nbadcap++ > 2)\ncoff = xsh_size;\nbreak;\n}\n}\nskip:\ndefault:\nbreak;\n}\n}\nif (file_printf(ms, \", %sstripped\", stripped ? \"\" : \"not \") == -1)\nreturn -1;\nif (cap_hw1) {\nconst cap_desc_t *cdp;\nswitch (mach) {\ncase EM_SPARC:\ncase EM_SPARC32PLUS:\ncase EM_SPARCV9:\ncdp = cap_desc_sparc;\nbreak;\ncase EM_386:\ncase EM_IA_64:\ncase EM_AMD64:\ncdp = cap_desc_386;\nbreak;\ndefault:\ncdp = NULL;\nbreak;\n}\nif (file_printf(ms, \", uses\") == -1)\nreturn -1;\nif (cdp) {\nwhile (cdp->cd_name) {\nif (cap_hw1 & cdp->cd_mask) {\nif (file_printf(ms,\n\" %s\", cdp->cd_name) == -1)\nreturn -1;\ncap_hw1 &= ~cdp->cd_mask;\n}\n++cdp;\n}\nif (cap_hw1)\nif (file_printf(ms,\n\" unknown hardware capability 0x%\"\nINT64_T_FORMAT \"x\",\n(unsigned long long)cap_hw1) == -1)\nreturn -1;\n} else {\nif (file_printf(ms,\n\" hardware capability 0x%\" INT64_T_FORMAT \"x\",\n(unsigned long long)cap_hw1) == -1)\nreturn -1;\n}\n}\nif (cap_sf1) {\nif (cap_sf1 & SF1_SUNW_FPUSED) {\nif (file_printf(ms,\n(cap_sf1 & SF1_SUNW_FPKNWN)\n? \", uses frame pointer\"\n: \", not known to use frame pointer\") == -1)\nreturn -1;\n}\ncap_sf1 &= ~SF1_SUNW_MASK;\nif (cap_sf1)\nif (file_printf(ms,\n\", with unknown software capability 0x%\"\nINT64_T_FORMAT \"x\",\n(unsigned long long)cap_sf1) == -1)\nreturn -1;\n}\nreturn 0;\n}", "label": 0}
{"index": 176329, "code": "static void destroy_super(struct super_block *s)\n{\nint i;\nlist_lru_destroy(&s->s_dentry_lru);\nlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\nfree_percpu(s->s_files);\n#endif\nfor (i = 0; i < SB_FREEZE_LEVELS; i++)\npercpu_counter_destroy(&s->s_writers.counter[i]);\nsecurity_sb_free(s);\nWARN_ON(!list_empty(&s->s_mounts));\nkfree(s->s_subtype);\nkfree(s->s_options);\nkfree_rcu(s, rcu);\n}", "contrast": "static void destroy_super(struct super_block *s)\n{\nint i;\nlist_lru_destroy(&s->s_dentry_lru);\nlist_lru_destroy(&s->s_inode_lru);\nfor (i = 0; i < SB_FREEZE_LEVELS; i++)\npercpu_counter_destroy(&s->s_writers.counter[i]);\nsecurity_sb_free(s);\nWARN_ON(!list_empty(&s->s_mounts));\nkfree(s->s_subtype);\nkfree(s->s_options);\nkfree_rcu(s, rcu);\n}", "label": 0}
{"index": 176330, "code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\nint retval;\nint remount_ro;\nif (sb->s_writers.frozen != SB_UNFROZEN)\nreturn -EBUSY;\n#ifdef CONFIG_BLOCK\nif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\nreturn -EACCES;\n#endif\nif (flags & MS_RDONLY)\nacct_auto_close(sb);\nshrink_dcache_sb(sb);\nsync_filesystem(sb);\nremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\nif (remount_ro) {\nif (force) {\nmark_files_ro(sb);\n} else {\nretval = sb_prepare_remount_readonly(sb);\nif (retval)\nreturn retval;\n}\n}\nif (sb->s_op->remount_fs) {\nretval = sb->s_op->remount_fs(sb, &flags, data);\nif (retval) {\nif (!force)\ngoto cancel_readonly;\nWARN(1, \"forced remount of a %s fs returned %i\\n\",\nsb->s_type->name, retval);\n}\n}\nsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\nsmp_wmb();\nsb->s_readonly_remount = 0;\nif (remount_ro && sb->s_bdev)\ninvalidate_bdev(sb->s_bdev);\nreturn 0;\ncancel_readonly:\nsb->s_readonly_remount = 0;\nreturn retval;\n}", "contrast": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\nint retval;\nint remount_ro;\nif (sb->s_writers.frozen != SB_UNFROZEN)\nreturn -EBUSY;\n#ifdef CONFIG_BLOCK\nif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\nreturn -EACCES;\n#endif\nif (flags & MS_RDONLY)\nacct_auto_close(sb);\nshrink_dcache_sb(sb);\nsync_filesystem(sb);\nremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\nif (remount_ro) {\nif (force) {\nsb->s_readonly_remount = 1;\nsmp_wmb();\n} else {\nretval = sb_prepare_remount_readonly(sb);\nif (retval)\nreturn retval;\n}\n}\nif (sb->s_op->remount_fs) {\nretval = sb->s_op->remount_fs(sb, &flags, data);\nif (retval) {\nif (!force)\ngoto cancel_readonly;\nWARN(1, \"forced remount of a %s fs returned %i\\n\",\nsb->s_type->name, retval);\n}\n}\nsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\nsmp_wmb();\nsb->s_readonly_remount = 0;\nif (remount_ro && sb->s_bdev)\ninvalidate_bdev(sb->s_bdev);\nreturn 0;\ncancel_readonly:\nsb->s_readonly_remount = 0;\nreturn retval;\n}", "label": 0}
{"index": 176338, "code": "krb5_gss_inquire_context(minor_status, context_handle, initiator_name,\nacceptor_name, lifetime_rec, mech_type, ret_flags,\nlocally_initiated, opened)\nOM_uint32 *minor_status;\ngss_ctx_id_t context_handle;\ngss_name_t *initiator_name;\ngss_name_t *acceptor_name;\nOM_uint32 *lifetime_rec;\ngss_OID *mech_type;\nOM_uint32 *ret_flags;\nint *locally_initiated;\nint *opened;\n{\nkrb5_context context;\nkrb5_error_code code;\nkrb5_gss_ctx_id_rec *ctx;\nkrb5_gss_name_t initiator, acceptor;\nkrb5_timestamp now;\nkrb5_deltat lifetime;\nif (initiator_name)\n*initiator_name = (gss_name_t) NULL;\nif (acceptor_name)\n*acceptor_name = (gss_name_t) NULL;\nctx = (krb5_gss_ctx_id_rec *) context_handle;\nif (! ctx->established) {\n*minor_status = KG_CTX_INCOMPLETE;\nreturn(GSS_S_NO_CONTEXT);\n}\ninitiator = NULL;\nacceptor = NULL;\ncontext = ctx->k5_context;\nif ((code = krb5_timeofday(context, &now))) {\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\nif ((lifetime = ctx->krb_times.endtime - now) < 0)\nlifetime = 0;\nif (initiator_name) {\nif ((code = kg_duplicate_name(context,\nctx->initiate ? ctx->here : ctx->there,\n&initiator))) {\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\n}\nif (acceptor_name) {\nif ((code = kg_duplicate_name(context,\nctx->initiate ? ctx->there : ctx->here,\n&acceptor))) {\nif (initiator)\nkg_release_name(context, &initiator);\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\n}\nif (initiator_name)\n*initiator_name = (gss_name_t) initiator;\nif (acceptor_name)\n*acceptor_name = (gss_name_t) acceptor;\nif (lifetime_rec)\n*lifetime_rec = lifetime;\nif (mech_type)\n*mech_type = (gss_OID) ctx->mech_used;\nif (ret_flags)\n*ret_flags = ctx->gss_flags;\nif (locally_initiated)\n*locally_initiated = ctx->initiate;\nif (opened)\n*opened = ctx->established;\n*minor_status = 0;\nreturn((lifetime == 0)?GSS_S_CONTEXT_EXPIRED:GSS_S_COMPLETE);\n}", "contrast": "krb5_gss_inquire_context(minor_status, context_handle, initiator_name,\nacceptor_name, lifetime_rec, mech_type, ret_flags,\nlocally_initiated, opened)\nOM_uint32 *minor_status;\ngss_ctx_id_t context_handle;\ngss_name_t *initiator_name;\ngss_name_t *acceptor_name;\nOM_uint32 *lifetime_rec;\ngss_OID *mech_type;\nOM_uint32 *ret_flags;\nint *locally_initiated;\nint *opened;\n{\nkrb5_context context;\nkrb5_error_code code;\nkrb5_gss_ctx_id_rec *ctx;\nkrb5_gss_name_t initiator, acceptor;\nkrb5_timestamp now;\nkrb5_deltat lifetime;\nif (initiator_name)\n*initiator_name = (gss_name_t) NULL;\nif (acceptor_name)\n*acceptor_name = (gss_name_t) NULL;\nctx = (krb5_gss_ctx_id_rec *) context_handle;\nif (ctx->terminated || !ctx->established) {\n*minor_status = KG_CTX_INCOMPLETE;\nreturn(GSS_S_NO_CONTEXT);\n}\ninitiator = NULL;\nacceptor = NULL;\ncontext = ctx->k5_context;\nif ((code = krb5_timeofday(context, &now))) {\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\nif ((lifetime = ctx->krb_times.endtime - now) < 0)\nlifetime = 0;\nif (initiator_name) {\nif ((code = kg_duplicate_name(context,\nctx->initiate ? ctx->here : ctx->there,\n&initiator))) {\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\n}\nif (acceptor_name) {\nif ((code = kg_duplicate_name(context,\nctx->initiate ? ctx->there : ctx->here,\n&acceptor))) {\nif (initiator)\nkg_release_name(context, &initiator);\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\n}\nif (initiator_name)\n*initiator_name = (gss_name_t) initiator;\nif (acceptor_name)\n*acceptor_name = (gss_name_t) acceptor;\nif (lifetime_rec)\n*lifetime_rec = lifetime;\nif (mech_type)\n*mech_type = (gss_OID) ctx->mech_used;\nif (ret_flags)\n*ret_flags = ctx->gss_flags;\nif (locally_initiated)\n*locally_initiated = ctx->initiate;\nif (opened)\n*opened = ctx->established;\n*minor_status = 0;\nreturn((lifetime == 0)?GSS_S_CONTEXT_EXPIRED:GSS_S_COMPLETE);\n}", "label": 0}
{"index": 176339, "code": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\ninput_message_buffer, conf_state, output_message_buffer, toktype)\nOM_uint32 *minor_status;\ngss_ctx_id_t context_handle;\nint conf_req_flag;\ngss_qop_t qop_req;\ngss_buffer_t input_message_buffer;\nint *conf_state;\ngss_buffer_t output_message_buffer;\nint toktype;\n{\nkrb5_gss_ctx_id_rec *ctx;\nkrb5_error_code code;\nkrb5_context context;\noutput_message_buffer->length = 0;\noutput_message_buffer->value = NULL;\nif (qop_req != 0) {\n*minor_status = (OM_uint32) G_UNKNOWN_QOP;\nreturn GSS_S_FAILURE;\n}\nctx = (krb5_gss_ctx_id_rec *) context_handle;\nif (! ctx->established) {\n*minor_status = KG_CTX_INCOMPLETE;\nreturn(GSS_S_NO_CONTEXT);\n}\ncontext = ctx->k5_context;\nswitch (ctx->proto)\n{\ncase 0:\ncode = make_seal_token_v1(context, ctx->enc, ctx->seq,\n&ctx->seq_send, ctx->initiate,\ninput_message_buffer, output_message_buffer,\nctx->signalg, ctx->cksum_size, ctx->sealalg,\nconf_req_flag, toktype, ctx->mech_used);\nbreak;\ncase 1:\ncode = gss_krb5int_make_seal_token_v3(context, ctx,\ninput_message_buffer,\noutput_message_buffer,\nconf_req_flag, toktype);\nbreak;\ndefault:\ncode = G_UNKNOWN_QOP;\nbreak;\n}\nif (code) {\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\nif (conf_state)\n*conf_state = conf_req_flag;\n*minor_status = 0;\nreturn(GSS_S_COMPLETE);\n}", "contrast": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\ninput_message_buffer, conf_state, output_message_buffer, toktype)\nOM_uint32 *minor_status;\ngss_ctx_id_t context_handle;\nint conf_req_flag;\ngss_qop_t qop_req;\ngss_buffer_t input_message_buffer;\nint *conf_state;\ngss_buffer_t output_message_buffer;\nint toktype;\n{\nkrb5_gss_ctx_id_rec *ctx;\nkrb5_error_code code;\nkrb5_context context;\noutput_message_buffer->length = 0;\noutput_message_buffer->value = NULL;\nif (qop_req != 0) {\n*minor_status = (OM_uint32) G_UNKNOWN_QOP;\nreturn GSS_S_FAILURE;\n}\nctx = (krb5_gss_ctx_id_rec *) context_handle;\nif (ctx->terminated || !ctx->established) {\n*minor_status = KG_CTX_INCOMPLETE;\nreturn(GSS_S_NO_CONTEXT);\n}\ncontext = ctx->k5_context;\nswitch (ctx->proto)\n{\ncase 0:\ncode = make_seal_token_v1(context, ctx->enc, ctx->seq,\n&ctx->seq_send, ctx->initiate,\ninput_message_buffer, output_message_buffer,\nctx->signalg, ctx->cksum_size, ctx->sealalg,\nconf_req_flag, toktype, ctx->mech_used);\nbreak;\ncase 1:\ncode = gss_krb5int_make_seal_token_v3(context, ctx,\ninput_message_buffer,\noutput_message_buffer,\nconf_req_flag, toktype);\nbreak;\ndefault:\ncode = G_UNKNOWN_QOP;\nbreak;\n}\nif (code) {\n*minor_status = code;\nsave_error_info(*minor_status, context);\nreturn(GSS_S_FAILURE);\n}\nif (conf_state)\n*conf_state = conf_req_flag;\n*minor_status = 0;\nreturn(GSS_S_COMPLETE);\n}", "label": 0}
{"index": 176345, "code": "main(int argc, char *argv[])\n{\nOM_uint32 minor, major;\ngss_ctx_id_t context;\ngss_union_ctx_id_desc uctx;\nkrb5_gss_ctx_id_rec kgctx;\nkrb5_key k1, k2;\nkrb5_keyblock kb1, kb2;\ngss_buffer_desc in, out;\nunsigned char k1buf[32], k2buf[32], outbuf[44];\nsize_t i;\ncontext = (gss_ctx_id_t)&uctx;\nuctx.mech_type = &mech_krb5;\nuctx.internal_ctx_id = (gss_ctx_id_t)&kgctx;\nkgctx.k5_context = NULL;\nkgctx.have_acceptor_subkey = 1;\nkb1.contents = k1buf;\nkb2.contents = k2buf;\nfor (i = 0; i < sizeof(tests) / sizeof(*tests); i++) {\nkb1.enctype = tests[i].enctype;\nkb1.length = fromhex(tests[i].key1, k1buf);\ncheck_k5err(NULL, \"create_key\", krb5_k_create_key(NULL, &kb1, &k1));\nkgctx.subkey = k1;\nkb2.enctype = tests[i].enctype;\nkb2.length = fromhex(tests[i].key2, k2buf);\ncheck_k5err(NULL, \"create_key\", krb5_k_create_key(NULL, &kb2, &k2));\nkgctx.acceptor_subkey = k2;\nin.length = 0;\nin.value = NULL;\nmajor = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_PARTIAL, &in,\n44, &out);\ncheck_gsserr(\"gss_pseudo_random\", major, minor);\n(void)fromhex(tests[i].out1, outbuf);\nassert(out.length == 44 && memcmp(out.value, outbuf, 44) == 0);\n(void)gss_release_buffer(&minor, &out);\nin.length = strlen(inputstr);\nin.value = (char *)inputstr;\nmajor = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_FULL, &in, 44,\n&out);\ncheck_gsserr(\"gss_pseudo_random\", major, minor);\n(void)fromhex(tests[i].out2, outbuf);\nassert(out.length == 44 && memcmp(out.value, outbuf, 44) == 0);\n(void)gss_release_buffer(&minor, &out);\nmajor = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_FULL, &in, 0,\n&out);\ncheck_gsserr(\"gss_pseudo_random\", major, minor);\nassert(out.length == 0);\n(void)gss_release_buffer(&minor, &out);\nkrb5_k_free_key(NULL, k1);\nkrb5_k_free_key(NULL, k2);\n}\nreturn 0;\n}", "contrast": "main(int argc, char *argv[])\n{\nOM_uint32 minor, major;\ngss_ctx_id_t context;\ngss_union_ctx_id_desc uctx;\nkrb5_gss_ctx_id_rec kgctx;\nkrb5_key k1, k2;\nkrb5_keyblock kb1, kb2;\ngss_buffer_desc in, out;\nunsigned char k1buf[32], k2buf[32], outbuf[44];\nsize_t i;\ncontext = (gss_ctx_id_t)&uctx;\nuctx.mech_type = &mech_krb5;\nuctx.internal_ctx_id = (gss_ctx_id_t)&kgctx;\nkgctx.k5_context = NULL;\nkgctx.established = 1;\nkgctx.have_acceptor_subkey = 1;\nkb1.contents = k1buf;\nkb2.contents = k2buf;\nfor (i = 0; i < sizeof(tests) / sizeof(*tests); i++) {\nkb1.enctype = tests[i].enctype;\nkb1.length = fromhex(tests[i].key1, k1buf);\ncheck_k5err(NULL, \"create_key\", krb5_k_create_key(NULL, &kb1, &k1));\nkgctx.subkey = k1;\nkb2.enctype = tests[i].enctype;\nkb2.length = fromhex(tests[i].key2, k2buf);\ncheck_k5err(NULL, \"create_key\", krb5_k_create_key(NULL, &kb2, &k2));\nkgctx.acceptor_subkey = k2;\nin.length = 0;\nin.value = NULL;\nmajor = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_PARTIAL, &in,\n44, &out);\ncheck_gsserr(\"gss_pseudo_random\", major, minor);\n(void)fromhex(tests[i].out1, outbuf);\nassert(out.length == 44 && memcmp(out.value, outbuf, 44) == 0);\n(void)gss_release_buffer(&minor, &out);\nin.length = strlen(inputstr);\nin.value = (char *)inputstr;\nmajor = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_FULL, &in, 44,\n&out);\ncheck_gsserr(\"gss_pseudo_random\", major, minor);\n(void)fromhex(tests[i].out2, outbuf);\nassert(out.length == 44 && memcmp(out.value, outbuf, 44) == 0);\n(void)gss_release_buffer(&minor, &out);\nmajor = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_FULL, &in, 0,\n&out);\ncheck_gsserr(\"gss_pseudo_random\", major, minor);\nassert(out.length == 0);\n(void)gss_release_buffer(&minor, &out);\nkrb5_k_free_key(NULL, k1);\nkrb5_k_free_key(NULL, k2);\n}\nreturn 0;\n}", "label": 0}
{"index": 176365, "code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\nioapic->rtc_status.pending_eoi = 0;\nbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "contrast": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\nioapic->rtc_status.pending_eoi = 0;\nbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}", "label": 0}
{"index": 176372, "code": "int open_debug_log(void) {\nif(verify_config || test_scheduling == TRUE)\nreturn OK;\nif(debug_level == DEBUGL_NONE)\nreturn OK;\nif((debug_file_fp = fopen(debug_file, \"a+\")) == NULL)\nreturn ERROR;\n(void)fcntl(fileno(debug_file_fp), F_SETFD, FD_CLOEXEC);\nreturn OK;\n}", "contrast": "int open_debug_log(void) {\nint open_debug_log(void)\n{\nint fh;\nstruct stat st;\nif(verify_config || test_scheduling == TRUE)\nreturn OK;\nif(debug_level == DEBUGL_NONE)\nreturn OK;\nif ((fh = open(debug_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1)\nreturn ERROR;\nif((debug_file_fp = fdopen(fh, \"a+\")) == NULL)\nreturn ERROR;\nif ((fstat(fh, &st)) == -1) {\ndebug_file_fp = NULL;\nclose(fh);\nreturn ERROR;\n}\nif (st.st_nlink != 1 || (st.st_mode & S_IFMT) != S_IFREG) {\ndebug_file_fp = NULL;\nclose(fh);\nreturn ERROR;\n}\n(void)fcntl(fh, F_SETFD, FD_CLOEXEC);\nreturn OK;\n}", "label": 0}
{"index": 176374, "code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\nconst struct sctp_endpoint *ep,\nconst struct sctp_association *asoc,\nconst sctp_subtype_t type,\nvoid *arg,\nsctp_cmd_seq_t *commands)\n{\nstruct sctp_chunk *chunk = arg;\nstruct sk_buff *skb = chunk->skb;\nsctp_chunkhdr_t *ch;\nsctp_errhdr_t *err;\n__u8 *ch_end;\nint ootb_shut_ack = 0;\nint ootb_cookie_ack = 0;\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\nch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\ndo {\nif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\ncommands);\nif (SCTP_CID_SHUTDOWN_ACK == ch->type)\nootb_shut_ack = 1;\nif (SCTP_CID_ABORT == ch->type)\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nif (SCTP_CID_COOKIE_ACK == ch->type)\nootb_cookie_ack = 1;\nif (SCTP_CID_ERROR == ch->type) {\nsctp_walk_errors(err, ch) {\nif (SCTP_ERROR_STALE_COOKIE == err->cause) {\nootb_cookie_ack = 1;\nbreak;\n}\n}\n}\nch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\nif (ch_end > skb_tail_pointer(skb))\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\ncommands);\nch = (sctp_chunkhdr_t *) ch_end;\n} while (ch_end < skb_tail_pointer(skb));\nif (ootb_shut_ack)\nreturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\nelse if (ootb_cookie_ack)\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nelse\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "contrast": "sctp_disposition_t sctp_sf_ootb(struct net *net,\nconst struct sctp_endpoint *ep,\nconst struct sctp_association *asoc,\nconst sctp_subtype_t type,\nvoid *arg,\nsctp_cmd_seq_t *commands)\n{\nstruct sctp_chunk *chunk = arg;\nstruct sk_buff *skb = chunk->skb;\nsctp_chunkhdr_t *ch;\nsctp_errhdr_t *err;\n__u8 *ch_end;\nint ootb_shut_ack = 0;\nint ootb_cookie_ack = 0;\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\nch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\ndo {\nif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\ncommands);\nch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\nif (ch_end > skb_tail_pointer(skb))\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\ncommands);\nif (SCTP_CID_SHUTDOWN_ACK == ch->type)\nootb_shut_ack = 1;\nif (SCTP_CID_ABORT == ch->type)\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nif (SCTP_CID_COOKIE_ACK == ch->type)\nootb_cookie_ack = 1;\nif (SCTP_CID_ERROR == ch->type) {\nsctp_walk_errors(err, ch) {\nif (SCTP_ERROR_STALE_COOKIE == err->cause) {\nootb_cookie_ack = 1;\nbreak;\n}\n}\n}\nch = (sctp_chunkhdr_t *) ch_end;\n} while (ch_end < skb_tail_pointer(skb));\nif (ootb_shut_ack)\nreturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\nelse if (ootb_cookie_ack)\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\nelse\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "label": 0}
{"index": 176399, "code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\nstruct ctl_table_header *head = grab_header(file_inode(file));\nstruct ctl_table_header *h = NULL;\nstruct ctl_table *entry;\nstruct ctl_dir *ctl_dir;\nunsigned long pos;\nif (IS_ERR(head))\nreturn PTR_ERR(head);\nctl_dir = container_of(head, struct ctl_dir, header);\nif (!dir_emit_dots(file, ctx))\nreturn 0;\npos = 2;\nfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\nif (!scan(h, entry, &pos, file, ctx)) {\nsysctl_head_finish(h);\nbreak;\n}\n}\nsysctl_head_finish(head);\nreturn 0;\n}", "contrast": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\nstruct ctl_table_header *head = grab_header(file_inode(file));\nstruct ctl_table_header *h = NULL;\nstruct ctl_table *entry;\nstruct ctl_dir *ctl_dir;\nunsigned long pos;\nif (IS_ERR(head))\nreturn PTR_ERR(head);\nctl_dir = container_of(head, struct ctl_dir, header);\nif (!dir_emit_dots(file, ctx))\ngoto out;\npos = 2;\nfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\nif (!scan(h, entry, &pos, file, ctx)) {\nsysctl_head_finish(h);\nbreak;\n}\n}\nout:\nsysctl_head_finish(head);\nreturn 0;\n}", "label": 0}
{"index": 176407, "code": "apr_status_t h2_stream_add_header(h2_stream *stream,\nconst char *name, size_t nlen,\nconst char *value, size_t vlen)\n{\nap_assert(stream);\nif (!stream->has_response) {\nif (name[0] == ':') {\nif ((vlen) > stream->session->s->limit_req_line) {\nap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n\"h2_stream(%ld-%d): pseudo header %s too long\",\nstream->session->id, stream->id, name);\nreturn h2_stream_set_error(stream,\nHTTP_REQUEST_URI_TOO_LARGE);\n}\n}\nelse if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\nap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n\"h2_stream(%ld-%d): header %s too long\",\nstream->session->id, stream->id, name);\nreturn h2_stream_set_error(stream,\nHTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n}\nif (name[0] != ':') {\n++stream->request_headers_added;\nif (stream->request_headers_added\n> stream->session->s->limit_req_fields) {\nap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n\"h2_stream(%ld-%d): too many header lines\",\nstream->session->id, stream->id);\nreturn h2_stream_set_error(stream,\nHTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n}\n}\n}\nif (h2_stream_is_scheduled(stream)) {\nreturn add_trailer(stream, name, nlen, value, vlen);\n}\nelse {\nif (!stream->rtmp) {\nstream->rtmp = h2_req_create(stream->id, stream->pool,\nNULL, NULL, NULL, NULL, NULL, 0);\n}\nif (stream->state != H2_STREAM_ST_OPEN) {\nreturn APR_ECONNRESET;\n}\nreturn h2_request_add_header(stream->rtmp, stream->pool,\nname, nlen, value, vlen);\n}\n}", "contrast": "apr_status_t h2_stream_add_header(h2_stream *stream,\nconst char *name, size_t nlen,\nconst char *value, size_t vlen)\n{\nint error = 0;\nap_assert(stream);\nif (stream->has_response) {\nreturn APR_EINVAL;\n}\n++stream->request_headers_added;\nif (name[0] == ':') {\nif ((vlen) > stream->session->s->limit_req_line) {\nap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n\"h2_stream(%ld-%d): pseudo header %s too long\",\nstream->session->id, stream->id, name);\nerror = HTTP_REQUEST_URI_TOO_LARGE;\n}\n}\nelse if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\nap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n\"h2_stream(%ld-%d): header %s too long\",\nstream->session->id, stream->id, name);\nerror = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n}\nif (stream->request_headers_added\n> stream->session->s->limit_req_fields + 4) {\nif (stream->request_headers_added\n> stream->session->s->limit_req_fields + 4 + 100) {\nreturn APR_ECONNRESET;\n}\nap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n\"h2_stream(%ld-%d): too many header lines\",\nstream->session->id, stream->id);\nerror = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n}\nif (h2_stream_is_scheduled(stream)) {\nreturn add_trailer(stream, name, nlen, value, vlen);\n}\nelse if (error) {\nreturn h2_stream_set_error(stream, error);\n}\nelse {\nif (!stream->rtmp) {\nstream->rtmp = h2_req_create(stream->id, stream->pool,\nNULL, NULL, NULL, NULL, NULL, 0);\n}\nif (stream->state != H2_STREAM_ST_OPEN) {\nreturn APR_ECONNRESET;\n}\nreturn h2_request_add_header(stream->rtmp, stream->pool,\nname, nlen, value, vlen);\n}\n}", "label": 0}
{"index": 176415, "code": "int tcp_v4_rcv(struct sk_buff *skb)\n{\nstruct net *net = dev_net(skb->dev);\nconst struct iphdr *iph;\nconst struct tcphdr *th;\nbool refcounted;\nstruct sock *sk;\nint ret;\nif (skb->pkt_type != PACKET_HOST)\ngoto discard_it;\n__TCP_INC_STATS(net, TCP_MIB_INSEGS);\nif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\ngoto discard_it;\nth = (const struct tcphdr *)skb->data;\nif (unlikely(th->doff < sizeof(struct tcphdr) / 4))\ngoto bad_packet;\nif (!pskb_may_pull(skb, th->doff * 4))\ngoto discard_it;\nif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))\ngoto csum_error;\nth = (const struct tcphdr *)skb->data;\niph = ip_hdr(skb);\nmemmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),\nsizeof(struct inet_skb_parm));\nbarrier();\nTCP_SKB_CB(skb)->seq = ntohl(th->seq);\nTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\nskb->len - th->doff * 4);\nTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\nTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\nTCP_SKB_CB(skb)->tcp_tw_isn = 0;\nTCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);\nTCP_SKB_CB(skb)->sacked\t = 0;\nlookup:\nsk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,\nth->dest, &refcounted);\nif (!sk)\ngoto no_tcp_socket;\nprocess:\nif (sk->sk_state == TCP_TIME_WAIT)\ngoto do_time_wait;\nif (sk->sk_state == TCP_NEW_SYN_RECV) {\nstruct request_sock *req = inet_reqsk(sk);\nstruct sock *nsk;\nsk = req->rsk_listener;\nif (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {\nsk_drops_add(sk, skb);\nreqsk_put(req);\ngoto discard_it;\n}\nif (unlikely(sk->sk_state != TCP_LISTEN)) {\ninet_csk_reqsk_queue_drop_and_put(sk, req);\ngoto lookup;\n}\nsock_hold(sk);\nrefcounted = true;\nnsk = tcp_check_req(sk, skb, req, false);\nif (!nsk) {\nreqsk_put(req);\ngoto discard_and_relse;\n}\nif (nsk == sk) {\nreqsk_put(req);\n} else if (tcp_child_process(sk, nsk, skb)) {\ntcp_v4_send_reset(nsk, skb);\ngoto discard_and_relse;\n} else {\nsock_put(sk);\nreturn 0;\n}\n}\nif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\ngoto discard_and_relse;\n}\nif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\ngoto discard_and_relse;\nif (tcp_v4_inbound_md5_hash(sk, skb))\ngoto discard_and_relse;\nnf_reset(skb);\nif (sk_filter(sk, skb))\ngoto discard_and_relse;\nskb->dev = NULL;\nif (sk->sk_state == TCP_LISTEN) {\nret = tcp_v4_do_rcv(sk, skb);\ngoto put_and_return;\n}\nsk_incoming_cpu_update(sk);\nbh_lock_sock_nested(sk);\ntcp_segs_in(tcp_sk(sk), skb);\nret = 0;\nif (!sock_owned_by_user(sk)) {\nif (!tcp_prequeue(sk, skb))\nret = tcp_v4_do_rcv(sk, skb);\n} else if (tcp_add_backlog(sk, skb)) {\ngoto discard_and_relse;\n}\nbh_unlock_sock(sk);\nput_and_return:\nif (refcounted)\nsock_put(sk);\nreturn ret;\nno_tcp_socket:\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\ngoto discard_it;\nif (tcp_checksum_complete(skb)) {\ncsum_error:\n__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n__TCP_INC_STATS(net, TCP_MIB_INERRS);\n} else {\ntcp_v4_send_reset(NULL, skb);\n}\ndiscard_it:\nkfree_skb(skb);\nreturn 0;\ndiscard_and_relse:\nsk_drops_add(sk, skb);\nif (refcounted)\nsock_put(sk);\ngoto discard_it;\ndo_time_wait:\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\ninet_twsk_put(inet_twsk(sk));\ngoto discard_it;\n}\nif (tcp_checksum_complete(skb)) {\ninet_twsk_put(inet_twsk(sk));\ngoto csum_error;\n}\nswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\ncase TCP_TW_SYN: {\nstruct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),\n&tcp_hashinfo, skb,\n__tcp_hdrlen(th),\niph->saddr, th->source,\niph->daddr, th->dest,\ninet_iif(skb));\nif (sk2) {\ninet_twsk_deschedule_put(inet_twsk(sk));\nsk = sk2;\nrefcounted = false;\ngoto process;\n}\n}\ncase TCP_TW_ACK:\ntcp_v4_timewait_ack(sk, skb);\nbreak;\ncase TCP_TW_RST:\ntcp_v4_send_reset(sk, skb);\ninet_twsk_deschedule_put(inet_twsk(sk));\ngoto discard_it;\ncase TCP_TW_SUCCESS:;\n}\ngoto discard_it;\n}", "contrast": "int tcp_v4_rcv(struct sk_buff *skb)\n{\nstruct net *net = dev_net(skb->dev);\nconst struct iphdr *iph;\nconst struct tcphdr *th;\nbool refcounted;\nstruct sock *sk;\nint ret;\nif (skb->pkt_type != PACKET_HOST)\ngoto discard_it;\n__TCP_INC_STATS(net, TCP_MIB_INSEGS);\nif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\ngoto discard_it;\nth = (const struct tcphdr *)skb->data;\nif (unlikely(th->doff < sizeof(struct tcphdr) / 4))\ngoto bad_packet;\nif (!pskb_may_pull(skb, th->doff * 4))\ngoto discard_it;\nif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))\ngoto csum_error;\nth = (const struct tcphdr *)skb->data;\niph = ip_hdr(skb);\nmemmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),\nsizeof(struct inet_skb_parm));\nbarrier();\nTCP_SKB_CB(skb)->seq = ntohl(th->seq);\nTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\nskb->len - th->doff * 4);\nTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\nTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\nTCP_SKB_CB(skb)->tcp_tw_isn = 0;\nTCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);\nTCP_SKB_CB(skb)->sacked\t = 0;\nlookup:\nsk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,\nth->dest, &refcounted);\nif (!sk)\ngoto no_tcp_socket;\nprocess:\nif (sk->sk_state == TCP_TIME_WAIT)\ngoto do_time_wait;\nif (sk->sk_state == TCP_NEW_SYN_RECV) {\nstruct request_sock *req = inet_reqsk(sk);\nstruct sock *nsk;\nsk = req->rsk_listener;\nif (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {\nsk_drops_add(sk, skb);\nreqsk_put(req);\ngoto discard_it;\n}\nif (unlikely(sk->sk_state != TCP_LISTEN)) {\ninet_csk_reqsk_queue_drop_and_put(sk, req);\ngoto lookup;\n}\nsock_hold(sk);\nrefcounted = true;\nnsk = tcp_check_req(sk, skb, req, false);\nif (!nsk) {\nreqsk_put(req);\ngoto discard_and_relse;\n}\nif (nsk == sk) {\nreqsk_put(req);\n} else if (tcp_child_process(sk, nsk, skb)) {\ntcp_v4_send_reset(nsk, skb);\ngoto discard_and_relse;\n} else {\nsock_put(sk);\nreturn 0;\n}\n}\nif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\ngoto discard_and_relse;\n}\nif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\ngoto discard_and_relse;\nif (tcp_v4_inbound_md5_hash(sk, skb))\ngoto discard_and_relse;\nnf_reset(skb);\nif (tcp_filter(sk, skb))\ngoto discard_and_relse;\nth = (const struct tcphdr *)skb->data;\niph = ip_hdr(skb);\nskb->dev = NULL;\nif (sk->sk_state == TCP_LISTEN) {\nret = tcp_v4_do_rcv(sk, skb);\ngoto put_and_return;\n}\nsk_incoming_cpu_update(sk);\nbh_lock_sock_nested(sk);\ntcp_segs_in(tcp_sk(sk), skb);\nret = 0;\nif (!sock_owned_by_user(sk)) {\nif (!tcp_prequeue(sk, skb))\nret = tcp_v4_do_rcv(sk, skb);\n} else if (tcp_add_backlog(sk, skb)) {\ngoto discard_and_relse;\n}\nbh_unlock_sock(sk);\nput_and_return:\nif (refcounted)\nsock_put(sk);\nreturn ret;\nno_tcp_socket:\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\ngoto discard_it;\nif (tcp_checksum_complete(skb)) {\ncsum_error:\n__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n__TCP_INC_STATS(net, TCP_MIB_INERRS);\n} else {\ntcp_v4_send_reset(NULL, skb);\n}\ndiscard_it:\nkfree_skb(skb);\nreturn 0;\ndiscard_and_relse:\nsk_drops_add(sk, skb);\nif (refcounted)\nsock_put(sk);\ngoto discard_it;\ndo_time_wait:\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\ninet_twsk_put(inet_twsk(sk));\ngoto discard_it;\n}\nif (tcp_checksum_complete(skb)) {\ninet_twsk_put(inet_twsk(sk));\ngoto csum_error;\n}\nswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\ncase TCP_TW_SYN: {\nstruct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),\n&tcp_hashinfo, skb,\n__tcp_hdrlen(th),\niph->saddr, th->source,\niph->daddr, th->dest,\ninet_iif(skb));\nif (sk2) {\ninet_twsk_deschedule_put(inet_twsk(sk));\nsk = sk2;\nrefcounted = false;\ngoto process;\n}\n}\ncase TCP_TW_ACK:\ntcp_v4_timewait_ack(sk, skb);\nbreak;\ncase TCP_TW_RST:\ntcp_v4_send_reset(sk, skb);\ninet_twsk_deschedule_put(inet_twsk(sk));\ngoto discard_it;\ncase TCP_TW_SUCCESS:;\n}\ngoto discard_it;\n}", "label": 0}
{"index": 176419, "code": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\nu32 cycle, size_t header_length, void *header, void *data)\n{\nstruct fwnet_device *dev;\nstruct fw_iso_packet packet;\n__be16 *hdr_ptr;\n__be32 *buf_ptr;\nint retval;\nu32 length;\nu16 source_node_id;\nu32 specifier_id;\nu32 ver;\nunsigned long offset;\nunsigned long flags;\ndev = data;\nhdr_ptr = header;\nlength = be16_to_cpup(hdr_ptr);\nspin_lock_irqsave(&dev->lock, flags);\noffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\nbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\nif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\ndev->broadcast_rcv_next_ptr = 0;\nspin_unlock_irqrestore(&dev->lock, flags);\nspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\nver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\nsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\nif (specifier_id == IANA_SPECIFIER_ID &&\n(ver == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n|| ver == RFC3146_SW_VERSION\n#endif\n)) {\nbuf_ptr += 2;\nlength -= IEEE1394_GASP_HDR_SIZE;\nfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\ncontext->card->generation, true);\n}\npacket.payload_length = dev->rcv_buffer_size;\npacket.interrupt = 1;\npacket.skip = 0;\npacket.tag = 3;\npacket.sy = 0;\npacket.header_length = IEEE1394_GASP_HDR_SIZE;\nspin_lock_irqsave(&dev->lock, flags);\nretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n&dev->broadcast_rcv_buffer, offset);\nspin_unlock_irqrestore(&dev->lock, flags);\nif (retval >= 0)\nfw_iso_context_queue_flush(dev->broadcast_rcv_context);\nelse\ndev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}", "contrast": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\nu32 cycle, size_t header_length, void *header, void *data)\n{\nstruct fwnet_device *dev;\nstruct fw_iso_packet packet;\n__be16 *hdr_ptr;\n__be32 *buf_ptr;\nint retval;\nu32 length;\nunsigned long offset;\nunsigned long flags;\ndev = data;\nhdr_ptr = header;\nlength = be16_to_cpup(hdr_ptr);\nspin_lock_irqsave(&dev->lock, flags);\noffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\nbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\nif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\ndev->broadcast_rcv_next_ptr = 0;\nspin_unlock_irqrestore(&dev->lock, flags);\nif (length > IEEE1394_GASP_HDR_SIZE &&\ngasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n(gasp_version(buf_ptr) == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n|| gasp_version(buf_ptr) == RFC3146_SW_VERSION\n#endif\n))\nfwnet_incoming_packet(dev, buf_ptr + 2,\nlength - IEEE1394_GASP_HDR_SIZE,\ngasp_source_id(buf_ptr),\ncontext->card->generation, true);\npacket.payload_length = dev->rcv_buffer_size;\npacket.interrupt = 1;\npacket.skip = 0;\npacket.tag = 3;\npacket.sy = 0;\npacket.header_length = IEEE1394_GASP_HDR_SIZE;\nspin_lock_irqsave(&dev->lock, flags);\nretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n&dev->broadcast_rcv_buffer, offset);\nspin_unlock_irqrestore(&dev->lock, flags);\nif (retval >= 0)\nfw_iso_context_queue_flush(dev->broadcast_rcv_context);\nelse\ndev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}", "label": 0}
{"index": 176440, "code": "m_authenticate(struct Client *client_p, struct Client *source_p,\nint parc, const char *parv[])\n{\nstruct Client *agent_p = NULL;\nstruct Client *saslserv_p = NULL;\nif(!IsCapable(source_p, CLICAP_SASL))\nreturn 0;\nif (strlen(client_p->id) == 3)\n{\nexit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\nreturn 0;\n}\nsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\nif (saslserv_p == NULL || !IsService(saslserv_p))\n{\nsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\nreturn 0;\n}\nif(source_p->localClient->sasl_complete)\n{\n*source_p->localClient->sasl_agent = '\\0';\nsource_p->localClient->sasl_complete = 0;\n}\nif(strlen(parv[1]) > 400)\n{\nsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\nreturn 0;\n}\nif(!*source_p->id)\n{\nstrcpy(source_p->id, generate_uid());\nadd_to_id_hash(source_p->id, source_p);\n}\nif(*source_p->localClient->sasl_agent)\nagent_p = find_id(source_p->localClient->sasl_agent);\nif(agent_p == NULL)\n{\nsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",\nme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\nsource_p->host, source_p->sockhost);\nif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)\nsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",\nme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\nparv[1], source_p->certfp);\nelse\nsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",\nme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\nparv[1]);\nrb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);\n}\nelse\nsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",\nme.id, agent_p->servptr->name, source_p->id, agent_p->id,\nparv[1]);\nsource_p->localClient->sasl_out++;\nreturn 0;\n}", "contrast": "m_authenticate(struct Client *client_p, struct Client *source_p,\nint parc, const char *parv[])\n{\nstruct Client *agent_p = NULL;\nstruct Client *saslserv_p = NULL;\nif(!IsCapable(source_p, CLICAP_SASL))\nreturn 0;\nif (strlen(client_p->id) == 3)\n{\nexit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\nreturn 0;\n}\nif (*parv[1] == ':' || strchr(parv[1], ' '))\n{\nexit_client(client_p, client_p, client_p, \"Malformed AUTHENTICATE\");\nreturn 0;\n}\nsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\nif (saslserv_p == NULL || !IsService(saslserv_p))\n{\nsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\nreturn 0;\n}\nif(source_p->localClient->sasl_complete)\n{\n*source_p->localClient->sasl_agent = '\\0';\nsource_p->localClient->sasl_complete = 0;\n}\nif(strlen(parv[1]) > 400)\n{\nsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\nreturn 0;\n}\nif(!*source_p->id)\n{\nstrcpy(source_p->id, generate_uid());\nadd_to_id_hash(source_p->id, source_p);\n}\nif(*source_p->localClient->sasl_agent)\nagent_p = find_id(source_p->localClient->sasl_agent);\nif(agent_p == NULL)\n{\nsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",\nme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\nsource_p->host, source_p->sockhost);\nif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)\nsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",\nme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\nparv[1], source_p->certfp);\nelse\nsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",\nme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\nparv[1]);\nrb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);\n}\nelse\nsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",\nme.id, agent_p->servptr->name, source_p->id, agent_p->id,\nparv[1]);\nsource_p->localClient->sasl_out++;\nreturn 0;\n}", "label": 0}
{"index": 176450, "code": "static void send_auth(char *username, char *password) {\nstruct mt_packet data;\nunsigned short width = 0;\nunsigned short height = 0;\nchar *terminal = getenv(\"TERM\");\nchar md5data[100];\nunsigned char md5sum[17];\nint plen;\nmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\nmlock(md5data, sizeof(md5data));\nmlock(md5sum, sizeof(md5data));\n#endif\nmd5data[0] = 0;\nstrncpy(md5data + 1, password, 82);\nmd5data[83] = '\\0';\nmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\nmd5_init(&state);\nmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\nmd5_finish(&state, (md5_byte_t *)md5sum + 1);\nmd5sum[0] = 0;\ninit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\nplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\nplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\nplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\nif (is_a_tty && get_terminal_size(&width, &height) != -1) {\nwidth = htole16(width);\nheight = htole16(height);\nplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\nplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n}\noutcounter += plen;\nsend_udp(&data, 1);\n}", "contrast": "static void send_auth(char *username, char *password) {\nstruct mt_packet data;\nunsigned short width = 0;\nunsigned short height = 0;\nchar *terminal = getenv(\"TERM\");\nchar md5data[100];\nunsigned char md5sum[17];\nint plen, act_pass_len;\nmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\nmlock(md5data, sizeof(md5data));\nmlock(md5sum, sizeof(md5data));\n#endif\nact_pass_len = strnlen(password, 82);\nmd5data[0] = 0;\nmemcpy(md5data + 1, password, act_pass_len);\nmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\nmd5_init(&state);\nmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\nmd5_finish(&state, (md5_byte_t *)md5sum + 1);\nmd5sum[0] = 0;\ninit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\nplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\nplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\nplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\nif (is_a_tty && get_terminal_size(&width, &height) != -1) {\nwidth = htole16(width);\nheight = htole16(height);\nplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\nplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n}\noutcounter += plen;\nsend_udp(&data, 1);\n}", "label": 0}
{"index": 176454, "code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\nstruct inode *inode, struct posix_acl *acl, int type)\n{\nint ret, size = 0;\nconst char *name;\nchar *value = NULL;\nswitch (type) {\ncase ACL_TYPE_ACCESS:\nname = XATTR_NAME_POSIX_ACL_ACCESS;\nif (acl) {\nret = posix_acl_equiv_mode(acl, &inode->i_mode);\nif (ret < 0)\nreturn ret;\nif (ret == 0)\nacl = NULL;\n}\nret = 0;\nbreak;\ncase ACL_TYPE_DEFAULT:\nif (!S_ISDIR(inode->i_mode))\nreturn acl ? -EINVAL : 0;\nname = XATTR_NAME_POSIX_ACL_DEFAULT;\nbreak;\ndefault:\nreturn -EINVAL;\n}\nif (acl) {\nsize = posix_acl_xattr_size(acl->a_count);\nvalue = kmalloc(size, GFP_KERNEL);\nif (!value) {\nret = -ENOMEM;\ngoto out;\n}\nret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\nif (ret < 0)\ngoto out;\n}\nret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\nkfree(value);\nif (!ret)\nset_cached_acl(inode, type, acl);\nreturn ret;\n}", "contrast": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\nstruct inode *inode, struct posix_acl *acl, int type)\n{\nint ret, size = 0;\nconst char *name;\nchar *value = NULL;\nswitch (type) {\ncase ACL_TYPE_ACCESS:\nname = XATTR_NAME_POSIX_ACL_ACCESS;\nif (acl) {\nret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\nif (ret)\nreturn ret;\n}\nret = 0;\nbreak;\ncase ACL_TYPE_DEFAULT:\nif (!S_ISDIR(inode->i_mode))\nreturn acl ? -EINVAL : 0;\nname = XATTR_NAME_POSIX_ACL_DEFAULT;\nbreak;\ndefault:\nreturn -EINVAL;\n}\nif (acl) {\nsize = posix_acl_xattr_size(acl->a_count);\nvalue = kmalloc(size, GFP_KERNEL);\nif (!value) {\nret = -ENOMEM;\ngoto out;\n}\nret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\nif (ret < 0)\ngoto out;\n}\nret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\nkfree(value);\nif (!ret)\nset_cached_acl(inode, type, acl);\nreturn ret;\n}", "label": 0}
{"index": 176466, "code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\nint error = 0;\nif (!acl)\ngoto set_acl;\nerror = -E2BIG;\nif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\nreturn error;\nif (type == ACL_TYPE_ACCESS) {\numode_t mode = inode->i_mode;\nerror = posix_acl_equiv_mode(acl, &mode);\nif (error <= 0) {\nacl = NULL;\nif (error < 0)\nreturn error;\n}\nerror = xfs_set_mode(inode, mode);\nif (error)\nreturn error;\n}\nset_acl:\nreturn __xfs_set_acl(inode, type, acl);\n}", "contrast": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\nint error = 0;\nif (!acl)\ngoto set_acl;\nerror = -E2BIG;\nif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\nreturn error;\nif (type == ACL_TYPE_ACCESS) {\numode_t mode;\nerror = posix_acl_update_mode(inode, &mode, &acl);\nif (error)\nreturn error;\nerror = xfs_set_mode(inode, mode);\nif (error)\nreturn error;\n}\nset_acl:\nreturn __xfs_set_acl(inode, type, acl);\n}", "label": 0}
{"index": 176472, "code": "auth_password(Authctxt *authctxt, const char *password)\n{\nstruct passwd * pw = authctxt->pw;\nint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\nstatic int expire_checked = 0;\n#endif\n#ifndef HAVE_CYGWIN\nif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\nok = 0;\n#endif\nif (*password == '\\0' && options.permit_empty_passwd == 0)\nreturn 0;\n#ifdef KRB5\nif (options.kerberos_authentication == 1) {\nint ret = auth_krb5_password(authctxt, password);\nif (ret == 1 || ret == 0)\nreturn ret && ok;\n}\n#endif\n#ifdef HAVE_CYGWIN\n{\nHANDLE hToken = cygwin_logon_user(pw, password);\nif (hToken == INVALID_HANDLE_VALUE)\nreturn 0;\ncygwin_set_impersonation_token(hToken);\nreturn ok;\n}\n#endif\n#ifdef USE_PAM\nif (options.use_pam)\nreturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\nif (!expire_checked) {\nexpire_checked = 1;\nif (auth_shadow_pwexpired(authctxt))\nauthctxt->force_pwchange = 1;\n}\n#endif\nresult = sys_auth_passwd(authctxt, password);\nif (authctxt->force_pwchange)\ndisable_forwarding();\nreturn (result && ok);\n}", "contrast": "auth_password(Authctxt *authctxt, const char *password)\n{\nstruct passwd * pw = authctxt->pw;\nint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\nstatic int expire_checked = 0;\n#endif\nif (strlen(password) > MAX_PASSWORD_LEN)\nreturn 0;\n#ifndef HAVE_CYGWIN\nif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\nok = 0;\n#endif\nif (*password == '\\0' && options.permit_empty_passwd == 0)\nreturn 0;\n#ifdef KRB5\nif (options.kerberos_authentication == 1) {\nint ret = auth_krb5_password(authctxt, password);\nif (ret == 1 || ret == 0)\nreturn ret && ok;\n}\n#endif\n#ifdef HAVE_CYGWIN\n{\nHANDLE hToken = cygwin_logon_user(pw, password);\nif (hToken == INVALID_HANDLE_VALUE)\nreturn 0;\ncygwin_set_impersonation_token(hToken);\nreturn ok;\n}\n#endif\n#ifdef USE_PAM\nif (options.use_pam)\nreturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\nif (!expire_checked) {\nexpire_checked = 1;\nif (auth_shadow_pwexpired(authctxt))\nauthctxt->force_pwchange = 1;\n}\n#endif\nresult = sys_auth_passwd(authctxt, password);\nif (authctxt->force_pwchange)\ndisable_forwarding();\nreturn (result && ok);\n}", "label": 0}
{"index": 176475, "code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\nstruct srpt_device *sdev;\nstruct srpt_rdma_ch *ch;\nstruct srpt_send_ioctx *target;\nint ret, i;\nret = -EINVAL;\nch = ioctx->ch;\nBUG_ON(!ch);\nBUG_ON(!ch->sport);\nsdev = ch->sport->sdev;\nBUG_ON(!sdev);\nspin_lock_irq(&sdev->spinlock);\nfor (i = 0; i < ch->rq_size; ++i) {\ntarget = ch->ioctx_ring[i];\nif (target->cmd.se_lun == ioctx->cmd.se_lun &&\ntarget->cmd.tag == tag &&\nsrpt_get_cmd_state(target) != SRPT_STATE_DONE) {\nret = 0;\nbreak;\n}\n}\nspin_unlock_irq(&sdev->spinlock);\nreturn ret;\n}", "contrast": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)", "label": 0}
{"index": 176504, "code": "gdImagePtr gdImageCreate (int sx, int sy)\n{\nint i;\ngdImagePtr im;\nif (overflow2(sx, sy)) {\nreturn NULL;\n}\nif (overflow2(sizeof(unsigned char *), sy)) {\nreturn NULL;\n}\nim = (gdImage *) gdCalloc(1, sizeof(gdImage));\nim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\nim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\nim->polyInts = 0;\nim->polyAllocated = 0;\nim->brush = 0;\nim->tile = 0;\nim->style = 0;\nfor (i = 0; i < sy; i++) {\nim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\nim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n}\nim->sx = sx;\nim->sy = sy;\nim->colorsTotal = 0;\nim->transparent = (-1);\nim->interlace = 0;\nim->thick = 1;\nim->AA = 0;\nim->AA_polygon = 0;\nfor (i = 0; i < gdMaxColors; i++) {\nim->open[i] = 1;\nim->red[i] = 0;\nim->green[i] = 0;\nim->blue[i] = 0;\n}\nim->trueColor = 0;\nim->tpixels = 0;\nim->cx1 = 0;\nim->cy1 = 0;\nim->cx2 = im->sx - 1;\nim->cy2 = im->sy - 1;\nim->interpolation = NULL;\nim->interpolation_id = GD_BILINEAR_FIXED;\nreturn im;\n}", "contrast": "gdImagePtr gdImageCreate (int sx, int sy)\n{\nint i;\ngdImagePtr im;\nif (overflow2(sx, sy)) {\nreturn NULL;\n}\nif (overflow2(sizeof(unsigned char *), sy)) {\nreturn NULL;\n}\nif (overflow2(sizeof(unsigned char *), sx)) {\nreturn NULL;\n}\nim = (gdImage *) gdCalloc(1, sizeof(gdImage));\nim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\nim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\nim->polyInts = 0;\nim->polyAllocated = 0;\nim->brush = 0;\nim->tile = 0;\nim->style = 0;\nfor (i = 0; i < sy; i++) {\nim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\nim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n}\nim->sx = sx;\nim->sy = sy;\nim->colorsTotal = 0;\nim->transparent = (-1);\nim->interlace = 0;\nim->thick = 1;\nim->AA = 0;\nim->AA_polygon = 0;\nfor (i = 0; i < gdMaxColors; i++) {\nim->open[i] = 1;\nim->red[i] = 0;\nim->green[i] = 0;\nim->blue[i] = 0;\n}\nim->trueColor = 0;\nim->tpixels = 0;\nim->cx1 = 0;\nim->cy1 = 0;\nim->cx2 = im->sx - 1;\nim->cy2 = im->sy - 1;\nim->interpolation = NULL;\nim->interpolation_id = GD_BILINEAR_FIXED;\nreturn im;\n}", "label": 0}
{"index": 176507, "code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\nstatic u32 challenge_timestamp;\nstatic unsigned int challenge_count;\nstruct tcp_sock *tp = tcp_sk(sk);\nu32 now;\nif (tcp_oow_rate_limited(sock_net(sk), skb,\nLINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n&tp->last_oow_ack_time))\nreturn;\nnow = jiffies / HZ;\nif (now != challenge_timestamp) {\nchallenge_timestamp = now;\nchallenge_count = 0;\n}\nif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\nNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\ntcp_send_ack(sk);\n}\n}", "contrast": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\nstatic u32 challenge_timestamp;\nstatic unsigned int challenge_count;\nstruct tcp_sock *tp = tcp_sk(sk);\nu32 count, now;\nif (tcp_oow_rate_limited(sock_net(sk), skb,\nLINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n&tp->last_oow_ack_time))\nreturn;\nnow = jiffies / HZ;\nif (now != challenge_timestamp) {\nu32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;\nchallenge_timestamp = now;\nWRITE_ONCE(challenge_count, half +\nprandom_u32_max(sysctl_tcp_challenge_ack_limit));\n}\ncount = READ_ONCE(challenge_count);\nif (count > 0) {\nWRITE_ONCE(challenge_count, count - 1);\nNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\ntcp_send_ack(sk);\n}\n}", "label": 0}
{"index": 176513, "code": "parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\nguint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\nconst wbxml_decoding *map)\n{\nguint32     tvb_len = tvb_reported_length (tvb);\nguint32     off     = offset;\nguint32     len;\nguint       str_len;\nguint32     ent;\nguint32     idx;\nguint8      peek;\nguint8      attr_save_known   = 0;\nconst char *attr_save_literal = NULL;\nDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\",\nlevel, offset));\nwhile (off < tvb_len) {\npeek = tvb_get_guint8 (tvb, off);\nDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\nif ((peek & 0x3F) < 5) switch (peek) {\ncase 0x00:\n*codepage_attr = tvb_get_guint8 (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 2,\n\"      |  Attr | A -->%3d \"\n\"| SWITCH_PAGE (Attr code page)    |\",\n*codepage_attr);\noff += 2;\nbreak;\ncase 0x01:\noff++;\nDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\nlevel, off - offset));\nreturn (off - offset);\ncase 0x02:\nent = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| ENTITY                          \"\n\"|     %s'&#%u;'\",\nlevel, *codepage_attr, Indent (level), ent);\noff += 1+len;\nbreak;\ncase 0x03:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| STR_I (Inline string)           \"\n\"|     %s\\'%s\\'\",\nlevel, *codepage_attr, Indent (level),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x04:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\nattr_save_known = 0;\nattr_save_literal = tvb_format_text (tvb,\nstr_tbl+idx, str_len-1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| LITERAL (Literal Attribute)     \"\n\"|   %s<%s />\",\nlevel, *codepage_attr, Indent (level),\nattr_save_literal);\noff += 1+len;\nbreak;\ncase 0x40:\ncase 0x41:\ncase 0x42:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| EXT_I_%1x    (Extension Token)    \"\n\"|     %s(%s: \\'%s\\')\",\nlevel, *codepage_attr, peek & 0x0f, Indent (level),\nmap_token (map->global, 0, peek),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x80:\ncase 0x81:\ncase 0x82:\nidx = tvb_get_guintvar (tvb, off+1, &len);\n{   char *s;\nif (map->ext_t[peek & 0x03])\ns = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\nelse\ns = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\nmap_token (map->global, 0, peek));\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_T_%1x    (Extension Token)    \"\n\"| %s%s)\",\nlevel, *codepage_attr, peek & 0x0f, Indent (level),\ns);\n}\noff += 1+len;\nbreak;\ncase 0x83:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| STR_T (Tableref string)         \"\n\"|     %s\\'%s\\'\",\nlevel, *codepage_attr, Indent (level),\ntvb_format_text (tvb, str_tbl+idx, str_len-1));\noff += 1+len;\nbreak;\ncase 0xC0:\ncase 0xC1:\ncase 0xC2:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"| EXT_%1x      (Extension Token)    \"\n\"|     %s(%s)\",\nlevel, *codepage_attr, peek & 0x0f, Indent (level),\nmap_token (map->global, 0, peek));\noff++;\nbreak;\ncase 0xC3:\nif (tvb_get_guint8 (tvb, 0)) {\nchar *str;\nif (attr_save_known) {\nif (map->opaque_binary_attr) {\nstr = map->opaque_binary_attr(tvb, off + 1,\nattr_save_known, *codepage_attr, &len);\n} else {\nstr = default_opaque_binary_attr(tvb, off + 1,\nattr_save_known, *codepage_attr, &len);\n}\n} else {\nif (map->opaque_literal_tag) {\nstr = map->opaque_literal_attr(tvb, off + 1,\nattr_save_literal, *codepage_attr, &len);\n} else {\nstr = default_opaque_literal_attr(tvb, off + 1,\nattr_save_literal, *codepage_attr, &len);\n}\n}\nproto_tree_add_text (tree, tvb, off, 1 + len,\n\"  %3d |  Attr | A %3d    \"\n\"| OPAQUE (Opaque data)            \"\n\"|       %s%s\",\nlevel, *codepage_attr, Indent (level), str);\noff += 1 + len;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"| RESERVED_2     (Invalid Token!) \"\n\"| WBXML 1.0 parsing stops here.\",\nlevel, *codepage_attr);\noff = tvb_len;\nDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\nlevel, off - offset));\nreturn (off - offset);\n}\nbreak;\ndefault:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"| %-10s     (Invalid Token!) \"\n\"| WBXML parsing stops here.\",\nlevel, *codepage_attr,\nval_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\noff = tvb_len;\nbreak;\n} else {\nif (peek & 0x80) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"|   Known attrValue 0x%02X          \"\n\"|       %s%s\",\nlevel, *codepage_attr, peek & 0x7f, Indent (level),\nmap_token (map->attrValue, *codepage_attr, peek));\noff++;\n} else {\nattr_save_known = peek & 0x7f;\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"|   Known attrStart 0x%02X          \"\n\"|   %s%s\",\nlevel, *codepage_attr, attr_save_known, Indent (level),\nmap_token (map->attrStart, *codepage_attr, peek));\noff++;\n}\n}\n}\nDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\nlevel, off - offset));\nreturn (off - offset);\n}", "contrast": "parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\nguint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\nconst wbxml_decoding *map)\n{\nguint32     tvb_len = tvb_reported_length (tvb);\nguint32     off     = offset, last_off;\nguint32     len;\nguint       str_len;\nguint32     ent;\nguint32     idx;\nguint8      peek;\nguint8      attr_save_known   = 0;\nconst char *attr_save_literal = NULL;\nDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\",\nlevel, offset));\nlast_off = off;\nwhile (off < tvb_len) {\npeek = tvb_get_guint8 (tvb, off);\nDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\nif ((peek & 0x3F) < 5) switch (peek) {\ncase 0x00:\n*codepage_attr = tvb_get_guint8 (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 2,\n\"      |  Attr | A -->%3d \"\n\"| SWITCH_PAGE (Attr code page)    |\",\n*codepage_attr);\noff += 2;\nbreak;\ncase 0x01:\noff++;\nDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\nlevel, off - offset));\nreturn (off - offset);\ncase 0x02:\nent = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| ENTITY                          \"\n\"|     %s'&#%u;'\",\nlevel, *codepage_attr, Indent (level), ent);\noff += 1+len;\nbreak;\ncase 0x03:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| STR_I (Inline string)           \"\n\"|     %s\\'%s\\'\",\nlevel, *codepage_attr, Indent (level),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x04:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\nattr_save_known = 0;\nattr_save_literal = tvb_format_text (tvb,\nstr_tbl+idx, str_len-1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| LITERAL (Literal Attribute)     \"\n\"|   %s<%s />\",\nlevel, *codepage_attr, Indent (level),\nattr_save_literal);\noff += 1+len;\nbreak;\ncase 0x40:\ncase 0x41:\ncase 0x42:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| EXT_I_%1x    (Extension Token)    \"\n\"|     %s(%s: \\'%s\\')\",\nlevel, *codepage_attr, peek & 0x0f, Indent (level),\nmap_token (map->global, 0, peek),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x80:\ncase 0x81:\ncase 0x82:\nidx = tvb_get_guintvar (tvb, off+1, &len);\n{   char *s;\nif (map->ext_t[peek & 0x03])\ns = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\nelse\ns = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\nmap_token (map->global, 0, peek));\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_T_%1x    (Extension Token)    \"\n\"| %s%s)\",\nlevel, *codepage_attr, peek & 0x0f, Indent (level),\ns);\n}\noff += 1+len;\nbreak;\ncase 0x83:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d |  Attr | A %3d    \"\n\"| STR_T (Tableref string)         \"\n\"|     %s\\'%s\\'\",\nlevel, *codepage_attr, Indent (level),\ntvb_format_text (tvb, str_tbl+idx, str_len-1));\noff += 1+len;\nbreak;\ncase 0xC0:\ncase 0xC1:\ncase 0xC2:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"| EXT_%1x      (Extension Token)    \"\n\"|     %s(%s)\",\nlevel, *codepage_attr, peek & 0x0f, Indent (level),\nmap_token (map->global, 0, peek));\noff++;\nbreak;\ncase 0xC3:\nif (tvb_get_guint8 (tvb, 0)) {\nchar *str;\nif (attr_save_known) {\nif (map->opaque_binary_attr) {\nstr = map->opaque_binary_attr(tvb, off + 1,\nattr_save_known, *codepage_attr, &len);\n} else {\nstr = default_opaque_binary_attr(tvb, off + 1,\nattr_save_known, *codepage_attr, &len);\n}\n} else {\nif (map->opaque_literal_tag) {\nstr = map->opaque_literal_attr(tvb, off + 1,\nattr_save_literal, *codepage_attr, &len);\n} else {\nstr = default_opaque_literal_attr(tvb, off + 1,\nattr_save_literal, *codepage_attr, &len);\n}\n}\nproto_tree_add_text (tree, tvb, off, 1 + len,\n\"  %3d |  Attr | A %3d    \"\n\"| OPAQUE (Opaque data)            \"\n\"|       %s%s\",\nlevel, *codepage_attr, Indent (level), str);\noff += 1 + len;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"| RESERVED_2     (Invalid Token!) \"\n\"| WBXML 1.0 parsing stops here.\",\nlevel, *codepage_attr);\noff = tvb_len;\nDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\nlevel, off - offset));\nreturn (off - offset);\n}\nbreak;\ndefault:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"| %-10s     (Invalid Token!) \"\n\"| WBXML parsing stops here.\",\nlevel, *codepage_attr,\nval_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\noff = tvb_len;\nbreak;\n} else {\nif (peek & 0x80) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"|   Known attrValue 0x%02X          \"\n\"|       %s%s\",\nlevel, *codepage_attr, peek & 0x7f, Indent (level),\nmap_token (map->attrValue, *codepage_attr, peek));\noff++;\n} else {\nattr_save_known = peek & 0x7f;\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d |  Attr | A %3d    \"\n\"|   Known attrStart 0x%02X          \"\n\"|   %s%s\",\nlevel, *codepage_attr, attr_save_known, Indent (level),\nmap_token (map->attrStart, *codepage_attr, peek));\noff++;\n}\n}\nif (off < last_off) {\nTHROW(ReportedBoundsError);\n}\nlast_off = off;\n}\nDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\nlevel, off - offset));\nreturn (off - offset);\n}", "label": 0}
{"index": 176514, "code": "parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\nguint32 str_tbl, guint8 *level,\nguint8 *codepage_stag, guint8 *codepage_attr)\n{\nguint32     tvb_len             = tvb_reported_length (tvb);\nguint32     off                 = offset;\nguint32     len;\nguint       str_len;\nguint32     ent;\nguint32     idx;\nguint8      peek;\nguint32     tag_len;\nguint8      tag_save_known      = 0;\nguint8      tag_new_known       = 0;\nconst char *tag_save_literal;\nconst char *tag_new_literal;\nchar       *tag_save_buf        = NULL;\nchar       *tag_new_buf         = NULL;\nguint8      parsing_tag_content = FALSE;\ntag_save_literal = NULL;\nDebugLog((\"parse_wbxml_tag (level = %u, offset = %u)\\n\", *level, offset));\nwhile (off < tvb_len) {\npeek = tvb_get_guint8 (tvb, off);\nDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\nif ((peek & 0x3F) < 4) switch (peek) {\ncase 0x00:\n*codepage_stag = tvb_get_guint8 (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 2,\n\"      | Tag   | T -->%3d \"\n\"| SWITCH_PAGE (Tag code page)     \"\n\"|\",\n*codepage_stag);\noff += 2;\nbreak;\ncase 0x01:\nif (tag_save_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Known Tag 0x%02X)            \"\n\"| %s</%s>\",\n*level, *codepage_stag, tag_save_known,\nIndent (*level),\ntag_save_literal);\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Literal Tag)               \"\n\"| %s</%s>\",\n*level, *codepage_stag, Indent (*level),\ntag_save_literal ? tag_save_literal : \"\");\n}\n(*level)--;\noff++;\nDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n*level, off - offset));\nreturn (off - offset);\ncase 0x02:\nent = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| ENTITY                          \"\n\"| %s'&#%u;'\",\n*level, *codepage_stag, Indent (*level), ent);\noff += 1+len;\nbreak;\ncase 0x03:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| STR_I (Inline string)           \"\n\"| %s\\'%s\\'\",\n*level, *codepage_stag, Indent(*level),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x40:\ncase 0x41:\ncase 0x42:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_I_%1x    (Extension Token)    \"\n\"| %s(Inline string extension: \\'%s\\')\",\n*level, *codepage_stag, peek & 0x0f, Indent (*level),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x43:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| PI (XML Processing Instruction) \"\n\"| %s<?xml\",\n*level, *codepage_stag, Indent (*level));\nlen = parse_wbxml_attribute_list (tree, tvb, off, str_tbl,\n*level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (PI)                        \"\n\"| %s?>\",\n*level, *codepage_stag, Indent (*level));\nbreak;\ncase 0x80:\ncase 0x81:\ncase 0x82:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_T_%1x    (Extension Token)    \"\n\"| %s(Extension Token, integer value: %u)\",\n*level, *codepage_stag, peek & 0x0f, Indent (*level),\nidx);\noff += 1+len;\nbreak;\ncase 0x83:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| STR_T (Tableref string)         \"\n\"| %s\\'%s\\'\",\n*level, *codepage_stag, Indent (*level),\ntvb_format_text (tvb, str_tbl+idx, str_len-1));\noff += 1+len;\nbreak;\ncase 0xC0:\ncase 0xC1:\ncase 0xC2:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_%1x      (Extension Token)    \"\n\"| %s(Single-byte extension)\",\n*level, *codepage_stag, peek & 0x0f, Indent (*level));\noff++;\nbreak;\ncase 0xC3:\nif (tvb_get_guint8 (tvb, 0)) {\nidx = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1 + len + idx,\n\"  %3d | Tag   | T %3d    \"\n\"| OPAQUE (Opaque data)            \"\n\"| %s(%d bytes of opaque data)\",\n*level, *codepage_stag, Indent (*level), idx);\noff += 1+len+idx;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| RESERVED_2     (Invalid Token!) \"\n\"| WBXML 1.0 parsing stops here.\",\n*level, *codepage_stag);\noff = tvb_len;\nDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n*level, off - offset));\nreturn (off - offset);\n}\nbreak;\n} else {\ntag_len = 0;\nif ((peek & 0x3F) == 4) {\nDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u)\"\n\" - TableRef follows!\\n\", peek, off));\nidx = tvb_get_guintvar (tvb, off+1, &tag_len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\ntag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\ntag_new_known = 0;\n} else {\ntag_new_known = peek & 0x3F;\ntag_new_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\ntag_new_known);\ntag_new_literal = tag_new_buf;\n}\nif (peek & 0x40) {\nif (parsing_tag_content) {\nDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n(*level)++;\nlen = parse_wbxml_tag (tree, tvb, off, str_tbl, level,\ncodepage_stag, codepage_attr);\noff += len;\n} else {\nif ((peek & 0x3F) == 4) {\ntag_save_literal = tag_new_literal;\ntag_save_known = 0;\n} else {\ntag_save_known = tag_new_known;\ntag_save_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\ntag_new_known);\ntag_save_literal = tag_save_buf;\n}\nif (peek & 0x80) {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02X           (AC) \"\n\"| %s<%s\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL_AC (Literal tag)   (AC) \"\n\"| %s<%s\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\n}\nlen = parse_wbxml_attribute_list (tree, tvb,\noff, str_tbl, *level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: \"\n\"len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (attribute list)            \"\n\"| %s>\",\n*level, *codepage_stag, Indent (*level));\n} else {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02X           (.C) \"\n\"| %s<%s>\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL_C  (Literal Tag)   (.C) \"\n\"| %s<%s>\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\n}\n}\nparsing_tag_content = TRUE;\nDebugLog((\"Tag in Tag - No recursion this time! \"\n\"(off = %u)\\n\", off));\n}\n} else {\nDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n(*level)++;\nif (peek & 0x80) {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02X           (A.) \"\n\"| %s<%s\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\nlen = parse_wbxml_attribute_list (tree, tvb,\noff, str_tbl, *level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: \"\n\"len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Known Tag)                 \"\n\"| %s/>\",\n*level, *codepage_stag, Indent (*level));\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL_A  (Literal Tag)   (A.) \"\n\"| %s<%s\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\nlen = parse_wbxml_attribute_list (tree, tvb,\noff, str_tbl, *level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: \"\n\"len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Literal Tag)               \"\n\"| %s/>\",\n*level, *codepage_stag, Indent (*level));\n}\n} else {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02x           (..) \"\n\"| %s<%s />\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL    (Literal Tag)   (..) \"\n\"| %s<%s />\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\n}\n}\n(*level)--;\n}\n}\n}\nDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\",\n*level, off - offset));\nreturn (off - offset);\n}", "contrast": "parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\nguint32 str_tbl, guint8 *level,\nguint8 *codepage_stag, guint8 *codepage_attr)\n{\nguint32     tvb_len             = tvb_reported_length (tvb);\nguint32     off                 = offset, last_off;\nguint32     len;\nguint       str_len;\nguint32     ent;\nguint32     idx;\nguint8      peek;\nguint32     tag_len;\nguint8      tag_save_known      = 0;\nguint8      tag_new_known       = 0;\nconst char *tag_save_literal;\nconst char *tag_new_literal;\nchar       *tag_save_buf        = NULL;\nchar       *tag_new_buf         = NULL;\nguint8      parsing_tag_content = FALSE;\ntag_save_literal = NULL;\nDebugLog((\"parse_wbxml_tag (level = %u, offset = %u)\\n\", *level, offset));\nlast_off = off;\nwhile (off < tvb_len) {\npeek = tvb_get_guint8 (tvb, off);\nDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\nif ((peek & 0x3F) < 4) switch (peek) {\ncase 0x00:\n*codepage_stag = tvb_get_guint8 (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 2,\n\"      | Tag   | T -->%3d \"\n\"| SWITCH_PAGE (Tag code page)     \"\n\"|\",\n*codepage_stag);\noff += 2;\nbreak;\ncase 0x01:\nif (tag_save_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Known Tag 0x%02X)            \"\n\"| %s</%s>\",\n*level, *codepage_stag, tag_save_known,\nIndent (*level),\ntag_save_literal);\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Literal Tag)               \"\n\"| %s</%s>\",\n*level, *codepage_stag, Indent (*level),\ntag_save_literal ? tag_save_literal : \"\");\n}\n(*level)--;\noff++;\nDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n*level, off - offset));\nreturn (off - offset);\ncase 0x02:\nent = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| ENTITY                          \"\n\"| %s'&#%u;'\",\n*level, *codepage_stag, Indent (*level), ent);\noff += 1+len;\nbreak;\ncase 0x03:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| STR_I (Inline string)           \"\n\"| %s\\'%s\\'\",\n*level, *codepage_stag, Indent(*level),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x40:\ncase 0x41:\ncase 0x42:\nlen = tvb_strsize (tvb, off+1);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_I_%1x    (Extension Token)    \"\n\"| %s(Inline string extension: \\'%s\\')\",\n*level, *codepage_stag, peek & 0x0f, Indent (*level),\ntvb_format_text (tvb, off+1, len-1));\noff += 1+len;\nbreak;\ncase 0x43:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| PI (XML Processing Instruction) \"\n\"| %s<?xml\",\n*level, *codepage_stag, Indent (*level));\nlen = parse_wbxml_attribute_list (tree, tvb, off, str_tbl,\n*level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (PI)                        \"\n\"| %s?>\",\n*level, *codepage_stag, Indent (*level));\nbreak;\ncase 0x80:\ncase 0x81:\ncase 0x82:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_T_%1x    (Extension Token)    \"\n\"| %s(Extension Token, integer value: %u)\",\n*level, *codepage_stag, peek & 0x0f, Indent (*level),\nidx);\noff += 1+len;\nbreak;\ncase 0x83:\nidx = tvb_get_guintvar (tvb, off+1, &len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\nproto_tree_add_text (tree, tvb, off, 1+len,\n\"  %3d | Tag   | T %3d    \"\n\"| STR_T (Tableref string)         \"\n\"| %s\\'%s\\'\",\n*level, *codepage_stag, Indent (*level),\ntvb_format_text (tvb, str_tbl+idx, str_len-1));\noff += 1+len;\nbreak;\ncase 0xC0:\ncase 0xC1:\ncase 0xC2:\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| EXT_%1x      (Extension Token)    \"\n\"| %s(Single-byte extension)\",\n*level, *codepage_stag, peek & 0x0f, Indent (*level));\noff++;\nbreak;\ncase 0xC3:\nif (tvb_get_guint8 (tvb, 0)) {\nidx = tvb_get_guintvar (tvb, off+1, &len);\nproto_tree_add_text (tree, tvb, off, 1 + len + idx,\n\"  %3d | Tag   | T %3d    \"\n\"| OPAQUE (Opaque data)            \"\n\"| %s(%d bytes of opaque data)\",\n*level, *codepage_stag, Indent (*level), idx);\noff += 1+len+idx;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| RESERVED_2     (Invalid Token!) \"\n\"| WBXML 1.0 parsing stops here.\",\n*level, *codepage_stag);\noff = tvb_len;\nDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n*level, off - offset));\nreturn (off - offset);\n}\nbreak;\n} else {\ntag_len = 0;\nif ((peek & 0x3F) == 4) {\nDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u)\"\n\" - TableRef follows!\\n\", peek, off));\nidx = tvb_get_guintvar (tvb, off+1, &tag_len);\nstr_len = tvb_strsize (tvb, str_tbl+idx);\ntag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\ntag_new_known = 0;\n} else {\ntag_new_known = peek & 0x3F;\ntag_new_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\ntag_new_known);\ntag_new_literal = tag_new_buf;\n}\nif (peek & 0x40) {\nif (parsing_tag_content) {\nDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n(*level)++;\nlen = parse_wbxml_tag (tree, tvb, off, str_tbl, level,\ncodepage_stag, codepage_attr);\noff += len;\n} else {\nif ((peek & 0x3F) == 4) {\ntag_save_literal = tag_new_literal;\ntag_save_known = 0;\n} else {\ntag_save_known = tag_new_known;\ntag_save_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\ntag_new_known);\ntag_save_literal = tag_save_buf;\n}\nif (peek & 0x80) {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02X           (AC) \"\n\"| %s<%s\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL_AC (Literal tag)   (AC) \"\n\"| %s<%s\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\n}\nlen = parse_wbxml_attribute_list (tree, tvb,\noff, str_tbl, *level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: \"\n\"len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (attribute list)            \"\n\"| %s>\",\n*level, *codepage_stag, Indent (*level));\n} else {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02X           (.C) \"\n\"| %s<%s>\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL_C  (Literal Tag)   (.C) \"\n\"| %s<%s>\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\n}\n}\nparsing_tag_content = TRUE;\nDebugLog((\"Tag in Tag - No recursion this time! \"\n\"(off = %u)\\n\", off));\n}\n} else {\nDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n(*level)++;\nif (peek & 0x80) {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02X           (A.) \"\n\"| %s<%s\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\nlen = parse_wbxml_attribute_list (tree, tvb,\noff, str_tbl, *level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: \"\n\"len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Known Tag)                 \"\n\"| %s/>\",\n*level, *codepage_stag, Indent (*level));\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL_A  (Literal Tag)   (A.) \"\n\"| %s<%s\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\nlen = parse_wbxml_attribute_list (tree, tvb,\noff, str_tbl, *level, codepage_attr);\noff += len;\nif (off >= tvb_len) {\nDebugLog((\"STAG: level = %u, ThrowException: \"\n\"len = %u (short frame)\\n\",\n*level, off - offset));\nTHROW(ReportedBoundsError);\n}\nproto_tree_add_text (tree, tvb, off-1, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| END (Literal Tag)               \"\n\"| %s/>\",\n*level, *codepage_stag, Indent (*level));\n}\n} else {\nif (tag_new_known) {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"|   Known Tag 0x%02x           (..) \"\n\"| %s<%s />\",\n*level, *codepage_stag, tag_new_known,\nIndent (*level), tag_new_literal);\noff++;\n} else {\nproto_tree_add_text (tree, tvb, off, 1,\n\"  %3d | Tag   | T %3d    \"\n\"| LITERAL    (Literal Tag)   (..) \"\n\"| %s<%s />\",\n*level, *codepage_stag, Indent (*level),\ntag_new_literal);\noff += 1 + tag_len;\n}\n}\n(*level)--;\n}\n}\nif (off < last_off) {\nTHROW(ReportedBoundsError);\n}\nlast_off = off;\n}\nDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\",\n*level, off - offset));\nreturn (off - offset);\n}", "label": 0}
{"index": 176518, "code": "dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\nproto_tree *parent_tree, gint offset, proto_item *top_item)\n{\nproto_tree *tree;\nproto_item *ti;\nnstime_t ts;\ntvbuff_t *new_tvb;\nguint caplen, len, frame_no;\ngint reported_length_remaining;\nti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);\ntree = proto_item_add_subtree (ti, ett_packet);\nts.secs = tvb_get_ntohl (tvb, offset);\nts.nsecs = tvb_get_ntohl (tvb, offset + 4) * 1000;\nproto_tree_add_time(tree, hf_timestamp, tvb, offset, 8, &ts);\noffset += 8;\ncaplen = tvb_get_ntohl (tvb, offset);\nti = proto_tree_add_item (tree, hf_caplen, tvb, offset, 4, ENC_BIG_ENDIAN);\noffset += 4;\nlen = tvb_get_ntohl (tvb, offset);\nproto_tree_add_item (tree, hf_len, tvb, offset, 4, ENC_BIG_ENDIAN);\noffset += 4;\nframe_no = tvb_get_ntohl (tvb, offset);\nproto_tree_add_item (tree, hf_npkt, tvb, offset, 4, ENC_BIG_ENDIAN);\noffset += 4;\nproto_item_append_text (ti, \", Frame %u\", frame_no);\nproto_item_append_text (top_item, \" Frame %u\", frame_no);\nreported_length_remaining = tvb_reported_length_remaining (tvb, offset);\nif (caplen > (guint)reported_length_remaining) {\nexpert_add_info(pinfo, ti, &ei_caplen_too_big);\nreturn;\n}\nnew_tvb = tvb_new_subset (tvb, offset, caplen, len);\nif (decode_content && linktype != WTAP_ENCAP_UNKNOWN) {\ndissector_try_uint(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree);\nif (!info_added) {\ncol_prepend_fence_fstr(pinfo->cinfo, COL_PROTOCOL, \"R|\");\ncol_prepend_fence_fstr (pinfo->cinfo, COL_INFO, \"Remote | \");\ninfo_added = TRUE;\nregister_frame_end_routine(pinfo, rpcap_frame_end);\n}\n} else {\nif (linktype == WTAP_ENCAP_UNKNOWN) {\nproto_item_append_text (ti, \", Unknown link-layer type\");\n}\ncall_dissector (data_handle, new_tvb, pinfo, top_tree);\n}\n}", "contrast": "dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\nproto_tree *parent_tree, gint offset, proto_item *top_item)\n{\nproto_tree *tree;\nproto_item *ti;\nnstime_t ts;\ntvbuff_t *new_tvb;\nguint caplen, len, frame_no;\ngint reported_length_remaining;\nstruct eth_phdr eth;\nvoid *phdr;\nti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);\ntree = proto_item_add_subtree (ti, ett_packet);\nts.secs = tvb_get_ntohl (tvb, offset);\nts.nsecs = tvb_get_ntohl (tvb, offset + 4) * 1000;\nproto_tree_add_time(tree, hf_timestamp, tvb, offset, 8, &ts);\noffset += 8;\ncaplen = tvb_get_ntohl (tvb, offset);\nti = proto_tree_add_item (tree, hf_caplen, tvb, offset, 4, ENC_BIG_ENDIAN);\noffset += 4;\nlen = tvb_get_ntohl (tvb, offset);\nproto_tree_add_item (tree, hf_len, tvb, offset, 4, ENC_BIG_ENDIAN);\noffset += 4;\nframe_no = tvb_get_ntohl (tvb, offset);\nproto_tree_add_item (tree, hf_npkt, tvb, offset, 4, ENC_BIG_ENDIAN);\noffset += 4;\nproto_item_append_text (ti, \", Frame %u\", frame_no);\nproto_item_append_text (top_item, \" Frame %u\", frame_no);\nreported_length_remaining = tvb_reported_length_remaining (tvb, offset);\nif (caplen > (guint)reported_length_remaining) {\nexpert_add_info(pinfo, ti, &ei_caplen_too_big);\nreturn;\n}\nnew_tvb = tvb_new_subset (tvb, offset, caplen, len);\nif (decode_content && linktype != WTAP_ENCAP_UNKNOWN) {\nswitch (linktype) {\ncase WTAP_ENCAP_ETHERNET:\neth.fcs_len = -1;\nphdr = &eth;\nbreak;\ndefault:\nphdr = NULL;\nbreak;\n}\ndissector_try_uint_new(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree, TRUE, phdr);\nif (!info_added) {\ncol_prepend_fence_fstr(pinfo->cinfo, COL_PROTOCOL, \"R|\");\ncol_prepend_fence_fstr (pinfo->cinfo, COL_INFO, \"Remote | \");\ninfo_added = TRUE;\nregister_frame_end_routine(pinfo, rpcap_frame_end);\n}\n} else {\nif (linktype == WTAP_ENCAP_UNKNOWN) {\nproto_item_append_text (ti, \", Unknown link-layer type\");\n}\ncall_dissector (data_handle, new_tvb, pinfo, top_tree);\n}\n}", "label": 0}
{"index": 176536, "code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\nint addr_len;\n#else\nsocklen_t addr_len;\n#endif\nint result;\nstruct sockaddr_in addr;\nmemset(&addr, 0, sizeof(addr));\naddr.sin_family = AF_INET;\naddr.sin_addr.s_addr = htonl(INADDR_ANY);\naddr.sin_port = htons(port);\naddr_len = sizeof(addr);\nresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\nreturn result;\n}", "contrast": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\nint addr_len;\n#else\nsocklen_t addr_len;\n#endif\nint result;\nstruct sockaddr_in addr;\nmemset(&addr, 0, sizeof(addr));\naddr.sin_family = AF_INET;\naddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\naddr.sin_port = htons(port);\naddr_len = sizeof(addr);\nresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\nreturn result;\n}", "label": 0}
{"index": 176538, "code": "PHPAPI PHP_FUNCTION(fread)\n{\nzval *arg1;\nlong len;\nphp_stream *stream;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\nRETURN_FALSE;\n}\nPHP_STREAM_TO_ZVAL(stream, &arg1);\nif (len <= 0) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\nRETURN_FALSE;\n}\nZ_STRVAL_P(return_value) = emalloc(len + 1);\nZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\nZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\nZ_TYPE_P(return_value) = IS_STRING;\n}", "contrast": "PHPAPI PHP_FUNCTION(fread)\n{\nzval *arg1;\nlong len;\nphp_stream *stream;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\nRETURN_FALSE;\n}\nPHP_STREAM_TO_ZVAL(stream, &arg1);\nif (len <= 0) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\nRETURN_FALSE;\n}\nif (len > INT_MAX) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\nRETURN_FALSE;\n}\nZ_STRVAL_P(return_value) = emalloc(len + 1);\nZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\nZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\nZ_TYPE_P(return_value) = IS_STRING;\n}", "label": 0}
{"index": 176543, "code": "static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n{\nconst char* loc_name        \t= NULL;\nint         loc_name_len    \t= 0;\nchar*       tag_value\t\t= NULL;\nchar*       empty_result\t= \"\";\nint         result    \t\t= 0;\nchar*       msg        \t\t= NULL;\nUErrorCode  status          \t= U_ZERO_ERROR;\nintl_error_reset( NULL TSRMLS_CC );\nif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n&loc_name ,&loc_name_len ) == FAILURE) {\nspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\nintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\nefree(msg);\nRETURN_FALSE;\n}\nif(loc_name_len == 0) {\nloc_name = intl_locale_get_default(TSRMLS_C);\n}\ntag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\nif( result == -1 ) {\nif( tag_value){\nefree( tag_value);\n}\nRETURN_STRING( empty_result , TRUE);\n}\nif( tag_value){\nRETURN_STRING( tag_value , FALSE);\n}\nif( result ==0) {\nspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\nintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\nefree(msg);\nRETURN_NULL();\n}\n}", "contrast": "static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\nstatic void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n{\nconst char* loc_name        \t= NULL;\nint         loc_name_len    \t= 0;\nchar*       tag_value\t\t= NULL;\nchar*       empty_result\t= \"\";\nint         result    \t\t= 0;\nchar*       msg        \t\t= NULL;\nUErrorCode  status          \t= U_ZERO_ERROR;\nintl_error_reset( NULL TSRMLS_CC );\nif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n&loc_name ,&loc_name_len ) == FAILURE) {\nspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\nintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\nefree(msg);\nRETURN_FALSE;\n}\nif(loc_name_len == 0) {\nloc_name = intl_locale_get_default(TSRMLS_C);\n}\ntag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\nif( result == -1 ) {\nif( tag_value){\nefree( tag_value);\n}\nRETURN_STRING( empty_result , TRUE);\n}\nif( tag_value){\nRETURN_STRING( tag_value , FALSE);\n}\nif( result ==0) {\nspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\nintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\nefree(msg);\nRETURN_NULL();\n}\n}", "label": 0}
{"index": 176587, "code": "static int replace_map_fd_with_map_ptr(struct verifier_env *env)\n{\nstruct bpf_insn *insn = env->prog->insnsi;\nint insn_cnt = env->prog->len;\nint i, j;\nfor (i = 0; i < insn_cnt; i++, insn++) {\nif (BPF_CLASS(insn->code) == BPF_LDX &&\n(BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\nverbose(\"BPF_LDX uses reserved fields\\n\");\nreturn -EINVAL;\n}\nif (BPF_CLASS(insn->code) == BPF_STX &&\n((BPF_MODE(insn->code) != BPF_MEM &&\nBPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\nverbose(\"BPF_STX uses reserved fields\\n\");\nreturn -EINVAL;\n}\nif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\nstruct bpf_map *map;\nstruct fd f;\nif (i == insn_cnt - 1 || insn[1].code != 0 ||\ninsn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\ninsn[1].off != 0) {\nverbose(\"invalid bpf_ld_imm64 insn\\n\");\nreturn -EINVAL;\n}\nif (insn->src_reg == 0)\ngoto next_insn;\nif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\nverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\nreturn -EINVAL;\n}\nf = fdget(insn->imm);\nmap = __bpf_map_get(f);\nif (IS_ERR(map)) {\nverbose(\"fd %d is not pointing to valid bpf_map\\n\",\ninsn->imm);\nreturn PTR_ERR(map);\n}\ninsn[0].imm = (u32) (unsigned long) map;\ninsn[1].imm = ((u64) (unsigned long) map) >> 32;\nfor (j = 0; j < env->used_map_cnt; j++)\nif (env->used_maps[j] == map) {\nfdput(f);\ngoto next_insn;\n}\nif (env->used_map_cnt >= MAX_USED_MAPS) {\nfdput(f);\nreturn -E2BIG;\n}\nenv->used_maps[env->used_map_cnt++] = map;\nbpf_map_inc(map, false);\nfdput(f);\nnext_insn:\ninsn++;\ni++;\n}\n}\nreturn 0;\n}", "contrast": "static int replace_map_fd_with_map_ptr(struct verifier_env *env)\n{\nstruct bpf_insn *insn = env->prog->insnsi;\nint insn_cnt = env->prog->len;\nint i, j;\nfor (i = 0; i < insn_cnt; i++, insn++) {\nif (BPF_CLASS(insn->code) == BPF_LDX &&\n(BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\nverbose(\"BPF_LDX uses reserved fields\\n\");\nreturn -EINVAL;\n}\nif (BPF_CLASS(insn->code) == BPF_STX &&\n((BPF_MODE(insn->code) != BPF_MEM &&\nBPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\nverbose(\"BPF_STX uses reserved fields\\n\");\nreturn -EINVAL;\n}\nif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\nstruct bpf_map *map;\nstruct fd f;\nif (i == insn_cnt - 1 || insn[1].code != 0 ||\ninsn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\ninsn[1].off != 0) {\nverbose(\"invalid bpf_ld_imm64 insn\\n\");\nreturn -EINVAL;\n}\nif (insn->src_reg == 0)\ngoto next_insn;\nif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\nverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\nreturn -EINVAL;\n}\nf = fdget(insn->imm);\nmap = __bpf_map_get(f);\nif (IS_ERR(map)) {\nverbose(\"fd %d is not pointing to valid bpf_map\\n\",\ninsn->imm);\nreturn PTR_ERR(map);\n}\ninsn[0].imm = (u32) (unsigned long) map;\ninsn[1].imm = ((u64) (unsigned long) map) >> 32;\nfor (j = 0; j < env->used_map_cnt; j++)\nif (env->used_maps[j] == map) {\nfdput(f);\ngoto next_insn;\n}\nif (env->used_map_cnt >= MAX_USED_MAPS) {\nfdput(f);\nreturn -E2BIG;\n}\nmap = bpf_map_inc(map, false);\nif (IS_ERR(map)) {\nfdput(f);\nreturn PTR_ERR(map);\n}\nenv->used_maps[env->used_map_cnt++] = map;\nfdput(f);\nnext_insn:\ninsn++;\ni++;\n}\n}\nreturn 0;\n}", "label": 0}
{"index": 176590, "code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\nlong unsigned int i;\nunsigned char c;\nchar buf2[15];\nmowgli_string_t *s = mowgli_string_create();\n*buf2 = '\\0';\n*outbuffer = '\\0';\nif ((!(s1) || (*(s1) == '\\0')))\n{\nreturn;\n}\nfor (i = 0; s1[i] != '\\0'; i++)\n{\nc = s1[i];\nif (c > 127)\n{\nsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\ns->append(s, buf2, strlen(buf2));\n}\nelse if (c == '&')\n{\ns->append(s, \"&amp;\", 5);\n}\nelse if (c == '<')\n{\ns->append(s, \"&lt;\", 4);\n}\nelse if (c == '>')\n{\ns->append(s, \"&gt;\", 4);\n}\nelse if (c == '\"')\n{\ns->append(s, \"&quot;\", 6);\n}\nelse\n{\ns->append_char(s, c);\n}\n}\nmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}", "contrast": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\nlong unsigned int i;\nunsigned char c;\nchar buf2[15];\nmowgli_string_t *s = mowgli_string_create();\n*buf2 = '\\0';\n*outbuffer = '\\0';\nif ((!(s1) || (*(s1) == '\\0')))\n{\nreturn;\n}\nfor (i = 0; s1[i] != '\\0'; i++)\n{\nc = s1[i];\nif (c > 127)\n{\nsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\ns->append(s, buf2, strlen(buf2));\n}\nelse if (c == '&')\n{\ns->append(s, \"&amp;\", 5);\n}\nelse if (c == '<')\n{\ns->append(s, \"&lt;\", 4);\n}\nelse if (c == '>')\n{\ns->append(s, \"&gt;\", 4);\n}\nelse if (c == '\"')\n{\ns->append(s, \"&quot;\", 6);\n}\nelse\n{\ns->append_char(s, c);\n}\n}\ns->append_char(s, 0);\nstrncpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}", "label": 0}
{"index": 176605, "code": "cJSON *cJSON_CreateNull( void )\n{\ncJSON *item = cJSON_New_Item();\nif ( item )\nitem->type = cJSON_NULL;\nreturn item;\n}", "contrast": "cJSON *cJSON_CreateNull( void )", "label": 0}
{"index": 176608, "code": "cJSON *cJSON_CreateStringArray( const char **strings, int count )\n{\nint i;\ncJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\nfor ( i = 0; a && i < count; ++i ) {\nn = cJSON_CreateString( strings[i] );\nif ( ! i )\na->child = n;\nelse\nsuffix_object( p, n );\np = n;\n}\nreturn a;\n}", "contrast": "cJSON *cJSON_CreateStringArray( const char **strings, int count )\ncJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}\ncJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}\ncJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}\ncJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\ncJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}\ncJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}\ncJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}\ncJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}\ncJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_Duplicate(cJSON *item,int recurse)\n{\ncJSON *newitem,*cptr,*nptr=0,*newchild;\nif (!item) return 0;\nnewitem=cJSON_New_Item();\nif (!newitem) return 0;\nnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\nif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\nif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\nif (!recurse) return newitem;\ncptr=item->child;\nwhile (cptr)\n{\nnewchild=cJSON_Duplicate(cptr,1);\nif (!newchild) {cJSON_Delete(newitem);return 0;}\nif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\nelse\t\t{newitem->child=newchild;nptr=newchild;}\ncptr=cptr->next;\n}\nreturn newitem;\n}\nvoid cJSON_Minify(char *json)\n{\nchar *into=json;\nwhile (*json)\n{\nif (*json==' ') json++;\nelse if (*json=='\\t') json++;\nelse if (*json=='\\r') json++;\nelse if (*json=='\\n') json++;\nelse if (*json=='/' && json[1]=='/')  while (*json && *json!='\\n') json++;\nelse if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}\nelse if (*json=='\\\"'){*into++=*json++;while (*json && *json!='\\\"'){if (*json=='\\\\') *into++=*json++;*into++=*json++;}*into++=*json++;}\nelse *into++=*json++;\n}\n*into=0;\n}", "label": 0}
{"index": 176621, "code": "cJSON *cJSON_Parse( const char *value )\n{\ncJSON *c;\nep = 0;\nif ( ! ( c = cJSON_New_Item() ) )\nreturn 0;\nif ( ! parse_value( c, skip( value ) ) ) {\ncJSON_Delete( c );\nreturn 0;\n}\nreturn c;\n}", "contrast": "cJSON *cJSON_Parse( const char *value )\ncJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n{\nconst char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;\ncJSON *c=cJSON_New_Item();\n*ep=0;\nif (!c) return 0;\nend=parse_value(c,skip(value),ep);\nif (!end)\t{cJSON_Delete(c);return 0;}\nif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\nif (return_parse_end) *return_parse_end=end;\nreturn c;\n}", "label": 0}
{"index": 176635, "code": "static char *print_array( cJSON *item, int depth, int fmt )\n{\nchar **entries;\nchar *out = 0, *ptr, *ret;\nint len = 5;\ncJSON *child = item->child;\nint numentries = 0, i = 0, fail = 0;\nwhile ( child ) {\n++numentries;\nchild = child->next;\n}\nif ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )\nreturn 0;\nmemset( entries, 0, numentries * sizeof(char*) );\nchild = item->child;\nwhile ( child && ! fail ) {\nret = print_value( child, depth + 1, fmt );\nentries[i++] = ret;\nif ( ret )\nlen += strlen( ret ) + 2 + ( fmt ? 1 : 0 );\nelse\nfail = 1;\nchild = child -> next;\n}\nif ( ! fail ) {\nout = (char*) cJSON_malloc( len );\nif ( ! out )\nfail = 1;\n}\nif ( fail ) {\nfor ( i = 0; i < numentries; ++i )\nif ( entries[i] )\ncJSON_free( entries[i] );\ncJSON_free( entries );\nreturn 0;\n}\n*out = '[';\nptr = out + 1;\n*ptr = 0;\nfor ( i = 0; i < numentries; ++i ) {\nstrcpy( ptr, entries[i] );\nptr += strlen( entries[i] );\nif ( i != numentries - 1 ) {\n*ptr++ = ',';\nif ( fmt )\n*ptr++ = ' ';\n*ptr = 0;\n}\ncJSON_free( entries[i] );\n}\ncJSON_free( entries );\n*ptr++ = ']';\n*ptr++ = 0;\nreturn out;\n}", "contrast": "static char *print_array( cJSON *item, int depth, int fmt )\nstatic char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)\n{\nchar **entries;\nchar *out=0,*ptr,*ret;int len=5;\ncJSON *child=item->child;\nint numentries=0,i=0,fail=0;\nsize_t tmplen=0;\nwhile (child) numentries++,child=child->next;\nif (!numentries)\n{\nif (p)\tout=ensure(p,3);\nelse\tout=(char*)cJSON_malloc(3);\nif (out) strcpy(out,\"[]\");\nreturn out;\n}\nif (p)\n{\ni=p->offset;\nptr=ensure(p,1);if (!ptr) return 0;\t*ptr='[';\tp->offset++;\nchild=item->child;\nwhile (child && !fail)\n{\nprint_value(child,depth+1,fmt,p);\np->offset=update(p);\nif (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}\nchild=child->next;\n}\nptr=ensure(p,2);if (!ptr) return 0;\t*ptr++=']';*ptr=0;\nout=(p->buffer)+i;\n}\nelse\n{\nentries=(char**)cJSON_malloc(numentries*sizeof(char*));\nif (!entries) return 0;\nmemset(entries,0,numentries*sizeof(char*));\nchild=item->child;\nwhile (child && !fail)\n{\nret=print_value(child,depth+1,fmt,0);\nentries[i++]=ret;\nif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\nchild=child->next;\n}\nif (!fail)\tout=(char*)cJSON_malloc(len);\nif (!out) fail=1;\nif (fail)\n{\nfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\ncJSON_free(entries);\nreturn 0;\n}\n*out='[';\nptr=out+1;*ptr=0;\nfor (i=0;i<numentries;i++)\n{\ntmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;\nif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\ncJSON_free(entries[i]);\n}\ncJSON_free(entries);\n*ptr++=']';*ptr++=0;\n}\nreturn out;\n}", "label": 0}
{"index": 176685, "code": "static int acm_probe(struct usb_interface *intf,\nconst struct usb_device_id *id)\n{\nstruct usb_cdc_union_desc *union_header = NULL;\nstruct usb_cdc_country_functional_desc *cfd = NULL;\nunsigned char *buffer = intf->altsetting->extra;\nint buflen = intf->altsetting->extralen;\nstruct usb_interface *control_interface;\nstruct usb_interface *data_interface;\nstruct usb_endpoint_descriptor *epctrl = NULL;\nstruct usb_endpoint_descriptor *epread = NULL;\nstruct usb_endpoint_descriptor *epwrite = NULL;\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\nstruct acm *acm;\nint minor;\nint ctrlsize, readsize;\nu8 *buf;\nu8 ac_management_function = 0;\nu8 call_management_function = 0;\nint call_interface_num = -1;\nint data_interface_num = -1;\nunsigned long quirks;\nint num_rx_buf;\nint i;\nunsigned int elength = 0;\nint combined_interfaces = 0;\nstruct device *tty_dev;\nint rv = -ENOMEM;\nquirks = (unsigned long)id->driver_info;\nif (quirks == IGNORE_DEVICE)\nreturn -ENODEV;\nnum_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;\nif (quirks == NO_UNION_NORMAL) {\ndata_interface = usb_ifnum_to_if(usb_dev, 1);\ncontrol_interface = usb_ifnum_to_if(usb_dev, 0);\ngoto skip_normal_probe;\n}\nif (!buffer) {\ndev_err(&intf->dev, \"Weird descriptor references\\n\");\nreturn -EINVAL;\n}\nif (!buflen) {\nif (intf->cur_altsetting->endpoint &&\nintf->cur_altsetting->endpoint->extralen &&\nintf->cur_altsetting->endpoint->extra) {\ndev_dbg(&intf->dev,\n\"Seeking extra descriptors on endpoint\\n\");\nbuflen = intf->cur_altsetting->endpoint->extralen;\nbuffer = intf->cur_altsetting->endpoint->extra;\n} else {\ndev_err(&intf->dev,\n\"Zero length descriptor references\\n\");\nreturn -EINVAL;\n}\n}\nwhile (buflen > 0) {\nelength = buffer[0];\nif (!elength) {\ndev_err(&intf->dev, \"skipping garbage byte\\n\");\nelength = 1;\ngoto next_desc;\n}\nif (buffer[1] != USB_DT_CS_INTERFACE) {\ndev_err(&intf->dev, \"skipping garbage\\n\");\ngoto next_desc;\n}\nswitch (buffer[2]) {\ncase USB_CDC_UNION_TYPE:\nif (elength < sizeof(struct usb_cdc_union_desc))\ngoto next_desc;\nif (union_header) {\ndev_err(&intf->dev, \"More than one \"\n\"union descriptor, skipping ...\\n\");\ngoto next_desc;\n}\nunion_header = (struct usb_cdc_union_desc *)buffer;\nbreak;\ncase USB_CDC_COUNTRY_TYPE:\nif (elength < sizeof(struct usb_cdc_country_functional_desc))\ngoto next_desc;\ncfd = (struct usb_cdc_country_functional_desc *)buffer;\nbreak;\ncase USB_CDC_HEADER_TYPE:\nbreak;\ncase USB_CDC_ACM_TYPE:\nif (elength < 4)\ngoto next_desc;\nac_management_function = buffer[3];\nbreak;\ncase USB_CDC_CALL_MANAGEMENT_TYPE:\nif (elength < 5)\ngoto next_desc;\ncall_management_function = buffer[3];\ncall_interface_num = buffer[4];\nbreak;\ndefault:\ndev_dbg(&intf->dev, \"Ignoring descriptor: \"\n\"type %02x, length %ud\\n\",\nbuffer[2], elength);\nbreak;\n}\nnext_desc:\nbuflen -= elength;\nbuffer += elength;\n}\nif (!union_header) {\nif (call_interface_num > 0) {\ndev_dbg(&intf->dev, \"No union descriptor, using call management descriptor\\n\");\nif (quirks & NO_DATA_INTERFACE)\ndata_interface = usb_ifnum_to_if(usb_dev, 0);\nelse\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = call_interface_num));\ncontrol_interface = intf;\n} else {\nif (intf->cur_altsetting->desc.bNumEndpoints != 3) {\ndev_dbg(&intf->dev,\"No union descriptor, giving up\\n\");\nreturn -ENODEV;\n} else {\ndev_warn(&intf->dev,\"No union descriptor, testing for castrated device\\n\");\ncombined_interfaces = 1;\ncontrol_interface = data_interface = intf;\ngoto look_for_collapsed_interface;\n}\n}\n} else {\ncontrol_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = union_header->bSlaveInterface0));\n}\nif (!control_interface || !data_interface) {\ndev_dbg(&intf->dev, \"no interfaces\\n\");\nreturn -ENODEV;\n}\nif (data_interface_num != call_interface_num)\ndev_dbg(&intf->dev, \"Separate call control interface. That is not fully supported.\\n\");\nif (control_interface == data_interface) {\ndev_warn(&intf->dev,\"Control and data interfaces are not separated!\\n\");\ncombined_interfaces = 1;\nquirks |= NO_CAP_LINE;\nif (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {\ndev_err(&intf->dev, \"This needs exactly 3 endpoints\\n\");\nreturn -EINVAL;\n}\nlook_for_collapsed_interface:\nfor (i = 0; i < 3; i++) {\nstruct usb_endpoint_descriptor *ep;\nep = &data_interface->cur_altsetting->endpoint[i].desc;\nif (usb_endpoint_is_int_in(ep))\nepctrl = ep;\nelse if (usb_endpoint_is_bulk_out(ep))\nepwrite = ep;\nelse if (usb_endpoint_is_bulk_in(ep))\nepread = ep;\nelse\nreturn -EINVAL;\n}\nif (!epctrl || !epread || !epwrite)\nreturn -ENODEV;\nelse\ngoto made_compressed_probe;\n}\nskip_normal_probe:\nif (data_interface->cur_altsetting->desc.bInterfaceClass\n!= CDC_DATA_INTERFACE_TYPE) {\nif (control_interface->cur_altsetting->desc.bInterfaceClass\n== CDC_DATA_INTERFACE_TYPE) {\ndev_dbg(&intf->dev,\n\"Your device has switched interfaces.\\n\");\nswap(control_interface, data_interface);\n} else {\nreturn -EINVAL;\n}\n}\nif (!combined_interfaces && intf != control_interface)\nreturn -ENODEV;\nif (!combined_interfaces && usb_interface_claimed(data_interface)) {\ndev_dbg(&intf->dev, \"The data interface isn't available\\n\");\nreturn -EBUSY;\n}\nif (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||\ncontrol_interface->cur_altsetting->desc.bNumEndpoints == 0)\nreturn -EINVAL;\nepctrl = &control_interface->cur_altsetting->endpoint[0].desc;\nepread = &data_interface->cur_altsetting->endpoint[0].desc;\nepwrite = &data_interface->cur_altsetting->endpoint[1].desc;\nif (!usb_endpoint_dir_in(epread)) {\ndev_dbg(&intf->dev,\n\"The data interface has switched endpoints\\n\");\nswap(epread, epwrite);\n}\nmade_compressed_probe:\ndev_dbg(&intf->dev, \"interfaces are valid\\n\");\nacm = kzalloc(sizeof(struct acm), GFP_KERNEL);\nif (acm == NULL)\ngoto alloc_fail;\nminor = acm_alloc_minor(acm);\nif (minor < 0) {\ndev_err(&intf->dev, \"no more free acm devices\\n\");\nkfree(acm);\nreturn -ENODEV;\n}\nctrlsize = usb_endpoint_maxp(epctrl);\nreadsize = usb_endpoint_maxp(epread) *\n(quirks == SINGLE_RX_URB ? 1 : 2);\nacm->combined_interfaces = combined_interfaces;\nacm->writesize = usb_endpoint_maxp(epwrite) * 20;\nacm->control = control_interface;\nacm->data = data_interface;\nacm->minor = minor;\nacm->dev = usb_dev;\nacm->ctrl_caps = ac_management_function;\nif (quirks & NO_CAP_LINE)\nacm->ctrl_caps &= ~USB_CDC_CAP_LINE;\nacm->ctrlsize = ctrlsize;\nacm->readsize = readsize;\nacm->rx_buflimit = num_rx_buf;\nINIT_WORK(&acm->work, acm_softint);\ninit_waitqueue_head(&acm->wioctl);\nspin_lock_init(&acm->write_lock);\nspin_lock_init(&acm->read_lock);\nmutex_init(&acm->mutex);\nacm->rx_endpoint = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);\nacm->is_int_ep = usb_endpoint_xfer_int(epread);\nif (acm->is_int_ep)\nacm->bInterval = epread->bInterval;\ntty_port_init(&acm->port);\nacm->port.ops = &acm_port_ops;\ninit_usb_anchor(&acm->delayed);\nacm->quirks = quirks;\nbuf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);\nif (!buf)\ngoto alloc_fail2;\nacm->ctrl_buffer = buf;\nif (acm_write_buffers_alloc(acm) < 0)\ngoto alloc_fail4;\nacm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);\nif (!acm->ctrlurb)\ngoto alloc_fail5;\nfor (i = 0; i < num_rx_buf; i++) {\nstruct acm_rb *rb = &(acm->read_buffers[i]);\nstruct urb *urb;\nrb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,\n&rb->dma);\nif (!rb->base)\ngoto alloc_fail6;\nrb->index = i;\nrb->instance = acm;\nurb = usb_alloc_urb(0, GFP_KERNEL);\nif (!urb)\ngoto alloc_fail6;\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\nurb->transfer_dma = rb->dma;\nif (acm->is_int_ep) {\nusb_fill_int_urb(urb, acm->dev,\nacm->rx_endpoint,\nrb->base,\nacm->readsize,\nacm_read_bulk_callback, rb,\nacm->bInterval);\n} else {\nusb_fill_bulk_urb(urb, acm->dev,\nacm->rx_endpoint,\nrb->base,\nacm->readsize,\nacm_read_bulk_callback, rb);\n}\nacm->read_urbs[i] = urb;\n__set_bit(i, &acm->read_urbs_free);\n}\nfor (i = 0; i < ACM_NW; i++) {\nstruct acm_wb *snd = &(acm->wb[i]);\nsnd->urb = usb_alloc_urb(0, GFP_KERNEL);\nif (snd->urb == NULL)\ngoto alloc_fail7;\nif (usb_endpoint_xfer_int(epwrite))\nusb_fill_int_urb(snd->urb, usb_dev,\nusb_sndintpipe(usb_dev, epwrite->bEndpointAddress),\nNULL, acm->writesize, acm_write_bulk, snd, epwrite->bInterval);\nelse\nusb_fill_bulk_urb(snd->urb, usb_dev,\nusb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),\nNULL, acm->writesize, acm_write_bulk, snd);\nsnd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\nif (quirks & SEND_ZERO_PACKET)\nsnd->urb->transfer_flags |= URB_ZERO_PACKET;\nsnd->instance = acm;\n}\nusb_set_intfdata(intf, acm);\ni = device_create_file(&intf->dev, &dev_attr_bmCapabilities);\nif (i < 0)\ngoto alloc_fail7;\nif (cfd) {\nacm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);\nif (!acm->country_codes)\ngoto skip_countries;\nacm->country_code_size = cfd->bLength - 4;\nmemcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,\ncfd->bLength - 4);\nacm->country_rel_date = cfd->iCountryCodeRelDate;\ni = device_create_file(&intf->dev, &dev_attr_wCountryCodes);\nif (i < 0) {\nkfree(acm->country_codes);\nacm->country_codes = NULL;\nacm->country_code_size = 0;\ngoto skip_countries;\n}\ni = device_create_file(&intf->dev,\n&dev_attr_iCountryCodeRelDate);\nif (i < 0) {\ndevice_remove_file(&intf->dev, &dev_attr_wCountryCodes);\nkfree(acm->country_codes);\nacm->country_codes = NULL;\nacm->country_code_size = 0;\ngoto skip_countries;\n}\n}\nskip_countries:\nusb_fill_int_urb(acm->ctrlurb, usb_dev,\nusb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),\nacm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm,\nepctrl->bInterval ? epctrl->bInterval : 16);\nacm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\nacm->ctrlurb->transfer_dma = acm->ctrl_dma;\ndev_info(&intf->dev, \"ttyACM%d: USB ACM device\\n\", minor);\nacm->line.dwDTERate = cpu_to_le32(9600);\nacm->line.bDataBits = 8;\nacm_set_line(acm, &acm->line);\nusb_driver_claim_interface(&acm_driver, data_interface, acm);\nusb_set_intfdata(data_interface, acm);\nusb_get_intf(control_interface);\ntty_dev = tty_port_register_device(&acm->port, acm_tty_driver, minor,\n&control_interface->dev);\nif (IS_ERR(tty_dev)) {\nrv = PTR_ERR(tty_dev);\ngoto alloc_fail8;\n}\nif (quirks & CLEAR_HALT_CONDITIONS) {\nusb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress));\nusb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress));\n}\nreturn 0;\nalloc_fail8:\nif (acm->country_codes) {\ndevice_remove_file(&acm->control->dev,\n&dev_attr_wCountryCodes);\ndevice_remove_file(&acm->control->dev,\n&dev_attr_iCountryCodeRelDate);\nkfree(acm->country_codes);\n}\ndevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\nalloc_fail7:\nusb_set_intfdata(intf, NULL);\nfor (i = 0; i < ACM_NW; i++)\nusb_free_urb(acm->wb[i].urb);\nalloc_fail6:\nfor (i = 0; i < num_rx_buf; i++)\nusb_free_urb(acm->read_urbs[i]);\nacm_read_buffers_free(acm);\nusb_free_urb(acm->ctrlurb);\nalloc_fail5:\nacm_write_buffers_free(acm);\nalloc_fail4:\nusb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\nalloc_fail2:\nacm_release_minor(acm);\nkfree(acm);\nalloc_fail:\nreturn rv;\n}", "contrast": "static int acm_probe(struct usb_interface *intf,\nconst struct usb_device_id *id)\n{\nstruct usb_cdc_union_desc *union_header = NULL;\nstruct usb_cdc_country_functional_desc *cfd = NULL;\nunsigned char *buffer = intf->altsetting->extra;\nint buflen = intf->altsetting->extralen;\nstruct usb_interface *control_interface;\nstruct usb_interface *data_interface;\nstruct usb_endpoint_descriptor *epctrl = NULL;\nstruct usb_endpoint_descriptor *epread = NULL;\nstruct usb_endpoint_descriptor *epwrite = NULL;\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\nstruct acm *acm;\nint minor;\nint ctrlsize, readsize;\nu8 *buf;\nu8 ac_management_function = 0;\nu8 call_management_function = 0;\nint call_interface_num = -1;\nint data_interface_num = -1;\nunsigned long quirks;\nint num_rx_buf;\nint i;\nunsigned int elength = 0;\nint combined_interfaces = 0;\nstruct device *tty_dev;\nint rv = -ENOMEM;\nquirks = (unsigned long)id->driver_info;\nif (quirks == IGNORE_DEVICE)\nreturn -ENODEV;\nnum_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;\nif (quirks == NO_UNION_NORMAL) {\ndata_interface = usb_ifnum_to_if(usb_dev, 1);\ncontrol_interface = usb_ifnum_to_if(usb_dev, 0);\nif (!data_interface || !control_interface)\nreturn -ENODEV;\ngoto skip_normal_probe;\n}\nif (!buffer) {\ndev_err(&intf->dev, \"Weird descriptor references\\n\");\nreturn -EINVAL;\n}\nif (!buflen) {\nif (intf->cur_altsetting->endpoint &&\nintf->cur_altsetting->endpoint->extralen &&\nintf->cur_altsetting->endpoint->extra) {\ndev_dbg(&intf->dev,\n\"Seeking extra descriptors on endpoint\\n\");\nbuflen = intf->cur_altsetting->endpoint->extralen;\nbuffer = intf->cur_altsetting->endpoint->extra;\n} else {\ndev_err(&intf->dev,\n\"Zero length descriptor references\\n\");\nreturn -EINVAL;\n}\n}\nwhile (buflen > 0) {\nelength = buffer[0];\nif (!elength) {\ndev_err(&intf->dev, \"skipping garbage byte\\n\");\nelength = 1;\ngoto next_desc;\n}\nif (buffer[1] != USB_DT_CS_INTERFACE) {\ndev_err(&intf->dev, \"skipping garbage\\n\");\ngoto next_desc;\n}\nswitch (buffer[2]) {\ncase USB_CDC_UNION_TYPE:\nif (elength < sizeof(struct usb_cdc_union_desc))\ngoto next_desc;\nif (union_header) {\ndev_err(&intf->dev, \"More than one \"\n\"union descriptor, skipping ...\\n\");\ngoto next_desc;\n}\nunion_header = (struct usb_cdc_union_desc *)buffer;\nbreak;\ncase USB_CDC_COUNTRY_TYPE:\nif (elength < sizeof(struct usb_cdc_country_functional_desc))\ngoto next_desc;\ncfd = (struct usb_cdc_country_functional_desc *)buffer;\nbreak;\ncase USB_CDC_HEADER_TYPE:\nbreak;\ncase USB_CDC_ACM_TYPE:\nif (elength < 4)\ngoto next_desc;\nac_management_function = buffer[3];\nbreak;\ncase USB_CDC_CALL_MANAGEMENT_TYPE:\nif (elength < 5)\ngoto next_desc;\ncall_management_function = buffer[3];\ncall_interface_num = buffer[4];\nbreak;\ndefault:\ndev_dbg(&intf->dev, \"Ignoring descriptor: \"\n\"type %02x, length %ud\\n\",\nbuffer[2], elength);\nbreak;\n}\nnext_desc:\nbuflen -= elength;\nbuffer += elength;\n}\nif (!union_header) {\nif (call_interface_num > 0) {\ndev_dbg(&intf->dev, \"No union descriptor, using call management descriptor\\n\");\nif (quirks & NO_DATA_INTERFACE)\ndata_interface = usb_ifnum_to_if(usb_dev, 0);\nelse\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = call_interface_num));\ncontrol_interface = intf;\n} else {\nif (intf->cur_altsetting->desc.bNumEndpoints != 3) {\ndev_dbg(&intf->dev,\"No union descriptor, giving up\\n\");\nreturn -ENODEV;\n} else {\ndev_warn(&intf->dev,\"No union descriptor, testing for castrated device\\n\");\ncombined_interfaces = 1;\ncontrol_interface = data_interface = intf;\ngoto look_for_collapsed_interface;\n}\n}\n} else {\ncontrol_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = union_header->bSlaveInterface0));\n}\nif (!control_interface || !data_interface) {\ndev_dbg(&intf->dev, \"no interfaces\\n\");\nreturn -ENODEV;\n}\nif (data_interface_num != call_interface_num)\ndev_dbg(&intf->dev, \"Separate call control interface. That is not fully supported.\\n\");\nif (control_interface == data_interface) {\ndev_warn(&intf->dev,\"Control and data interfaces are not separated!\\n\");\ncombined_interfaces = 1;\nquirks |= NO_CAP_LINE;\nif (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {\ndev_err(&intf->dev, \"This needs exactly 3 endpoints\\n\");\nreturn -EINVAL;\n}\nlook_for_collapsed_interface:\nfor (i = 0; i < 3; i++) {\nstruct usb_endpoint_descriptor *ep;\nep = &data_interface->cur_altsetting->endpoint[i].desc;\nif (usb_endpoint_is_int_in(ep))\nepctrl = ep;\nelse if (usb_endpoint_is_bulk_out(ep))\nepwrite = ep;\nelse if (usb_endpoint_is_bulk_in(ep))\nepread = ep;\nelse\nreturn -EINVAL;\n}\nif (!epctrl || !epread || !epwrite)\nreturn -ENODEV;\nelse\ngoto made_compressed_probe;\n}\nskip_normal_probe:\nif (data_interface->cur_altsetting->desc.bInterfaceClass\n!= CDC_DATA_INTERFACE_TYPE) {\nif (control_interface->cur_altsetting->desc.bInterfaceClass\n== CDC_DATA_INTERFACE_TYPE) {\ndev_dbg(&intf->dev,\n\"Your device has switched interfaces.\\n\");\nswap(control_interface, data_interface);\n} else {\nreturn -EINVAL;\n}\n}\nif (!combined_interfaces && intf != control_interface)\nreturn -ENODEV;\nif (!combined_interfaces && usb_interface_claimed(data_interface)) {\ndev_dbg(&intf->dev, \"The data interface isn't available\\n\");\nreturn -EBUSY;\n}\nif (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||\ncontrol_interface->cur_altsetting->desc.bNumEndpoints == 0)\nreturn -EINVAL;\nepctrl = &control_interface->cur_altsetting->endpoint[0].desc;\nepread = &data_interface->cur_altsetting->endpoint[0].desc;\nepwrite = &data_interface->cur_altsetting->endpoint[1].desc;\nif (!usb_endpoint_dir_in(epread)) {\ndev_dbg(&intf->dev,\n\"The data interface has switched endpoints\\n\");\nswap(epread, epwrite);\n}\nmade_compressed_probe:\ndev_dbg(&intf->dev, \"interfaces are valid\\n\");\nacm = kzalloc(sizeof(struct acm), GFP_KERNEL);\nif (acm == NULL)\ngoto alloc_fail;\nminor = acm_alloc_minor(acm);\nif (minor < 0) {\ndev_err(&intf->dev, \"no more free acm devices\\n\");\nkfree(acm);\nreturn -ENODEV;\n}\nctrlsize = usb_endpoint_maxp(epctrl);\nreadsize = usb_endpoint_maxp(epread) *\n(quirks == SINGLE_RX_URB ? 1 : 2);\nacm->combined_interfaces = combined_interfaces;\nacm->writesize = usb_endpoint_maxp(epwrite) * 20;\nacm->control = control_interface;\nacm->data = data_interface;\nacm->minor = minor;\nacm->dev = usb_dev;\nacm->ctrl_caps = ac_management_function;\nif (quirks & NO_CAP_LINE)\nacm->ctrl_caps &= ~USB_CDC_CAP_LINE;\nacm->ctrlsize = ctrlsize;\nacm->readsize = readsize;\nacm->rx_buflimit = num_rx_buf;\nINIT_WORK(&acm->work, acm_softint);\ninit_waitqueue_head(&acm->wioctl);\nspin_lock_init(&acm->write_lock);\nspin_lock_init(&acm->read_lock);\nmutex_init(&acm->mutex);\nacm->rx_endpoint = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);\nacm->is_int_ep = usb_endpoint_xfer_int(epread);\nif (acm->is_int_ep)\nacm->bInterval = epread->bInterval;\ntty_port_init(&acm->port);\nacm->port.ops = &acm_port_ops;\ninit_usb_anchor(&acm->delayed);\nacm->quirks = quirks;\nbuf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);\nif (!buf)\ngoto alloc_fail2;\nacm->ctrl_buffer = buf;\nif (acm_write_buffers_alloc(acm) < 0)\ngoto alloc_fail4;\nacm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);\nif (!acm->ctrlurb)\ngoto alloc_fail5;\nfor (i = 0; i < num_rx_buf; i++) {\nstruct acm_rb *rb = &(acm->read_buffers[i]);\nstruct urb *urb;\nrb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,\n&rb->dma);\nif (!rb->base)\ngoto alloc_fail6;\nrb->index = i;\nrb->instance = acm;\nurb = usb_alloc_urb(0, GFP_KERNEL);\nif (!urb)\ngoto alloc_fail6;\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\nurb->transfer_dma = rb->dma;\nif (acm->is_int_ep) {\nusb_fill_int_urb(urb, acm->dev,\nacm->rx_endpoint,\nrb->base,\nacm->readsize,\nacm_read_bulk_callback, rb,\nacm->bInterval);\n} else {\nusb_fill_bulk_urb(urb, acm->dev,\nacm->rx_endpoint,\nrb->base,\nacm->readsize,\nacm_read_bulk_callback, rb);\n}\nacm->read_urbs[i] = urb;\n__set_bit(i, &acm->read_urbs_free);\n}\nfor (i = 0; i < ACM_NW; i++) {\nstruct acm_wb *snd = &(acm->wb[i]);\nsnd->urb = usb_alloc_urb(0, GFP_KERNEL);\nif (snd->urb == NULL)\ngoto alloc_fail7;\nif (usb_endpoint_xfer_int(epwrite))\nusb_fill_int_urb(snd->urb, usb_dev,\nusb_sndintpipe(usb_dev, epwrite->bEndpointAddress),\nNULL, acm->writesize, acm_write_bulk, snd, epwrite->bInterval);\nelse\nusb_fill_bulk_urb(snd->urb, usb_dev,\nusb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),\nNULL, acm->writesize, acm_write_bulk, snd);\nsnd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\nif (quirks & SEND_ZERO_PACKET)\nsnd->urb->transfer_flags |= URB_ZERO_PACKET;\nsnd->instance = acm;\n}\nusb_set_intfdata(intf, acm);\ni = device_create_file(&intf->dev, &dev_attr_bmCapabilities);\nif (i < 0)\ngoto alloc_fail7;\nif (cfd) {\nacm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);\nif (!acm->country_codes)\ngoto skip_countries;\nacm->country_code_size = cfd->bLength - 4;\nmemcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,\ncfd->bLength - 4);\nacm->country_rel_date = cfd->iCountryCodeRelDate;\ni = device_create_file(&intf->dev, &dev_attr_wCountryCodes);\nif (i < 0) {\nkfree(acm->country_codes);\nacm->country_codes = NULL;\nacm->country_code_size = 0;\ngoto skip_countries;\n}\ni = device_create_file(&intf->dev,\n&dev_attr_iCountryCodeRelDate);\nif (i < 0) {\ndevice_remove_file(&intf->dev, &dev_attr_wCountryCodes);\nkfree(acm->country_codes);\nacm->country_codes = NULL;\nacm->country_code_size = 0;\ngoto skip_countries;\n}\n}\nskip_countries:\nusb_fill_int_urb(acm->ctrlurb, usb_dev,\nusb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),\nacm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm,\nepctrl->bInterval ? epctrl->bInterval : 16);\nacm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\nacm->ctrlurb->transfer_dma = acm->ctrl_dma;\ndev_info(&intf->dev, \"ttyACM%d: USB ACM device\\n\", minor);\nacm->line.dwDTERate = cpu_to_le32(9600);\nacm->line.bDataBits = 8;\nacm_set_line(acm, &acm->line);\nusb_driver_claim_interface(&acm_driver, data_interface, acm);\nusb_set_intfdata(data_interface, acm);\nusb_get_intf(control_interface);\ntty_dev = tty_port_register_device(&acm->port, acm_tty_driver, minor,\n&control_interface->dev);\nif (IS_ERR(tty_dev)) {\nrv = PTR_ERR(tty_dev);\ngoto alloc_fail8;\n}\nif (quirks & CLEAR_HALT_CONDITIONS) {\nusb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress));\nusb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress));\n}\nreturn 0;\nalloc_fail8:\nif (acm->country_codes) {\ndevice_remove_file(&acm->control->dev,\n&dev_attr_wCountryCodes);\ndevice_remove_file(&acm->control->dev,\n&dev_attr_iCountryCodeRelDate);\nkfree(acm->country_codes);\n}\ndevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\nalloc_fail7:\nusb_set_intfdata(intf, NULL);\nfor (i = 0; i < ACM_NW; i++)\nusb_free_urb(acm->wb[i].urb);\nalloc_fail6:\nfor (i = 0; i < num_rx_buf; i++)\nusb_free_urb(acm->read_urbs[i]);\nacm_read_buffers_free(acm);\nusb_free_urb(acm->ctrlurb);\nalloc_fail5:\nacm_write_buffers_free(acm);\nalloc_fail4:\nusb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\nalloc_fail2:\nacm_release_minor(acm);\nkfree(acm);\nalloc_fail:\nreturn rv;\n}", "label": 0}
{"index": 176714, "code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\nstruct bpf_insn *insn = prog->insnsi;\nint insn_cnt = prog->len;\nint i;\nfor (i = 0; i < insn_cnt; i++, insn++) {\nif (BPF_CLASS(insn->code) != BPF_JMP ||\nBPF_OP(insn->code) == BPF_CALL ||\nBPF_OP(insn->code) == BPF_EXIT)\ncontinue;\nif (i < pos && i + insn->off + 1 > pos)\ninsn->off += delta;\nelse if (i > pos && i + insn->off + 1 < pos)\ninsn->off -= delta;\n}\n}", "contrast": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\nstruct bpf_insn *insn = prog->insnsi;\nint insn_cnt = prog->len;\nint i;\nfor (i = 0; i < insn_cnt; i++, insn++) {\nif (BPF_CLASS(insn->code) != BPF_JMP ||\nBPF_OP(insn->code) == BPF_CALL ||\nBPF_OP(insn->code) == BPF_EXIT)\ncontinue;\nif (i < pos && i + insn->off + 1 > pos)\ninsn->off += delta;\nelse if (i > pos + delta && i + insn->off + 1 <= pos + delta)\ninsn->off -= delta;\n}\n}", "label": 0}
{"index": 176717, "code": "static void finish_object(struct object *obj,\nstruct strbuf *path, const char *name,\nvoid *cb_data)\n{\nstruct rev_list_info *info = cb_data;\nif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\ndie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\nif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\nparse_object(obj->oid.hash);\n}", "contrast": "static void finish_object(struct object *obj,\nstatic void finish_object(struct object *obj, const char *name, void *cb_data)\n{\nstruct rev_list_info *info = cb_data;\nif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\ndie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\nif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\nparse_object(obj->oid.hash);\n}", "label": 0}
{"index": 176721, "code": "void traverse_commit_list(struct rev_info *revs,\nshow_commit_fn show_commit,\nshow_object_fn show_object,\nvoid *data)\n{\nint i;\nstruct commit *commit;\nstruct strbuf base;\nstrbuf_init(&base, PATH_MAX);\nwhile ((commit = get_revision(revs)) != NULL) {\nif (commit->tree)\nadd_pending_tree(revs, commit->tree);\nshow_commit(commit, data);\n}\nfor (i = 0; i < revs->pending.nr; i++) {\nstruct object_array_entry *pending = revs->pending.objects + i;\nstruct object *obj = pending->item;\nconst char *name = pending->name;\nconst char *path = pending->path;\nif (obj->flags & (UNINTERESTING | SEEN))\ncontinue;\nif (obj->type == OBJ_TAG) {\nobj->flags |= SEEN;\nshow_object(obj, NULL, name, data);\ncontinue;\n}\nif (!path)\npath = \"\";\nif (obj->type == OBJ_TREE) {\nprocess_tree(revs, (struct tree *)obj, show_object,\n&base, path, data);\ncontinue;\n}\nif (obj->type == OBJ_BLOB) {\nprocess_blob(revs, (struct blob *)obj, show_object,\nNULL, path, data);\ncontinue;\n}\ndie(\"unknown pending object %s (%s)\",\noid_to_hex(&obj->oid), name);\n}\nobject_array_clear(&revs->pending);\nstrbuf_release(&base);\n}", "contrast": "void traverse_commit_list(struct rev_info *revs,\nshow_commit_fn show_commit,\nshow_object_fn show_object,\nvoid *data)\n{\nint i;\nstruct commit *commit;\nstruct strbuf base;\nstrbuf_init(&base, PATH_MAX);\nwhile ((commit = get_revision(revs)) != NULL) {\nif (commit->tree)\nadd_pending_tree(revs, commit->tree);\nshow_commit(commit, data);\n}\nfor (i = 0; i < revs->pending.nr; i++) {\nstruct object_array_entry *pending = revs->pending.objects + i;\nstruct object *obj = pending->item;\nconst char *name = pending->name;\nconst char *path = pending->path;\nif (obj->flags & (UNINTERESTING | SEEN))\ncontinue;\nif (obj->type == OBJ_TAG) {\nobj->flags |= SEEN;\nshow_object(obj, name, data);\ncontinue;\n}\nif (!path)\npath = \"\";\nif (obj->type == OBJ_TREE) {\nprocess_tree(revs, (struct tree *)obj, show_object,\n&base, path, data);\ncontinue;\n}\nif (obj->type == OBJ_BLOB) {\nprocess_blob(revs, (struct blob *)obj, show_object,\n&base, path, data);\ncontinue;\n}\ndie(\"unknown pending object %s (%s)\",\noid_to_hex(&obj->oid), name);\n}\nobject_array_clear(&revs->pending);\nstrbuf_release(&base);\n}", "label": 0}
{"index": 176743, "code": "int ecryptfs_privileged_open(struct file **lower_file,\nstruct dentry *lower_dentry,\nstruct vfsmount *lower_mnt,\nconst struct cred *cred)\n{\nstruct ecryptfs_open_req req;\nint flags = O_LARGEFILE;\nint rc = 0;\ninit_completion(&req.done);\nreq.lower_file = lower_file;\nreq.path.dentry = lower_dentry;\nreq.path.mnt = lower_mnt;\nflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n(*lower_file) = dentry_open(&req.path, flags, cred);\nif (!IS_ERR(*lower_file))\ngoto out;\nif ((flags & O_ACCMODE) == O_RDONLY) {\nrc = PTR_ERR((*lower_file));\ngoto out;\n}\nmutex_lock(&ecryptfs_kthread_ctl.mux);\nif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\nrc = -EIO;\nmutex_unlock(&ecryptfs_kthread_ctl.mux);\nprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\"aborting privileged request to open lower file\\n\",\n__func__);\ngoto out;\n}\nlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\nmutex_unlock(&ecryptfs_kthread_ctl.mux);\nwake_up(&ecryptfs_kthread_ctl.wait);\nwait_for_completion(&req.done);\nif (IS_ERR(*lower_file))\nrc = PTR_ERR(*lower_file);\nout:\nreturn rc;\n}", "contrast": "int ecryptfs_privileged_open(struct file **lower_file,\nstruct dentry *lower_dentry,\nstruct vfsmount *lower_mnt,\nconst struct cred *cred)\n{\nstruct ecryptfs_open_req req;\nint flags = O_LARGEFILE;\nint rc = 0;\ninit_completion(&req.done);\nreq.lower_file = lower_file;\nreq.path.dentry = lower_dentry;\nreq.path.mnt = lower_mnt;\nflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n(*lower_file) = dentry_open(&req.path, flags, cred);\nif (!IS_ERR(*lower_file))\ngoto have_file;\nif ((flags & O_ACCMODE) == O_RDONLY) {\nrc = PTR_ERR((*lower_file));\ngoto out;\n}\nmutex_lock(&ecryptfs_kthread_ctl.mux);\nif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\nrc = -EIO;\nmutex_unlock(&ecryptfs_kthread_ctl.mux);\nprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\"aborting privileged request to open lower file\\n\",\n__func__);\ngoto out;\n}\nlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\nmutex_unlock(&ecryptfs_kthread_ctl.mux);\nwake_up(&ecryptfs_kthread_ctl.wait);\nwait_for_completion(&req.done);\nif (IS_ERR(*lower_file)) {\nrc = PTR_ERR(*lower_file);\ngoto out;\n}\nhave_file:\nif ((*lower_file)->f_op->mmap == NULL) {\nfput(*lower_file);\n*lower_file = NULL;\nrc = -EMEDIUMTYPE;\n}\nout:\nreturn rc;\n}", "label": 0}
{"index": 176744, "code": "static struct dentry *proc_mount(struct file_system_type *fs_type,\nint flags, const char *dev_name, void *data)\n{\nint err;\nstruct super_block *sb;\nstruct pid_namespace *ns;\nchar *options;\nif (flags & MS_KERNMOUNT) {\nns = (struct pid_namespace *)data;\noptions = NULL;\n} else {\nns = task_active_pid_ns(current);\noptions = data;\nif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\nreturn ERR_PTR(-EPERM);\n}\nsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\nif (IS_ERR(sb))\nreturn ERR_CAST(sb);\nif (!proc_parse_options(options, ns)) {\ndeactivate_locked_super(sb);\nreturn ERR_PTR(-EINVAL);\n}\nif (!sb->s_root) {\nerr = proc_fill_super(sb);\nif (err) {\ndeactivate_locked_super(sb);\nreturn ERR_PTR(err);\n}\nsb->s_flags |= MS_ACTIVE;\nsb->s_iflags |= SB_I_NOEXEC;\n}\nreturn dget(sb->s_root);\n}", "contrast": "static struct dentry *proc_mount(struct file_system_type *fs_type,\nint flags, const char *dev_name, void *data)\n{\nint err;\nstruct super_block *sb;\nstruct pid_namespace *ns;\nchar *options;\nif (flags & MS_KERNMOUNT) {\nns = (struct pid_namespace *)data;\noptions = NULL;\n} else {\nns = task_active_pid_ns(current);\noptions = data;\nif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\nreturn ERR_PTR(-EPERM);\n}\nsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\nif (IS_ERR(sb))\nreturn ERR_CAST(sb);\nsb->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;\nif (!proc_parse_options(options, ns)) {\ndeactivate_locked_super(sb);\nreturn ERR_PTR(-EINVAL);\n}\nif (!sb->s_root) {\nerr = proc_fill_super(sb);\nif (err) {\ndeactivate_locked_super(sb);\nreturn ERR_PTR(err);\n}\nsb->s_flags |= MS_ACTIVE;\nsb->s_iflags |= SB_I_NOEXEC;\n}\nreturn dget(sb->s_root);\n}", "label": 0}
{"index": 176752, "code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\nstruct skcipher_ctx *ctx;\nstruct alg_sock *ask = alg_sk(sk);\nunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\nif (!ctx)\nreturn -ENOMEM;\nctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\nGFP_KERNEL);\nif (!ctx->iv) {\nsock_kfree_s(sk, ctx, len);\nreturn -ENOMEM;\n}\nmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\nINIT_LIST_HEAD(&ctx->tsgl);\nctx->len = len;\nctx->used = 0;\nctx->more = 0;\nctx->merge = 0;\nctx->enc = 0;\natomic_set(&ctx->inflight, 0);\naf_alg_init_completion(&ctx->completion);\nask->private = ctx;\nskcipher_request_set_tfm(&ctx->req, private);\nskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\naf_alg_complete, &ctx->completion);\nsk->sk_destruct = skcipher_sock_destruct;\nreturn 0;\n}", "contrast": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\nstruct skcipher_ctx *ctx;\nstruct alg_sock *ask = alg_sk(sk);\nstruct skcipher_tfm *tfm = private;\nstruct crypto_skcipher *skcipher = tfm->skcipher;\nunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\nif (!tfm->has_key)\nreturn -ENOKEY;\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\nif (!ctx)\nreturn -ENOMEM;\nctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\nGFP_KERNEL);\nif (!ctx->iv) {\nsock_kfree_s(sk, ctx, len);\nreturn -ENOMEM;\n}\nmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\nINIT_LIST_HEAD(&ctx->tsgl);\nctx->len = len;\nctx->used = 0;\nctx->more = 0;\nctx->merge = 0;\nctx->enc = 0;\natomic_set(&ctx->inflight, 0);\naf_alg_init_completion(&ctx->completion);\nask->private = ctx;\nskcipher_request_set_tfm(&ctx->req, skcipher);\nskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\naf_alg_complete, &ctx->completion);\nsk->sk_destruct = skcipher_sock_destruct;\nreturn 0;\n}", "label": 0}
{"index": 176754, "code": "static void skcipher_release(void *private)\n{\ncrypto_free_skcipher(private);\n}", "contrast": "static void skcipher_release(void *private)\n{\nstruct skcipher_tfm *tfm = private;\ncrypto_free_skcipher(tfm->skcipher);\nkfree(tfm);\n}", "label": 0}
{"index": 176763, "code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\nunsigned long val;\nvoid *ptr = NULL;\nif (!atomic_pool) {\nWARN(1, \"coherent pool not initialised!\\n\");\nreturn NULL;\n}\nval = gen_pool_alloc(atomic_pool, size);\nif (val) {\nphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n*ret_page = phys_to_page(phys);\nptr = (void *)val;\nif (flags & __GFP_ZERO)\nmemset(ptr, 0, size);\n}\nreturn ptr;\n}", "contrast": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\nunsigned long val;\nvoid *ptr = NULL;\nif (!atomic_pool) {\nWARN(1, \"coherent pool not initialised!\\n\");\nreturn NULL;\n}\nval = gen_pool_alloc(atomic_pool, size);\nif (val) {\nphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n*ret_page = phys_to_page(phys);\nptr = (void *)val;\nmemset(ptr, 0, size);\n}\nreturn ptr;\n}", "label": 0}
{"index": 176775, "code": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\nint result;\nhandle_t *handle = NULL;\nstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\nbool write = vmf->flags & FAULT_FLAG_WRITE;\nif (write) {\nsb_start_pagefault(sb);\nfile_update_time(vma->vm_file);\nhandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\nEXT4_DATA_TRANS_BLOCKS(sb));\n}\nif (IS_ERR(handle))\nresult = VM_FAULT_SIGBUS;\nelse\nresult = __dax_fault(vma, vmf, ext4_get_block_dax,\next4_end_io_unwritten);\nif (write) {\nif (!IS_ERR(handle))\next4_journal_stop(handle);\nsb_end_pagefault(sb);\n}\nreturn result;\n}", "contrast": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\nint result;\nhandle_t *handle = NULL;\nstruct inode *inode = file_inode(vma->vm_file);\nstruct super_block *sb = inode->i_sb;\nbool write = vmf->flags & FAULT_FLAG_WRITE;\nif (write) {\nsb_start_pagefault(sb);\nfile_update_time(vma->vm_file);\ndown_read(&EXT4_I(inode)->i_mmap_sem);\nhandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\nEXT4_DATA_TRANS_BLOCKS(sb));\n} else\ndown_read(&EXT4_I(inode)->i_mmap_sem);\nif (IS_ERR(handle))\nresult = VM_FAULT_SIGBUS;\nelse\nresult = __dax_fault(vma, vmf, ext4_get_block_dax,\next4_end_io_unwritten);\nif (write) {\nif (!IS_ERR(handle))\next4_journal_stop(handle);\nup_read(&EXT4_I(inode)->i_mmap_sem);\nsb_end_pagefault(sb);\n} else\nup_read(&EXT4_I(inode)->i_mmap_sem);\nreturn result;\n}", "label": 0}
{"index": 176787, "code": "NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\nstatic const char module[] = \"NeXTDecode\";\nunsigned char *bp, *op;\ntmsize_t cc;\nuint8* row;\ntmsize_t scanline, n;\n(void) s;\nfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n*op++ = 0xff;\nbp = (unsigned char *)tif->tif_rawcp;\ncc = tif->tif_rawcc;\nscanline = tif->tif_scanlinesize;\nif (occ % scanline)\n{\nTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\nreturn (0);\n}\nfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\nn = *bp++, cc--;\nswitch (n) {\ncase LITERALROW:\nif (cc < scanline)\ngoto bad;\n_TIFFmemcpy(row, bp, scanline);\nbp += scanline;\ncc -= scanline;\nbreak;\ncase LITERALSPAN: {\ntmsize_t off;\nif( cc < 4 )\ngoto bad;\noff = (bp[0] * 256) + bp[1];\nn = (bp[2] * 256) + bp[3];\nif (cc < 4+n || off+n > scanline)\ngoto bad;\n_TIFFmemcpy(row+off, bp+4, n);\nbp += 4+n;\ncc -= 4+n;\nbreak;\n}\ndefault: {\nuint32 npixels = 0, grey;\nuint32 imagewidth = tif->tif_dir.td_imagewidth;\nif( isTiled(tif) )\nimagewidth = tif->tif_dir.td_tilewidth;\nop = row;\nfor (;;) {\ngrey = (uint32)((n>>6) & 0x3);\nn &= 0x3f;\nwhile (n-- > 0 && npixels < imagewidth)\nSETPIXEL(op, grey);\nif (npixels >= imagewidth)\nbreak;\nif (cc == 0)\ngoto bad;\nn = *bp++, cc--;\n}\nbreak;\n}\n}\n}\ntif->tif_rawcp = (uint8*) bp;\ntif->tif_rawcc = cc;\nreturn (1);\nbad:\nTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n(long) tif->tif_row);\nreturn (0);\n}", "contrast": "NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\nstatic const char module[] = \"NeXTDecode\";\nunsigned char *bp, *op;\ntmsize_t cc;\nuint8* row;\ntmsize_t scanline, n;\n(void) s;\nfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n*op++ = 0xff;\nbp = (unsigned char *)tif->tif_rawcp;\ncc = tif->tif_rawcc;\nscanline = tif->tif_scanlinesize;\nif (occ % scanline)\n{\nTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\nreturn (0);\n}\nfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\nn = *bp++, cc--;\nswitch (n) {\ncase LITERALROW:\nif (cc < scanline)\ngoto bad;\n_TIFFmemcpy(row, bp, scanline);\nbp += scanline;\ncc -= scanline;\nbreak;\ncase LITERALSPAN: {\ntmsize_t off;\nif( cc < 4 )\ngoto bad;\noff = (bp[0] * 256) + bp[1];\nn = (bp[2] * 256) + bp[3];\nif (cc < 4+n || off+n > scanline)\ngoto bad;\n_TIFFmemcpy(row+off, bp+4, n);\nbp += 4+n;\ncc -= 4+n;\nbreak;\n}\ndefault: {\nuint32 npixels = 0, grey;\nuint32 imagewidth = tif->tif_dir.td_imagewidth;\nif( isTiled(tif) )\nimagewidth = tif->tif_dir.td_tilewidth;\ntmsize_t op_offset = 0;\nop = row;\nfor (;;) {\ngrey = (uint32)((n>>6) & 0x3);\nn &= 0x3f;\nwhile (n-- > 0 && npixels < imagewidth && op_offset < scanline)\nSETPIXEL(op, grey);\nif (npixels >= imagewidth)\nbreak;\nif (op_offset >= scanline ) {\nTIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\",\n(long) tif->tif_row);\nreturn (0);\n}\nif (cc == 0)\ngoto bad;\nn = *bp++, cc--;\n}\nbreak;\n}\n}\n}\ntif->tif_rawcp = (uint8*) bp;\ntif->tif_rawcc = cc;\nreturn (1);\nbad:\nTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n(long) tif->tif_row);\nreturn (0);\n}", "label": 0}
{"index": 176799, "code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\nstatic generic_ret              ret;\nchar                            *prime_arg;\ngss_buffer_desc                 client_name,\nservice_name;\nOM_uint32                       minor_stat;\nkadm5_server_handle_t           handle;\nconst char                      *errmsg = NULL;\nxdr_free(xdr_generic_ret, &ret);\nif ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\ngoto exit_func;\nif ((ret.code = check_handle((void *)handle)))\ngoto exit_func;\nret.api_version = handle->api_version;\nif (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\nret.code = KADM5_FAILURE;\ngoto exit_func;\n}\nprime_arg = arg->name;\nif (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\nrqst2name(rqstp),\nACL_DELETE, NULL, NULL)) {\nlog_unauth(\"kadm5_delete_policy\", prime_arg,\n&client_name, &service_name, rqstp);\nret.code = KADM5_AUTH_DELETE;\n} else {\nret.code = kadm5_delete_policy((void *)handle, arg->name);\nif( ret.code != 0 )\nerrmsg = krb5_get_error_message(handle->context, ret.code);\nlog_done(\"kadm5_delete_policy\",\n((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n&client_name, &service_name, rqstp);\nif (errmsg != NULL)\nkrb5_free_error_message(handle->context, errmsg);\n}\ngss_release_buffer(&minor_stat, &client_name);\ngss_release_buffer(&minor_stat, &service_name);\nexit_func:\nfree_server_handle(handle);\nreturn &ret;\n}", "contrast": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\nstatic generic_ret              ret;\nchar                            *prime_arg;\ngss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\ngss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\nOM_uint32                       minor_stat;\nkadm5_server_handle_t           handle;\nconst char                      *errmsg = NULL;\nxdr_free(xdr_generic_ret, &ret);\nif ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\ngoto exit_func;\nif ((ret.code = check_handle((void *)handle)))\ngoto exit_func;\nret.api_version = handle->api_version;\nif (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\nret.code = KADM5_FAILURE;\ngoto exit_func;\n}\nprime_arg = arg->name;\nif (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\nrqst2name(rqstp),\nACL_DELETE, NULL, NULL)) {\nlog_unauth(\"kadm5_delete_policy\", prime_arg,\n&client_name, &service_name, rqstp);\nret.code = KADM5_AUTH_DELETE;\n} else {\nret.code = kadm5_delete_policy((void *)handle, arg->name);\nif( ret.code != 0 )\nerrmsg = krb5_get_error_message(handle->context, ret.code);\nlog_done(\"kadm5_delete_policy\",\n((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n&client_name, &service_name, rqstp);\nif (errmsg != NULL)\nkrb5_free_error_message(handle->context, errmsg);\n}\nexit_func:\ngss_release_buffer(&minor_stat, &client_name);\ngss_release_buffer(&minor_stat, &service_name);\nfree_server_handle(handle);\nreturn &ret;\n}", "label": 0}
{"index": 176822, "code": "ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\next4_lblk_t iblock, unsigned int max_blocks,\nstruct ext4_ext_path *path, int flags,\nunsigned int allocated, struct buffer_head *bh_result,\next4_fsblk_t newblock)\n{\nint ret = 0;\nint err = 0;\next4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;\next_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical\"\n\"block %llu, max_blocks %u, flags %d, allocated %u\",\ninode->i_ino, (unsigned long long)iblock, max_blocks,\nflags, allocated);\next4_ext_show_leaf(inode, path);\nif (flags == EXT4_GET_BLOCKS_PRE_IO) {\nret = ext4_split_unwritten_extents(handle,\ninode, path, iblock,\nmax_blocks, flags);\nif (io)\nio->flag = EXT4_IO_UNWRITTEN;\nelse\next4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\ngoto out;\n}\nif (flags == EXT4_GET_BLOCKS_CONVERT) {\nret = ext4_convert_unwritten_extents_endio(handle, inode,\npath);\nif (ret >= 0)\next4_update_inode_fsync_trans(handle, inode, 1);\ngoto out2;\n}\nif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\ngoto map_out;\nif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\nset_buffer_unwritten(bh_result);\ngoto out1;\n}\nret = ext4_ext_convert_to_initialized(handle, inode,\npath, iblock,\nmax_blocks);\nif (ret >= 0)\next4_update_inode_fsync_trans(handle, inode, 1);\nout:\nif (ret <= 0) {\nerr = ret;\ngoto out2;\n} else\nallocated = ret;\nset_buffer_new(bh_result);\nif (allocated > max_blocks) {\nunmap_underlying_metadata_blocks(inode->i_sb->s_bdev,\nnewblock + max_blocks,\nallocated - max_blocks);\nallocated = max_blocks;\n}\nif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\next4_da_update_reserve_space(inode, allocated, 0);\nmap_out:\nset_buffer_mapped(bh_result);\nout1:\nif (allocated > max_blocks)\nallocated = max_blocks;\next4_ext_show_leaf(inode, path);\nbh_result->b_bdev = inode->i_sb->s_bdev;\nbh_result->b_blocknr = newblock;\nout2:\nif (path) {\next4_ext_drop_refs(path);\nkfree(path);\n}\nreturn err ? err : allocated;\n}", "contrast": "ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\next4_lblk_t iblock, unsigned int max_blocks,\nstruct ext4_ext_path *path, int flags,\nunsigned int allocated, struct buffer_head *bh_result,\next4_fsblk_t newblock)\n{\nint ret = 0;\nint err = 0;\next4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;\next_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical\"\n\"block %llu, max_blocks %u, flags %d, allocated %u\",\ninode->i_ino, (unsigned long long)iblock, max_blocks,\nflags, allocated);\next4_ext_show_leaf(inode, path);\nif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\nret = ext4_split_unwritten_extents(handle,\ninode, path, iblock,\nmax_blocks, flags);\nif (io)\nio->flag = EXT4_IO_UNWRITTEN;\nelse\next4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\nif (ext4_should_dioread_nolock(inode))\nset_buffer_uninit(bh_result);\ngoto out;\n}\nif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\nret = ext4_convert_unwritten_extents_endio(handle, inode,\npath);\nif (ret >= 0)\next4_update_inode_fsync_trans(handle, inode, 1);\ngoto out2;\n}\nif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\ngoto map_out;\nif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\nset_buffer_unwritten(bh_result);\ngoto out1;\n}\nret = ext4_ext_convert_to_initialized(handle, inode,\npath, iblock,\nmax_blocks);\nif (ret >= 0)\next4_update_inode_fsync_trans(handle, inode, 1);\nout:\nif (ret <= 0) {\nerr = ret;\ngoto out2;\n} else\nallocated = ret;\nset_buffer_new(bh_result);\nif (allocated > max_blocks) {\nunmap_underlying_metadata_blocks(inode->i_sb->s_bdev,\nnewblock + max_blocks,\nallocated - max_blocks);\nallocated = max_blocks;\n}\nif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\next4_da_update_reserve_space(inode, allocated, 0);\nmap_out:\nset_buffer_mapped(bh_result);\nout1:\nif (allocated > max_blocks)\nallocated = max_blocks;\next4_ext_show_leaf(inode, path);\nbh_result->b_bdev = inode->i_sb->s_bdev;\nbh_result->b_blocknr = newblock;\nout2:\nif (path) {\next4_ext_drop_refs(path);\nkfree(path);\n}\nreturn err ? err : allocated;\n}", "label": 0}
{"index": 176827, "code": "static void ext4_end_io_work(struct work_struct *work)\n{\next4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\nstruct inode *inode = io->inode;\nint ret = 0;\nmutex_lock(&inode->i_mutex);\nret = ext4_end_io_nolock(io);\nif (ret >= 0) {\nif (!list_empty(&io->list))\nlist_del_init(&io->list);\next4_free_io_end(io);\n}\nmutex_unlock(&inode->i_mutex);\n}", "contrast": "static void ext4_end_io_work(struct work_struct *work)\n{\next4_io_end_t\t\t*io = container_of(work, ext4_io_end_t, work);\nstruct inode\t\t*inode = io->inode;\nstruct ext4_inode_info\t*ei = EXT4_I(inode);\nunsigned long\t\tflags;\nint\t\t\tret;\nmutex_lock(&inode->i_mutex);\nret = ext4_end_io_nolock(io);\nif (ret < 0) {\nmutex_unlock(&inode->i_mutex);\nreturn;\n}\nspin_lock_irqsave(&ei->i_completed_io_lock, flags);\nif (!list_empty(&io->list))\nlist_del_init(&io->list);\nspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\nmutex_unlock(&inode->i_mutex);\next4_free_io_end(io);\n}", "label": 0}
{"index": 176835, "code": "int flush_completed_IO(struct inode *inode)\n{\next4_io_end_t *io;\nint ret = 0;\nint ret2 = 0;\nif (list_empty(&EXT4_I(inode)->i_completed_io_list))\nreturn ret;\ndump_completed_IO(inode);\nwhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\nio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\next4_io_end_t, list);\nret = ext4_end_io_nolock(io);\nif (ret < 0)\nret2 = ret;\nelse\nlist_del_init(&io->list);\n}\nreturn (ret2 < 0) ? ret2 : 0;\n}", "contrast": "int flush_completed_IO(struct inode *inode)\n{\next4_io_end_t *io;\nstruct ext4_inode_info *ei = EXT4_I(inode);\nunsigned long flags;\nint ret = 0;\nint ret2 = 0;\nif (list_empty(&ei->i_completed_io_list))\nreturn ret;\ndump_completed_IO(inode);\nspin_lock_irqsave(&ei->i_completed_io_lock, flags);\nwhile (!list_empty(&ei->i_completed_io_list)){\nio = list_entry(ei->i_completed_io_list.next,\next4_io_end_t, list);\nspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\nret = ext4_end_io_nolock(io);\nspin_lock_irqsave(&ei->i_completed_io_lock, flags);\nif (ret < 0)\nret2 = ret;\nelse\nlist_del_init(&io->list);\n}\nspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\nreturn (ret2 < 0) ? ret2 : 0;\n}", "label": 0}
{"index": 176840, "code": "static int ext4_show_options(struct seq_file *seq, struct vfsmount *vfs)\n{\nint def_errors;\nunsigned long def_mount_opts;\nstruct super_block *sb = vfs->mnt_sb;\nstruct ext4_sb_info *sbi = EXT4_SB(sb);\nstruct ext4_super_block *es = sbi->s_es;\ndef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\ndef_errors     = le16_to_cpu(es->s_errors);\nif (sbi->s_sb_block != 1)\nseq_printf(seq, \",sb=%llu\", sbi->s_sb_block);\nif (test_opt(sb, MINIX_DF))\nseq_puts(seq, \",minixdf\");\nif (test_opt(sb, GRPID) && !(def_mount_opts & EXT4_DEFM_BSDGROUPS))\nseq_puts(seq, \",grpid\");\nif (!test_opt(sb, GRPID) && (def_mount_opts & EXT4_DEFM_BSDGROUPS))\nseq_puts(seq, \",nogrpid\");\nif (sbi->s_resuid != EXT4_DEF_RESUID ||\nle16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID) {\nseq_printf(seq, \",resuid=%u\", sbi->s_resuid);\n}\nif (sbi->s_resgid != EXT4_DEF_RESGID ||\nle16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID) {\nseq_printf(seq, \",resgid=%u\", sbi->s_resgid);\n}\nif (test_opt(sb, ERRORS_RO)) {\nif (def_errors == EXT4_ERRORS_PANIC ||\ndef_errors == EXT4_ERRORS_CONTINUE) {\nseq_puts(seq, \",errors=remount-ro\");\n}\n}\nif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\nseq_puts(seq, \",errors=continue\");\nif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\nseq_puts(seq, \",errors=panic\");\nif (test_opt(sb, NO_UID32) && !(def_mount_opts & EXT4_DEFM_UID16))\nseq_puts(seq, \",nouid32\");\nif (test_opt(sb, DEBUG) && !(def_mount_opts & EXT4_DEFM_DEBUG))\nseq_puts(seq, \",debug\");\nif (test_opt(sb, OLDALLOC))\nseq_puts(seq, \",oldalloc\");\n#ifdef CONFIG_EXT4_FS_XATTR\nif (test_opt(sb, XATTR_USER) &&\n!(def_mount_opts & EXT4_DEFM_XATTR_USER))\nseq_puts(seq, \",user_xattr\");\nif (!test_opt(sb, XATTR_USER) &&\n(def_mount_opts & EXT4_DEFM_XATTR_USER)) {\nseq_puts(seq, \",nouser_xattr\");\n}\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\nif (test_opt(sb, POSIX_ACL) && !(def_mount_opts & EXT4_DEFM_ACL))\nseq_puts(seq, \",acl\");\nif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT4_DEFM_ACL))\nseq_puts(seq, \",noacl\");\n#endif\nif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\nseq_printf(seq, \",commit=%u\",\n(unsigned) (sbi->s_commit_interval / HZ));\n}\nif (sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME) {\nseq_printf(seq, \",min_batch_time=%u\",\n(unsigned) sbi->s_min_batch_time);\n}\nif (sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME) {\nseq_printf(seq, \",max_batch_time=%u\",\n(unsigned) sbi->s_min_batch_time);\n}\nseq_puts(seq, \",barrier=\");\nseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\nif (test_opt(sb, JOURNAL_ASYNC_COMMIT))\nseq_puts(seq, \",journal_async_commit\");\nif (test_opt(sb, NOBH))\nseq_puts(seq, \",nobh\");\nif (test_opt(sb, I_VERSION))\nseq_puts(seq, \",i_version\");\nif (!test_opt(sb, DELALLOC))\nseq_puts(seq, \",nodelalloc\");\nif (sbi->s_stripe)\nseq_printf(seq, \",stripe=%lu\", sbi->s_stripe);\nif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\nseq_puts(seq, \",data=journal\");\nelse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\nseq_puts(seq, \",data=ordered\");\nelse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\nseq_puts(seq, \",data=writeback\");\nif (sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\nseq_printf(seq, \",inode_readahead_blks=%u\",\nsbi->s_inode_readahead_blks);\nif (test_opt(sb, DATA_ERR_ABORT))\nseq_puts(seq, \",data_err=abort\");\nif (test_opt(sb, NO_AUTO_DA_ALLOC))\nseq_puts(seq, \",noauto_da_alloc\");\nif (test_opt(sb, DISCARD))\nseq_puts(seq, \",discard\");\nif (test_opt(sb, NOLOAD))\nseq_puts(seq, \",norecovery\");\next4_show_quota_options(seq, sb);\nreturn 0;\n}", "contrast": "static int ext4_show_options(struct seq_file *seq, struct vfsmount *vfs)\n{\nint def_errors;\nunsigned long def_mount_opts;\nstruct super_block *sb = vfs->mnt_sb;\nstruct ext4_sb_info *sbi = EXT4_SB(sb);\nstruct ext4_super_block *es = sbi->s_es;\ndef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\ndef_errors     = le16_to_cpu(es->s_errors);\nif (sbi->s_sb_block != 1)\nseq_printf(seq, \",sb=%llu\", sbi->s_sb_block);\nif (test_opt(sb, MINIX_DF))\nseq_puts(seq, \",minixdf\");\nif (test_opt(sb, GRPID) && !(def_mount_opts & EXT4_DEFM_BSDGROUPS))\nseq_puts(seq, \",grpid\");\nif (!test_opt(sb, GRPID) && (def_mount_opts & EXT4_DEFM_BSDGROUPS))\nseq_puts(seq, \",nogrpid\");\nif (sbi->s_resuid != EXT4_DEF_RESUID ||\nle16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID) {\nseq_printf(seq, \",resuid=%u\", sbi->s_resuid);\n}\nif (sbi->s_resgid != EXT4_DEF_RESGID ||\nle16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID) {\nseq_printf(seq, \",resgid=%u\", sbi->s_resgid);\n}\nif (test_opt(sb, ERRORS_RO)) {\nif (def_errors == EXT4_ERRORS_PANIC ||\ndef_errors == EXT4_ERRORS_CONTINUE) {\nseq_puts(seq, \",errors=remount-ro\");\n}\n}\nif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\nseq_puts(seq, \",errors=continue\");\nif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\nseq_puts(seq, \",errors=panic\");\nif (test_opt(sb, NO_UID32) && !(def_mount_opts & EXT4_DEFM_UID16))\nseq_puts(seq, \",nouid32\");\nif (test_opt(sb, DEBUG) && !(def_mount_opts & EXT4_DEFM_DEBUG))\nseq_puts(seq, \",debug\");\nif (test_opt(sb, OLDALLOC))\nseq_puts(seq, \",oldalloc\");\n#ifdef CONFIG_EXT4_FS_XATTR\nif (test_opt(sb, XATTR_USER) &&\n!(def_mount_opts & EXT4_DEFM_XATTR_USER))\nseq_puts(seq, \",user_xattr\");\nif (!test_opt(sb, XATTR_USER) &&\n(def_mount_opts & EXT4_DEFM_XATTR_USER)) {\nseq_puts(seq, \",nouser_xattr\");\n}\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\nif (test_opt(sb, POSIX_ACL) && !(def_mount_opts & EXT4_DEFM_ACL))\nseq_puts(seq, \",acl\");\nif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT4_DEFM_ACL))\nseq_puts(seq, \",noacl\");\n#endif\nif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\nseq_printf(seq, \",commit=%u\",\n(unsigned) (sbi->s_commit_interval / HZ));\n}\nif (sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME) {\nseq_printf(seq, \",min_batch_time=%u\",\n(unsigned) sbi->s_min_batch_time);\n}\nif (sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME) {\nseq_printf(seq, \",max_batch_time=%u\",\n(unsigned) sbi->s_min_batch_time);\n}\nseq_puts(seq, \",barrier=\");\nseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\nif (test_opt(sb, JOURNAL_ASYNC_COMMIT))\nseq_puts(seq, \",journal_async_commit\");\nif (test_opt(sb, NOBH))\nseq_puts(seq, \",nobh\");\nif (test_opt(sb, I_VERSION))\nseq_puts(seq, \",i_version\");\nif (!test_opt(sb, DELALLOC))\nseq_puts(seq, \",nodelalloc\");\nif (sbi->s_stripe)\nseq_printf(seq, \",stripe=%lu\", sbi->s_stripe);\nif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\nseq_puts(seq, \",data=journal\");\nelse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\nseq_puts(seq, \",data=ordered\");\nelse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\nseq_puts(seq, \",data=writeback\");\nif (sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\nseq_printf(seq, \",inode_readahead_blks=%u\",\nsbi->s_inode_readahead_blks);\nif (test_opt(sb, DATA_ERR_ABORT))\nseq_puts(seq, \",data_err=abort\");\nif (test_opt(sb, NO_AUTO_DA_ALLOC))\nseq_puts(seq, \",noauto_da_alloc\");\nif (test_opt(sb, DISCARD))\nseq_puts(seq, \",discard\");\nif (test_opt(sb, NOLOAD))\nseq_puts(seq, \",norecovery\");\nif (test_opt(sb, DIOREAD_NOLOCK))\nseq_puts(seq, \",dioread_nolock\");\next4_show_quota_options(seq, sb);\nreturn 0;\n}", "label": 0}
{"index": 176844, "code": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\nmutex_lock(&kvm->arch.vpit->pit_state.lock);\nmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\nkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\nmutex_unlock(&kvm->arch.vpit->pit_state.lock);\nreturn 0;\n}", "contrast": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\nint i;\nmutex_lock(&kvm->arch.vpit->pit_state.lock);\nmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\nfor (i = 0; i < 3; i++)\nkvm_pit_load_count(kvm, i, ps->channels[i].count, 0);\nmutex_unlock(&kvm->arch.vpit->pit_state.lock);\nreturn 0;\n}", "label": 0}
{"index": 176850, "code": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\nunsigned long address, pte_t *page_table, pmd_t *pmd,\nunsigned int flags)\n{\nstruct mem_cgroup *memcg;\nstruct page *page;\nspinlock_t *ptl;\npte_t entry;\npte_unmap(page_table);\nif (check_stack_guard_page(vma, address) < 0)\nreturn VM_FAULT_SIGSEGV;\nif (!(flags & FAULT_FLAG_WRITE) && !mm_forbids_zeropage(mm)) {\nentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\nvma->vm_page_prot));\npage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\nif (!pte_none(*page_table))\ngoto unlock;\ngoto setpte;\n}\nif (unlikely(anon_vma_prepare(vma)))\ngoto oom;\npage = alloc_zeroed_user_highpage_movable(vma, address);\nif (!page)\ngoto oom;\nif (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &memcg))\ngoto oom_free_page;\n__SetPageUptodate(page);\nentry = mk_pte(page, vma->vm_page_prot);\nif (vma->vm_flags & VM_WRITE)\nentry = pte_mkwrite(pte_mkdirty(entry));\npage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\nif (!pte_none(*page_table))\ngoto release;\ninc_mm_counter_fast(mm, MM_ANONPAGES);\npage_add_new_anon_rmap(page, vma, address);\nmem_cgroup_commit_charge(page, memcg, false);\nlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\nset_pte_at(mm, address, page_table, entry);\nupdate_mmu_cache(vma, address, page_table);\nunlock:\npte_unmap_unlock(page_table, ptl);\nreturn 0;\nrelease:\nmem_cgroup_cancel_charge(page, memcg);\npage_cache_release(page);\ngoto unlock;\noom_free_page:\npage_cache_release(page);\noom:\nreturn VM_FAULT_OOM;\n}", "contrast": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\nunsigned long address, pte_t *page_table, pmd_t *pmd,\nunsigned int flags)\n{\nstruct mem_cgroup *memcg;\nstruct page *page;\nspinlock_t *ptl;\npte_t entry;\npte_unmap(page_table);\nif (vma->vm_flags & VM_SHARED)\nreturn VM_FAULT_SIGBUS;\nif (check_stack_guard_page(vma, address) < 0)\nreturn VM_FAULT_SIGSEGV;\nif (!(flags & FAULT_FLAG_WRITE) && !mm_forbids_zeropage(mm)) {\nentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\nvma->vm_page_prot));\npage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\nif (!pte_none(*page_table))\ngoto unlock;\ngoto setpte;\n}\nif (unlikely(anon_vma_prepare(vma)))\ngoto oom;\npage = alloc_zeroed_user_highpage_movable(vma, address);\nif (!page)\ngoto oom;\nif (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &memcg))\ngoto oom_free_page;\n__SetPageUptodate(page);\nentry = mk_pte(page, vma->vm_page_prot);\nif (vma->vm_flags & VM_WRITE)\nentry = pte_mkwrite(pte_mkdirty(entry));\npage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\nif (!pte_none(*page_table))\ngoto release;\ninc_mm_counter_fast(mm, MM_ANONPAGES);\npage_add_new_anon_rmap(page, vma, address);\nmem_cgroup_commit_charge(page, memcg, false);\nlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\nset_pte_at(mm, address, page_table, entry);\nupdate_mmu_cache(vma, address, page_table);\nunlock:\npte_unmap_unlock(page_table, ptl);\nreturn 0;\nrelease:\nmem_cgroup_cancel_charge(page, memcg);\npage_cache_release(page);\ngoto unlock;\noom_free_page:\npage_cache_release(page);\noom:\nreturn VM_FAULT_OOM;\n}", "label": 0}
{"index": 176864, "code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\nint reg = (instr >> 12) & 15;\nif (reg == 15)\nreturn 1;\nregs->uregs[reg] = current_thread_info()->tp_value;\nregs->ARM_pc += 4;\nreturn 0;\n}", "contrast": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\nint reg = (instr >> 12) & 15;\nif (reg == 15)\nreturn 1;\nregs->uregs[reg] = current_thread_info()->tp_value[0];\nregs->ARM_pc += 4;\nreturn 0;\n}", "label": 0}
{"index": 176869, "code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\nLIST_HEAD(tmp_list);\nstruct mount *p;\nif (how & UMOUNT_PROPAGATE)\npropagate_mount_unlock(mnt);\nfor (p = mnt; p; p = next_mnt(p, mnt)) {\np->mnt.mnt_flags |= MNT_UMOUNT;\nlist_move(&p->mnt_list, &tmp_list);\n}\nlist_for_each_entry(p, &tmp_list, mnt_list) {\nlist_del_init(&p->mnt_child);\n}\nif (how & UMOUNT_PROPAGATE)\npropagate_umount(&tmp_list);\nwhile (!list_empty(&tmp_list)) {\np = list_first_entry(&tmp_list, struct mount, mnt_list);\nlist_del_init(&p->mnt_expire);\nlist_del_init(&p->mnt_list);\n__touch_mnt_namespace(p->mnt_ns);\np->mnt_ns = NULL;\nif (how & UMOUNT_SYNC)\np->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\npin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\nif (mnt_has_parent(p)) {\nmnt_add_count(p->mnt_parent, -1);\numount_mnt(p);\n}\nchange_mnt_propagation(p, MS_PRIVATE);\n}\n}", "contrast": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\nLIST_HEAD(tmp_list);\nstruct mount *p;\nif (how & UMOUNT_PROPAGATE)\npropagate_mount_unlock(mnt);\nfor (p = mnt; p; p = next_mnt(p, mnt)) {\np->mnt.mnt_flags |= MNT_UMOUNT;\nlist_move(&p->mnt_list, &tmp_list);\n}\nlist_for_each_entry(p, &tmp_list, mnt_list) {\nlist_del_init(&p->mnt_child);\n}\nif (how & UMOUNT_PROPAGATE)\npropagate_umount(&tmp_list);\nwhile (!list_empty(&tmp_list)) {\nbool disconnect;\np = list_first_entry(&tmp_list, struct mount, mnt_list);\nlist_del_init(&p->mnt_expire);\nlist_del_init(&p->mnt_list);\n__touch_mnt_namespace(p->mnt_ns);\np->mnt_ns = NULL;\nif (how & UMOUNT_SYNC)\np->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\ndisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\npin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\ndisconnect ? &unmounted : NULL);\nif (mnt_has_parent(p)) {\nmnt_add_count(p->mnt_parent, -1);\nif (!disconnect) {\nlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n} else {\numount_mnt(p);\n}\n}\nchange_mnt_propagation(p, MS_PRIVATE);\n}\n}", "label": 0}
{"index": 176879, "code": "BOOL transport_accept_nla(rdpTransport* transport)\n{\nfreerdp* instance;\nrdpSettings* settings;\nif (transport->TlsIn == NULL)\ntransport->TlsIn = tls_new(transport->settings);\nif (transport->TlsOut == NULL)\ntransport->TlsOut = transport->TlsIn;\ntransport->layer = TRANSPORT_LAYER_TLS;\ntransport->TlsIn->sockfd = transport->TcpIn->sockfd;\nif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\nreturn FALSE;\nif (transport->settings->Authentication != TRUE)\nreturn TRUE;\nsettings = transport->settings;\ninstance = (freerdp*) settings->instance;\nif (transport->credssp == NULL)\ntransport->credssp = credssp_new(instance, transport, settings);\nif (credssp_authenticate(transport->credssp) < 0)\n{\nfprintf(stderr, \"client authentication failure\\n\");\ncredssp_free(transport->credssp);\nreturn FALSE;\n}\nreturn TRUE;\n}", "contrast": "BOOL transport_accept_nla(rdpTransport* transport)\n{\nfreerdp* instance;\nrdpSettings* settings;\nif (transport->TlsIn == NULL)\ntransport->TlsIn = tls_new(transport->settings);\nif (transport->TlsOut == NULL)\ntransport->TlsOut = transport->TlsIn;\ntransport->layer = TRANSPORT_LAYER_TLS;\ntransport->TlsIn->sockfd = transport->TcpIn->sockfd;\nif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\nreturn FALSE;\nif (transport->settings->Authentication != TRUE)\nreturn TRUE;\nsettings = transport->settings;\ninstance = (freerdp*) settings->instance;\nif (transport->credssp == NULL)\ntransport->credssp = credssp_new(instance, transport, settings);\nif (credssp_authenticate(transport->credssp) < 0)\n{\nfprintf(stderr, \"client authentication failure\\n\");\ncredssp_free(transport->credssp);\ntransport->credssp = NULL;\nreturn FALSE;\n}\nreturn TRUE;\n}", "label": 0}
{"index": 176880, "code": "BOOL transport_connect_nla(rdpTransport* transport)\n{\nfreerdp* instance;\nrdpSettings* settings;\nif (transport->layer == TRANSPORT_LAYER_TSG)\nreturn TRUE;\nif (!transport_connect_tls(transport))\nreturn FALSE;\nif (transport->settings->Authentication != TRUE)\nreturn TRUE;\nsettings = transport->settings;\ninstance = (freerdp*) settings->instance;\nif (transport->credssp == NULL)\ntransport->credssp = credssp_new(instance, transport, settings);\nif (credssp_authenticate(transport->credssp) < 0)\n{\nif (!connectErrorCode)\nconnectErrorCode = AUTHENTICATIONERROR;\nfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\ncredssp_free(transport->credssp);\nreturn FALSE;\n}\ncredssp_free(transport->credssp);\nreturn TRUE;\n}", "contrast": "BOOL transport_connect_nla(rdpTransport* transport)\n{\nfreerdp* instance;\nrdpSettings* settings;\nif (transport->layer == TRANSPORT_LAYER_TSG)\nreturn TRUE;\nif (!transport_connect_tls(transport))\nreturn FALSE;\nif (transport->settings->Authentication != TRUE)\nreturn TRUE;\nsettings = transport->settings;\ninstance = (freerdp*) settings->instance;\nif (transport->credssp == NULL)\ntransport->credssp = credssp_new(instance, transport, settings);\nif (credssp_authenticate(transport->credssp) < 0)\n{\nif (!connectErrorCode)\nconnectErrorCode = AUTHENTICATIONERROR;\nfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\ncredssp_free(transport->credssp);\ntransport->credssp = NULL;\nreturn FALSE;\n}\ncredssp_free(transport->credssp);\nreturn TRUE;\n}", "label": 0}
{"index": 176882, "code": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\nvoid* pointer;\nif (!handle)\nreturn NULL;\npointer = (void*) ~((size_t) handle->dwLower);\nreturn pointer;\n}", "contrast": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\nvoid* pointer;\nif (!handle || !SecIsValidHandle(handle))\nreturn NULL;\npointer = (void*) ~((size_t) handle->dwLower);\nreturn pointer;\n}", "label": 0}
{"index": 176891, "code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\nif (likely(i->nr_segs == 1)) {\ni->iov_offset += bytes;\n} else {\nconst struct iovec *iov = i->iov;\nsize_t base = i->iov_offset;\nwhile (bytes) {\nint copy = min(bytes, iov->iov_len - base);\nbytes -= copy;\nbase += copy;\nif (iov->iov_len == base) {\niov++;\nbase = 0;\n}\n}\ni->iov = iov;\ni->iov_offset = base;\n}\n}", "contrast": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\nif (likely(i->nr_segs == 1)) {\ni->iov_offset += bytes;\n} else {\nconst struct iovec *iov = i->iov;\nsize_t base = i->iov_offset;\nwhile (bytes || !iov->iov_len) {\nint copy = min(bytes, iov->iov_len - base);\nbytes -= copy;\nbase += copy;\nif (iov->iov_len == base) {\niov++;\nbase = 0;\n}\n}\ni->iov = iov;\ni->iov_offset = base;\n}\n}", "label": 0}
{"index": 176909, "code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\nstruct bpf_insn *insn,\nstruct bpf_reg_state *dst_reg,\nstruct bpf_reg_state src_reg)\n{\nstruct bpf_reg_state *regs = cur_regs(env);\nu8 opcode = BPF_OP(insn->code);\nbool src_known, dst_known;\ns64 smin_val, smax_val;\nu64 umin_val, umax_val;\nu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\nsmin_val = src_reg.smin_value;\nsmax_val = src_reg.smax_value;\numin_val = src_reg.umin_value;\numax_val = src_reg.umax_value;\nsrc_known = tnum_is_const(src_reg.var_off);\ndst_known = tnum_is_const(dst_reg->var_off);\nswitch (opcode) {\ncase BPF_ADD:\nif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\nsigned_add_overflows(dst_reg->smax_value, smax_val)) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value += smin_val;\ndst_reg->smax_value += smax_val;\n}\nif (dst_reg->umin_value + umin_val < umin_val ||\ndst_reg->umax_value + umax_val < umax_val) {\ndst_reg->umin_value = 0;\ndst_reg->umax_value = U64_MAX;\n} else {\ndst_reg->umin_value += umin_val;\ndst_reg->umax_value += umax_val;\n}\ndst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\nbreak;\ncase BPF_SUB:\nif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\nsigned_sub_overflows(dst_reg->smax_value, smin_val)) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value -= smax_val;\ndst_reg->smax_value -= smin_val;\n}\nif (dst_reg->umin_value < umax_val) {\ndst_reg->umin_value = 0;\ndst_reg->umax_value = U64_MAX;\n} else {\ndst_reg->umin_value -= umax_val;\ndst_reg->umax_value -= umin_val;\n}\ndst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\nbreak;\ncase BPF_MUL:\ndst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\nif (smin_val < 0 || dst_reg->smin_value < 0) {\n__mark_reg_unbounded(dst_reg);\n__update_reg_bounds(dst_reg);\nbreak;\n}\nif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n__mark_reg_unbounded(dst_reg);\n__update_reg_bounds(dst_reg);\nbreak;\n}\ndst_reg->umin_value *= umin_val;\ndst_reg->umax_value *= umax_val;\nif (dst_reg->umax_value > S64_MAX) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value = dst_reg->umin_value;\ndst_reg->smax_value = dst_reg->umax_value;\n}\nbreak;\ncase BPF_AND:\nif (src_known && dst_known) {\n__mark_reg_known(dst_reg, dst_reg->var_off.value &\nsrc_reg.var_off.value);\nbreak;\n}\ndst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\ndst_reg->umin_value = dst_reg->var_off.value;\ndst_reg->umax_value = min(dst_reg->umax_value, umax_val);\nif (dst_reg->smin_value < 0 || smin_val < 0) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value = dst_reg->umin_value;\ndst_reg->smax_value = dst_reg->umax_value;\n}\n__update_reg_bounds(dst_reg);\nbreak;\ncase BPF_OR:\nif (src_known && dst_known) {\n__mark_reg_known(dst_reg, dst_reg->var_off.value |\nsrc_reg.var_off.value);\nbreak;\n}\ndst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\ndst_reg->umin_value = max(dst_reg->umin_value, umin_val);\ndst_reg->umax_value = dst_reg->var_off.value |\ndst_reg->var_off.mask;\nif (dst_reg->smin_value < 0 || smin_val < 0) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value = dst_reg->umin_value;\ndst_reg->smax_value = dst_reg->umax_value;\n}\n__update_reg_bounds(dst_reg);\nbreak;\ncase BPF_LSH:\nif (umax_val >= insn_bitness) {\nmark_reg_unknown(env, regs, insn->dst_reg);\nbreak;\n}\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\nif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\ndst_reg->umin_value = 0;\ndst_reg->umax_value = U64_MAX;\n} else {\ndst_reg->umin_value <<= umin_val;\ndst_reg->umax_value <<= umax_val;\n}\nif (src_known)\ndst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\nelse\ndst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n__update_reg_bounds(dst_reg);\nbreak;\ncase BPF_RSH:\nif (umax_val >= insn_bitness) {\nmark_reg_unknown(env, regs, insn->dst_reg);\nbreak;\n}\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\nif (src_known)\ndst_reg->var_off = tnum_rshift(dst_reg->var_off,\numin_val);\nelse\ndst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\ndst_reg->umin_value >>= umax_val;\ndst_reg->umax_value >>= umin_val;\n__update_reg_bounds(dst_reg);\nbreak;\ndefault:\nmark_reg_unknown(env, regs, insn->dst_reg);\nbreak;\n}\nif (BPF_CLASS(insn->code) != BPF_ALU64) {\ncoerce_reg_to_size(dst_reg, 4);\ncoerce_reg_to_size(&src_reg, 4);\n}\n__reg_deduce_bounds(dst_reg);\n__reg_bound_offset(dst_reg);\nreturn 0;\n}", "contrast": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\nstruct bpf_insn *insn,\nstruct bpf_reg_state *dst_reg,\nstruct bpf_reg_state src_reg)\n{\nstruct bpf_reg_state *regs = cur_regs(env);\nu8 opcode = BPF_OP(insn->code);\nbool src_known, dst_known;\ns64 smin_val, smax_val;\nu64 umin_val, umax_val;\nu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\nsmin_val = src_reg.smin_value;\nsmax_val = src_reg.smax_value;\numin_val = src_reg.umin_value;\numax_val = src_reg.umax_value;\nsrc_known = tnum_is_const(src_reg.var_off);\ndst_known = tnum_is_const(dst_reg->var_off);\nif (!src_known &&\nopcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n__mark_reg_unknown(dst_reg);\nreturn 0;\n}\nswitch (opcode) {\ncase BPF_ADD:\nif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\nsigned_add_overflows(dst_reg->smax_value, smax_val)) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value += smin_val;\ndst_reg->smax_value += smax_val;\n}\nif (dst_reg->umin_value + umin_val < umin_val ||\ndst_reg->umax_value + umax_val < umax_val) {\ndst_reg->umin_value = 0;\ndst_reg->umax_value = U64_MAX;\n} else {\ndst_reg->umin_value += umin_val;\ndst_reg->umax_value += umax_val;\n}\ndst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\nbreak;\ncase BPF_SUB:\nif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\nsigned_sub_overflows(dst_reg->smax_value, smin_val)) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value -= smax_val;\ndst_reg->smax_value -= smin_val;\n}\nif (dst_reg->umin_value < umax_val) {\ndst_reg->umin_value = 0;\ndst_reg->umax_value = U64_MAX;\n} else {\ndst_reg->umin_value -= umax_val;\ndst_reg->umax_value -= umin_val;\n}\ndst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\nbreak;\ncase BPF_MUL:\ndst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\nif (smin_val < 0 || dst_reg->smin_value < 0) {\n__mark_reg_unbounded(dst_reg);\n__update_reg_bounds(dst_reg);\nbreak;\n}\nif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n__mark_reg_unbounded(dst_reg);\n__update_reg_bounds(dst_reg);\nbreak;\n}\ndst_reg->umin_value *= umin_val;\ndst_reg->umax_value *= umax_val;\nif (dst_reg->umax_value > S64_MAX) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value = dst_reg->umin_value;\ndst_reg->smax_value = dst_reg->umax_value;\n}\nbreak;\ncase BPF_AND:\nif (src_known && dst_known) {\n__mark_reg_known(dst_reg, dst_reg->var_off.value &\nsrc_reg.var_off.value);\nbreak;\n}\ndst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\ndst_reg->umin_value = dst_reg->var_off.value;\ndst_reg->umax_value = min(dst_reg->umax_value, umax_val);\nif (dst_reg->smin_value < 0 || smin_val < 0) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value = dst_reg->umin_value;\ndst_reg->smax_value = dst_reg->umax_value;\n}\n__update_reg_bounds(dst_reg);\nbreak;\ncase BPF_OR:\nif (src_known && dst_known) {\n__mark_reg_known(dst_reg, dst_reg->var_off.value |\nsrc_reg.var_off.value);\nbreak;\n}\ndst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\ndst_reg->umin_value = max(dst_reg->umin_value, umin_val);\ndst_reg->umax_value = dst_reg->var_off.value |\ndst_reg->var_off.mask;\nif (dst_reg->smin_value < 0 || smin_val < 0) {\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\n} else {\ndst_reg->smin_value = dst_reg->umin_value;\ndst_reg->smax_value = dst_reg->umax_value;\n}\n__update_reg_bounds(dst_reg);\nbreak;\ncase BPF_LSH:\nif (umax_val >= insn_bitness) {\nmark_reg_unknown(env, regs, insn->dst_reg);\nbreak;\n}\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\nif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\ndst_reg->umin_value = 0;\ndst_reg->umax_value = U64_MAX;\n} else {\ndst_reg->umin_value <<= umin_val;\ndst_reg->umax_value <<= umax_val;\n}\nif (src_known)\ndst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\nelse\ndst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n__update_reg_bounds(dst_reg);\nbreak;\ncase BPF_RSH:\nif (umax_val >= insn_bitness) {\nmark_reg_unknown(env, regs, insn->dst_reg);\nbreak;\n}\ndst_reg->smin_value = S64_MIN;\ndst_reg->smax_value = S64_MAX;\nif (src_known)\ndst_reg->var_off = tnum_rshift(dst_reg->var_off,\numin_val);\nelse\ndst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\ndst_reg->umin_value >>= umax_val;\ndst_reg->umax_value >>= umin_val;\n__update_reg_bounds(dst_reg);\nbreak;\ndefault:\nmark_reg_unknown(env, regs, insn->dst_reg);\nbreak;\n}\nif (BPF_CLASS(insn->code) != BPF_ALU64) {\ncoerce_reg_to_size(dst_reg, 4);\ncoerce_reg_to_size(&src_reg, 4);\n}\n__reg_deduce_bounds(dst_reg);\n__reg_bound_offset(dst_reg);\nreturn 0;\n}", "label": 0}
{"index": 176913, "code": "_kdc_as_rep(kdc_request_t r,\nkrb5_data *reply,\nconst char *from,\nstruct sockaddr *from_addr,\nint datagram_reply)\n{\nkrb5_context context = r->context;\nkrb5_kdc_configuration *config = r->config;\nKDC_REQ *req = &r->req;\nKDC_REQ_BODY *b = NULL;\nAS_REP rep;\nKDCOptions f;\nkrb5_enctype setype;\nkrb5_error_code ret = 0;\nKey *skey;\nint found_pa = 0;\nint i, flags = HDB_F_FOR_AS_REQ;\nMETHOD_DATA error_method;\nconst PA_DATA *pa;\nmemset(&rep, 0, sizeof(rep));\nerror_method.len = 0;\nerror_method.val = NULL;\nret = _kdc_fast_unwrap_request(r);\nif (ret) {\n_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\ngoto out;\n}\nb = &req->req_body;\nf = b->kdc_options;\nif (f.canonicalize)\nflags |= HDB_F_CANON;\nif(b->sname == NULL){\nret = KRB5KRB_ERR_GENERIC;\n_kdc_set_e_text(r, \"No server in request\");\n} else{\nret = _krb5_principalname2krb5_principal (context,\n&r->server_princ,\n*(b->sname),\nb->realm);\nif (ret == 0)\nret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n}\nif (ret) {\nkdc_log(context, config, 0,\n\"AS-REQ malformed server name from %s\", from);\ngoto out;\n}\nif(b->cname == NULL){\nret = KRB5KRB_ERR_GENERIC;\n_kdc_set_e_text(r, \"No client in request\");\n} else {\nret = _krb5_principalname2krb5_principal (context,\n&r->client_princ,\n*(b->cname),\nb->realm);\nif (ret)\ngoto out;\nret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n}\nif (ret) {\nkdc_log(context, config, 0,\n\"AS-REQ malformed client name from %s\", from);\ngoto out;\n}\nkdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\nr->client_name, from, r->server_name);\nif (_kdc_is_anonymous(context, r->client_princ)) {\nif (!_kdc_is_anon_request(b)) {\nkdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\nret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\ngoto out;\n}\n} else if (_kdc_is_anon_request(b)) {\nkdc_log(context, config, 0,\n\"Request for a anonymous ticket with non \"\n\"anonymous client name: %s\", r->client_name);\nret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\ngoto out;\n}\nret = _kdc_db_fetch(context, config, r->client_princ,\nHDB_F_GET_CLIENT | flags, NULL,\n&r->clientdb, &r->client);\nif(ret == HDB_ERR_NOT_FOUND_HERE) {\nkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\nr->client_name);\ngoto out;\n} else if (ret == HDB_ERR_WRONG_REALM) {\nchar *fixed_client_name = NULL;\nret = krb5_unparse_name(context, r->client->entry.principal,\n&fixed_client_name);\nif (ret) {\ngoto out;\n}\nkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\nr->client_name, fixed_client_name);\nfree(fixed_client_name);\nret = _kdc_fast_mk_error(context, r,\n&error_method,\nr->armor_crypto,\n&req->req_body,\nKRB5_KDC_ERR_WRONG_REALM,\nNULL,\nr->server_princ,\nNULL,\n&r->client->entry.principal->realm,\nNULL, NULL,\nreply);\ngoto out;\n} else if(ret){\nconst char *msg = krb5_get_error_message(context, ret);\nkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\nkrb5_free_error_message(context, msg);\nret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\ngoto out;\n}\nret = _kdc_db_fetch(context, config, r->server_princ,\nHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\nNULL, NULL, &r->server);\nif(ret == HDB_ERR_NOT_FOUND_HERE) {\nkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\nr->server_name);\ngoto out;\n} else if(ret){\nconst char *msg = krb5_get_error_message(context, ret);\nkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\nkrb5_free_error_message(context, msg);\nret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\ngoto out;\n}\nret = _kdc_find_etype(context,\nkrb5_principal_is_krbtgt(context, r->server_princ) ?\nconfig->tgt_use_strongest_session_key :\nconfig->svc_use_strongest_session_key, FALSE,\nr->client, b->etype.val, b->etype.len, &r->sessionetype,\nNULL);\nif (ret) {\nkdc_log(context, config, 0,\n\"Client (%s) from %s has no common enctypes with KDC \"\n\"to use for the session key\",\nr->client_name, from);\ngoto out;\n}\nif(req->padata){\nunsigned int n;\nlog_patypes(context, config, req->padata);\nfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\nif (pat[n].validate == NULL)\ncontinue;\nif (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\ncontinue;\nkdc_log(context, config, 5,\n\"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\ni = 0;\npa = _kdc_find_padata(req, &i, pat[n].type);\nif (pa) {\nret = pat[n].validate(r, pa);\nif (ret != 0) {\ngoto out;\n}\nkdc_log(context, config, 0,\n\"%s pre-authentication succeeded -- %s\",\npat[n].name, r->client_name);\nfound_pa = 1;\nr->et.flags.pre_authent = 1;\n}\n}\n}\nif (found_pa == 0) {\nKey *ckey = NULL;\nsize_t n;\nfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\nif ((pat[n].flags & PA_ANNOUNCE) == 0)\ncontinue;\nret = krb5_padata_add(context, &error_method,\npat[n].type, NULL, 0);\nif (ret)\ngoto out;\n}\nret = _kdc_find_etype(context,\nconfig->preauth_use_strongest_session_key, TRUE,\nr->client, b->etype.val, b->etype.len, NULL, &ckey);\nif (ret == 0) {\nif (older_enctype(ckey->key.keytype)) {\nret = get_pa_etype_info(context, config,\n&error_method, ckey);\nif (ret)\ngoto out;\n}\nret = get_pa_etype_info2(context, config,\n&error_method, ckey);\nif (ret)\ngoto out;\n}\nif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\nret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n_kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\ngoto out;\n}\nif (ckey == NULL) {\nret = KRB5KDC_ERR_CLIENT_NOTYET;\n_kdc_set_e_text(r, \"Doesn't have a client key available\");\ngoto out;\n}\nkrb5_free_keyblock_contents(r->context,  &r->reply_key);\nret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\nif (ret)\ngoto out;\n}\nif (r->clientdb->hdb_auth_status) {\nr->clientdb->hdb_auth_status(context, r->clientdb, r->client,\nHDB_AUTH_SUCCESS);\n}\nret = _kdc_check_access(context, config, r->client, r->client_name,\nr->server, r->server_name,\nreq, &error_method);\nif(ret)\ngoto out;\nret = _kdc_get_preferred_key(context, config,\nr->server, r->server_name,\n&setype, &skey);\nif(ret)\ngoto out;\nif(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n|| (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\nret = KRB5KDC_ERR_BADOPTION;\n_kdc_set_e_text(r, \"Bad KDC options\");\ngoto out;\n}\nrep.pvno = 5;\nrep.msg_type = krb_as_rep;\nif (_kdc_is_anonymous(context, r->client_princ)) {\nRealm anon_realm=KRB5_ANON_REALM;\nret = copy_Realm(&anon_realm, &rep.crealm);\n} else\nret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\nif (ret)\ngoto out;\nret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\nif (ret)\ngoto out;\nrep.ticket.tkt_vno = 5;\nret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\nif (ret)\ngoto out;\n_krb5_principal2principalname(&rep.ticket.sname,\nr->server->entry.principal);\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\nif (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\nrep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\nr->et.flags.initial = 1;\nif(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\nr->et.flags.forwardable = f.forwardable;\nelse if (f.forwardable) {\n_kdc_set_e_text(r, \"Ticket may not be forwardable\");\nret = KRB5KDC_ERR_POLICY;\ngoto out;\n}\nif(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\nr->et.flags.proxiable = f.proxiable;\nelse if (f.proxiable) {\n_kdc_set_e_text(r, \"Ticket may not be proxiable\");\nret = KRB5KDC_ERR_POLICY;\ngoto out;\n}\nif(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\nr->et.flags.may_postdate = f.allow_postdate;\nelse if (f.allow_postdate){\n_kdc_set_e_text(r, \"Ticket may not be postdate\");\nret = KRB5KDC_ERR_POLICY;\ngoto out;\n}\nif(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n_kdc_set_e_text(r, \"Bad address list in requested\");\nret = KRB5KRB_AP_ERR_BADADDR;\ngoto out;\n}\nret = copy_PrincipalName(&rep.cname, &r->et.cname);\nif (ret)\ngoto out;\nret = copy_Realm(&rep.crealm, &r->et.crealm);\nif (ret)\ngoto out;\n{\ntime_t start;\ntime_t t;\nstart = r->et.authtime = kdc_time;\nif(f.postdated && req->req_body.from){\nALLOC(r->et.starttime);\nstart = *r->et.starttime = *req->req_body.from;\nr->et.flags.invalid = 1;\nr->et.flags.postdated = 1;\n}\n_kdc_fix_time(&b->till);\nt = *b->till;\nif(r->client->entry.max_life)\nt = start + min(t - start, *r->client->entry.max_life);\nif(r->server->entry.max_life)\nt = start + min(t - start, *r->server->entry.max_life);\n#if 0\nt = min(t, start + realm->max_life);\n#endif\nr->et.endtime = t;\nif(f.renewable_ok && r->et.endtime < *b->till){\nf.renewable = 1;\nif(b->rtime == NULL){\nALLOC(b->rtime);\n*b->rtime = 0;\n}\nif(*b->rtime < *b->till)\n*b->rtime = *b->till;\n}\nif(f.renewable && b->rtime){\nt = *b->rtime;\nif(t == 0)\nt = MAX_TIME;\nif(r->client->entry.max_renew)\nt = start + min(t - start, *r->client->entry.max_renew);\nif(r->server->entry.max_renew)\nt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\nt = min(t, start + realm->max_renew);\n#endif\nALLOC(r->et.renew_till);\n*r->et.renew_till = t;\nr->et.flags.renewable = 1;\n}\n}\nif (_kdc_is_anon_request(b))\nr->et.flags.anonymous = 1;\nif(b->addresses){\nALLOC(r->et.caddr);\ncopy_HostAddresses(b->addresses, r->et.caddr);\n}\nr->et.transited.tr_type = DOMAIN_X500_COMPRESS;\nkrb5_data_zero(&r->et.transited.contents);\nr->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\nif (r->ek.last_req.val == NULL) {\nret = ENOMEM;\ngoto out;\n}\nr->ek.last_req.len = 0;\nif (r->client->entry.pw_end\n&& (config->kdc_warn_pwexpire == 0\n|| kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\nr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\nr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n++r->ek.last_req.len;\n}\nif (r->client->entry.valid_end) {\nr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\nr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n++r->ek.last_req.len;\n}\nif (r->ek.last_req.len == 0) {\nr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\nr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n++r->ek.last_req.len;\n}\nr->ek.nonce = b->nonce;\nif (r->client->entry.valid_end || r->client->entry.pw_end) {\nALLOC(r->ek.key_expiration);\nif (r->client->entry.valid_end) {\nif (r->client->entry.pw_end)\n*r->ek.key_expiration = min(*r->client->entry.valid_end,\n*r->client->entry.pw_end);\nelse\n*r->ek.key_expiration = *r->client->entry.valid_end;\n} else\n*r->ek.key_expiration = *r->client->entry.pw_end;\n} else\nr->ek.key_expiration = NULL;\nr->ek.flags = r->et.flags;\nr->ek.authtime = r->et.authtime;\nif (r->et.starttime) {\nALLOC(r->ek.starttime);\n*r->ek.starttime = *r->et.starttime;\n}\nr->ek.endtime = r->et.endtime;\nif (r->et.renew_till) {\nALLOC(r->ek.renew_till);\n*r->ek.renew_till = *r->et.renew_till;\n}\nret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\nif (ret)\ngoto out;\nret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\nif (ret)\ngoto out;\nif(r->et.caddr){\nALLOC(r->ek.caddr);\ncopy_HostAddresses(r->et.caddr, r->ek.caddr);\n}\nif (r->session_key.keytype == ETYPE_NULL) {\nret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\nif (ret)\ngoto out;\n}\nif (r->reply_key.keytype == ETYPE_NULL) {\n_kdc_set_e_text(r, \"Client have no reply key\");\nret = KRB5KDC_ERR_CLIENT_NOTYET;\ngoto out;\n}\nret = copy_EncryptionKey(&r->session_key, &r->et.key);\nif (ret)\ngoto out;\nret = copy_EncryptionKey(&r->session_key, &r->ek.key);\nif (ret)\ngoto out;\nif (r->outpadata.len) {\nALLOC(rep.padata);\nif (rep.padata == NULL) {\nret = ENOMEM;\ngoto out;\n}\nret = copy_METHOD_DATA(&r->outpadata, rep.padata);\nif (ret)\ngoto out;\n}\nif (send_pac_p(context, req)) {\ngenerate_pac(r, skey);\n}\n_kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\nr->et.endtime, r->et.renew_till);\nret = _kdc_add_KRB5SignedPath(context,\nconfig,\nr->server,\nsetype,\nr->client->entry.principal,\nNULL,\nNULL,\n&r->et);\nif (ret)\ngoto out;\nlog_as_req(context, config, r->reply_key.keytype, setype, b);\nr->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\ni = 0;\npa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\nif (pa) {\nret = add_enc_pa_rep(r);\nif (ret) {\nconst char *msg = krb5_get_error_message(r->context, ret);\n_kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\nkrb5_free_error_message(r->context, msg);\ngoto out;\n}\n}\nret = _kdc_encode_reply(context, config,\nr->armor_crypto, req->req_body.nonce,\n&rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n&skey->key, r->client->entry.kvno,\n&r->reply_key, 0, &r->e_text, reply);\nif (ret)\ngoto out;\nif (datagram_reply && reply->length > config->max_datagram_reply_length) {\nkrb5_data_free(reply);\nret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n_kdc_set_e_text(r, \"Reply packet too large\");\n}\nout:\nfree_AS_REP(&rep);\nif(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\nret = _kdc_fast_mk_error(context, r,\n&error_method,\nr->armor_crypto,\n&req->req_body,\nret, r->e_text,\nr->server_princ,\n&r->client_princ->name,\n&r->client_princ->realm,\nNULL, NULL,\nreply);\nif (ret)\ngoto out2;\n}\nout2:\nfree_EncTicketPart(&r->et);\nfree_EncKDCRepPart(&r->ek);\nfree_KDCFastState(&r->fast);\nif (error_method.len)\nfree_METHOD_DATA(&error_method);\nif (r->outpadata.len)\nfree_METHOD_DATA(&r->outpadata);\nif (r->client_princ) {\nkrb5_free_principal(context, r->client_princ);\nr->client_princ = NULL;\n}\nif (r->client_name) {\nfree(r->client_name);\nr->client_name = NULL;\n}\nif (r->server_princ){\nkrb5_free_principal(context, r->server_princ);\nr->server_princ = NULL;\n}\nif (r->server_name) {\nfree(r->server_name);\nr->server_name = NULL;\n}\nif (r->client)\n_kdc_free_ent(context, r->client);\nif (r->server)\n_kdc_free_ent(context, r->server);\nif (r->armor_crypto) {\nkrb5_crypto_destroy(r->context, r->armor_crypto);\nr->armor_crypto = NULL;\n}\nkrb5_free_keyblock_contents(r->context, &r->reply_key);\nkrb5_free_keyblock_contents(r->context, &r->session_key);\nreturn ret;\n}", "contrast": "_kdc_as_rep(kdc_request_t r,\nkrb5_data *reply,\nconst char *from,\nstruct sockaddr *from_addr,\nint datagram_reply)\n{\nkrb5_context context = r->context;\nkrb5_kdc_configuration *config = r->config;\nKDC_REQ *req = &r->req;\nKDC_REQ_BODY *b = NULL;\nAS_REP rep;\nKDCOptions f;\nkrb5_enctype setype;\nkrb5_error_code ret = 0;\nKey *skey;\nint found_pa = 0;\nint i, flags = HDB_F_FOR_AS_REQ;\nMETHOD_DATA error_method;\nconst PA_DATA *pa;\nmemset(&rep, 0, sizeof(rep));\nerror_method.len = 0;\nerror_method.val = NULL;\nret = _kdc_fast_unwrap_request(r);\nif (ret) {\n_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\ngoto out;\n}\nb = &req->req_body;\nf = b->kdc_options;\nif (f.canonicalize)\nflags |= HDB_F_CANON;\nif(b->sname == NULL){\nret = KRB5KRB_ERR_GENERIC;\n_kdc_set_e_text(r, \"No server in request\");\n} else{\nret = _krb5_principalname2krb5_principal (context,\n&r->server_princ,\n*(b->sname),\nb->realm);\nif (ret == 0)\nret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n}\nif (ret) {\nkdc_log(context, config, 0,\n\"AS-REQ malformed server name from %s\", from);\ngoto out;\n}\nif(b->cname == NULL){\nret = KRB5KRB_ERR_GENERIC;\n_kdc_set_e_text(r, \"No client in request\");\n} else {\nret = _krb5_principalname2krb5_principal (context,\n&r->client_princ,\n*(b->cname),\nb->realm);\nif (ret)\ngoto out;\nret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n}\nif (ret) {\nkdc_log(context, config, 0,\n\"AS-REQ malformed client name from %s\", from);\ngoto out;\n}\nkdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\nr->client_name, from, r->server_name);\nif (_kdc_is_anonymous(context, r->client_princ)) {\nif (!_kdc_is_anon_request(b)) {\nkdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\nret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\ngoto out;\n}\n} else if (_kdc_is_anon_request(b)) {\nkdc_log(context, config, 0,\n\"Request for a anonymous ticket with non \"\n\"anonymous client name: %s\", r->client_name);\nret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\ngoto out;\n}\nret = _kdc_db_fetch(context, config, r->client_princ,\nHDB_F_GET_CLIENT | flags, NULL,\n&r->clientdb, &r->client);\nif(ret == HDB_ERR_NOT_FOUND_HERE) {\nkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\nr->client_name);\ngoto out;\n} else if (ret == HDB_ERR_WRONG_REALM) {\nchar *fixed_client_name = NULL;\nret = krb5_unparse_name(context, r->client->entry.principal,\n&fixed_client_name);\nif (ret) {\ngoto out;\n}\nkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\nr->client_name, fixed_client_name);\nfree(fixed_client_name);\nret = _kdc_fast_mk_error(context, r,\n&error_method,\nr->armor_crypto,\n&req->req_body,\nKRB5_KDC_ERR_WRONG_REALM,\nNULL,\nr->server_princ,\nNULL,\n&r->client->entry.principal->realm,\nNULL, NULL,\nreply);\ngoto out;\n} else if(ret){\nconst char *msg = krb5_get_error_message(context, ret);\nkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\nkrb5_free_error_message(context, msg);\nret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\ngoto out;\n}\nret = _kdc_db_fetch(context, config, r->server_princ,\nHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\nNULL, NULL, &r->server);\nif(ret == HDB_ERR_NOT_FOUND_HERE) {\nkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\nr->server_name);\ngoto out;\n} else if(ret){\nconst char *msg = krb5_get_error_message(context, ret);\nkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\nkrb5_free_error_message(context, msg);\nret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\ngoto out;\n}\nret = _kdc_find_etype(context,\nkrb5_principal_is_krbtgt(context, r->server_princ) ?\nconfig->tgt_use_strongest_session_key :\nconfig->svc_use_strongest_session_key, FALSE,\nr->client, b->etype.val, b->etype.len, &r->sessionetype,\nNULL);\nif (ret) {\nkdc_log(context, config, 0,\n\"Client (%s) from %s has no common enctypes with KDC \"\n\"to use for the session key\",\nr->client_name, from);\ngoto out;\n}\nif(req->padata){\nunsigned int n;\nlog_patypes(context, config, req->padata);\nfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\nif (pat[n].validate == NULL)\ncontinue;\nif (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\ncontinue;\nkdc_log(context, config, 5,\n\"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\ni = 0;\npa = _kdc_find_padata(req, &i, pat[n].type);\nif (pa) {\nret = pat[n].validate(r, pa);\nif (ret != 0) {\ngoto out;\n}\nkdc_log(context, config, 0,\n\"%s pre-authentication succeeded -- %s\",\npat[n].name, r->client_name);\nfound_pa = 1;\nr->et.flags.pre_authent = 1;\n}\n}\n}\nif (found_pa == 0) {\nKey *ckey = NULL;\nsize_t n;\nfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\nif ((pat[n].flags & PA_ANNOUNCE) == 0)\ncontinue;\nret = krb5_padata_add(context, &error_method,\npat[n].type, NULL, 0);\nif (ret)\ngoto out;\n}\nret = _kdc_find_etype(context,\nconfig->preauth_use_strongest_session_key, TRUE,\nr->client, b->etype.val, b->etype.len, NULL, &ckey);\nif (ret == 0) {\nif (older_enctype(ckey->key.keytype)) {\nret = get_pa_etype_info(context, config,\n&error_method, ckey);\nif (ret)\ngoto out;\n}\nret = get_pa_etype_info2(context, config,\n&error_method, ckey);\nif (ret)\ngoto out;\n}\nif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\nret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n_kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\ngoto out;\n}\nif (ckey == NULL) {\nret = KRB5KDC_ERR_CLIENT_NOTYET;\n_kdc_set_e_text(r, \"Doesn't have a client key available\");\ngoto out;\n}\nkrb5_free_keyblock_contents(r->context,  &r->reply_key);\nret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\nif (ret)\ngoto out;\n}\nif (r->clientdb->hdb_auth_status) {\nr->clientdb->hdb_auth_status(context, r->clientdb, r->client,\nHDB_AUTH_SUCCESS);\n}\nret = _kdc_check_access(context, config, r->client, r->client_name,\nr->server, r->server_name,\nreq, &error_method);\nif(ret)\ngoto out;\nret = _kdc_get_preferred_key(context, config,\nr->server, r->server_name,\n&setype, &skey);\nif(ret)\ngoto out;\nif(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n|| (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\nret = KRB5KDC_ERR_BADOPTION;\n_kdc_set_e_text(r, \"Bad KDC options\");\ngoto out;\n}\nrep.pvno = 5;\nrep.msg_type = krb_as_rep;\nif (_kdc_is_anonymous(context, r->client_princ)) {\nRealm anon_realm=KRB5_ANON_REALM;\nret = copy_Realm(&anon_realm, &rep.crealm);\n} else\nret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\nif (ret)\ngoto out;\nret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\nif (ret)\ngoto out;\nrep.ticket.tkt_vno = 5;\nret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\nif (ret)\ngoto out;\n_krb5_principal2principalname(&rep.ticket.sname,\nr->server->entry.principal);\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\nif (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\nrep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\nr->et.flags.initial = 1;\nif(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\nr->et.flags.forwardable = f.forwardable;\nelse if (f.forwardable) {\n_kdc_set_e_text(r, \"Ticket may not be forwardable\");\nret = KRB5KDC_ERR_POLICY;\ngoto out;\n}\nif(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\nr->et.flags.proxiable = f.proxiable;\nelse if (f.proxiable) {\n_kdc_set_e_text(r, \"Ticket may not be proxiable\");\nret = KRB5KDC_ERR_POLICY;\ngoto out;\n}\nif(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\nr->et.flags.may_postdate = f.allow_postdate;\nelse if (f.allow_postdate){\n_kdc_set_e_text(r, \"Ticket may not be postdate\");\nret = KRB5KDC_ERR_POLICY;\ngoto out;\n}\nif(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n_kdc_set_e_text(r, \"Bad address list in requested\");\nret = KRB5KRB_AP_ERR_BADADDR;\ngoto out;\n}\nret = copy_PrincipalName(&rep.cname, &r->et.cname);\nif (ret)\ngoto out;\nret = copy_Realm(&rep.crealm, &r->et.crealm);\nif (ret)\ngoto out;\n{\ntime_t start;\ntime_t t;\nstart = r->et.authtime = kdc_time;\nif(f.postdated && req->req_body.from){\nALLOC(r->et.starttime);\nstart = *r->et.starttime = *req->req_body.from;\nr->et.flags.invalid = 1;\nr->et.flags.postdated = 1;\n}\n_kdc_fix_time(&b->till);\nt = *b->till;\nif(r->client->entry.max_life)\nt = start + min(t - start, *r->client->entry.max_life);\nif(r->server->entry.max_life)\nt = start + min(t - start, *r->server->entry.max_life);\n#if 0\nt = min(t, start + realm->max_life);\n#endif\nr->et.endtime = t;\nif(f.renewable_ok && r->et.endtime < *b->till){\nf.renewable = 1;\nif(b->rtime == NULL){\nALLOC(b->rtime);\n*b->rtime = 0;\n}\nif(*b->rtime < *b->till)\n*b->rtime = *b->till;\n}\nif(f.renewable && b->rtime){\nt = *b->rtime;\nif(t == 0)\nt = MAX_TIME;\nif(r->client->entry.max_renew)\nt = start + min(t - start, *r->client->entry.max_renew);\nif(r->server->entry.max_renew)\nt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\nt = min(t, start + realm->max_renew);\n#endif\nALLOC(r->et.renew_till);\n*r->et.renew_till = t;\nr->et.flags.renewable = 1;\n}\n}\nif (_kdc_is_anon_request(b))\nr->et.flags.anonymous = 1;\nif(b->addresses){\nALLOC(r->et.caddr);\ncopy_HostAddresses(b->addresses, r->et.caddr);\n}\nr->et.transited.tr_type = DOMAIN_X500_COMPRESS;\nkrb5_data_zero(&r->et.transited.contents);\nr->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\nif (r->ek.last_req.val == NULL) {\nret = ENOMEM;\ngoto out;\n}\nr->ek.last_req.len = 0;\nif (r->client->entry.pw_end\n&& (config->kdc_warn_pwexpire == 0\n|| kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\nr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\nr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n++r->ek.last_req.len;\n}\nif (r->client->entry.valid_end) {\nr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\nr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n++r->ek.last_req.len;\n}\nif (r->ek.last_req.len == 0) {\nr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\nr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n++r->ek.last_req.len;\n}\nr->ek.nonce = b->nonce;\nif (r->client->entry.valid_end || r->client->entry.pw_end) {\nALLOC(r->ek.key_expiration);\nif (r->client->entry.valid_end) {\nif (r->client->entry.pw_end)\n*r->ek.key_expiration = min(*r->client->entry.valid_end,\n*r->client->entry.pw_end);\nelse\n*r->ek.key_expiration = *r->client->entry.valid_end;\n} else\n*r->ek.key_expiration = *r->client->entry.pw_end;\n} else\nr->ek.key_expiration = NULL;\nr->ek.flags = r->et.flags;\nr->ek.authtime = r->et.authtime;\nif (r->et.starttime) {\nALLOC(r->ek.starttime);\n*r->ek.starttime = *r->et.starttime;\n}\nr->ek.endtime = r->et.endtime;\nif (r->et.renew_till) {\nALLOC(r->ek.renew_till);\n*r->ek.renew_till = *r->et.renew_till;\n}\nret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\nif (ret)\ngoto out;\nret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\nif (ret)\ngoto out;\nif(r->et.caddr){\nALLOC(r->ek.caddr);\ncopy_HostAddresses(r->et.caddr, r->ek.caddr);\n}\nif (r->session_key.keytype == ETYPE_NULL) {\nret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\nif (ret)\ngoto out;\n}\nif (r->reply_key.keytype == ETYPE_NULL) {\n_kdc_set_e_text(r, \"Client have no reply key\");\nret = KRB5KDC_ERR_CLIENT_NOTYET;\ngoto out;\n}\nret = copy_EncryptionKey(&r->session_key, &r->et.key);\nif (ret)\ngoto out;\nret = copy_EncryptionKey(&r->session_key, &r->ek.key);\nif (ret)\ngoto out;\nif (r->outpadata.len) {\nALLOC(rep.padata);\nif (rep.padata == NULL) {\nret = ENOMEM;\ngoto out;\n}\nret = copy_METHOD_DATA(&r->outpadata, rep.padata);\nif (ret)\ngoto out;\n}\nif (send_pac_p(context, req)) {\ngenerate_pac(r, skey);\n}\n_kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\nr->et.endtime, r->et.renew_till);\nret = _kdc_add_KRB5SignedPath(context,\nconfig,\nr->server,\nsetype,\nr->client->entry.principal,\nNULL,\nNULL,\n&r->et);\nif (ret)\ngoto out;\nlog_as_req(context, config, r->reply_key.keytype, setype, b);\nr->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\ni = 0;\npa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\nif (pa) {\nret = add_enc_pa_rep(r);\nif (ret) {\nconst char *msg = krb5_get_error_message(r->context, ret);\n_kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\nkrb5_free_error_message(r->context, msg);\ngoto out;\n}\n}\nret = _kdc_encode_reply(context, config,\nr->armor_crypto, req->req_body.nonce,\n&rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n&skey->key, r->client->entry.kvno,\n&r->reply_key, 0, &r->e_text, reply);\nif (ret)\ngoto out;\nif (datagram_reply && reply->length > config->max_datagram_reply_length) {\nkrb5_data_free(reply);\nret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n_kdc_set_e_text(r, \"Reply packet too large\");\n}\nout:\nfree_AS_REP(&rep);\nif (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\nret = _kdc_fast_mk_error(context, r,\n&error_method,\nr->armor_crypto,\n&req->req_body,\nret, r->e_text,\nr->server_princ,\nr->client_princ ?\n&r->client_princ->name : NULL,\nr->client_princ ?\n&r->client_princ->realm : NULL,\nNULL, NULL,\nreply);\nif (ret)\ngoto out2;\n}\nout2:\nfree_EncTicketPart(&r->et);\nfree_EncKDCRepPart(&r->ek);\nfree_KDCFastState(&r->fast);\nif (error_method.len)\nfree_METHOD_DATA(&error_method);\nif (r->outpadata.len)\nfree_METHOD_DATA(&r->outpadata);\nif (r->client_princ) {\nkrb5_free_principal(context, r->client_princ);\nr->client_princ = NULL;\n}\nif (r->client_name) {\nfree(r->client_name);\nr->client_name = NULL;\n}\nif (r->server_princ){\nkrb5_free_principal(context, r->server_princ);\nr->server_princ = NULL;\n}\nif (r->server_name) {\nfree(r->server_name);\nr->server_name = NULL;\n}\nif (r->client)\n_kdc_free_ent(context, r->client);\nif (r->server)\n_kdc_free_ent(context, r->server);\nif (r->armor_crypto) {\nkrb5_crypto_destroy(r->context, r->armor_crypto);\nr->armor_crypto = NULL;\n}\nkrb5_free_keyblock_contents(r->context, &r->reply_key);\nkrb5_free_keyblock_contents(r->context, &r->session_key);\nreturn ret;\n}", "label": 0}
{"index": 176918, "code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\nstruct netlink_ext_ack *extack)\n{\nstruct net *net = sock_net(skb->sk);\nstruct nlattr *attrs[XFRMA_MAX+1];\nconst struct xfrm_link *link;\nint type, err;\n#ifdef CONFIG_COMPAT\nif (in_compat_syscall())\nreturn -EOPNOTSUPP;\n#endif\ntype = nlh->nlmsg_type;\nif (type > XFRM_MSG_MAX)\nreturn -EINVAL;\ntype -= XFRM_MSG_BASE;\nlink = &xfrm_dispatch[type];\nif (!netlink_net_capable(skb, CAP_NET_ADMIN))\nreturn -EPERM;\nif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\ntype == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n(nlh->nlmsg_flags & NLM_F_DUMP)) {\nif (link->dump == NULL)\nreturn -EINVAL;\n{\nstruct netlink_dump_control c = {\n.dump = link->dump,\n.done = link->done,\n};\nreturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n}\n}\nerr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\nlink->nla_max ? : XFRMA_MAX,\nlink->nla_pol ? : xfrma_policy, extack);\nif (err < 0)\nreturn err;\nif (link->doit == NULL)\nreturn -EINVAL;\nreturn link->doit(skb, nlh, attrs);\n}", "contrast": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\nstruct netlink_ext_ack *extack)\n{\nstruct net *net = sock_net(skb->sk);\nstruct nlattr *attrs[XFRMA_MAX+1];\nconst struct xfrm_link *link;\nint type, err;\n#ifdef CONFIG_COMPAT\nif (in_compat_syscall())\nreturn -EOPNOTSUPP;\n#endif\ntype = nlh->nlmsg_type;\nif (type > XFRM_MSG_MAX)\nreturn -EINVAL;\ntype -= XFRM_MSG_BASE;\nlink = &xfrm_dispatch[type];\nif (!netlink_net_capable(skb, CAP_NET_ADMIN))\nreturn -EPERM;\nif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\ntype == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n(nlh->nlmsg_flags & NLM_F_DUMP)) {\nif (link->dump == NULL)\nreturn -EINVAL;\n{\nstruct netlink_dump_control c = {\n.start = link->start,\n.dump = link->dump,\n.done = link->done,\n};\nreturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n}\n}\nerr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\nlink->nla_max ? : XFRMA_MAX,\nlink->nla_pol ? : xfrma_policy, extack);\nif (err < 0)\nreturn err;\nif (link->doit == NULL)\nreturn -EINVAL;\nreturn link->doit(skb, nlh, attrs);\n}", "label": 0}
{"index": 176930, "code": "static int usb_parse_configuration(struct usb_device *dev, int cfgidx,\nstruct usb_host_config *config, unsigned char *buffer, int size)\n{\nstruct device *ddev = &dev->dev;\nunsigned char *buffer0 = buffer;\nint cfgno;\nint nintf, nintf_orig;\nint i, j, n;\nstruct usb_interface_cache *intfc;\nunsigned char *buffer2;\nint size2;\nstruct usb_descriptor_header *header;\nint len, retval;\nu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\nunsigned iad_num = 0;\nmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\nif (config->desc.bDescriptorType != USB_DT_CONFIG ||\nconfig->desc.bLength < USB_DT_CONFIG_SIZE ||\nconfig->desc.bLength > size) {\ndev_err(ddev, \"invalid descriptor for config index %d: \"\n\"type = 0x%X, length = %d\\n\", cfgidx,\nconfig->desc.bDescriptorType, config->desc.bLength);\nreturn -EINVAL;\n}\ncfgno = config->desc.bConfigurationValue;\nbuffer += config->desc.bLength;\nsize -= config->desc.bLength;\nnintf = nintf_orig = config->desc.bNumInterfaces;\nif (nintf > USB_MAXINTERFACES) {\ndev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\"using maximum allowed: %d\\n\",\ncfgno, nintf, USB_MAXINTERFACES);\nnintf = USB_MAXINTERFACES;\n}\nn = 0;\nfor ((buffer2 = buffer, size2 = size);\nsize2 > 0;\n(buffer2 += header->bLength, size2 -= header->bLength)) {\nif (size2 < sizeof(struct usb_descriptor_header)) {\ndev_warn(ddev, \"config %d descriptor has %d excess \"\n\"byte%s, ignoring\\n\",\ncfgno, size2, plural(size2));\nbreak;\n}\nheader = (struct usb_descriptor_header *) buffer2;\nif ((header->bLength > size2) || (header->bLength < 2)) {\ndev_warn(ddev, \"config %d has an invalid descriptor \"\n\"of length %d, skipping remainder of the config\\n\",\ncfgno, header->bLength);\nbreak;\n}\nif (header->bDescriptorType == USB_DT_INTERFACE) {\nstruct usb_interface_descriptor *d;\nint inum;\nd = (struct usb_interface_descriptor *) header;\nif (d->bLength < USB_DT_INTERFACE_SIZE) {\ndev_warn(ddev, \"config %d has an invalid \"\n\"interface descriptor of length %d, \"\n\"skipping\\n\", cfgno, d->bLength);\ncontinue;\n}\ninum = d->bInterfaceNumber;\nif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\nn >= nintf_orig) {\ndev_warn(ddev, \"config %d has more interface \"\n\"descriptors, than it declares in \"\n\"bNumInterfaces, ignoring interface \"\n\"number: %d\\n\", cfgno, inum);\ncontinue;\n}\nif (inum >= nintf_orig)\ndev_warn(ddev, \"config %d has an invalid \"\n\"interface number: %d but max is %d\\n\",\ncfgno, inum, nintf_orig - 1);\nfor (i = 0; i < n; ++i) {\nif (inums[i] == inum)\nbreak;\n}\nif (i < n) {\nif (nalts[i] < 255)\n++nalts[i];\n} else if (n < USB_MAXINTERFACES) {\ninums[n] = inum;\nnalts[n] = 1;\n++n;\n}\n} else if (header->bDescriptorType ==\nUSB_DT_INTERFACE_ASSOCIATION) {\nif (iad_num == USB_MAXIADS) {\ndev_warn(ddev, \"found more Interface \"\n\"Association Descriptors \"\n\"than allocated for in \"\n\"configuration %d\\n\", cfgno);\n} else {\nconfig->intf_assoc[iad_num] =\n(struct usb_interface_assoc_descriptor\n*)header;\niad_num++;\n}\n} else if (header->bDescriptorType == USB_DT_DEVICE ||\nheader->bDescriptorType == USB_DT_CONFIG)\ndev_warn(ddev, \"config %d contains an unexpected \"\n\"descriptor of type 0x%X, skipping\\n\",\ncfgno, header->bDescriptorType);\n}\nsize = buffer2 - buffer;\nconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\nif (n != nintf)\ndev_warn(ddev, \"config %d has %d interface%s, different from \"\n\"the descriptor's value: %d\\n\",\ncfgno, n, plural(n), nintf_orig);\nelse if (n == 0)\ndev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\nconfig->desc.bNumInterfaces = nintf = n;\nfor (i = 0; i < nintf; ++i) {\nfor (j = 0; j < nintf; ++j) {\nif (inums[j] == i)\nbreak;\n}\nif (j >= nintf)\ndev_warn(ddev, \"config %d has no interface number \"\n\"%d\\n\", cfgno, i);\n}\nfor (i = 0; i < nintf; ++i) {\nj = nalts[i];\nif (j > USB_MAXALTSETTING) {\ndev_warn(ddev, \"too many alternate settings for \"\n\"config %d interface %d: %d, \"\n\"using maximum allowed: %d\\n\",\ncfgno, inums[i], j, USB_MAXALTSETTING);\nnalts[i] = j = USB_MAXALTSETTING;\n}\nlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\nconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\nif (!intfc)\nreturn -ENOMEM;\nkref_init(&intfc->ref);\n}\nconfig->extra = buffer;\ni = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\nUSB_DT_INTERFACE, &n);\nconfig->extralen = i;\nif (n > 0)\ndev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\nn, plural(n), \"configuration\");\nbuffer += i;\nsize -= i;\nwhile (size > 0) {\nretval = usb_parse_interface(ddev, cfgno, config,\nbuffer, size, inums, nalts);\nif (retval < 0)\nreturn retval;\nbuffer += retval;\nsize -= retval;\n}\nfor (i = 0; i < nintf; ++i) {\nintfc = config->intf_cache[i];\nfor (j = 0; j < intfc->num_altsetting; ++j) {\nfor (n = 0; n < intfc->num_altsetting; ++n) {\nif (intfc->altsetting[n].desc.\nbAlternateSetting == j)\nbreak;\n}\nif (n >= intfc->num_altsetting)\ndev_warn(ddev, \"config %d interface %d has no \"\n\"altsetting %d\\n\", cfgno, inums[i], j);\n}\n}\nreturn 0;\n}", "contrast": "static int usb_parse_configuration(struct usb_device *dev, int cfgidx,\nstruct usb_host_config *config, unsigned char *buffer, int size)\n{\nstruct device *ddev = &dev->dev;\nunsigned char *buffer0 = buffer;\nint cfgno;\nint nintf, nintf_orig;\nint i, j, n;\nstruct usb_interface_cache *intfc;\nunsigned char *buffer2;\nint size2;\nstruct usb_descriptor_header *header;\nint len, retval;\nu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\nunsigned iad_num = 0;\nmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\nif (config->desc.bDescriptorType != USB_DT_CONFIG ||\nconfig->desc.bLength < USB_DT_CONFIG_SIZE ||\nconfig->desc.bLength > size) {\ndev_err(ddev, \"invalid descriptor for config index %d: \"\n\"type = 0x%X, length = %d\\n\", cfgidx,\nconfig->desc.bDescriptorType, config->desc.bLength);\nreturn -EINVAL;\n}\ncfgno = config->desc.bConfigurationValue;\nbuffer += config->desc.bLength;\nsize -= config->desc.bLength;\nnintf = nintf_orig = config->desc.bNumInterfaces;\nif (nintf > USB_MAXINTERFACES) {\ndev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\"using maximum allowed: %d\\n\",\ncfgno, nintf, USB_MAXINTERFACES);\nnintf = USB_MAXINTERFACES;\n}\nn = 0;\nfor ((buffer2 = buffer, size2 = size);\nsize2 > 0;\n(buffer2 += header->bLength, size2 -= header->bLength)) {\nif (size2 < sizeof(struct usb_descriptor_header)) {\ndev_warn(ddev, \"config %d descriptor has %d excess \"\n\"byte%s, ignoring\\n\",\ncfgno, size2, plural(size2));\nbreak;\n}\nheader = (struct usb_descriptor_header *) buffer2;\nif ((header->bLength > size2) || (header->bLength < 2)) {\ndev_warn(ddev, \"config %d has an invalid descriptor \"\n\"of length %d, skipping remainder of the config\\n\",\ncfgno, header->bLength);\nbreak;\n}\nif (header->bDescriptorType == USB_DT_INTERFACE) {\nstruct usb_interface_descriptor *d;\nint inum;\nd = (struct usb_interface_descriptor *) header;\nif (d->bLength < USB_DT_INTERFACE_SIZE) {\ndev_warn(ddev, \"config %d has an invalid \"\n\"interface descriptor of length %d, \"\n\"skipping\\n\", cfgno, d->bLength);\ncontinue;\n}\ninum = d->bInterfaceNumber;\nif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\nn >= nintf_orig) {\ndev_warn(ddev, \"config %d has more interface \"\n\"descriptors, than it declares in \"\n\"bNumInterfaces, ignoring interface \"\n\"number: %d\\n\", cfgno, inum);\ncontinue;\n}\nif (inum >= nintf_orig)\ndev_warn(ddev, \"config %d has an invalid \"\n\"interface number: %d but max is %d\\n\",\ncfgno, inum, nintf_orig - 1);\nfor (i = 0; i < n; ++i) {\nif (inums[i] == inum)\nbreak;\n}\nif (i < n) {\nif (nalts[i] < 255)\n++nalts[i];\n} else if (n < USB_MAXINTERFACES) {\ninums[n] = inum;\nnalts[n] = 1;\n++n;\n}\n} else if (header->bDescriptorType ==\nUSB_DT_INTERFACE_ASSOCIATION) {\nstruct usb_interface_assoc_descriptor *d;\nd = (struct usb_interface_assoc_descriptor *)header;\nif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\ndev_warn(ddev,\n\"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\ncfgno, d->bLength);\ncontinue;\n}\nif (iad_num == USB_MAXIADS) {\ndev_warn(ddev, \"found more Interface \"\n\"Association Descriptors \"\n\"than allocated for in \"\n\"configuration %d\\n\", cfgno);\n} else {\nconfig->intf_assoc[iad_num] = d;\niad_num++;\n}\n} else if (header->bDescriptorType == USB_DT_DEVICE ||\nheader->bDescriptorType == USB_DT_CONFIG)\ndev_warn(ddev, \"config %d contains an unexpected \"\n\"descriptor of type 0x%X, skipping\\n\",\ncfgno, header->bDescriptorType);\n}\nsize = buffer2 - buffer;\nconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\nif (n != nintf)\ndev_warn(ddev, \"config %d has %d interface%s, different from \"\n\"the descriptor's value: %d\\n\",\ncfgno, n, plural(n), nintf_orig);\nelse if (n == 0)\ndev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\nconfig->desc.bNumInterfaces = nintf = n;\nfor (i = 0; i < nintf; ++i) {\nfor (j = 0; j < nintf; ++j) {\nif (inums[j] == i)\nbreak;\n}\nif (j >= nintf)\ndev_warn(ddev, \"config %d has no interface number \"\n\"%d\\n\", cfgno, i);\n}\nfor (i = 0; i < nintf; ++i) {\nj = nalts[i];\nif (j > USB_MAXALTSETTING) {\ndev_warn(ddev, \"too many alternate settings for \"\n\"config %d interface %d: %d, \"\n\"using maximum allowed: %d\\n\",\ncfgno, inums[i], j, USB_MAXALTSETTING);\nnalts[i] = j = USB_MAXALTSETTING;\n}\nlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\nconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\nif (!intfc)\nreturn -ENOMEM;\nkref_init(&intfc->ref);\n}\nconfig->extra = buffer;\ni = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\nUSB_DT_INTERFACE, &n);\nconfig->extralen = i;\nif (n > 0)\ndev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\nn, plural(n), \"configuration\");\nbuffer += i;\nsize -= i;\nwhile (size > 0) {\nretval = usb_parse_interface(ddev, cfgno, config,\nbuffer, size, inums, nalts);\nif (retval < 0)\nreturn retval;\nbuffer += retval;\nsize -= retval;\n}\nfor (i = 0; i < nintf; ++i) {\nintfc = config->intf_cache[i];\nfor (j = 0; j < intfc->num_altsetting; ++j) {\nfor (n = 0; n < intfc->num_altsetting; ++n) {\nif (intfc->altsetting[n].desc.\nbAlternateSetting == j)\nbreak;\n}\nif (n >= intfc->num_altsetting)\ndev_warn(ddev, \"config %d interface %d has no \"\n\"altsetting %d\\n\", cfgno, inums[i], j);\n}\n}\nreturn 0;\n}", "label": 0}
{"index": 176937, "code": "void uwbd_stop(struct uwb_rc *rc)\n{\nkthread_stop(rc->uwbd.task);\nuwbd_flush(rc);\n}", "contrast": "void uwbd_stop(struct uwb_rc *rc)\n{\nif (rc->uwbd.task)\nkthread_stop(rc->uwbd.task);\nuwbd_flush(rc);\n}", "label": 0}
{"index": 176950, "code": "build_config(char *prefix, struct server *server)\n{\nchar *path    = NULL;\nint path_size = strlen(prefix) + strlen(server->port) + 20;\npath = ss_malloc(path_size);\nsnprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\nFILE *f = fopen(path, \"w+\");\nif (f == NULL) {\nif (verbose) {\nLOGE(\"unable to open config file\");\n}\nss_free(path);\nreturn;\n}\nfprintf(f, \"{\\n\");\nfprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\nfprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\nif (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\nif (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\nif (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\nif (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\nif (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\nfprintf(f, \"\\n}\\n\");\nfclose(f);\nss_free(path);\n}", "contrast": "build_config(char *prefix, struct server *server)\nbuild_config(char *prefix, struct manager_ctx *manager, struct server *server)\n{\nchar *path    = NULL;\nint path_size = strlen(prefix) + strlen(server->port) + 20;\npath = ss_malloc(path_size);\nsnprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\nFILE *f = fopen(path, \"w+\");\nif (f == NULL) {\nif (verbose) {\nLOGE(\"unable to open config file\");\n}\nss_free(path);\nreturn;\n}\nfprintf(f, \"{\\n\");\nfprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\nfprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\nif (server->method)\nfprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\nelse if (manager->method)\nfprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", manager->method);\nif (server->fast_open[0])\nfprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\nif (server->mode)\nfprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\nif (server->plugin)\nfprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\nif (server->plugin_opts)\nfprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\nfprintf(f, \"\\n}\\n\");\nfclose(f);\nss_free(path);\n}", "label": 0}
{"index": 176957, "code": "int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\nconst Signature *s, const SigMatchData *smd,\nFlow *f,\nuint8_t *buffer, uint32_t buffer_len,\nuint32_t stream_start_offset,\nuint8_t inspection_mode, void *data)\n{\nSCEnter();\nKEYWORD_PROFILING_START;\ndet_ctx->inspection_recursion_counter++;\nif (det_ctx->inspection_recursion_counter == de_ctx->inspection_recursion_limit) {\ndet_ctx->discontinue_matching = 1;\nKEYWORD_PROFILING_END(det_ctx, smd->type, 0);\nSCReturnInt(0);\n}\nif (smd == NULL || buffer_len == 0) {\nKEYWORD_PROFILING_END(det_ctx, smd->type, 0);\nSCReturnInt(0);\n}\nif (smd->type == DETECT_CONTENT) {\nDetectContentData *cd = (DetectContentData *)smd->ctx;\nSCLogDebug(\"inspecting content %\"PRIu32\" buffer_len %\"PRIu32, cd->id, buffer_len);\n#ifdef DEBUG\nBUG_ON(cd->depth != 0 && cd->depth <= cd->offset);\n#endif\nuint8_t *found = NULL;\nuint32_t offset = 0;\nuint32_t depth = buffer_len;\nuint32_t prev_offset = 0;\nuint32_t prev_buffer_offset = det_ctx->buffer_offset;\ndo {\nif ((cd->flags & DETECT_CONTENT_DISTANCE) ||\n(cd->flags & DETECT_CONTENT_WITHIN)) {\nSCLogDebug(\"det_ctx->buffer_offset %\"PRIu32, det_ctx->buffer_offset);\noffset = prev_buffer_offset;\ndepth = buffer_len;\nint distance = cd->distance;\nif (cd->flags & DETECT_CONTENT_DISTANCE) {\nif (cd->flags & DETECT_CONTENT_DISTANCE_BE) {\ndistance = det_ctx->bj_values[cd->distance];\n}\nif (distance < 0 && (uint32_t)(abs(distance)) > offset)\noffset = 0;\nelse\noffset += distance;\nSCLogDebug(\"cd->distance %\"PRIi32\", offset %\"PRIu32\", depth %\"PRIu32,\ndistance, offset, depth);\n}\nif (cd->flags & DETECT_CONTENT_WITHIN) {\nif (cd->flags & DETECT_CONTENT_WITHIN_BE) {\nif ((int32_t)depth > (int32_t)(prev_buffer_offset + det_ctx->bj_values[cd->within] + distance)) {\ndepth = prev_buffer_offset + det_ctx->bj_values[cd->within] + distance;\n}\n} else {\nif ((int32_t)depth > (int32_t)(prev_buffer_offset + cd->within + distance)) {\ndepth = prev_buffer_offset + cd->within + distance;\n}\nSCLogDebug(\"cd->within %\"PRIi32\", det_ctx->buffer_offset %\"PRIu32\", depth %\"PRIu32,\ncd->within, prev_buffer_offset, depth);\n}\nif (stream_start_offset != 0 && prev_buffer_offset == 0) {\nif (depth <= stream_start_offset) {\ngoto no_match;\n} else if (depth >= (stream_start_offset + buffer_len)) {\n;\n} else {\ndepth = depth - stream_start_offset;\n}\n}\n}\nif (cd->flags & DETECT_CONTENT_DEPTH_BE) {\nif ((det_ctx->bj_values[cd->depth] + prev_buffer_offset) < depth) {\ndepth = prev_buffer_offset + det_ctx->bj_values[cd->depth];\n}\n} else {\nif (cd->depth != 0) {\nif ((cd->depth + prev_buffer_offset) < depth) {\ndepth = prev_buffer_offset + cd->depth;\n}\nSCLogDebug(\"cd->depth %\"PRIu32\", depth %\"PRIu32, cd->depth, depth);\n}\n}\nif (cd->flags & DETECT_CONTENT_OFFSET_BE) {\nif (det_ctx->bj_values[cd->offset] > offset)\noffset = det_ctx->bj_values[cd->offset];\n} else {\nif (cd->offset > offset) {\noffset = cd->offset;\nSCLogDebug(\"setting offset %\"PRIu32, offset);\n}\n}\n} else {\nif (cd->flags & DETECT_CONTENT_DEPTH_BE) {\ndepth = det_ctx->bj_values[cd->depth];\n} else {\nif (cd->depth != 0) {\ndepth = cd->depth;\n}\n}\nif (stream_start_offset != 0 && cd->flags & DETECT_CONTENT_DEPTH) {\nif (depth <= stream_start_offset) {\ngoto no_match;\n} else if (depth >= (stream_start_offset + buffer_len)) {\n;\n} else {\ndepth = depth - stream_start_offset;\n}\n}\nif (cd->flags & DETECT_CONTENT_OFFSET_BE)\noffset = det_ctx->bj_values[cd->offset];\nelse\noffset = cd->offset;\nprev_buffer_offset = 0;\n}\nSCLogDebug(\"offset %\"PRIu32\", prev_offset %\"PRIu32, offset, prev_offset);\nif (prev_offset != 0)\noffset = prev_offset;\nSCLogDebug(\"offset %\"PRIu32\", depth %\"PRIu32, offset, depth);\nif (depth > buffer_len)\ndepth = buffer_len;\nif (offset > depth || depth == 0) {\nif (cd->flags & DETECT_CONTENT_NEGATED) {\ngoto match;\n} else {\ngoto no_match;\n}\n}\nuint8_t *sbuffer = buffer + offset;\nuint32_t sbuffer_len = depth - offset;\nuint32_t match_offset = 0;\nSCLogDebug(\"sbuffer_len %\"PRIu32, sbuffer_len);\n#ifdef DEBUG\nBUG_ON(sbuffer_len > buffer_len);\n#endif\nfound = SpmScan(cd->spm_ctx, det_ctx->spm_thread_ctx, sbuffer,\nsbuffer_len);\nSCLogDebug(\"found %p cd negated %s\", found, cd->flags & DETECT_CONTENT_NEGATED ? \"true\" : \"false\");\nif (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {\ngoto no_match;\n} else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\ngoto match;\n} else if (found != NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\nSCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\", but negated so no match\", cd->id, match_offset);\nif (DETECT_CONTENT_IS_SINGLE(cd))\ndet_ctx->discontinue_matching = 1;\ngoto no_match;\n} else {\nmatch_offset = (uint32_t)((found - buffer) + cd->content_len);\nSCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\"\", cd->id, match_offset);\ndet_ctx->buffer_offset = match_offset;\nif (cd->flags & DETECT_CONTENT_REPLACE) {\nif (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD) {\ndet_ctx->replist = DetectReplaceAddToList(det_ctx->replist, found, cd);\n} else {\nSCLogWarning(SC_ERR_INVALID_VALUE, \"Can't modify payload without packet\");\n}\n}\nif (!(cd->flags & DETECT_CONTENT_RELATIVE_NEXT)) {\nSCLogDebug(\"no relative match coming up, so this is a match\");\ngoto match;\n}\nif (smd->is_last) {\ngoto no_match;\n}\nSCLogDebug(\"content %\"PRIu32, cd->id);\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nint r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\nf, buffer, buffer_len, stream_start_offset, inspection_mode, data);\nif (r == 1) {\nSCReturnInt(1);\n}\nif (det_ctx->discontinue_matching)\ngoto no_match;\nprev_offset = (match_offset - (cd->content_len - 1));\nSCLogDebug(\"trying to see if there is another match after prev_offset %\"PRIu32, prev_offset);\n}\n} while(1);\n} else if (smd->type == DETECT_ISDATAAT) {\nSCLogDebug(\"inspecting isdataat\");\nDetectIsdataatData *id = (DetectIsdataatData *)smd->ctx;\nif (id->flags & ISDATAAT_RELATIVE) {\nif (det_ctx->buffer_offset + id->dataat > buffer_len) {\nSCLogDebug(\"det_ctx->buffer_offset + id->dataat %\"PRIu32\" > %\"PRIu32, det_ctx->buffer_offset + id->dataat, buffer_len);\nif (id->flags & ISDATAAT_NEGATED)\ngoto match;\ngoto no_match;\n} else {\nSCLogDebug(\"relative isdataat match\");\nif (id->flags & ISDATAAT_NEGATED)\ngoto no_match;\ngoto match;\n}\n} else {\nif (id->dataat < buffer_len) {\nSCLogDebug(\"absolute isdataat match\");\nif (id->flags & ISDATAAT_NEGATED)\ngoto no_match;\ngoto match;\n} else {\nSCLogDebug(\"absolute isdataat mismatch, id->isdataat %\"PRIu32\", buffer_len %\"PRIu32\"\", id->dataat, buffer_len);\nif (id->flags & ISDATAAT_NEGATED)\ngoto match;\ngoto no_match;\n}\n}\n} else if (smd->type == DETECT_PCRE) {\nSCLogDebug(\"inspecting pcre\");\nDetectPcreData *pe = (DetectPcreData *)smd->ctx;\nuint32_t prev_buffer_offset = det_ctx->buffer_offset;\nuint32_t prev_offset = 0;\nint r = 0;\ndet_ctx->pcre_match_start_offset = 0;\ndo {\nPacket *p = NULL;\nif (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD)\np = (Packet *)data;\nr = DetectPcrePayloadMatch(det_ctx, s, smd, p, f,\nbuffer, buffer_len);\nif (r == 0) {\ngoto no_match;\n}\nif (!(pe->flags & DETECT_PCRE_RELATIVE_NEXT)) {\nSCLogDebug(\"no relative match coming up, so this is a match\");\ngoto match;\n}\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nprev_offset = det_ctx->pcre_match_start_offset;\nr = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\nf, buffer, buffer_len, stream_start_offset, inspection_mode, data);\nif (r == 1) {\nSCReturnInt(1);\n}\nif (det_ctx->discontinue_matching)\ngoto no_match;\ndet_ctx->buffer_offset = prev_buffer_offset;\ndet_ctx->pcre_match_start_offset = prev_offset;\n} while (1);\n} else if (smd->type == DETECT_BYTETEST) {\nDetectBytetestData *btd = (DetectBytetestData *)smd->ctx;\nuint8_t flags = btd->flags;\nint32_t offset = btd->offset;\nuint64_t value = btd->value;\nif (flags & DETECT_BYTETEST_OFFSET_BE) {\noffset = det_ctx->bj_values[offset];\n}\nif (flags & DETECT_BYTETEST_VALUE_BE) {\nvalue = det_ctx->bj_values[value];\n}\nif (flags & DETECT_BYTETEST_DCE && data != NULL) {\nDCERPCState *dcerpc_state = (DCERPCState *)data;\nflags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\nDETECT_BYTETEST_LITTLE: 0);\n}\nif (DetectBytetestDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len, flags,\noffset, value) != 1) {\ngoto no_match;\n}\ngoto match;\n} else if (smd->type == DETECT_BYTEJUMP) {\nDetectBytejumpData *bjd = (DetectBytejumpData *)smd->ctx;\nuint8_t flags = bjd->flags;\nint32_t offset = bjd->offset;\nif (flags & DETECT_BYTEJUMP_OFFSET_BE) {\noffset = det_ctx->bj_values[offset];\n}\nif (flags & DETECT_BYTEJUMP_DCE && data != NULL) {\nDCERPCState *dcerpc_state = (DCERPCState *)data;\nflags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\nDETECT_BYTEJUMP_LITTLE: 0);\n}\nif (DetectBytejumpDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len,\nflags, offset) != 1) {\ngoto no_match;\n}\ngoto match;\n} else if (smd->type == DETECT_BYTE_EXTRACT) {\nDetectByteExtractData *bed = (DetectByteExtractData *)smd->ctx;\nuint8_t endian = bed->endian;\nif ((bed->flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN) &&\nendian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL) {\nDCERPCState *dcerpc_state = (DCERPCState *)data;\nendian |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?\nDETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG);\n}\nif (DetectByteExtractDoMatch(det_ctx, smd, s, buffer,\nbuffer_len,\n&det_ctx->bj_values[bed->local_id],\nendian) != 1) {\ngoto no_match;\n}\ngoto match;\n} else if (smd->type == DETECT_AL_URILEN) {\nSCLogDebug(\"inspecting uri len\");\nint r = 0;\nDetectUrilenData *urilend = (DetectUrilenData *) smd->ctx;\nswitch (urilend->mode) {\ncase DETECT_URILEN_EQ:\nif (buffer_len == urilend->urilen1)\nr = 1;\nbreak;\ncase DETECT_URILEN_LT:\nif (buffer_len < urilend->urilen1)\nr = 1;\nbreak;\ncase DETECT_URILEN_GT:\nif (buffer_len > urilend->urilen1)\nr = 1;\nbreak;\ncase DETECT_URILEN_RA:\nif (buffer_len > urilend->urilen1 &&\nbuffer_len < urilend->urilen2) {\nr = 1;\n}\nbreak;\n}\nif (r == 1) {\ngoto match;\n}\ndet_ctx->discontinue_matching = 0;\ngoto no_match;\n#ifdef HAVE_LUA\n}\nelse if (smd->type == DETECT_LUA) {\nSCLogDebug(\"lua starting\");\nif (DetectLuaMatchBuffer(det_ctx, s, smd, buffer, buffer_len,\ndet_ctx->buffer_offset, f) != 1)\n{\nSCLogDebug(\"lua no_match\");\ngoto no_match;\n}\nSCLogDebug(\"lua match\");\ngoto match;\n#endif\n} else if (smd->type == DETECT_BASE64_DECODE) {\nif (DetectBase64DecodeDoMatch(det_ctx, s, smd, buffer, buffer_len)) {\nif (s->sm_arrays[DETECT_SM_LIST_BASE64_DATA] != NULL) {\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nif (DetectBase64DataDoMatch(de_ctx, det_ctx, s, f)) {\ngoto final_match;\n}\n}\n}\n} else {\nSCLogDebug(\"sm->type %u\", smd->type);\n#ifdef DEBUG\nBUG_ON(1);\n#endif\n}\nno_match:\nKEYWORD_PROFILING_END(det_ctx, smd->type, 0);\nSCReturnInt(0);\nmatch:\nif (!smd->is_last) {\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nint r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\nf, buffer, buffer_len, stream_start_offset, inspection_mode, data);\nSCReturnInt(r);\n}\nfinal_match:\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nSCReturnInt(1);\n}", "contrast": "int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\nconst Signature *s, const SigMatchData *smd,\nFlow *f,\nuint8_t *buffer, uint32_t buffer_len,\nuint32_t stream_start_offset,\nuint8_t inspection_mode, void *data)\n{\nSCEnter();\nKEYWORD_PROFILING_START;\ndet_ctx->inspection_recursion_counter++;\nif (det_ctx->inspection_recursion_counter == de_ctx->inspection_recursion_limit) {\ndet_ctx->discontinue_matching = 1;\nKEYWORD_PROFILING_END(det_ctx, smd->type, 0);\nSCReturnInt(0);\n}\nif (smd == NULL || buffer_len == 0) {\nKEYWORD_PROFILING_END(det_ctx, smd->type, 0);\nSCReturnInt(0);\n}\nif (smd->type == DETECT_CONTENT) {\nDetectContentData *cd = (DetectContentData *)smd->ctx;\nSCLogDebug(\"inspecting content %\"PRIu32\" buffer_len %\"PRIu32, cd->id, buffer_len);\n#ifdef DEBUG\nBUG_ON(cd->depth != 0 && cd->depth <= cd->offset);\n#endif\nuint8_t *found = NULL;\nuint32_t offset = 0;\nuint32_t depth = buffer_len;\nuint32_t prev_offset = 0;\nuint32_t prev_buffer_offset = det_ctx->buffer_offset;\ndo {\nif ((cd->flags & DETECT_CONTENT_DISTANCE) ||\n(cd->flags & DETECT_CONTENT_WITHIN)) {\nSCLogDebug(\"det_ctx->buffer_offset %\"PRIu32, det_ctx->buffer_offset);\noffset = prev_buffer_offset;\ndepth = buffer_len;\nint distance = cd->distance;\nif (cd->flags & DETECT_CONTENT_DISTANCE) {\nif (cd->flags & DETECT_CONTENT_DISTANCE_BE) {\ndistance = det_ctx->bj_values[cd->distance];\n}\nif (distance < 0 && (uint32_t)(abs(distance)) > offset)\noffset = 0;\nelse\noffset += distance;\nSCLogDebug(\"cd->distance %\"PRIi32\", offset %\"PRIu32\", depth %\"PRIu32,\ndistance, offset, depth);\n}\nif (cd->flags & DETECT_CONTENT_WITHIN) {\nif (cd->flags & DETECT_CONTENT_WITHIN_BE) {\nif ((int32_t)depth > (int32_t)(prev_buffer_offset + det_ctx->bj_values[cd->within] + distance)) {\ndepth = prev_buffer_offset + det_ctx->bj_values[cd->within] + distance;\n}\n} else {\nif ((int32_t)depth > (int32_t)(prev_buffer_offset + cd->within + distance)) {\ndepth = prev_buffer_offset + cd->within + distance;\n}\nSCLogDebug(\"cd->within %\"PRIi32\", det_ctx->buffer_offset %\"PRIu32\", depth %\"PRIu32,\ncd->within, prev_buffer_offset, depth);\n}\nif (stream_start_offset != 0 && prev_buffer_offset == 0) {\nif (depth <= stream_start_offset) {\ngoto no_match;\n} else if (depth >= (stream_start_offset + buffer_len)) {\n;\n} else {\ndepth = depth - stream_start_offset;\n}\n}\n}\nif (cd->flags & DETECT_CONTENT_DEPTH_BE) {\nif ((det_ctx->bj_values[cd->depth] + prev_buffer_offset) < depth) {\ndepth = prev_buffer_offset + det_ctx->bj_values[cd->depth];\n}\n} else {\nif (cd->depth != 0) {\nif ((cd->depth + prev_buffer_offset) < depth) {\ndepth = prev_buffer_offset + cd->depth;\n}\nSCLogDebug(\"cd->depth %\"PRIu32\", depth %\"PRIu32, cd->depth, depth);\n}\n}\nif (cd->flags & DETECT_CONTENT_OFFSET_BE) {\nif (det_ctx->bj_values[cd->offset] > offset)\noffset = det_ctx->bj_values[cd->offset];\n} else {\nif (cd->offset > offset) {\noffset = cd->offset;\nSCLogDebug(\"setting offset %\"PRIu32, offset);\n}\n}\n} else {\nif (cd->flags & DETECT_CONTENT_DEPTH_BE) {\ndepth = det_ctx->bj_values[cd->depth];\n} else {\nif (cd->depth != 0) {\ndepth = cd->depth;\n}\n}\nif (stream_start_offset != 0 && cd->flags & DETECT_CONTENT_DEPTH) {\nif (depth <= stream_start_offset) {\ngoto no_match;\n} else if (depth >= (stream_start_offset + buffer_len)) {\n;\n} else {\ndepth = depth - stream_start_offset;\n}\n}\nif (cd->flags & DETECT_CONTENT_OFFSET_BE)\noffset = det_ctx->bj_values[cd->offset];\nelse\noffset = cd->offset;\nprev_buffer_offset = 0;\n}\nSCLogDebug(\"offset %\"PRIu32\", prev_offset %\"PRIu32, offset, prev_offset);\nif (prev_offset != 0)\noffset = prev_offset;\nSCLogDebug(\"offset %\"PRIu32\", depth %\"PRIu32, offset, depth);\nif (depth > buffer_len)\ndepth = buffer_len;\nif (offset > depth || depth == 0) {\nif (cd->flags & DETECT_CONTENT_NEGATED) {\ngoto match;\n} else {\ngoto no_match;\n}\n}\nuint8_t *sbuffer = buffer + offset;\nuint32_t sbuffer_len = depth - offset;\nuint32_t match_offset = 0;\nSCLogDebug(\"sbuffer_len %\"PRIu32, sbuffer_len);\n#ifdef DEBUG\nBUG_ON(sbuffer_len > buffer_len);\n#endif\nfound = SpmScan(cd->spm_ctx, det_ctx->spm_thread_ctx, sbuffer,\nsbuffer_len);\nSCLogDebug(\"found %p cd negated %s\", found, cd->flags & DETECT_CONTENT_NEGATED ? \"true\" : \"false\");\nif (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {\nif ((cd->flags & (DETECT_CONTENT_DISTANCE|DETECT_CONTENT_WITHIN)) == 0) {\ndet_ctx->discontinue_matching = 1;\n}\ngoto no_match;\n} else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\ngoto match;\n} else if (found != NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\nSCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\", but negated so no match\", cd->id, match_offset);\nif (DETECT_CONTENT_IS_SINGLE(cd))\ndet_ctx->discontinue_matching = 1;\ngoto no_match;\n} else {\nmatch_offset = (uint32_t)((found - buffer) + cd->content_len);\nSCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\"\", cd->id, match_offset);\ndet_ctx->buffer_offset = match_offset;\nif (cd->flags & DETECT_CONTENT_REPLACE) {\nif (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD) {\ndet_ctx->replist = DetectReplaceAddToList(det_ctx->replist, found, cd);\n} else {\nSCLogWarning(SC_ERR_INVALID_VALUE, \"Can't modify payload without packet\");\n}\n}\nif (smd->is_last) {\ngoto match;\n}\nSCLogDebug(\"content %\"PRIu32, cd->id);\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nint r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\nf, buffer, buffer_len, stream_start_offset, inspection_mode, data);\nif (r == 1) {\nSCReturnInt(1);\n}\nSCLogDebug(\"no match for 'next sm'\");\nif (det_ctx->discontinue_matching) {\nSCLogDebug(\"'next sm' said to discontinue this right now\");\ngoto no_match;\n}\nif ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {\nSCLogDebug(\"'next sm' does not depend on me, so we can give up\");\ndet_ctx->discontinue_matching = 1;\ngoto no_match;\n}\nSCLogDebug(\"'next sm' depends on me %p, lets see what we can do (flags %u)\", cd, cd->flags);\nprev_offset = (match_offset - (cd->content_len - 1));\nSCLogDebug(\"trying to see if there is another match after prev_offset %\"PRIu32, prev_offset);\n}\n} while(1);\n} else if (smd->type == DETECT_ISDATAAT) {\nSCLogDebug(\"inspecting isdataat\");\nDetectIsdataatData *id = (DetectIsdataatData *)smd->ctx;\nif (id->flags & ISDATAAT_RELATIVE) {\nif (det_ctx->buffer_offset + id->dataat > buffer_len) {\nSCLogDebug(\"det_ctx->buffer_offset + id->dataat %\"PRIu32\" > %\"PRIu32, det_ctx->buffer_offset + id->dataat, buffer_len);\nif (id->flags & ISDATAAT_NEGATED)\ngoto match;\ngoto no_match;\n} else {\nSCLogDebug(\"relative isdataat match\");\nif (id->flags & ISDATAAT_NEGATED)\ngoto no_match;\ngoto match;\n}\n} else {\nif (id->dataat < buffer_len) {\nSCLogDebug(\"absolute isdataat match\");\nif (id->flags & ISDATAAT_NEGATED)\ngoto no_match;\ngoto match;\n} else {\nSCLogDebug(\"absolute isdataat mismatch, id->isdataat %\"PRIu32\", buffer_len %\"PRIu32\"\", id->dataat, buffer_len);\nif (id->flags & ISDATAAT_NEGATED)\ngoto match;\ngoto no_match;\n}\n}\n} else if (smd->type == DETECT_PCRE) {\nSCLogDebug(\"inspecting pcre\");\nDetectPcreData *pe = (DetectPcreData *)smd->ctx;\nuint32_t prev_buffer_offset = det_ctx->buffer_offset;\nuint32_t prev_offset = 0;\nint r = 0;\ndet_ctx->pcre_match_start_offset = 0;\ndo {\nPacket *p = NULL;\nif (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD)\np = (Packet *)data;\nr = DetectPcrePayloadMatch(det_ctx, s, smd, p, f,\nbuffer, buffer_len);\nif (r == 0) {\ngoto no_match;\n}\nif (!(pe->flags & DETECT_PCRE_RELATIVE_NEXT)) {\nSCLogDebug(\"no relative match coming up, so this is a match\");\ngoto match;\n}\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nprev_offset = det_ctx->pcre_match_start_offset;\nr = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\nf, buffer, buffer_len, stream_start_offset, inspection_mode, data);\nif (r == 1) {\nSCReturnInt(1);\n}\nif (det_ctx->discontinue_matching)\ngoto no_match;\ndet_ctx->buffer_offset = prev_buffer_offset;\ndet_ctx->pcre_match_start_offset = prev_offset;\n} while (1);\n} else if (smd->type == DETECT_BYTETEST) {\nDetectBytetestData *btd = (DetectBytetestData *)smd->ctx;\nuint8_t flags = btd->flags;\nint32_t offset = btd->offset;\nuint64_t value = btd->value;\nif (flags & DETECT_BYTETEST_OFFSET_BE) {\noffset = det_ctx->bj_values[offset];\n}\nif (flags & DETECT_BYTETEST_VALUE_BE) {\nvalue = det_ctx->bj_values[value];\n}\nif (flags & DETECT_BYTETEST_DCE && data != NULL) {\nDCERPCState *dcerpc_state = (DCERPCState *)data;\nflags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\nDETECT_BYTETEST_LITTLE: 0);\n}\nif (DetectBytetestDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len, flags,\noffset, value) != 1) {\ngoto no_match;\n}\ngoto match;\n} else if (smd->type == DETECT_BYTEJUMP) {\nDetectBytejumpData *bjd = (DetectBytejumpData *)smd->ctx;\nuint8_t flags = bjd->flags;\nint32_t offset = bjd->offset;\nif (flags & DETECT_BYTEJUMP_OFFSET_BE) {\noffset = det_ctx->bj_values[offset];\n}\nif (flags & DETECT_BYTEJUMP_DCE && data != NULL) {\nDCERPCState *dcerpc_state = (DCERPCState *)data;\nflags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\nDETECT_BYTEJUMP_LITTLE: 0);\n}\nif (DetectBytejumpDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len,\nflags, offset) != 1) {\ngoto no_match;\n}\ngoto match;\n} else if (smd->type == DETECT_BYTE_EXTRACT) {\nDetectByteExtractData *bed = (DetectByteExtractData *)smd->ctx;\nuint8_t endian = bed->endian;\nif ((bed->flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN) &&\nendian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL) {\nDCERPCState *dcerpc_state = (DCERPCState *)data;\nendian |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?\nDETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG);\n}\nif (DetectByteExtractDoMatch(det_ctx, smd, s, buffer,\nbuffer_len,\n&det_ctx->bj_values[bed->local_id],\nendian) != 1) {\ngoto no_match;\n}\ngoto match;\n} else if (smd->type == DETECT_AL_URILEN) {\nSCLogDebug(\"inspecting uri len\");\nint r = 0;\nDetectUrilenData *urilend = (DetectUrilenData *) smd->ctx;\nswitch (urilend->mode) {\ncase DETECT_URILEN_EQ:\nif (buffer_len == urilend->urilen1)\nr = 1;\nbreak;\ncase DETECT_URILEN_LT:\nif (buffer_len < urilend->urilen1)\nr = 1;\nbreak;\ncase DETECT_URILEN_GT:\nif (buffer_len > urilend->urilen1)\nr = 1;\nbreak;\ncase DETECT_URILEN_RA:\nif (buffer_len > urilend->urilen1 &&\nbuffer_len < urilend->urilen2) {\nr = 1;\n}\nbreak;\n}\nif (r == 1) {\ngoto match;\n}\ndet_ctx->discontinue_matching = 0;\ngoto no_match;\n#ifdef HAVE_LUA\n}\nelse if (smd->type == DETECT_LUA) {\nSCLogDebug(\"lua starting\");\nif (DetectLuaMatchBuffer(det_ctx, s, smd, buffer, buffer_len,\ndet_ctx->buffer_offset, f) != 1)\n{\nSCLogDebug(\"lua no_match\");\ngoto no_match;\n}\nSCLogDebug(\"lua match\");\ngoto match;\n#endif\n} else if (smd->type == DETECT_BASE64_DECODE) {\nif (DetectBase64DecodeDoMatch(det_ctx, s, smd, buffer, buffer_len)) {\nif (s->sm_arrays[DETECT_SM_LIST_BASE64_DATA] != NULL) {\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nif (DetectBase64DataDoMatch(de_ctx, det_ctx, s, f)) {\ngoto final_match;\n}\n}\n}\n} else {\nSCLogDebug(\"sm->type %u\", smd->type);\n#ifdef DEBUG\nBUG_ON(1);\n#endif\n}\nno_match:\nKEYWORD_PROFILING_END(det_ctx, smd->type, 0);\nSCReturnInt(0);\nmatch:\nif (!smd->is_last) {\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nint r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\nf, buffer, buffer_len, stream_start_offset, inspection_mode, data);\nSCReturnInt(r);\n}\nfinal_match:\nKEYWORD_PROFILING_END(det_ctx, smd->type, 1);\nSCReturnInt(1);\n}", "label": 0}
{"index": 176964, "code": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\nint port)\n{\nunsigned long flags;\nstruct snd_seq_client_port *new_port, *p;\nint num = -1;\nif (snd_BUG_ON(!client))\nreturn NULL;\nif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\npr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\nreturn NULL;\n}\nnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\nif (!new_port)\nreturn NULL;\nnew_port->addr.client = client->number;\nnew_port->addr.port = -1;\nnew_port->owner = THIS_MODULE;\nsprintf(new_port->name, \"port-%d\", num);\nsnd_use_lock_init(&new_port->use_lock);\nport_subs_info_init(&new_port->c_src);\nport_subs_info_init(&new_port->c_dest);\nnum = port >= 0 ? port : 0;\nmutex_lock(&client->ports_mutex);\nwrite_lock_irqsave(&client->ports_lock, flags);\nlist_for_each_entry(p, &client->ports_list_head, list) {\nif (p->addr.port > num)\nbreak;\nif (port < 0)\nnum = p->addr.port + 1;\n}\nlist_add_tail(&new_port->list, &p->list);\nclient->num_ports++;\nnew_port->addr.port = num;\nwrite_unlock_irqrestore(&client->ports_lock, flags);\nmutex_unlock(&client->ports_mutex);\nsprintf(new_port->name, \"port-%d\", num);\nreturn new_port;\n}", "contrast": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\nint port)\n{\nunsigned long flags;\nstruct snd_seq_client_port *new_port, *p;\nint num = -1;\nif (snd_BUG_ON(!client))\nreturn NULL;\nif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\npr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\nreturn NULL;\n}\nnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\nif (!new_port)\nreturn NULL;\nnew_port->addr.client = client->number;\nnew_port->addr.port = -1;\nnew_port->owner = THIS_MODULE;\nsprintf(new_port->name, \"port-%d\", num);\nsnd_use_lock_init(&new_port->use_lock);\nport_subs_info_init(&new_port->c_src);\nport_subs_info_init(&new_port->c_dest);\nsnd_use_lock_use(&new_port->use_lock);\nnum = port >= 0 ? port : 0;\nmutex_lock(&client->ports_mutex);\nwrite_lock_irqsave(&client->ports_lock, flags);\nlist_for_each_entry(p, &client->ports_list_head, list) {\nif (p->addr.port > num)\nbreak;\nif (port < 0)\nnum = p->addr.port + 1;\n}\nlist_add_tail(&new_port->list, &p->list);\nclient->num_ports++;\nnew_port->addr.port = num;\nsprintf(new_port->name, \"port-%d\", num);\nwrite_unlock_irqrestore(&client->ports_lock, flags);\nmutex_unlock(&client->ports_mutex);\nreturn new_port;\n}", "label": 0}
{"index": 176972, "code": "static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\n{\nstruct device *idev = &interface->dev;\nstruct usb_device *udev = interface_to_usbdev(interface);\nstruct lego_usb_tower *dev = NULL;\nstruct usb_host_interface *iface_desc;\nstruct usb_endpoint_descriptor* endpoint;\nstruct tower_get_version_reply get_version_reply;\nint i;\nint retval = -ENOMEM;\nint result;\ndev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\nif (!dev)\ngoto exit;\nmutex_init(&dev->lock);\ndev->udev = udev;\ndev->open_count = 0;\ndev->read_buffer = NULL;\ndev->read_buffer_length = 0;\ndev->read_packet_length = 0;\nspin_lock_init (&dev->read_buffer_lock);\ndev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\ndev->read_last_arrival = jiffies;\ninit_waitqueue_head (&dev->read_wait);\ninit_waitqueue_head (&dev->write_wait);\ndev->interrupt_in_buffer = NULL;\ndev->interrupt_in_endpoint = NULL;\ndev->interrupt_in_urb = NULL;\ndev->interrupt_in_running = 0;\ndev->interrupt_in_done = 0;\ndev->interrupt_out_buffer = NULL;\ndev->interrupt_out_endpoint = NULL;\ndev->interrupt_out_urb = NULL;\ndev->interrupt_out_busy = 0;\niface_desc = interface->cur_altsetting;\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\nendpoint = &iface_desc->endpoint[i].desc;\nif (usb_endpoint_xfer_int(endpoint)) {\nif (usb_endpoint_dir_in(endpoint))\ndev->interrupt_in_endpoint = endpoint;\nelse\ndev->interrupt_out_endpoint = endpoint;\n}\n}\nif(dev->interrupt_in_endpoint == NULL) {\ndev_err(idev, \"interrupt in endpoint not found\\n\");\ngoto error;\n}\nif (dev->interrupt_out_endpoint == NULL) {\ndev_err(idev, \"interrupt out endpoint not found\\n\");\ngoto error;\n}\ndev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\nif (!dev->read_buffer)\ngoto error;\ndev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\nif (!dev->interrupt_in_buffer)\ngoto error;\ndev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\nif (!dev->interrupt_in_urb)\ngoto error;\ndev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\nif (!dev->interrupt_out_buffer)\ngoto error;\ndev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\nif (!dev->interrupt_out_urb)\ngoto error;\ndev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\ndev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\nusb_set_intfdata (interface, dev);\nretval = usb_register_dev (interface, &tower_class);\nif (retval) {\ndev_err(idev, \"Not able to get a minor for this device.\\n\");\nusb_set_intfdata (interface, NULL);\ngoto error;\n}\ndev->minor = interface->minor;\ndev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\nUSB_MAJOR, dev->minor);\nresult = usb_control_msg (udev,\nusb_rcvctrlpipe(udev, 0),\nLEGO_USB_TOWER_REQUEST_GET_VERSION,\nUSB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n0,\n0,\n&get_version_reply,\nsizeof(get_version_reply),\n1000);\nif (result < 0) {\ndev_err(idev, \"LEGO USB Tower get version control request failed\\n\");\nretval = result;\ngoto error;\n}\ndev_info(&interface->dev, \"LEGO USB Tower firmware version is %d.%d \"\n\"build %d\\n\", get_version_reply.major,\nget_version_reply.minor,\nle16_to_cpu(get_version_reply.build_no));\nexit:\nreturn retval;\nerror:\ntower_delete(dev);\nreturn retval;\n}", "contrast": "static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\n{\nstruct device *idev = &interface->dev;\nstruct usb_device *udev = interface_to_usbdev(interface);\nstruct lego_usb_tower *dev = NULL;\nstruct usb_host_interface *iface_desc;\nstruct usb_endpoint_descriptor* endpoint;\nstruct tower_get_version_reply get_version_reply;\nint i;\nint retval = -ENOMEM;\nint result;\ndev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\nif (!dev)\ngoto exit;\nmutex_init(&dev->lock);\ndev->udev = udev;\ndev->open_count = 0;\ndev->read_buffer = NULL;\ndev->read_buffer_length = 0;\ndev->read_packet_length = 0;\nspin_lock_init (&dev->read_buffer_lock);\ndev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\ndev->read_last_arrival = jiffies;\ninit_waitqueue_head (&dev->read_wait);\ninit_waitqueue_head (&dev->write_wait);\ndev->interrupt_in_buffer = NULL;\ndev->interrupt_in_endpoint = NULL;\ndev->interrupt_in_urb = NULL;\ndev->interrupt_in_running = 0;\ndev->interrupt_in_done = 0;\ndev->interrupt_out_buffer = NULL;\ndev->interrupt_out_endpoint = NULL;\ndev->interrupt_out_urb = NULL;\ndev->interrupt_out_busy = 0;\niface_desc = interface->cur_altsetting;\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\nendpoint = &iface_desc->endpoint[i].desc;\nif (usb_endpoint_xfer_int(endpoint)) {\nif (usb_endpoint_dir_in(endpoint))\ndev->interrupt_in_endpoint = endpoint;\nelse\ndev->interrupt_out_endpoint = endpoint;\n}\n}\nif(dev->interrupt_in_endpoint == NULL) {\ndev_err(idev, \"interrupt in endpoint not found\\n\");\ngoto error;\n}\nif (dev->interrupt_out_endpoint == NULL) {\ndev_err(idev, \"interrupt out endpoint not found\\n\");\ngoto error;\n}\ndev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\nif (!dev->read_buffer)\ngoto error;\ndev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\nif (!dev->interrupt_in_buffer)\ngoto error;\ndev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\nif (!dev->interrupt_in_urb)\ngoto error;\ndev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\nif (!dev->interrupt_out_buffer)\ngoto error;\ndev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\nif (!dev->interrupt_out_urb)\ngoto error;\ndev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\ndev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\nresult = usb_control_msg (udev,\nusb_rcvctrlpipe(udev, 0),\nLEGO_USB_TOWER_REQUEST_GET_VERSION,\nUSB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n0,\n0,\n&get_version_reply,\nsizeof(get_version_reply),\n1000);\nif (result < 0) {\ndev_err(idev, \"LEGO USB Tower get version control request failed\\n\");\nretval = result;\ngoto error;\n}\ndev_info(&interface->dev, \"LEGO USB Tower firmware version is %d.%d \"\n\"build %d\\n\", get_version_reply.major,\nget_version_reply.minor,\nle16_to_cpu(get_version_reply.build_no));\nusb_set_intfdata (interface, dev);\nretval = usb_register_dev (interface, &tower_class);\nif (retval) {\ndev_err(idev, \"Not able to get a minor for this device.\\n\");\nusb_set_intfdata (interface, NULL);\ngoto error;\n}\ndev->minor = interface->minor;\ndev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\nUSB_MAJOR, dev->minor);\nexit:\nreturn retval;\nerror:\ntower_delete(dev);\nreturn retval;\n}", "label": 0}
{"index": 176981, "code": "is_link_trusted (NautilusFile *file,\ngboolean      is_launcher)\n{\nGFile *location;\ngboolean res;\nif (!is_launcher)\n{\nreturn TRUE;\n}\nif (nautilus_file_can_execute (file))\n{\nreturn TRUE;\n}\nres = FALSE;\nif (nautilus_file_is_local (file))\n{\nlocation = nautilus_file_get_location (file);\nres = nautilus_is_in_system_dir (location);\ng_object_unref (location);\n}\nreturn res;\n}", "contrast": "is_link_trusted (NautilusFile *file,\ngboolean      is_launcher)\n{\nGFile *location;\ngboolean res;\ng_autofree gchar* trusted = NULL;\nif (!is_launcher)\n{\nreturn TRUE;\n}\ntrusted = nautilus_file_get_metadata (file,\nNAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\nNULL);\nif (nautilus_file_can_execute (file) && trusted != NULL)\n{\nreturn TRUE;\n}\nres = FALSE;\nif (nautilus_file_is_local (file))\n{\nlocation = nautilus_file_get_location (file);\nres = nautilus_is_in_system_dir (location);\ng_object_unref (location);\n}\nreturn res;\n}", "label": 0}
{"index": 176987, "code": "activate_desktop_file (ActivateParameters *parameters,\nNautilusFile       *file)\n{\nActivateParametersDesktop *parameters_desktop;\nchar *primary, *secondary, *display_name;\nGtkWidget *dialog;\nGdkScreen *screen;\nchar *uri;\nscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\nif (!nautilus_file_is_trusted_link (file))\n{\nparameters_desktop = g_new0 (ActivateParametersDesktop, 1);\nif (parameters->parent_window)\n{\nparameters_desktop->parent_window = parameters->parent_window;\ng_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n}\nparameters_desktop->file = nautilus_file_ref (file);\nprimary = _(\"Untrusted application launcher\");\ndisplay_name = nautilus_file_get_display_name (file);\nsecondary =\ng_strdup_printf (_(\"The application launcher \u201c%s\u201d has not been marked as trusted. \"\n\"If you do not know the source of this file, launching it may be unsafe.\"\n),\ndisplay_name);\ndialog = gtk_message_dialog_new (parameters->parent_window,\n0,\nGTK_MESSAGE_WARNING,\nGTK_BUTTONS_NONE,\nNULL);\ng_object_set (dialog,\n\"text\", primary,\n\"secondary-text\", secondary,\nNULL);\ngtk_dialog_add_button (GTK_DIALOG (dialog),\n_(\"_Launch Anyway\"), RESPONSE_RUN);\nif (nautilus_file_can_set_permissions (file))\n{\ngtk_dialog_add_button (GTK_DIALOG (dialog),\n_(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n}\ngtk_dialog_add_button (GTK_DIALOG (dialog),\n_(\"_Cancel\"), GTK_RESPONSE_CANCEL);\ngtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\ng_signal_connect (dialog, \"response\",\nG_CALLBACK (untrusted_launcher_response_callback),\nparameters_desktop);\ngtk_widget_show (dialog);\ng_free (display_name);\ng_free (secondary);\nreturn;\n}\nuri = nautilus_file_get_uri (file);\nDEBUG (\"Launching trusted launcher %s\", uri);\nnautilus_launch_desktop_file (screen, uri, NULL,\nparameters->parent_window);\ng_free (uri);\n}", "contrast": "activate_desktop_file (ActivateParameters *parameters,\nNautilusFile       *file)\n{\nActivateParametersDesktop *parameters_desktop;\nchar *primary, *secondary, *display_name;\nGtkWidget *dialog;\nGdkScreen *screen;\nchar *uri;\nscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\nif (!nautilus_file_is_trusted_link (file))\n{\nparameters_desktop = g_new0 (ActivateParametersDesktop, 1);\nif (parameters->parent_window)\n{\nparameters_desktop->parent_window = parameters->parent_window;\ng_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n}\nparameters_desktop->file = nautilus_file_ref (file);\nprimary = _(\"Untrusted application launcher\");\ndisplay_name = nautilus_file_get_display_name (file);\nsecondary =\ng_strdup_printf (_(\"The application launcher \u201c%s\u201d has not been marked as trusted. \"\n\"If you do not know the source of this file, launching it may be unsafe.\"\n),\ndisplay_name);\ndialog = gtk_message_dialog_new (parameters->parent_window,\n0,\nGTK_MESSAGE_WARNING,\nGTK_BUTTONS_NONE,\nNULL);\ng_object_set (dialog,\n\"text\", primary,\n\"secondary-text\", secondary,\nNULL);\ngtk_dialog_add_button (GTK_DIALOG (dialog),\n_(\"_Cancel\"), GTK_RESPONSE_CANCEL);\ngtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\nif (nautilus_file_can_set_permissions (file))\n{\ngtk_dialog_add_button (GTK_DIALOG (dialog),\n_(\"Trust and _Launch\"), GTK_RESPONSE_OK);\n}\ng_signal_connect (dialog, \"response\",\nG_CALLBACK (untrusted_launcher_response_callback),\nparameters_desktop);\ngtk_widget_show (dialog);\ng_free (display_name);\ng_free (secondary);\nreturn;\n}\nuri = nautilus_file_get_uri (file);\nDEBUG (\"Launching trusted launcher %s\", uri);\nnautilus_launch_desktop_file (screen, uri, NULL,\nparameters->parent_window);\ng_free (uri);\n}", "label": 0}
{"index": 176991, "code": "static MagickBooleanType ReadPSDLayersInternal(Image *image,\nconst ImageInfo *image_info,const PSDInfo *psd_info,\nconst MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\nchar\ntype[4];\nLayerInfo\n*layer_info;\nMagickSizeType\nsize;\nMagickBooleanType\nstatus;\nregister ssize_t\ni;\nssize_t\ncount,\nj,\nnumber_layers;\nsize=GetPSDSize(psd_info,image);\nif (size == 0)\n{\n(void) ReadBlobLong(image);\ncount=ReadBlob(image,4,(unsigned char *) type);\nReversePSDString(image,type,4);\nstatus=MagickFalse;\nif ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\nreturn(MagickTrue);\nelse\n{\ncount=ReadBlob(image,4,(unsigned char *) type);\nReversePSDString(image,type,4);\nif ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\nsize=GetPSDSize(psd_info,image);\nelse\nreturn(MagickTrue);\n}\n}\nstatus=MagickTrue;\nif (size != 0)\n{\nlayer_info=(LayerInfo *) NULL;\nnumber_layers=(short) ReadBlobShort(image);\nif (number_layers < 0)\n{\nnumber_layers=MagickAbsoluteValue(number_layers);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  negative layer count corrected for\");\nimage->matte=MagickTrue;\n}\nif (skip_layers != MagickFalse)\nreturn(MagickTrue);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  image contains %.20g layers\",(double) number_layers);\nif (number_layers == 0)\nThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\nimage->filename);\nlayer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\nsizeof(*layer_info));\nif (layer_info == (LayerInfo *) NULL)\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  allocation of LayerInfo failed\");\nThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\nimage->filename);\n}\n(void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\nsizeof(*layer_info));\nfor (i=0; i < number_layers; i++)\n{\nssize_t\nx,\ny;\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  reading layer #%.20g\",(double) i+1);\nlayer_info[i].page.y=ReadBlobSignedLong(image);\nlayer_info[i].page.x=ReadBlobSignedLong(image);\ny=ReadBlobSignedLong(image);\nx=ReadBlobSignedLong(image);\nlayer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\nlayer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\nlayer_info[i].channels=ReadBlobShort(image);\nif (layer_info[i].channels > MaxPSDChannels)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\nimage->filename);\n}\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n(double) layer_info[i].page.x,(double) layer_info[i].page.y,\n(double) layer_info[i].page.height,(double)\nlayer_info[i].page.width,(double) layer_info[i].channels);\nfor (j=0; j < (ssize_t) layer_info[i].channels; j++)\n{\nlayer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\nlayer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\nimage);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n(double) layer_info[i].channel_info[j].type,\n(double) layer_info[i].channel_info[j].size);\n}\ncount=ReadBlob(image,4,(unsigned char *) type);\nReversePSDString(image,type,4);\nif ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  layer type was %.4s instead of 8BIM\", type);\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\nimage->filename);\n}\n(void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\nReversePSDString(image,layer_info[i].blendkey,4);\nlayer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\nReadBlobByte(image));\nlayer_info[i].clipping=(unsigned char) ReadBlobByte(image);\nlayer_info[i].flags=(unsigned char) ReadBlobByte(image);\nlayer_info[i].visible=!(layer_info[i].flags & 0x02);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\nlayer_info[i].blendkey,(double) layer_info[i].opacity,\nlayer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\nlayer_info[i].visible ? \"true\" : \"false\");\n(void) ReadBlobByte(image);\nsize=ReadBlobLong(image);\nif (size != 0)\n{\nMagickSizeType\ncombined_length,\nlength;\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"    layer contains additional info\");\nlength=ReadBlobLong(image);\ncombined_length=length+4;\nif (length != 0)\n{\nlayer_info[i].mask.page.y=ReadBlobSignedLong(image);\nlayer_info[i].mask.page.x=ReadBlobSignedLong(image);\nlayer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-\nlayer_info[i].mask.page.y);\nlayer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-\nlayer_info[i].mask.page.x);\nlayer_info[i].mask.background=(unsigned char) ReadBlobByte(\nimage);\nlayer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\nif (!(layer_info[i].mask.flags & 0x01))\n{\nlayer_info[i].mask.page.y=layer_info[i].mask.page.y-\nlayer_info[i].page.y;\nlayer_info[i].mask.page.x=layer_info[i].mask.page.x-\nlayer_info[i].page.x;\n}\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n(double) layer_info[i].mask.page.x,(double)\nlayer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n(double) layer_info[i].mask.page.height,(double)\n((MagickOffsetType) length)-18);\nif (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n}\n}\nlength=ReadBlobLong(image);\ncombined_length+=length+4;\nif (length != 0)\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer blending ranges: length=%.20g\",(double)\n((MagickOffsetType) length));\nfor (j=0; j < (ssize_t) length; j+=8)\n{\nsize_t blend_source=ReadBlobLong(image);\nsize_t blend_dest=ReadBlobLong(image);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"        source(%x), dest(%x)\",(unsigned int)\nblend_source,(unsigned int) blend_dest);\n}\n}\nlength=(MagickSizeType) (unsigned char) ReadBlobByte(image);\ncombined_length+=length+1;\nif (length > 0)\n(void) ReadBlob(image,(size_t) length++,layer_info[i].name);\nlayer_info[i].name[length]='\\0';\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer name: %s\",layer_info[i].name);\nif ((length % 4) != 0)\n{\nlength=4-(length % 4);\ncombined_length+=length;\nif (DiscardBlobBytes(image,length) == MagickFalse)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\n}\n}\nlength=(MagickSizeType) size-combined_length;\nif (length > 0)\n{\nunsigned char\n*info;\nif (length > GetBlobSize(image))\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\n\"InsufficientImageDataInFile\",image->filename);\n}\nlayer_info[i].info=AcquireStringInfo((const size_t) length);\ninfo=GetStringInfoDatum(layer_info[i].info);\n(void) ReadBlob(image,(const size_t) length,info);\n}\n}\n}\nfor (i=0; i < number_layers; i++)\n{\nif ((layer_info[i].page.width == 0) ||\n(layer_info[i].page.height == 0))\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer data is empty\");\nif (layer_info[i].info != (StringInfo *) NULL)\nlayer_info[i].info=DestroyStringInfo(layer_info[i].info);\ncontinue;\n}\nlayer_info[i].image=CloneImage(image,layer_info[i].page.width,\nlayer_info[i].page.height,MagickFalse,exception);\nif (layer_info[i].image == (Image *) NULL)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  allocation of image for layer %.20g failed\",(double) i);\nThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\nimage->filename);\n}\nif (layer_info[i].info != (StringInfo *) NULL)\n{\n(void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\nlayer_info[i].info);\nlayer_info[i].info=DestroyStringInfo(layer_info[i].info);\n}\n}\nif (image_info->ping == MagickFalse)\n{\nfor (i=0; i < number_layers; i++)\n{\nif (layer_info[i].image == (Image *) NULL)\n{\nfor (j=0; j < layer_info[i].channels; j++)\n{\nif (DiscardBlobBytes(image,(MagickSizeType)\nlayer_info[i].channel_info[j].size) == MagickFalse)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\n}\n}\ncontinue;\n}\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  reading data for layer %.20g\",(double) i);\nstatus=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\nexception);\nif (status == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\nnumber_layers);\nif (status == MagickFalse)\nbreak;\n}\n}\nif (status != MagickFalse)\n{\nfor (i=0; i < number_layers; i++)\n{\nif (layer_info[i].image == (Image *) NULL)\n{\nfor (j=i; j < number_layers - 1; j++)\nlayer_info[j] = layer_info[j+1];\nnumber_layers--;\ni--;\n}\n}\nif (number_layers > 0)\n{\nfor (i=0; i < number_layers; i++)\n{\nif (i > 0)\nlayer_info[i].image->previous=layer_info[i-1].image;\nif (i < (number_layers-1))\nlayer_info[i].image->next=layer_info[i+1].image;\nlayer_info[i].image->page=layer_info[i].page;\n}\nimage->next=layer_info[0].image;\nlayer_info[0].image->previous=image;\n}\nlayer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n}\nelse\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\n}\nreturn(status);\n}", "contrast": "static MagickBooleanType ReadPSDLayersInternal(Image *image,\nconst ImageInfo *image_info,const PSDInfo *psd_info,\nconst MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\nchar\ntype[4];\nLayerInfo\n*layer_info;\nMagickSizeType\nsize;\nMagickBooleanType\nstatus;\nregister ssize_t\ni;\nssize_t\ncount,\nj,\nnumber_layers;\nsize=GetPSDSize(psd_info,image);\nif (size == 0)\n{\n(void) ReadBlobLong(image);\ncount=ReadBlob(image,4,(unsigned char *) type);\nReversePSDString(image,type,4);\nstatus=MagickFalse;\nif ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\nreturn(MagickTrue);\nelse\n{\ncount=ReadBlob(image,4,(unsigned char *) type);\nReversePSDString(image,type,4);\nif ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\nsize=GetPSDSize(psd_info,image);\nelse\nreturn(MagickTrue);\n}\n}\nstatus=MagickTrue;\nif (size != 0)\n{\nlayer_info=(LayerInfo *) NULL;\nnumber_layers=(short) ReadBlobShort(image);\nif (number_layers < 0)\n{\nnumber_layers=MagickAbsoluteValue(number_layers);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  negative layer count corrected for\");\nimage->matte=MagickTrue;\n}\nif (skip_layers != MagickFalse)\nreturn(MagickTrue);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  image contains %.20g layers\",(double) number_layers);\nif (number_layers == 0)\nThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\nimage->filename);\nlayer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\nsizeof(*layer_info));\nif (layer_info == (LayerInfo *) NULL)\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  allocation of LayerInfo failed\");\nThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\nimage->filename);\n}\n(void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\nsizeof(*layer_info));\nfor (i=0; i < number_layers; i++)\n{\nssize_t\nx,\ny;\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  reading layer #%.20g\",(double) i+1);\nlayer_info[i].page.y=ReadBlobSignedLong(image);\nlayer_info[i].page.x=ReadBlobSignedLong(image);\ny=ReadBlobSignedLong(image);\nx=ReadBlobSignedLong(image);\nlayer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\nlayer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\nlayer_info[i].channels=ReadBlobShort(image);\nif (layer_info[i].channels > MaxPSDChannels)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\nimage->filename);\n}\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n(double) layer_info[i].page.x,(double) layer_info[i].page.y,\n(double) layer_info[i].page.height,(double)\nlayer_info[i].page.width,(double) layer_info[i].channels);\nfor (j=0; j < (ssize_t) layer_info[i].channels; j++)\n{\nlayer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\nlayer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\nimage);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n(double) layer_info[i].channel_info[j].type,\n(double) layer_info[i].channel_info[j].size);\n}\ncount=ReadBlob(image,4,(unsigned char *) type);\nReversePSDString(image,type,4);\nif ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  layer type was %.4s instead of 8BIM\", type);\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\nimage->filename);\n}\n(void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\nReversePSDString(image,layer_info[i].blendkey,4);\nlayer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\nReadBlobByte(image));\nlayer_info[i].clipping=(unsigned char) ReadBlobByte(image);\nlayer_info[i].flags=(unsigned char) ReadBlobByte(image);\nlayer_info[i].visible=!(layer_info[i].flags & 0x02);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\nlayer_info[i].blendkey,(double) layer_info[i].opacity,\nlayer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\nlayer_info[i].visible ? \"true\" : \"false\");\n(void) ReadBlobByte(image);\nsize=ReadBlobLong(image);\nif (size != 0)\n{\nMagickSizeType\ncombined_length,\nlength;\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"    layer contains additional info\");\nlength=ReadBlobLong(image);\ncombined_length=length+4;\nif (length != 0)\n{\nlayer_info[i].mask.page.y=ReadBlobSignedLong(image);\nlayer_info[i].mask.page.x=ReadBlobSignedLong(image);\nlayer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-\nlayer_info[i].mask.page.y);\nlayer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-\nlayer_info[i].mask.page.x);\nlayer_info[i].mask.background=(unsigned char) ReadBlobByte(\nimage);\nlayer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\nif (!(layer_info[i].mask.flags & 0x01))\n{\nlayer_info[i].mask.page.y=layer_info[i].mask.page.y-\nlayer_info[i].page.y;\nlayer_info[i].mask.page.x=layer_info[i].mask.page.x-\nlayer_info[i].page.x;\n}\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n(double) layer_info[i].mask.page.x,(double)\nlayer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n(double) layer_info[i].mask.page.height,(double)\n((MagickOffsetType) length)-18);\nif (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n}\n}\nlength=ReadBlobLong(image);\ncombined_length+=length+4;\nif (length != 0)\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer blending ranges: length=%.20g\",(double)\n((MagickOffsetType) length));\nfor (j=0; j < (ssize_t) length; j+=8)\n{\nsize_t blend_source=ReadBlobLong(image);\nsize_t blend_dest=ReadBlobLong(image);\nif (EOFBlob(image) != MagickFalse)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\n\"InsufficientImageDataInFile\",image->filename);\n}\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"        source(%x), dest(%x)\",(unsigned int)\nblend_source,(unsigned int) blend_dest);\n}\n}\nlength=(MagickSizeType) (unsigned char) ReadBlobByte(image);\ncombined_length+=length+1;\nif (length > 0)\n(void) ReadBlob(image,(size_t) length++,layer_info[i].name);\nlayer_info[i].name[length]='\\0';\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer name: %s\",layer_info[i].name);\nif ((length % 4) != 0)\n{\nlength=4-(length % 4);\ncombined_length+=length;\nif (DiscardBlobBytes(image,length) == MagickFalse)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\n}\n}\nlength=(MagickSizeType) size-combined_length;\nif (length > 0)\n{\nunsigned char\n*info;\nif (length > GetBlobSize(image))\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\n\"InsufficientImageDataInFile\",image->filename);\n}\nlayer_info[i].info=AcquireStringInfo((const size_t) length);\ninfo=GetStringInfoDatum(layer_info[i].info);\n(void) ReadBlob(image,(const size_t) length,info);\n}\n}\n}\nfor (i=0; i < number_layers; i++)\n{\nif ((layer_info[i].page.width == 0) ||\n(layer_info[i].page.height == 0))\n{\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"      layer data is empty\");\nif (layer_info[i].info != (StringInfo *) NULL)\nlayer_info[i].info=DestroyStringInfo(layer_info[i].info);\ncontinue;\n}\nlayer_info[i].image=CloneImage(image,layer_info[i].page.width,\nlayer_info[i].page.height,MagickFalse,exception);\nif (layer_info[i].image == (Image *) NULL)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  allocation of image for layer %.20g failed\",(double) i);\nThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\nimage->filename);\n}\nif (layer_info[i].info != (StringInfo *) NULL)\n{\n(void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\nlayer_info[i].info);\nlayer_info[i].info=DestroyStringInfo(layer_info[i].info);\n}\n}\nif (image_info->ping == MagickFalse)\n{\nfor (i=0; i < number_layers; i++)\n{\nif (layer_info[i].image == (Image *) NULL)\n{\nfor (j=0; j < layer_info[i].channels; j++)\n{\nif (DiscardBlobBytes(image,(MagickSizeType)\nlayer_info[i].channel_info[j].size) == MagickFalse)\n{\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\nThrowBinaryException(CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\n}\n}\ncontinue;\n}\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  reading data for layer %.20g\",(double) i);\nstatus=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\nexception);\nif (status == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\nnumber_layers);\nif (status == MagickFalse)\nbreak;\n}\n}\nif (status != MagickFalse)\n{\nfor (i=0; i < number_layers; i++)\n{\nif (layer_info[i].image == (Image *) NULL)\n{\nfor (j=i; j < number_layers - 1; j++)\nlayer_info[j] = layer_info[j+1];\nnumber_layers--;\ni--;\n}\n}\nif (number_layers > 0)\n{\nfor (i=0; i < number_layers; i++)\n{\nif (i > 0)\nlayer_info[i].image->previous=layer_info[i-1].image;\nif (i < (number_layers-1))\nlayer_info[i].image->next=layer_info[i+1].image;\nlayer_info[i].image->page=layer_info[i].page;\n}\nimage->next=layer_info[0].image;\nlayer_info[0].image->previous=image;\n}\nlayer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n}\nelse\nlayer_info=DestroyLayerInfo(layer_info,number_layers);\n}\nreturn(status);\n}", "label": 0}
{"index": 176992, "code": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nchar\ncolorspace[MaxTextExtent],\ntext[MaxTextExtent];\nImage\n*image;\nIndexPacket\n*indexes;\nlong\nx_offset,\ny_offset;\nMagickBooleanType\nstatus;\nMagickPixelPacket\npixel;\nQuantumAny\nrange;\nregister ssize_t\ni,\nx;\nregister PixelPacket\n*q;\nssize_t\ncount,\ntype,\ny;\nunsigned long\ndepth,\nheight,\nmax_value,\nwidth;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\n(void) ResetMagickMemory(text,0,sizeof(text));\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\ndo\n{\nwidth=0;\nheight=0;\nmax_value=0;\n*colorspace='\\0';\ncount=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\ncolorspace);\nif ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->columns=width;\nimage->rows=height;\nfor (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)\nif (depth >= 64)\nbreak;\nimage->depth=depth;\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nLocaleLower(colorspace);\ni=(ssize_t) strlen(colorspace)-1;\nimage->matte=MagickFalse;\nif ((i > 0) && (colorspace[i] == 'a'))\n{\ncolorspace[i]='\\0';\nimage->matte=MagickTrue;\n}\ntype=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\nif (type < 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->colorspace=(ColorspaceType) type;\n(void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n(void) SetImageBackgroundColor(image);\nrange=GetQuantumRange(image->depth);\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\ndouble\nblue,\ngreen,\nindex,\nopacity,\nred;\nred=0.0;\ngreen=0.0;\nblue=0.0;\nindex=0.0;\nopacity=0.0;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (ReadBlobString(image,text) == (char *) NULL)\nbreak;\nswitch (image->colorspace)\n{\ncase GRAYColorspace:\n{\nif (image->matte != MagickFalse)\n{\n(void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",&x_offset,\n&y_offset,&red,&opacity);\ngreen=red;\nblue=red;\nbreak;\n}\n(void) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,&y_offset,&red);\ngreen=red;\nblue=red;\nbreak;\n}\ncase CMYKColorspace:\n{\nif (image->matte != MagickFalse)\n{\n(void) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\nbreak;\n}\n(void) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n&y_offset,&red,&green,&blue,&index);\nbreak;\n}\ndefault:\n{\nif (image->matte != MagickFalse)\n{\n(void) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&opacity);\nbreak;\n}\n(void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue);\nbreak;\n}\n}\nif (strchr(text,'%') != (char *) NULL)\n{\nred*=0.01*range;\ngreen*=0.01*range;\nblue*=0.01*range;\nindex*=0.01*range;\nopacity*=0.01*range;\n}\nif (image->colorspace == LabColorspace)\n{\ngreen+=(range+1)/2.0;\nblue+=(range+1)/2.0;\n}\npixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\nrange);\npixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\nrange);\npixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\nrange);\npixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),\nrange);\npixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+\n0.5),range);\nq=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\nexception);\nif (q == (PixelPacket *) NULL)\ncontinue;\nSetPixelRed(q,pixel.red);\nSetPixelGreen(q,pixel.green);\nSetPixelBlue(q,pixel.blue);\nif (image->colorspace == CMYKColorspace)\n{\nindexes=GetAuthenticIndexQueue(image);\nSetPixelIndex(indexes,pixel.index);\n}\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,pixel.opacity);\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\n}\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nchar\ncolorspace[MaxTextExtent],\ntext[MaxTextExtent];\nImage\n*image;\nIndexPacket\n*indexes;\nlong\nx_offset,\ny_offset;\nMagickBooleanType\nstatus;\nMagickPixelPacket\npixel;\nQuantumAny\nrange;\nregister ssize_t\ni,\nx;\nregister PixelPacket\n*q;\nssize_t\ncount,\ntype,\ny;\nunsigned long\ndepth,\nheight,\nmax_value,\nwidth;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\n(void) ResetMagickMemory(text,0,sizeof(text));\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\ndo\n{\nwidth=0;\nheight=0;\nmax_value=0;\n*colorspace='\\0';\ncount=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\ncolorspace);\nif ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->columns=width;\nimage->rows=height;\nif ((max_value == 0) || (max_value > 4294967295))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nfor (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\nimage->depth=depth;\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nLocaleLower(colorspace);\ni=(ssize_t) strlen(colorspace)-1;\nimage->matte=MagickFalse;\nif ((i > 0) && (colorspace[i] == 'a'))\n{\ncolorspace[i]='\\0';\nimage->matte=MagickTrue;\n}\ntype=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\nif (type < 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->colorspace=(ColorspaceType) type;\n(void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n(void) SetImageBackgroundColor(image);\nrange=GetQuantumRange(image->depth);\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\ndouble\nblue,\ngreen,\nindex,\nopacity,\nred;\nred=0.0;\ngreen=0.0;\nblue=0.0;\nindex=0.0;\nopacity=0.0;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (ReadBlobString(image,text) == (char *) NULL)\nbreak;\nswitch (image->colorspace)\n{\ncase GRAYColorspace:\n{\nif (image->matte != MagickFalse)\n{\n(void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",&x_offset,\n&y_offset,&red,&opacity);\ngreen=red;\nblue=red;\nbreak;\n}\n(void) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,&y_offset,&red);\ngreen=red;\nblue=red;\nbreak;\n}\ncase CMYKColorspace:\n{\nif (image->matte != MagickFalse)\n{\n(void) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\nbreak;\n}\n(void) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n&y_offset,&red,&green,&blue,&index);\nbreak;\n}\ndefault:\n{\nif (image->matte != MagickFalse)\n{\n(void) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&opacity);\nbreak;\n}\n(void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue);\nbreak;\n}\n}\nif (strchr(text,'%') != (char *) NULL)\n{\nred*=0.01*range;\ngreen*=0.01*range;\nblue*=0.01*range;\nindex*=0.01*range;\nopacity*=0.01*range;\n}\nif (image->colorspace == LabColorspace)\n{\ngreen+=(range+1)/2.0;\nblue+=(range+1)/2.0;\n}\npixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\nrange);\npixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\nrange);\npixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\nrange);\npixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),\nrange);\npixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+\n0.5),range);\nq=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\nexception);\nif (q == (PixelPacket *) NULL)\ncontinue;\nSetPixelRed(q,pixel.red);\nSetPixelGreen(q,pixel.green);\nSetPixelBlue(q,pixel.blue);\nif (image->colorspace == CMYKColorspace)\n{\nindexes=GetAuthenticIndexQueue(image);\nSetPixelIndex(indexes,pixel.index);\n}\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,pixel.opacity);\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\n}\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177010, "code": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\nmbedtls_x509_crt *trust_ca,\nmbedtls_x509_crl *ca_crl,\nconst mbedtls_x509_crt_profile *profile,\nconst char *cn, uint32_t *flags,\nint (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\nvoid *p_vrfy )\n{\nsize_t cn_len;\nint ret;\nint pathlen = 0, selfsigned = 0;\nmbedtls_x509_crt *parent;\nmbedtls_x509_name *name;\nmbedtls_x509_sequence *cur = NULL;\nmbedtls_pk_type_t pk_type;\nif( profile == NULL )\nreturn( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n*flags = 0;\nif( cn != NULL )\n{\nname = &crt->subject;\ncn_len = strlen( cn );\nif( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n{\ncur = &crt->subject_alt_names;\nwhile( cur != NULL )\n{\nif( cur->buf.len == cn_len &&\nx509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\nbreak;\nif( cur->buf.len > 2 &&\nmemcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\nx509_check_wildcard( cn, &cur->buf ) == 0 )\n{\nbreak;\n}\ncur = cur->next;\n}\nif( cur == NULL )\n*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n}\nelse\n{\nwhile( name != NULL )\n{\nif( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n{\nif( name->val.len == cn_len &&\nx509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\nbreak;\nif( name->val.len > 2 &&\nmemcmp( name->val.p, \"*.\", 2 ) == 0 &&\nx509_check_wildcard( cn, &name->val ) == 0 )\nbreak;\n}\nname = name->next;\n}\nif( name == NULL )\n*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n}\n}\npk_type = mbedtls_pk_get_type( &crt->pk );\nif( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n*flags |= MBEDTLS_X509_BADCERT_BAD_PK;\nif( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n*flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\nfor( parent = trust_ca; parent != NULL; parent = parent->next )\n{\nif( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\nbreak;\n}\nif( parent != NULL )\n{\nret = x509_crt_verify_top( crt, parent, ca_crl, profile,\npathlen, selfsigned, flags, f_vrfy, p_vrfy );\nif( ret != 0 )\nreturn( ret );\n}\nelse\n{\nfor( parent = crt->next; parent != NULL; parent = parent->next )\nif( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\nbreak;\nif( parent != NULL )\n{\nret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\npathlen, selfsigned, flags, f_vrfy, p_vrfy );\nif( ret != 0 )\nreturn( ret );\n}\nelse\n{\nret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\npathlen, selfsigned, flags, f_vrfy, p_vrfy );\nif( ret != 0 )\nreturn( ret );\n}\n}\nif( *flags != 0 )\nreturn( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\nreturn( 0 );\n}", "contrast": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\nmbedtls_x509_crt *trust_ca,\nmbedtls_x509_crl *ca_crl,\nconst mbedtls_x509_crt_profile *profile,\nconst char *cn, uint32_t *flags,\nint (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\nvoid *p_vrfy )\n{\nsize_t cn_len;\nint ret;\nint pathlen = 0, selfsigned = 0;\nmbedtls_x509_crt *parent;\nmbedtls_x509_name *name;\nmbedtls_x509_sequence *cur = NULL;\nmbedtls_pk_type_t pk_type;\n*flags = 0;\nif( profile == NULL )\n{\nret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\ngoto exit;\n}\nif( cn != NULL )\n{\nname = &crt->subject;\ncn_len = strlen( cn );\nif( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n{\ncur = &crt->subject_alt_names;\nwhile( cur != NULL )\n{\nif( cur->buf.len == cn_len &&\nx509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\nbreak;\nif( cur->buf.len > 2 &&\nmemcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\nx509_check_wildcard( cn, &cur->buf ) == 0 )\n{\nbreak;\n}\ncur = cur->next;\n}\nif( cur == NULL )\n*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n}\nelse\n{\nwhile( name != NULL )\n{\nif( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n{\nif( name->val.len == cn_len &&\nx509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\nbreak;\nif( name->val.len > 2 &&\nmemcmp( name->val.p, \"*.\", 2 ) == 0 &&\nx509_check_wildcard( cn, &name->val ) == 0 )\nbreak;\n}\nname = name->next;\n}\nif( name == NULL )\n*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n}\n}\npk_type = mbedtls_pk_get_type( &crt->pk );\nif( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n*flags |= MBEDTLS_X509_BADCERT_BAD_PK;\nif( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n*flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\nfor( parent = trust_ca; parent != NULL; parent = parent->next )\n{\nif( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\nbreak;\n}\nif( parent != NULL )\n{\nret = x509_crt_verify_top( crt, parent, ca_crl, profile,\npathlen, selfsigned, flags, f_vrfy, p_vrfy );\nif( ret != 0 )\ngoto exit;\n}\nelse\n{\nfor( parent = crt->next; parent != NULL; parent = parent->next )\nif( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\nbreak;\nif( parent != NULL )\n{\nret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\npathlen, selfsigned, flags, f_vrfy, p_vrfy );\nif( ret != 0 )\ngoto exit;\n}\nelse\n{\nret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\npathlen, selfsigned, flags, f_vrfy, p_vrfy );\nif( ret != 0 )\ngoto exit;\n}\n}\nexit:\nif( ret != 0 )\n{\n*flags = (uint32_t) -1;\nreturn( ret );\n}\nif( *flags != 0 )\nreturn( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\nreturn( 0 );\n}", "label": 0}
{"index": 177019, "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nImage *image, *image2=NULL,\n*rotated_image;\nPixelPacket *q;\nunsigned int status;\nMATHeader MATLAB_HDR;\nsize_t size;\nsize_t CellType;\nQuantumInfo *quantum_info;\nImageInfo *clone_info;\nint i;\nssize_t ldblk;\nunsigned char *BImgBuff = NULL;\ndouble MinVal, MaxVal;\nsize_t Unknown6;\nunsigned z, z2;\nunsigned Frames;\nint logging;\nint sample_size;\nMagickOffsetType filepos=0x80;\nBlobInfo *blob;\nsize_t one;\nunsigned int (*ReadBlobXXXLong)(Image *image);\nunsigned short (*ReadBlobXXXShort)(Image *image);\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nlogging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\nimage = AcquireImage(image_info);\nstatus = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nclone_info=CloneImageInfo(image_info);\nif(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n{\nimage2=ReadMATImageV4(image_info,image,exception);\nif (image2  == NULL)\ngoto MATLAB_KO;\nimage=image2;\ngoto END_OF_READING;\n}\nMATLAB_HDR.Version = ReadBlobLSBShort(image);\nif(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\nMATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\nif (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n{\nReadBlobXXXLong = ReadBlobLSBLong;\nReadBlobXXXShort = ReadBlobLSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesLSB;\nReadBlobFloatsXXX = ReadBlobFloatsLSB;\nimage->endian = LSBEndian;\n}\nelse if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n{\nReadBlobXXXLong = ReadBlobMSBLong;\nReadBlobXXXShort = ReadBlobMSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesMSB;\nReadBlobFloatsXXX = ReadBlobFloatsMSB;\nimage->endian = MSBEndian;\n}\nelse\ngoto MATLAB_KO;\nif (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nfilepos = TellBlob(image);\nwhile(!EOFBlob(image))\n{\nFrames = 1;\n(void) SeekBlob(image,filepos,SEEK_SET);\nMATLAB_HDR.DataType = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nMATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nfilepos += MATLAB_HDR.ObjectSize + 4 + 4;\nimage2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nif(MATLAB_HDR.DataType == miCOMPRESSED)\n{\nimage2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\nif(image2==NULL) continue;\nMATLAB_HDR.DataType = ReadBlobXXXLong(image2);\n}\n#endif\nif(MATLAB_HDR.DataType!=miMATRIX) continue;\nMATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\nMATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\nMATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\nMATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\nif(image!=image2)\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\nswitch(MATLAB_HDR.DimFlag)\n{\ncase  8: z2=z=1; break;\ncase 12: z2=z = ReadBlobXXXLong(image2);\nUnknown6 = ReadBlobXXXLong(image2);\n(void) Unknown6;\nif(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nbreak;\ncase 16: z2=z = ReadBlobXXXLong(image2);\nif(z!=3 && z!=1)\nThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nFrames = ReadBlobXXXLong(image2);\nif (Frames == 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\ndefault: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n}\nMATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\nMATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\nif (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\nMATLAB_HDR.StructureClass != mxSINGLE_CLASS &&\nMATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&\nMATLAB_HDR.StructureClass != mxINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxINT64_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT64_CLASS)\nThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\nswitch (MATLAB_HDR.NameFlag)\n{\ncase 0:\nsize = ReadBlobXXXLong(image2);\nsize = 4 * (ssize_t) ((size + 3 + 1) / 4);\n(void) SeekBlob(image2, size, SEEK_CUR);\nbreak;\ncase 1:\ncase 2:\ncase 3:\ncase 4:\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nbreak;\ndefault:\ngoto MATLAB_KO;\n}\nCellType = ReadBlobXXXLong(image2);\nif (logging)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nNEXT_FRAME:\nswitch (CellType)\n{\ncase miINT8:\ncase miUINT8:\nsample_size = 8;\nif(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\nimage->depth = 1;\nelse\nimage->depth = 8;\nldblk = (ssize_t) MATLAB_HDR.SizeX;\nbreak;\ncase miINT16:\ncase miUINT16:\nsample_size = 16;\nimage->depth = 16;\nldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT32:\ncase miUINT32:\nsample_size = 32;\nimage->depth = 32;\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT64:\ncase miUINT64:\nsample_size = 64;\nimage->depth = 64;\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ncase miSINGLE:\nsample_size = 32;\nimage->depth = 32;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miDOUBLE:\nsample_size = 64;\nimage->depth = 64;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\nif (sizeof(double) != 8)\nRestoreMSCWarning\nThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ndefault:\nThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n}\n(void) sample_size;\nimage->columns = MATLAB_HDR.SizeX;\nimage->rows = MATLAB_HDR.SizeY;\nquantum_info=AcquireQuantumInfo(clone_info,image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\none=1;\nimage->colors = one << image->depth;\nif (image->columns == 0 || image->rows == 0)\ngoto MATLAB_KO;\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n{\nSetImageColorspace(image,GRAYColorspace);\nimage->type=GrayscaleType;\n}\nif (image_info->ping)\n{\nsize_t temp = image->columns;\nimage->columns = image->rows;\nimage->rows = temp;\ngoto done_reading;\n}\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nBImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));\nif (BImgBuff == NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\nMinVal = 0;\nMaxVal = 0;\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n}\nif(z==1) z=0;\ndo\n{\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nq=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto done_reading;\n}\nif(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\nif((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n{\nFixLogical((unsigned char *)BImgBuff,ldblk);\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n{\nImportQuantumPixelsFailed:\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\nbreak;\n}\n}\nelse\n{\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\ngoto ImportQuantumPixelsFailed;\nif (z<=1 &&\n(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\nFixSignedValues(q,MATLAB_HDR.SizeX);\n}\nif (!SyncAuthenticPixels(image,exception))\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\n}\n} while(z-- >= 2);\nExitLoop:\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\nCellType = ReadBlobXXXLong(image2);\ni = ReadBlobXXXLong(image2);\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n}\nif (CellType==miDOUBLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\nInsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n}\nif (CellType==miSINGLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\nInsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n}\n}\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\nimage->type=GrayscaleType;\nif (image->depth == 1)\nimage->type=BilevelType;\nif(image2==image)\nimage2 = NULL;\nrotated_image = RotateImage(image, 90.0, exception);\nif (rotated_image != (Image *) NULL)\n{\nrotated_image->page.x=0;\nrotated_image->page.y=0;\nblob = rotated_image->blob;\nrotated_image->blob = image->blob;\nrotated_image->colors = image->colors;\nimage->blob = blob;\nAppendImageToList(&image,rotated_image);\nDeleteImageFromList(&image);\n}\ndone_reading:\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\n}\n}\nAcquireNextImage(image_info,image);\nif (image->next == (Image *) NULL) break;\nimage=SyncNextImageInList(image);\nimage->columns=image->rows=0;\nimage->colors=0;\nRelinquishMagickMemory(BImgBuff);\nBImgBuff = NULL;\nif(--Frames>0)\n{\nz = z2;\nif(image2==NULL) image2 = image;\ngoto NEXT_FRAME;\n}\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) unlink(clone_info->filename);\n}\n}\n}\n}\nRelinquishMagickMemory(BImgBuff);\nquantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\nclone_info=DestroyImageInfo(clone_info);\nCloseBlob(image);\n{\nImage *p;\nssize_t scene=0;\np=image;\nimage=NULL;\nwhile (p != (Image *) NULL)\n{\nImage *tmp=p;\nif ((p->rows == 0) || (p->columns == 0)) {\np=p->previous;\nDeleteImageFromList(&tmp);\n} else {\nimage=p;\np=p->previous;\n}\n}\nfor (p=image; p != (Image *) NULL; p=p->next)\np->scene=scene++;\n}\nif(clone_info != NULL)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\nDestroyImageInfo(clone_info);\nclone_info = NULL;\n}\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\nif(image==NULL)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nreturn (image);\n}", "contrast": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nImage *image, *image2=NULL,\n*rotated_image;\nPixelPacket *q;\nunsigned int status;\nMATHeader MATLAB_HDR;\nsize_t size;\nsize_t CellType;\nQuantumInfo *quantum_info;\nImageInfo *clone_info;\nint i;\nssize_t ldblk;\nunsigned char *BImgBuff = NULL;\ndouble MinVal, MaxVal;\nsize_t Unknown6;\nunsigned z, z2;\nunsigned Frames;\nint logging;\nint sample_size;\nMagickOffsetType filepos=0x80;\nBlobInfo *blob;\nsize_t one;\nunsigned int (*ReadBlobXXXLong)(Image *image);\nunsigned short (*ReadBlobXXXShort)(Image *image);\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nlogging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\nquantum_info=(QuantumInfo *) NULL;\nimage = AcquireImage(image_info);\nstatus = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nclone_info=CloneImageInfo(image_info);\nif(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n{\nimage2=ReadMATImageV4(image_info,image,exception);\nif (image2  == NULL)\ngoto MATLAB_KO;\nimage=image2;\ngoto END_OF_READING;\n}\nMATLAB_HDR.Version = ReadBlobLSBShort(image);\nif(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\nMATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\nif (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n{\nReadBlobXXXLong = ReadBlobLSBLong;\nReadBlobXXXShort = ReadBlobLSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesLSB;\nReadBlobFloatsXXX = ReadBlobFloatsLSB;\nimage->endian = LSBEndian;\n}\nelse if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n{\nReadBlobXXXLong = ReadBlobMSBLong;\nReadBlobXXXShort = ReadBlobMSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesMSB;\nReadBlobFloatsXXX = ReadBlobFloatsMSB;\nimage->endian = MSBEndian;\n}\nelse\ngoto MATLAB_KO;\nif (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nfilepos = TellBlob(image);\nwhile(!EOFBlob(image))\n{\nFrames = 1;\n(void) SeekBlob(image,filepos,SEEK_SET);\nMATLAB_HDR.DataType = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nMATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nfilepos += MATLAB_HDR.ObjectSize + 4 + 4;\nimage2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nif(MATLAB_HDR.DataType == miCOMPRESSED)\n{\nimage2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\nif(image2==NULL) continue;\nMATLAB_HDR.DataType = ReadBlobXXXLong(image2);\n}\n#endif\nif(MATLAB_HDR.DataType!=miMATRIX) continue;\nMATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\nMATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\nMATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\nMATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\nif(image!=image2)\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\nswitch(MATLAB_HDR.DimFlag)\n{\ncase  8: z2=z=1; break;\ncase 12: z2=z = ReadBlobXXXLong(image2);\nUnknown6 = ReadBlobXXXLong(image2);\n(void) Unknown6;\nif(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nbreak;\ncase 16: z2=z = ReadBlobXXXLong(image2);\nif(z!=3 && z!=1)\nThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nFrames = ReadBlobXXXLong(image2);\nif (Frames == 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\ndefault: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n}\nMATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\nMATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\nif (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\nMATLAB_HDR.StructureClass != mxSINGLE_CLASS &&\nMATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&\nMATLAB_HDR.StructureClass != mxINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxINT64_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT64_CLASS)\nThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\nswitch (MATLAB_HDR.NameFlag)\n{\ncase 0:\nsize = ReadBlobXXXLong(image2);\nsize = 4 * (ssize_t) ((size + 3 + 1) / 4);\n(void) SeekBlob(image2, size, SEEK_CUR);\nbreak;\ncase 1:\ncase 2:\ncase 3:\ncase 4:\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nbreak;\ndefault:\ngoto MATLAB_KO;\n}\nCellType = ReadBlobXXXLong(image2);\nif (logging)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nNEXT_FRAME:\nswitch (CellType)\n{\ncase miINT8:\ncase miUINT8:\nsample_size = 8;\nif(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\nimage->depth = 1;\nelse\nimage->depth = 8;\nldblk = (ssize_t) MATLAB_HDR.SizeX;\nbreak;\ncase miINT16:\ncase miUINT16:\nsample_size = 16;\nimage->depth = 16;\nldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT32:\ncase miUINT32:\nsample_size = 32;\nimage->depth = 32;\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT64:\ncase miUINT64:\nsample_size = 64;\nimage->depth = 64;\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ncase miSINGLE:\nsample_size = 32;\nimage->depth = 32;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miDOUBLE:\nsample_size = 64;\nimage->depth = 64;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\nif (sizeof(double) != 8)\nRestoreMSCWarning\nThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ndefault:\nThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n}\n(void) sample_size;\nimage->columns = MATLAB_HDR.SizeX;\nimage->rows = MATLAB_HDR.SizeY;\nquantum_info=AcquireQuantumInfo(clone_info,image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\none=1;\nimage->colors = one << image->depth;\nif (image->columns == 0 || image->rows == 0)\ngoto MATLAB_KO;\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n{\nSetImageColorspace(image,GRAYColorspace);\nimage->type=GrayscaleType;\n}\nif (image_info->ping)\n{\nsize_t temp = image->columns;\nimage->columns = image->rows;\nimage->rows = temp;\ngoto done_reading;\n}\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nBImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));\nif (BImgBuff == NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\nMinVal = 0;\nMaxVal = 0;\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n}\nif(z==1) z=0;\ndo\n{\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nq=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto done_reading;\n}\nif(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\nif((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n{\nFixLogical((unsigned char *)BImgBuff,ldblk);\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n{\nImportQuantumPixelsFailed:\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\nbreak;\n}\n}\nelse\n{\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\ngoto ImportQuantumPixelsFailed;\nif (z<=1 &&\n(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\nFixSignedValues(q,MATLAB_HDR.SizeX);\n}\nif (!SyncAuthenticPixels(image,exception))\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\n}\n} while(z-- >= 2);\nExitLoop:\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\nCellType = ReadBlobXXXLong(image2);\ni = ReadBlobXXXLong(image2);\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n}\nif (CellType==miDOUBLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\nInsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n}\nif (CellType==miSINGLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\nInsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n}\n}\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\nimage->type=GrayscaleType;\nif (image->depth == 1)\nimage->type=BilevelType;\nif(image2==image)\nimage2 = NULL;\nrotated_image = RotateImage(image, 90.0, exception);\nif (rotated_image != (Image *) NULL)\n{\nrotated_image->page.x=0;\nrotated_image->page.y=0;\nblob = rotated_image->blob;\nrotated_image->blob = image->blob;\nrotated_image->colors = image->colors;\nimage->blob = blob;\nAppendImageToList(&image,rotated_image);\nDeleteImageFromList(&image);\n}\ndone_reading:\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\n}\n}\nAcquireNextImage(image_info,image);\nif (image->next == (Image *) NULL) break;\nimage=SyncNextImageInList(image);\nimage->columns=image->rows=0;\nimage->colors=0;\nRelinquishMagickMemory(BImgBuff);\nBImgBuff = NULL;\nif(--Frames>0)\n{\nz = z2;\nif(image2==NULL) image2 = image;\ngoto NEXT_FRAME;\n}\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) unlink(clone_info->filename);\n}\n}\n}\n}\nRelinquishMagickMemory(BImgBuff);\nif (quantum_info != (QuantumInfo *) NULL)\nquantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\nclone_info=DestroyImageInfo(clone_info);\nCloseBlob(image);\n{\nImage *p;\nssize_t scene=0;\np=image;\nimage=NULL;\nwhile (p != (Image *) NULL)\n{\nImage *tmp=p;\nif ((p->rows == 0) || (p->columns == 0)) {\np=p->previous;\nDeleteImageFromList(&tmp);\n} else {\nimage=p;\np=p->previous;\n}\n}\nfor (p=image; p != (Image *) NULL; p=p->next)\np->scene=scene++;\n}\nif(clone_info != NULL)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\nDestroyImageInfo(clone_info);\nclone_info = NULL;\n}\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\nif(image==NULL)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nreturn (image);\n}", "label": 0}
{"index": 177030, "code": "ubik_print(netdissect_options *ndo,\nregister const u_char *bp)\n{\nint ubik_op;\nint32_t temp;\nubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\nND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\nbp += sizeof(struct rx_header) + 4;\nswitch (ubik_op) {\ncase 10000:\nND_TCHECK2(bp[0], 4);\ntemp = EXTRACT_32BITS(bp);\nbp += sizeof(int32_t);\nND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\nND_PRINT((ndo, \" votestart\"));\nDATEOUT();\nND_PRINT((ndo, \" dbversion\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nbreak;\ncase 10003:\nND_PRINT((ndo, \" site\"));\nUINTOUT();\nbreak;\ncase 20000:\ncase 20001:\ncase 20007:\ncase 20008:\ncase 20010:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nbreak;\ncase 20002:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" pos\"));\nINTOUT();\nND_PRINT((ndo, \" length\"));\nINTOUT();\ntemp = EXTRACT_32BITS(bp);\nbp += sizeof(int32_t);\ntok2str(ubik_lock_types, \"type %d\", temp);\nbreak;\ncase 20003:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" pos\"));\nINTOUT();\nbreak;\ncase 20005:\nND_PRINT((ndo, \" file\"));\nINTOUT();\nbreak;\ncase 20006:\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" length\"));\nINTOUT();\nND_PRINT((ndo, \" dbversion\"));\nUBIK_VERSIONOUT();\nbreak;\ncase 20009:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" length\"));\nINTOUT();\nbreak;\ncase 20012:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" oldversion\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" newversion\"));\nUBIK_VERSIONOUT();\nbreak;\ndefault:\n;\n}\nreturn;\ntrunc:\nND_PRINT((ndo, \" [|ubik]\"));\n}", "contrast": "ubik_print(netdissect_options *ndo,\nregister const u_char *bp)\n{\nint ubik_op;\nint32_t temp;\nubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\nND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\nbp += sizeof(struct rx_header) + 4;\nswitch (ubik_op) {\ncase 10000:\nND_TCHECK2(bp[0], 4);\ntemp = EXTRACT_32BITS(bp);\nbp += sizeof(int32_t);\nND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\nND_PRINT((ndo, \" votestart\"));\nDATEOUT();\nND_PRINT((ndo, \" dbversion\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nbreak;\ncase 10003:\nND_PRINT((ndo, \" site\"));\nUINTOUT();\nbreak;\ncase 20000:\ncase 20001:\ncase 20007:\ncase 20008:\ncase 20010:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nbreak;\ncase 20002:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" pos\"));\nINTOUT();\nND_PRINT((ndo, \" length\"));\nINTOUT();\nND_TCHECK_32BITS(bp);\ntemp = EXTRACT_32BITS(bp);\nbp += sizeof(int32_t);\ntok2str(ubik_lock_types, \"type %d\", temp);\nbreak;\ncase 20003:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" pos\"));\nINTOUT();\nbreak;\ncase 20005:\nND_PRINT((ndo, \" file\"));\nINTOUT();\nbreak;\ncase 20006:\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" length\"));\nINTOUT();\nND_PRINT((ndo, \" dbversion\"));\nUBIK_VERSIONOUT();\nbreak;\ncase 20009:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" file\"));\nINTOUT();\nND_PRINT((ndo, \" length\"));\nINTOUT();\nbreak;\ncase 20012:\nND_PRINT((ndo, \" tid\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" oldversion\"));\nUBIK_VERSIONOUT();\nND_PRINT((ndo, \" newversion\"));\nUBIK_VERSIONOUT();\nbreak;\ndefault:\n;\n}\nreturn;\ntrunc:\nND_PRINT((ndo, \" [|ubik]\"));\n}", "label": 0}
{"index": 177071, "code": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\nconst uint32_t *ptr = (const uint32_t *)dat;\nif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\nND_PRINT((ndo, \"A\"));\n}\nif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\nND_PRINT((ndo, \"D\"));\n}\n}", "contrast": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\nl2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\nconst uint32_t *ptr = (const uint32_t *)dat;\nif (length < 4) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\nND_PRINT((ndo, \"A\"));\n}\nif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\nND_PRINT((ndo, \"D\"));\n}\n}", "label": 0}
{"index": 177072, "code": "l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\n{\nconst uint16_t *ptr = (const uint16_t *)dat;\nuint16_t val_h, val_l;\nptr++;\nval_h = EXTRACT_16BITS(ptr); ptr++;\nval_l = EXTRACT_16BITS(ptr); ptr++;\nND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\nval_h = EXTRACT_16BITS(ptr); ptr++;\nval_l = EXTRACT_16BITS(ptr); ptr++;\nND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\nval_h = EXTRACT_16BITS(ptr); ptr++;\nval_l = EXTRACT_16BITS(ptr); ptr++;\nND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\nval_h = EXTRACT_16BITS(ptr); ptr++;\nval_l = EXTRACT_16BITS(ptr); ptr++;\nND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\nval_h = EXTRACT_16BITS(ptr); ptr++;\nval_l = EXTRACT_16BITS(ptr); ptr++;\nND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\nval_h = EXTRACT_16BITS(ptr); ptr++;\nval_l = EXTRACT_16BITS(ptr); ptr++;\nND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}", "contrast": "l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\nl2tp_call_errors_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\nconst uint16_t *ptr = (const uint16_t *)dat;\nuint16_t val_h, val_l;\nif (length < 2) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nptr++;\nlength -= 2;\nif (length < 4) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\nif (length < 4) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\nif (length < 4) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\nif (length < 4) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\nif (length < 4) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\nND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\nif (length < 4) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nval_h = EXTRACT_16BITS(ptr); ptr++;\nval_l = EXTRACT_16BITS(ptr); ptr++;\nND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}", "label": 0}
{"index": 177075, "code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\nconst uint16_t *ptr = (const uint16_t *)dat;\nND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\nEXTRACT_16BITS(ptr))));\n}", "contrast": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\nl2tp_msgtype_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\nconst uint16_t *ptr = (const uint16_t *)dat;\nif (length < 2) {\nND_PRINT((ndo, \"AVP too short\"));\nreturn;\n}\nND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\nEXTRACT_16BITS(ptr))));\n}", "label": 0}
{"index": 177093, "code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\nint result;\nu_char c;\nint saw_digit;\nint neg;\nint too_large;\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\ntoo_large = 0;\nneg = 0;\nif (*bp == '-') {\nneg = 1;\nbp++;\nlen--;\n}\nresult = 0;\nsaw_digit = 0;\nfor (;;) {\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\nc = *bp;\nif (!(c >= '0' && c <= '9')) {\nif (!saw_digit)\ngoto invalid;\nbreak;\n}\nc -= '0';\nif (result > (INT_MAX / 10)) {\ntoo_large = 1;\n} else {\nresult *= 10;\nif (result == INT_MAX && c > (INT_MAX % 10)) {\ntoo_large = 1;\n} else\nresult += c;\n}\nbp++;\nlen--;\nsaw_digit = 1;\n}\nif (!saw_digit)\ngoto invalid;\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\nif (*bp != '\\r')\ngoto invalid;\nbp++;\nlen--;\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\nif (*bp != '\\n')\ngoto invalid;\nbp++;\nlen--;\n*endp = bp;\nif (neg) {\nif (too_large || result != 1)\nreturn (-4);\nresult = -1;\n}\nreturn (too_large ? -3 : result);\ntrunc:\nreturn (-2);\ninvalid:\nreturn (-5);\n}", "contrast": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\nint result;\nu_char c;\nint saw_digit;\nint neg;\nint too_large;\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\ntoo_large = 0;\nneg = 0;\nif (*bp == '-') {\nneg = 1;\nbp++;\nlen--;\n}\nresult = 0;\nsaw_digit = 0;\nfor (;;) {\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\nc = *bp;\nif (!(c >= '0' && c <= '9')) {\nif (!saw_digit) {\nbp++;\ngoto invalid;\n}\nbreak;\n}\nc -= '0';\nif (result > (INT_MAX / 10)) {\ntoo_large = 1;\n} else {\nresult *= 10;\nif (result == INT_MAX && c > (INT_MAX % 10)) {\ntoo_large = 1;\n} else\nresult += c;\n}\nbp++;\nlen--;\nsaw_digit = 1;\n}\nif (!saw_digit)\ngoto invalid;\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\nif (*bp != '\\r') {\nbp++;\ngoto invalid;\n}\nbp++;\nlen--;\nif (len == 0)\ngoto trunc;\nND_TCHECK(*bp);\nif (*bp != '\\n') {\nbp++;\ngoto invalid;\n}\nbp++;\nlen--;\n*endp = bp;\nif (neg) {\nif (too_large || result != 1)\nreturn (-4);\nresult = -1;\n}\nreturn (too_large ? -3 : result);\ntrunc:\n*endp = bp;\nreturn (-2);\ninvalid:\n*endp = bp;\nreturn (-5);\n}", "label": 0}
{"index": 177094, "code": "telnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n{\nint i, x;\nu_int c;\nconst u_char *osp, *p;\n#define FETCH(c, sp, length) \\\ndo { \\\nif (length < 1) \\\ngoto pktend; \\\nND_TCHECK(*sp); \\\nc = *sp++; \\\nlength--; \\\n} while (0)\nosp = sp;\nFETCH(c, sp, length);\nif (c != IAC)\ngoto pktend;\nFETCH(c, sp, length);\nif (c == IAC) {\nif (print)\nND_PRINT((ndo, \"IAC IAC\"));\ngoto done;\n}\ni = c - TELCMD_FIRST;\nif (i < 0 || i > IAC - TELCMD_FIRST)\ngoto pktend;\nswitch (c) {\ncase DONT:\ncase DO:\ncase WONT:\ncase WILL:\ncase SB:\nFETCH(x, sp, length);\nif (x >= 0 && x < NTELOPTS) {\nif (print)\nND_PRINT((ndo, \"%s %s\", telcmds[i], telopts[x]));\n} else {\nif (print)\nND_PRINT((ndo, \"%s %#x\", telcmds[i], x));\n}\nif (c != SB)\nbreak;\np = sp;\nwhile (length > (u_int)(p + 1 - sp)) {\nND_TCHECK2(*p, 2);\nif (p[0] == IAC && p[1] == SE)\nbreak;\np++;\n}\nif (*p != IAC)\ngoto pktend;\nswitch (x) {\ncase TELOPT_AUTHENTICATION:\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, authcmd)));\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, authtype)));\nbreak;\ncase TELOPT_ENCRYPT:\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, enccmd)));\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, enctype)));\nbreak;\ndefault:\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, cmds)));\nbreak;\n}\nwhile (p > sp) {\nFETCH(x, sp, length);\nif (print)\nND_PRINT((ndo, \" %#x\", x));\n}\nif (print)\nND_PRINT((ndo, \" SE\"));\nsp += 2;\nbreak;\ndefault:\nif (print)\nND_PRINT((ndo, \"%s\", telcmds[i]));\ngoto done;\n}\ndone:\nreturn sp - osp;\ntrunc:\nND_PRINT((ndo, \"%s\", tstr));\npktend:\nreturn -1;\n#undef FETCH\n}", "contrast": "telnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n{\nint i, x;\nu_int c;\nconst u_char *osp, *p;\n#define FETCH(c, sp, length) \\\ndo { \\\nif (length < 1) \\\ngoto pktend; \\\nND_TCHECK(*sp); \\\nc = *sp++; \\\nlength--; \\\n} while (0)\nosp = sp;\nFETCH(c, sp, length);\nif (c != IAC)\ngoto pktend;\nFETCH(c, sp, length);\nif (c == IAC) {\nif (print)\nND_PRINT((ndo, \"IAC IAC\"));\ngoto done;\n}\ni = c - TELCMD_FIRST;\nif (i < 0 || i > IAC - TELCMD_FIRST)\ngoto pktend;\nswitch (c) {\ncase DONT:\ncase DO:\ncase WONT:\ncase WILL:\ncase SB:\nFETCH(x, sp, length);\nif (x >= 0 && x < NTELOPTS) {\nif (print)\nND_PRINT((ndo, \"%s %s\", telcmds[i], telopts[x]));\n} else {\nif (print)\nND_PRINT((ndo, \"%s %#x\", telcmds[i], x));\n}\nif (c != SB)\nbreak;\np = sp;\nwhile (length > (u_int)(p + 1 - sp)) {\nND_TCHECK2(*p, 2);\nif (p[0] == IAC && p[1] == SE)\nbreak;\np++;\n}\nND_TCHECK(*p);\nif (*p != IAC)\ngoto pktend;\nswitch (x) {\ncase TELOPT_AUTHENTICATION:\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, authcmd)));\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, authtype)));\nbreak;\ncase TELOPT_ENCRYPT:\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, enccmd)));\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, enctype)));\nbreak;\ndefault:\nif (p <= sp)\nbreak;\nFETCH(c, sp, length);\nif (print)\nND_PRINT((ndo, \" %s\", STR_OR_ID(c, cmds)));\nbreak;\n}\nwhile (p > sp) {\nFETCH(x, sp, length);\nif (print)\nND_PRINT((ndo, \" %#x\", x));\n}\nif (print)\nND_PRINT((ndo, \" SE\"));\nsp += 2;\nbreak;\ndefault:\nif (print)\nND_PRINT((ndo, \"%s\", telcmds[i]));\ngoto done;\n}\ndone:\nreturn sp - osp;\ntrunc:\nND_PRINT((ndo, \"%s\", tstr));\npktend:\nreturn -1;\n#undef FETCH\n}", "label": 0}
{"index": 177155, "code": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\nint i;\nif (huff->loc[ch] == NULL) {\nHuff_transmit(huff, NYT, fout);\nfor (i = 7; i >= 0; i--) {\nadd_bit((char)((ch >> i) & 0x1), fout);\n}\n} else {\nsend(huff->loc[ch], NULL, fout);\n}\n}", "contrast": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\nvoid Huff_transmit (huff_t *huff, int ch, byte *fout, int maxoffset) {\nint i;\nif (huff->loc[ch] == NULL) {\nHuff_transmit(huff, NYT, fout, maxoffset);\nfor (i = 7; i >= 0; i--) {\nadd_bit((char)((ch >> i) & 0x1), fout);\n}\n} else {\nsend(huff->loc[ch], NULL, fout, maxoffset);\n}\n}", "label": 0}
{"index": 177156, "code": "static void send(node_t *node, node_t *child, byte *fout) {\nif (node->parent) {\nsend(node->parent, node, fout);\n}\nif (child) {\nif (node->right == child) {\nadd_bit(1, fout);\n} else {\nadd_bit(0, fout);\n}\n}\n}", "contrast": "static void send(node_t *node, node_t *child, byte *fout) {\nstatic void send(node_t *node, node_t *child, byte *fout, int maxoffset) {\nif (node->parent) {\nsend(node->parent, node, fout, maxoffset);\n}\nif (child) {\nif (bloc >= maxoffset) {\nbloc = maxoffset + 1;\nreturn;\n}\nif (node->right == child) {\nadd_bit(1, fout);\n} else {\nadd_bit(0, fout);\n}\n}\n}", "label": 0}
{"index": 177158, "code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\nint\ti;\noldsize += bits;\nif ( msg->maxsize - msg->cursize < 4 ) {\nmsg->overflowed = qtrue;\nreturn;\n}\nif ( bits == 0 || bits < -31 || bits > 32 ) {\nCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n}\nif ( bits < 0 ) {\nbits = -bits;\n}\nif ( msg->oob ) {\nif ( bits == 8 ) {\nmsg->data[msg->cursize] = value;\nmsg->cursize += 1;\nmsg->bit += 8;\n} else if ( bits == 16 ) {\nshort temp = value;\nCopyLittleShort( &msg->data[msg->cursize], &temp );\nmsg->cursize += 2;\nmsg->bit += 16;\n} else if ( bits==32 ) {\nCopyLittleLong( &msg->data[msg->cursize], &value );\nmsg->cursize += 4;\nmsg->bit += 32;\n} else {\nCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n}\n} else {\nvalue &= (0xffffffff >> (32 - bits));\nif ( bits&7 ) {\nint nbits;\nnbits = bits&7;\nfor( i = 0; i < nbits; i++ ) {\nHuff_putBit( (value & 1), msg->data, &msg->bit );\nvalue = (value >> 1);\n}\nbits = bits - nbits;\n}\nif ( bits ) {\nfor( i = 0; i < bits; i += 8 ) {\nHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\nvalue = (value >> 8);\n}\n}\nmsg->cursize = (msg->bit >> 3) + 1;\n}\n}", "contrast": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\nint\ti;\noldsize += bits;\nif ( msg->overflowed ) {\nreturn;\n}\nif ( bits == 0 || bits < -31 || bits > 32 ) {\nCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n}\nif ( bits < 0 ) {\nbits = -bits;\n}\nif ( msg->oob ) {\nif ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {\nmsg->overflowed = qtrue;\nreturn;\n}\nif ( bits == 8 ) {\nmsg->data[msg->cursize] = value;\nmsg->cursize += 1;\nmsg->bit += 8;\n} else if ( bits == 16 ) {\nshort temp = value;\nCopyLittleShort( &msg->data[msg->cursize], &temp );\nmsg->cursize += 2;\nmsg->bit += 16;\n} else if ( bits==32 ) {\nCopyLittleLong( &msg->data[msg->cursize], &value );\nmsg->cursize += 4;\nmsg->bit += 32;\n} else {\nCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n}\n} else {\nvalue &= (0xffffffff >> (32 - bits));\nif ( bits&7 ) {\nint nbits;\nnbits = bits&7;\nif ( msg->bit + nbits > msg->maxsize << 3 ) {\nmsg->overflowed = qtrue;\nreturn;\n}\nfor( i = 0; i < nbits; i++ ) {\nHuff_putBit( (value & 1), msg->data, &msg->bit );\nvalue = (value >> 1);\n}\nbits = bits - nbits;\n}\nif ( bits ) {\nfor( i = 0; i < bits; i += 8 ) {\nHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );\nvalue = (value >> 8);\nif ( msg->bit > msg->maxsize << 3 ) {\nmsg->overflowed = qtrue;\nreturn;\n}\n}\n}\nmsg->cursize = (msg->bit >> 3) + 1;\n}\n}", "label": 0}
{"index": 177168, "code": "void acpi_ns_terminate(void)\n{\nacpi_status status;\nACPI_FUNCTION_TRACE(ns_terminate);\n#ifdef ACPI_EXEC_APP\n{\nunion acpi_operand_object *prev;\nunion acpi_operand_object *next;\nnext = acpi_gbl_module_code_list;\nwhile (next) {\nprev = next;\nnext = next->method.mutex;\nprev->method.mutex = NULL;\nacpi_ut_remove_reference(prev);\n}\n}\n#endif\nacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\nif (ACPI_FAILURE(status)) {\nreturn_VOID;\n}\nacpi_ns_delete_node(acpi_gbl_root_node);\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\nACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\nreturn_VOID;\n}", "contrast": "void acpi_ns_terminate(void)\n{\nacpi_status status;\nunion acpi_operand_object *prev;\nunion acpi_operand_object *next;\nACPI_FUNCTION_TRACE(ns_terminate);\nnext = acpi_gbl_module_code_list;\nwhile (next) {\nprev = next;\nnext = next->method.mutex;\nprev->method.mutex = NULL;\nacpi_ut_remove_reference(prev);\n}\nacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\nif (ACPI_FAILURE(status)) {\nreturn_VOID;\n}\nacpi_ns_delete_node(acpi_gbl_root_node);\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\nACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\nreturn_VOID;\n}", "label": 0}
{"index": 177169, "code": "gss_accept_sec_context (minor_status,\ncontext_handle,\nverifier_cred_handle,\ninput_token_buffer,\ninput_chan_bindings,\nsrc_name,\nmech_type,\noutput_token,\nret_flags,\ntime_rec,\nd_cred)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_cred_id_t\t\tverifier_cred_handle;\ngss_buffer_t\t\tinput_token_buffer;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_name_t *\t\tsrc_name;\ngss_OID *\t\tmech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\ngss_cred_id_t *\t\td_cred;\n{\nOM_uint32\t\tstatus, temp_status, temp_minor_status;\nOM_uint32\t\ttemp_ret_flags = 0;\ngss_union_ctx_id_t\tunion_ctx_id = NULL;\ngss_cred_id_t\tinput_cred_handle = GSS_C_NO_CREDENTIAL;\ngss_cred_id_t\ttmp_d_cred = GSS_C_NO_CREDENTIAL;\ngss_name_t\t\tinternal_name = GSS_C_NO_NAME;\ngss_name_t\t\ttmp_src_name = GSS_C_NO_NAME;\ngss_OID_desc\ttoken_mech_type_desc;\ngss_OID\t\ttoken_mech_type = &token_mech_type_desc;\ngss_OID\t\tactual_mech = GSS_C_NO_OID;\ngss_OID\t\tselected_mech = GSS_C_NO_OID;\ngss_OID\t\tpublic_mech;\ngss_mechanism\tmech = NULL;\ngss_union_cred_t\tuc;\nint\t\t\ti;\nstatus = val_acc_sec_ctx_args(minor_status,\ncontext_handle,\nverifier_cred_handle,\ninput_token_buffer,\ninput_chan_bindings,\nsrc_name,\nmech_type,\noutput_token,\nret_flags,\ntime_rec,\nd_cred);\nif (status != GSS_S_COMPLETE)\nreturn (status);\nif(*context_handle == GSS_C_NO_CONTEXT) {\nif (input_token_buffer == GSS_C_NO_BUFFER)\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nstatus = gssint_get_mech_type(token_mech_type, input_token_buffer);\nif (status)\nreturn status;\nif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\nuc = (gss_union_cred_t)verifier_cred_handle;\nfor (i = 0; i < uc->count; i++) {\npublic_mech = gssint_get_public_oid(&uc->mechs_array[i]);\nif (public_mech && g_OID_equal(token_mech_type, public_mech)) {\nselected_mech = &uc->mechs_array[i];\nbreak;\n}\n}\n}\nif (selected_mech == GSS_C_NO_OID) {\nstatus = gssint_select_mech_type(minor_status, token_mech_type,\n&selected_mech);\nif (status)\nreturn status;\n}\n} else {\nunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\nselected_mech = union_ctx_id->mech_type;\n}\nif (*context_handle == GSS_C_NO_CONTEXT) {\nstatus = GSS_S_FAILURE;\nunion_ctx_id = (gss_union_ctx_id_t)\nmalloc(sizeof(gss_union_ctx_id_desc));\nif (!union_ctx_id)\nreturn (GSS_S_FAILURE);\nunion_ctx_id->loopback = union_ctx_id;\nunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\nstatus = generic_gss_copy_oid(&temp_minor_status, selected_mech,\n&union_ctx_id->mech_type);\nif (status != GSS_S_COMPLETE) {\nfree(union_ctx_id);\nreturn (status);\n}\n*context_handle = (gss_ctx_id_t)union_ctx_id;\n}\nif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\ninput_cred_handle =\ngssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,\nselected_mech);\nif (input_cred_handle == GSS_C_NO_CREDENTIAL) {\nstatus = GSS_S_NO_CRED;\ngoto error_out;\n}\n} else if (!allow_mech_by_default(selected_mech)) {\nstatus = GSS_S_NO_CRED;\ngoto error_out;\n}\nmech = gssint_get_mechanism(selected_mech);\nif (mech && mech->gss_accept_sec_context) {\nstatus = mech->gss_accept_sec_context(minor_status,\n&union_ctx_id->internal_ctx_id,\ninput_cred_handle,\ninput_token_buffer,\ninput_chan_bindings,\nsrc_name ? &internal_name : NULL,\n&actual_mech,\noutput_token,\n&temp_ret_flags,\ntime_rec,\nd_cred ? &tmp_d_cred : NULL);\nif (status == GSS_S_CONTINUE_NEEDED)\nreturn GSS_S_CONTINUE_NEEDED;\nif (status != GSS_S_COMPLETE) {\nmap_error(minor_status, mech);\ngoto error_out;\n}\nif (src_name != NULL) {\nif (internal_name != GSS_C_NO_NAME) {\ntemp_status = gssint_convert_name_to_union_name(\n&temp_minor_status, mech,\ninternal_name, &tmp_src_name);\nif (temp_status != GSS_S_COMPLETE) {\nstatus = temp_status;\n*minor_status = temp_minor_status;\nmap_error(minor_status, mech);\nif (output_token->length)\n(void) gss_release_buffer(&temp_minor_status,\noutput_token);\ngoto error_out;\n}\n*src_name = tmp_src_name;\n} else\n*src_name = GSS_C_NO_NAME;\n}\n#define g_OID_prefix_equal(o1, o2) \\\n(((o1)->length >= (o2)->length) && \\\n(memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\nif ((temp_ret_flags & GSS_C_DELEG_FLAG) &&\ntmp_d_cred != GSS_C_NO_CREDENTIAL) {\npublic_mech = gssint_get_public_oid(selected_mech);\nif (actual_mech != GSS_C_NO_OID &&\npublic_mech != GSS_C_NO_OID &&\n!g_OID_prefix_equal(actual_mech, public_mech)) {\n*d_cred = tmp_d_cred;\n} else {\ngss_union_cred_t d_u_cred = NULL;\nd_u_cred = malloc(sizeof (gss_union_cred_desc));\nif (d_u_cred == NULL) {\nstatus = GSS_S_FAILURE;\ngoto error_out;\n}\n(void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));\nd_u_cred->count = 1;\nstatus = generic_gss_copy_oid(&temp_minor_status,\nselected_mech,\n&d_u_cred->mechs_array);\nif (status != GSS_S_COMPLETE) {\nfree(d_u_cred);\ngoto error_out;\n}\nd_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));\nif (d_u_cred->cred_array != NULL) {\nd_u_cred->cred_array[0] = tmp_d_cred;\n} else {\nfree(d_u_cred);\nstatus = GSS_S_FAILURE;\ngoto error_out;\n}\nd_u_cred->loopback = d_u_cred;\n*d_cred = (gss_cred_id_t)d_u_cred;\n}\n}\nif (mech_type != NULL)\n*mech_type = gssint_get_public_oid(actual_mech);\nif (ret_flags != NULL)\n*ret_flags = temp_ret_flags;\nreturn\t(status);\n} else {\nstatus = GSS_S_BAD_MECH;\n}\nerror_out:\nif (union_ctx_id) {\nif (union_ctx_id->mech_type) {\nif (union_ctx_id->mech_type->elements)\nfree(union_ctx_id->mech_type->elements);\nfree(union_ctx_id->mech_type);\n}\nif (union_ctx_id->internal_ctx_id && mech &&\nmech->gss_delete_sec_context) {\nmech->gss_delete_sec_context(&temp_minor_status,\n&union_ctx_id->internal_ctx_id,\nGSS_C_NO_BUFFER);\n}\nfree(union_ctx_id);\n*context_handle = GSS_C_NO_CONTEXT;\n}\nif (src_name)\n*src_name = GSS_C_NO_NAME;\nif (tmp_src_name != GSS_C_NO_NAME)\n(void) gss_release_buffer(&temp_minor_status,\n(gss_buffer_t)tmp_src_name);\nreturn (status);\n}", "contrast": "gss_accept_sec_context (minor_status,\ncontext_handle,\nverifier_cred_handle,\ninput_token_buffer,\ninput_chan_bindings,\nsrc_name,\nmech_type,\noutput_token,\nret_flags,\ntime_rec,\nd_cred)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_cred_id_t\t\tverifier_cred_handle;\ngss_buffer_t\t\tinput_token_buffer;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_name_t *\t\tsrc_name;\ngss_OID *\t\tmech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\ngss_cred_id_t *\t\td_cred;\n{\nOM_uint32\t\tstatus, temp_status, temp_minor_status;\nOM_uint32\t\ttemp_ret_flags = 0;\ngss_union_ctx_id_t\tunion_ctx_id = NULL;\ngss_cred_id_t\tinput_cred_handle = GSS_C_NO_CREDENTIAL;\ngss_cred_id_t\ttmp_d_cred = GSS_C_NO_CREDENTIAL;\ngss_name_t\t\tinternal_name = GSS_C_NO_NAME;\ngss_name_t\t\ttmp_src_name = GSS_C_NO_NAME;\ngss_OID_desc\ttoken_mech_type_desc;\ngss_OID\t\ttoken_mech_type = &token_mech_type_desc;\ngss_OID\t\tactual_mech = GSS_C_NO_OID;\ngss_OID\t\tselected_mech = GSS_C_NO_OID;\ngss_OID\t\tpublic_mech;\ngss_mechanism\tmech = NULL;\ngss_union_cred_t\tuc;\nint\t\t\ti;\nstatus = val_acc_sec_ctx_args(minor_status,\ncontext_handle,\nverifier_cred_handle,\ninput_token_buffer,\ninput_chan_bindings,\nsrc_name,\nmech_type,\noutput_token,\nret_flags,\ntime_rec,\nd_cred);\nif (status != GSS_S_COMPLETE)\nreturn (status);\nif(*context_handle == GSS_C_NO_CONTEXT) {\nif (input_token_buffer == GSS_C_NO_BUFFER)\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nstatus = gssint_get_mech_type(token_mech_type, input_token_buffer);\nif (status)\nreturn status;\nif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\nuc = (gss_union_cred_t)verifier_cred_handle;\nfor (i = 0; i < uc->count; i++) {\npublic_mech = gssint_get_public_oid(&uc->mechs_array[i]);\nif (public_mech && g_OID_equal(token_mech_type, public_mech)) {\nselected_mech = &uc->mechs_array[i];\nbreak;\n}\n}\n}\nif (selected_mech == GSS_C_NO_OID) {\nstatus = gssint_select_mech_type(minor_status, token_mech_type,\n&selected_mech);\nif (status)\nreturn status;\n}\n} else {\nunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\nselected_mech = union_ctx_id->mech_type;\nif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\nreturn (GSS_S_NO_CONTEXT);\n}\nif (*context_handle == GSS_C_NO_CONTEXT) {\nstatus = GSS_S_FAILURE;\nunion_ctx_id = (gss_union_ctx_id_t)\nmalloc(sizeof(gss_union_ctx_id_desc));\nif (!union_ctx_id)\nreturn (GSS_S_FAILURE);\nunion_ctx_id->loopback = union_ctx_id;\nunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\nstatus = generic_gss_copy_oid(&temp_minor_status, selected_mech,\n&union_ctx_id->mech_type);\nif (status != GSS_S_COMPLETE) {\nfree(union_ctx_id);\nreturn (status);\n}\n}\nif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\ninput_cred_handle =\ngssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,\nselected_mech);\nif (input_cred_handle == GSS_C_NO_CREDENTIAL) {\nstatus = GSS_S_NO_CRED;\ngoto error_out;\n}\n} else if (!allow_mech_by_default(selected_mech)) {\nstatus = GSS_S_NO_CRED;\ngoto error_out;\n}\nmech = gssint_get_mechanism(selected_mech);\nif (mech && mech->gss_accept_sec_context) {\nstatus = mech->gss_accept_sec_context(minor_status,\n&union_ctx_id->internal_ctx_id,\ninput_cred_handle,\ninput_token_buffer,\ninput_chan_bindings,\nsrc_name ? &internal_name : NULL,\n&actual_mech,\noutput_token,\n&temp_ret_flags,\ntime_rec,\nd_cred ? &tmp_d_cred : NULL);\nif (status == GSS_S_CONTINUE_NEEDED) {\n*context_handle = (gss_ctx_id_t)union_ctx_id;\nreturn GSS_S_CONTINUE_NEEDED;\n}\nif (status != GSS_S_COMPLETE) {\nmap_error(minor_status, mech);\ngoto error_out;\n}\nif (src_name != NULL) {\nif (internal_name != GSS_C_NO_NAME) {\ntemp_status = gssint_convert_name_to_union_name(\n&temp_minor_status, mech,\ninternal_name, &tmp_src_name);\nif (temp_status != GSS_S_COMPLETE) {\nstatus = temp_status;\n*minor_status = temp_minor_status;\nmap_error(minor_status, mech);\nif (output_token->length)\n(void) gss_release_buffer(&temp_minor_status,\noutput_token);\ngoto error_out;\n}\n*src_name = tmp_src_name;\n} else\n*src_name = GSS_C_NO_NAME;\n}\n#define g_OID_prefix_equal(o1, o2) \\\n(((o1)->length >= (o2)->length) && \\\n(memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\nif ((temp_ret_flags & GSS_C_DELEG_FLAG) &&\ntmp_d_cred != GSS_C_NO_CREDENTIAL) {\npublic_mech = gssint_get_public_oid(selected_mech);\nif (actual_mech != GSS_C_NO_OID &&\npublic_mech != GSS_C_NO_OID &&\n!g_OID_prefix_equal(actual_mech, public_mech)) {\n*d_cred = tmp_d_cred;\n} else {\ngss_union_cred_t d_u_cred = NULL;\nd_u_cred = malloc(sizeof (gss_union_cred_desc));\nif (d_u_cred == NULL) {\nstatus = GSS_S_FAILURE;\ngoto error_out;\n}\n(void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));\nd_u_cred->count = 1;\nstatus = generic_gss_copy_oid(&temp_minor_status,\nselected_mech,\n&d_u_cred->mechs_array);\nif (status != GSS_S_COMPLETE) {\nfree(d_u_cred);\ngoto error_out;\n}\nd_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));\nif (d_u_cred->cred_array != NULL) {\nd_u_cred->cred_array[0] = tmp_d_cred;\n} else {\nfree(d_u_cred);\nstatus = GSS_S_FAILURE;\ngoto error_out;\n}\nd_u_cred->loopback = d_u_cred;\n*d_cred = (gss_cred_id_t)d_u_cred;\n}\n}\nif (mech_type != NULL)\n*mech_type = gssint_get_public_oid(actual_mech);\nif (ret_flags != NULL)\n*ret_flags = temp_ret_flags;\n*context_handle = (gss_ctx_id_t)union_ctx_id;\nreturn GSS_S_COMPLETE;\n} else {\nstatus = GSS_S_BAD_MECH;\n}\nerror_out:\nif (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\nif (union_ctx_id->mech_type) {\nif (union_ctx_id->mech_type->elements)\nfree(union_ctx_id->mech_type->elements);\nfree(union_ctx_id->mech_type);\n}\nif (union_ctx_id->internal_ctx_id && mech &&\nmech->gss_delete_sec_context) {\nmech->gss_delete_sec_context(&temp_minor_status,\n&union_ctx_id->internal_ctx_id,\nGSS_C_NO_BUFFER);\n}\nfree(union_ctx_id);\n}\nif (src_name)\n*src_name = GSS_C_NO_NAME;\nif (tmp_src_name != GSS_C_NO_NAME)\n(void) gss_release_buffer(&temp_minor_status,\n(gss_buffer_t)tmp_src_name);\nreturn (status);\n}", "label": 0}
{"index": 177170, "code": "gss_complete_auth_token (OM_uint32 *minor_status,\nconst gss_ctx_id_t context_handle,\ngss_buffer_t input_message_buffer)\n{\nOM_uint32\t\tstatus;\ngss_union_ctx_id_t\tctx;\ngss_mechanism\tmech;\nif (context_handle == GSS_C_NO_CONTEXT)\nreturn GSS_S_NO_CONTEXT;\nctx = (gss_union_ctx_id_t) context_handle;\nmech = gssint_get_mechanism (ctx->mech_type);\nif (mech != NULL) {\nif (mech->gss_complete_auth_token != NULL) {\nstatus = mech->gss_complete_auth_token(minor_status,\nctx->internal_ctx_id,\ninput_message_buffer);\nif (status != GSS_S_COMPLETE)\nmap_error(minor_status, mech);\n} else\nstatus = GSS_S_COMPLETE;\n} else\nstatus = GSS_S_BAD_MECH;\nreturn status;\n}", "contrast": "gss_complete_auth_token (OM_uint32 *minor_status,\nconst gss_ctx_id_t context_handle,\ngss_buffer_t input_message_buffer)\n{\nOM_uint32\t\tstatus;\ngss_union_ctx_id_t\tctx;\ngss_mechanism\tmech;\nif (context_handle == GSS_C_NO_CONTEXT)\nreturn GSS_S_NO_CONTEXT;\nctx = (gss_union_ctx_id_t) context_handle;\nif (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\nreturn GSS_S_NO_CONTEXT;\nmech = gssint_get_mechanism (ctx->mech_type);\nif (mech != NULL) {\nif (mech->gss_complete_auth_token != NULL) {\nstatus = mech->gss_complete_auth_token(minor_status,\nctx->internal_ctx_id,\ninput_message_buffer);\nif (status != GSS_S_COMPLETE)\nmap_error(minor_status, mech);\n} else\nstatus = GSS_S_COMPLETE;\n} else\nstatus = GSS_S_BAD_MECH;\nreturn status;\n}", "label": 0}
{"index": 177177, "code": "gss_process_context_token (minor_status,\ncontext_handle,\ntoken_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n{\nOM_uint32\t\tstatus;\ngss_union_ctx_id_t\tctx;\ngss_mechanism\tmech;\nif (minor_status == NULL)\nreturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n*minor_status = 0;\nif (context_handle == GSS_C_NO_CONTEXT)\nreturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\nif (token_buffer == GSS_C_NO_BUFFER)\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nif (GSS_EMPTY_BUFFER(token_buffer))\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nctx = (gss_union_ctx_id_t) context_handle;\nmech = gssint_get_mechanism (ctx->mech_type);\nif (mech) {\nif (mech->gss_process_context_token) {\nstatus = mech->gss_process_context_token(\nminor_status,\nctx->internal_ctx_id,\ntoken_buffer);\nif (status != GSS_S_COMPLETE)\nmap_error(minor_status, mech);\n} else\nstatus = GSS_S_UNAVAILABLE;\nreturn(status);\n}\nreturn (GSS_S_BAD_MECH);\n}", "contrast": "gss_process_context_token (minor_status,\ncontext_handle,\ntoken_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n{\nOM_uint32\t\tstatus;\ngss_union_ctx_id_t\tctx;\ngss_mechanism\tmech;\nif (minor_status == NULL)\nreturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n*minor_status = 0;\nif (context_handle == GSS_C_NO_CONTEXT)\nreturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\nif (token_buffer == GSS_C_NO_BUFFER)\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nif (GSS_EMPTY_BUFFER(token_buffer))\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nctx = (gss_union_ctx_id_t) context_handle;\nif (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\nreturn (GSS_S_NO_CONTEXT);\nmech = gssint_get_mechanism (ctx->mech_type);\nif (mech) {\nif (mech->gss_process_context_token) {\nstatus = mech->gss_process_context_token(\nminor_status,\nctx->internal_ctx_id,\ntoken_buffer);\nif (status != GSS_S_COMPLETE)\nmap_error(minor_status, mech);\n} else\nstatus = GSS_S_UNAVAILABLE;\nreturn(status);\n}\nreturn (GSS_S_BAD_MECH);\n}", "label": 0}
{"index": 177185, "code": "gss_verify_mic (minor_status,\ncontext_handle,\nmessage_buffer,\ntoken_buffer,\nqop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n{\nOM_uint32\t\tstatus;\ngss_union_ctx_id_t\tctx;\ngss_mechanism\tmech;\nif (minor_status == NULL)\nreturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n*minor_status = 0;\nif (context_handle == GSS_C_NO_CONTEXT)\nreturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\nif ((message_buffer == GSS_C_NO_BUFFER) ||\nGSS_EMPTY_BUFFER(token_buffer))\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nctx = (gss_union_ctx_id_t) context_handle;\nmech = gssint_get_mechanism (ctx->mech_type);\nif (mech) {\nif (mech->gss_verify_mic) {\nstatus = mech->gss_verify_mic(\nminor_status,\nctx->internal_ctx_id,\nmessage_buffer,\ntoken_buffer,\nqop_state);\nif (status != GSS_S_COMPLETE)\nmap_error(minor_status, mech);\n} else\nstatus = GSS_S_UNAVAILABLE;\nreturn(status);\n}\nreturn (GSS_S_BAD_MECH);\n}", "contrast": "gss_verify_mic (minor_status,\ncontext_handle,\nmessage_buffer,\ntoken_buffer,\nqop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n{\nOM_uint32\t\tstatus;\ngss_union_ctx_id_t\tctx;\ngss_mechanism\tmech;\nif (minor_status == NULL)\nreturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n*minor_status = 0;\nif (context_handle == GSS_C_NO_CONTEXT)\nreturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\nif ((message_buffer == GSS_C_NO_BUFFER) ||\nGSS_EMPTY_BUFFER(token_buffer))\nreturn (GSS_S_CALL_INACCESSIBLE_READ);\nctx = (gss_union_ctx_id_t) context_handle;\nif (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\nreturn (GSS_S_NO_CONTEXT);\nmech = gssint_get_mechanism (ctx->mech_type);\nif (mech) {\nif (mech->gss_verify_mic) {\nstatus = mech->gss_verify_mic(\nminor_status,\nctx->internal_ctx_id,\nmessage_buffer,\ntoken_buffer,\nqop_state);\nif (status != GSS_S_COMPLETE)\nmap_error(minor_status, mech);\n} else\nstatus = GSS_S_UNAVAILABLE;\nreturn(status);\n}\nreturn (GSS_S_BAD_MECH);\n}", "label": 0}
{"index": 177194, "code": "static int ape_decode_frame(AVCodecContext *avctx, void *data,\nint *got_frame_ptr, AVPacket *avpkt)\n{\nAVFrame *frame     = data;\nconst uint8_t *buf = avpkt->data;\nAPEContext *s = avctx->priv_data;\nuint8_t *sample8;\nint16_t *sample16;\nint32_t *sample24;\nint i, ch, ret;\nint blockstodecode;\nav_assert0(s->samples >= 0);\nif(!s->samples){\nuint32_t nblocks, offset;\nint buf_size;\nif (!avpkt->size) {\n*got_frame_ptr = 0;\nreturn 0;\n}\nif (avpkt->size < 8) {\nav_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nbuf_size = avpkt->size & ~3;\nif (buf_size != avpkt->size) {\nav_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n\"extra bytes at the end will be skipped.\\n\");\n}\nif (s->fileversion < 3950)\nbuf_size += 2;\nav_fast_padded_malloc(&s->data, &s->data_size, buf_size);\nif (!s->data)\nreturn AVERROR(ENOMEM);\ns->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,\nbuf_size >> 2);\nmemset(s->data + (buf_size & ~3), 0, buf_size & 3);\ns->ptr = s->data;\ns->data_end = s->data + buf_size;\nnblocks = bytestream_get_be32(&s->ptr);\noffset  = bytestream_get_be32(&s->ptr);\nif (s->fileversion >= 3900) {\nif (offset > 3) {\nav_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\ns->data = NULL;\nreturn AVERROR_INVALIDDATA;\n}\nif (s->data_end - s->ptr < offset) {\nav_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\nreturn AVERROR_INVALIDDATA;\n}\ns->ptr += offset;\n} else {\nif ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\nreturn ret;\nif (s->fileversion > 3800)\nskip_bits_long(&s->gb, offset * 8);\nelse\nskip_bits_long(&s->gb, offset);\n}\nif (!nblocks || nblocks > INT_MAX) {\nav_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\nnblocks);\nreturn AVERROR_INVALIDDATA;\n}\nif (init_frame_decoder(s) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\nreturn AVERROR_INVALIDDATA;\n}\ns->samples = nblocks;\n}\nif (!s->data) {\n*got_frame_ptr = 0;\nreturn avpkt->size;\n}\nblockstodecode = FFMIN(s->blocks_per_loop, s->samples);\nif (s->fileversion < 3930)\nblockstodecode = s->samples;\nav_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));\nif (!s->decoded_buffer)\nreturn AVERROR(ENOMEM);\nmemset(s->decoded_buffer, 0, s->decoded_size);\ns->decoded[0] = s->decoded_buffer;\ns->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\nframe->nb_samples = blockstodecode;\nif ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\nreturn ret;\ns->error=0;\nif ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\nape_unpack_mono(s, blockstodecode);\nelse\nape_unpack_stereo(s, blockstodecode);\nemms_c();\nif (s->error) {\ns->samples=0;\nav_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nswitch (s->bps) {\ncase 8:\nfor (ch = 0; ch < s->channels; ch++) {\nsample8 = (uint8_t *)frame->data[ch];\nfor (i = 0; i < blockstodecode; i++)\n*sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;\n}\nbreak;\ncase 16:\nfor (ch = 0; ch < s->channels; ch++) {\nsample16 = (int16_t *)frame->data[ch];\nfor (i = 0; i < blockstodecode; i++)\n*sample16++ = s->decoded[ch][i];\n}\nbreak;\ncase 24:\nfor (ch = 0; ch < s->channels; ch++) {\nsample24 = (int32_t *)frame->data[ch];\nfor (i = 0; i < blockstodecode; i++)\n*sample24++ = s->decoded[ch][i] << 8;\n}\nbreak;\n}\ns->samples -= blockstodecode;\n*got_frame_ptr = 1;\nreturn !s->samples ? avpkt->size : 0;\n}", "contrast": "static int ape_decode_frame(AVCodecContext *avctx, void *data,\nint *got_frame_ptr, AVPacket *avpkt)\n{\nAVFrame *frame     = data;\nconst uint8_t *buf = avpkt->data;\nAPEContext *s = avctx->priv_data;\nuint8_t *sample8;\nint16_t *sample16;\nint32_t *sample24;\nint i, ch, ret;\nint blockstodecode;\nuint64_t decoded_buffer_size;\nav_assert0(s->samples >= 0);\nif(!s->samples){\nuint32_t nblocks, offset;\nint buf_size;\nif (!avpkt->size) {\n*got_frame_ptr = 0;\nreturn 0;\n}\nif (avpkt->size < 8) {\nav_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nbuf_size = avpkt->size & ~3;\nif (buf_size != avpkt->size) {\nav_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n\"extra bytes at the end will be skipped.\\n\");\n}\nif (s->fileversion < 3950)\nbuf_size += 2;\nav_fast_padded_malloc(&s->data, &s->data_size, buf_size);\nif (!s->data)\nreturn AVERROR(ENOMEM);\ns->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,\nbuf_size >> 2);\nmemset(s->data + (buf_size & ~3), 0, buf_size & 3);\ns->ptr = s->data;\ns->data_end = s->data + buf_size;\nnblocks = bytestream_get_be32(&s->ptr);\noffset  = bytestream_get_be32(&s->ptr);\nif (s->fileversion >= 3900) {\nif (offset > 3) {\nav_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\ns->data = NULL;\nreturn AVERROR_INVALIDDATA;\n}\nif (s->data_end - s->ptr < offset) {\nav_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\nreturn AVERROR_INVALIDDATA;\n}\ns->ptr += offset;\n} else {\nif ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\nreturn ret;\nif (s->fileversion > 3800)\nskip_bits_long(&s->gb, offset * 8);\nelse\nskip_bits_long(&s->gb, offset);\n}\nif (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {\nav_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\nnblocks);\nreturn AVERROR_INVALIDDATA;\n}\nif (init_frame_decoder(s) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\nreturn AVERROR_INVALIDDATA;\n}\ns->samples = nblocks;\n}\nif (!s->data) {\n*got_frame_ptr = 0;\nreturn avpkt->size;\n}\nblockstodecode = FFMIN(s->blocks_per_loop, s->samples);\nif (s->fileversion < 3930)\nblockstodecode = s->samples;\ndecoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\nav_assert0(decoded_buffer_size <= INT_MAX);\nav_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\nif (!s->decoded_buffer)\nreturn AVERROR(ENOMEM);\nmemset(s->decoded_buffer, 0, s->decoded_size);\ns->decoded[0] = s->decoded_buffer;\ns->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\nframe->nb_samples = blockstodecode;\nif ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\nreturn ret;\ns->error=0;\nif ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\nape_unpack_mono(s, blockstodecode);\nelse\nape_unpack_stereo(s, blockstodecode);\nemms_c();\nif (s->error) {\ns->samples=0;\nav_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nswitch (s->bps) {\ncase 8:\nfor (ch = 0; ch < s->channels; ch++) {\nsample8 = (uint8_t *)frame->data[ch];\nfor (i = 0; i < blockstodecode; i++)\n*sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;\n}\nbreak;\ncase 16:\nfor (ch = 0; ch < s->channels; ch++) {\nsample16 = (int16_t *)frame->data[ch];\nfor (i = 0; i < blockstodecode; i++)\n*sample16++ = s->decoded[ch][i];\n}\nbreak;\ncase 24:\nfor (ch = 0; ch < s->channels; ch++) {\nsample24 = (int32_t *)frame->data[ch];\nfor (i = 0; i < blockstodecode; i++)\n*sample24++ = s->decoded[ch][i] << 8;\n}\nbreak;\n}\ns->samples -= blockstodecode;\n*got_frame_ptr = 1;\nreturn !s->samples ? avpkt->size : 0;\n}", "label": 0}
{"index": 177212, "code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\nunsigned long size, bool kernel, bool pinned,\nstruct virtio_gpu_object **bo_ptr)\n{\nstruct virtio_gpu_object *bo;\nenum ttm_bo_type type;\nsize_t acc_size;\nint ret;\nif (kernel)\ntype = ttm_bo_type_kernel;\nelse\ntype = ttm_bo_type_device;\n*bo_ptr = NULL;\nacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\nsizeof(struct virtio_gpu_object));\nbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\nif (bo == NULL)\nreturn -ENOMEM;\nsize = roundup(size, PAGE_SIZE);\nret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\nif (ret != 0)\nreturn ret;\nbo->dumb = false;\nvirtio_gpu_init_ttm_placement(bo, pinned);\nret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n&bo->placement, 0, !kernel, NULL, acc_size,\nNULL, NULL, &virtio_gpu_ttm_bo_destroy);\nif (ret != 0)\nreturn ret;\n*bo_ptr = bo;\nreturn 0;\n}", "contrast": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\nunsigned long size, bool kernel, bool pinned,\nstruct virtio_gpu_object **bo_ptr)\n{\nstruct virtio_gpu_object *bo;\nenum ttm_bo_type type;\nsize_t acc_size;\nint ret;\nif (kernel)\ntype = ttm_bo_type_kernel;\nelse\ntype = ttm_bo_type_device;\n*bo_ptr = NULL;\nacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\nsizeof(struct virtio_gpu_object));\nbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\nif (bo == NULL)\nreturn -ENOMEM;\nsize = roundup(size, PAGE_SIZE);\nret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\nif (ret != 0) {\nkfree(bo);\nreturn ret;\n}\nbo->dumb = false;\nvirtio_gpu_init_ttm_placement(bo, pinned);\nret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n&bo->placement, 0, !kernel, NULL, acc_size,\nNULL, NULL, &virtio_gpu_ttm_bo_destroy);\nif (ret != 0)\nreturn ret;\n*bo_ptr = bo;\nreturn 0;\n}", "label": 0}
{"index": 177215, "code": "de_dotdot( char* file )\n{\nchar* cp;\nchar* cp2;\nint l;\nwhile ( ( cp = strstr( file, \"//\") ) != (char*) 0 )\n{\nfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\ncontinue;\n(void) strcpy( cp + 1, cp2 );\n}\nwhile ( strncmp( file, \"./\", 2 ) == 0 )\n(void) memmove( file, file + 2, strlen( file ) - 1 );\nwhile ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n(void) memmove( cp, cp + 2, strlen( file ) - 1 );\nfor (;;)\n{\nwhile ( strncmp( file, \"../\", 3 ) == 0 )\n(void) memmove( file, file + 3, strlen( file ) - 2 );\ncp = strstr( file, \"/../\" );\nif ( cp == (char*) 0 )\nbreak;\nfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\ncontinue;\n(void) strcpy( cp2 + 1, cp + 4 );\n}\nwhile ( ( l = strlen( file ) ) > 3 &&\nstrcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n{\nfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\ncontinue;\nif ( cp2 < file )\nbreak;\n*cp2 = '\\0';\n}\n}", "contrast": "de_dotdot( char* file )\n{\nchar* cp;\nchar* cp2;\nint l;\nwhile ( ( cp = strstr( file, \"//\") ) != (char*) 0 )\n{\nfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\ncontinue;\n(void) strcpy( cp + 1, cp2 );\n}\nwhile ( strncmp( file, \"./\", 2 ) == 0 )\n(void) memmove( file, file + 2, strlen( file ) - 1 );\nwhile ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n(void) memmove( cp, cp + 2, strlen( cp ) - 1 );\nfor (;;)\n{\nwhile ( strncmp( file, \"../\", 3 ) == 0 )\n(void) memmove( file, file + 3, strlen( file ) - 2 );\ncp = strstr( file, \"/../\" );\nif ( cp == (char*) 0 )\nbreak;\nfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\ncontinue;\n(void) strcpy( cp2 + 1, cp + 4 );\n}\nwhile ( ( l = strlen( file ) ) > 3 &&\nstrcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n{\nfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\ncontinue;\nif ( cp2 < file )\nbreak;\n*cp2 = '\\0';\n}\n}", "label": 0}
{"index": 177218, "code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\nif (ctx->might_cancel) {\nctx->might_cancel = false;\nspin_lock(&cancel_lock);\nlist_del_rcu(&ctx->clist);\nspin_unlock(&cancel_lock);\n}\n}", "contrast": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\nstatic void __timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\nif (ctx->might_cancel) {\nctx->might_cancel = false;\nspin_lock(&cancel_lock);\nlist_del_rcu(&ctx->clist);\nspin_unlock(&cancel_lock);\n}\n}", "label": 0}
{"index": 177219, "code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\nif ((ctx->clockid == CLOCK_REALTIME ||\nctx->clockid == CLOCK_REALTIME_ALARM) &&\n(flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\nif (!ctx->might_cancel) {\nctx->might_cancel = true;\nspin_lock(&cancel_lock);\nlist_add_rcu(&ctx->clist, &cancel_list);\nspin_unlock(&cancel_lock);\n}\n} else if (ctx->might_cancel) {\ntimerfd_remove_cancel(ctx);\n}\n}", "contrast": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\nspin_lock(&ctx->cancel_lock);\nif ((ctx->clockid == CLOCK_REALTIME ||\nctx->clockid == CLOCK_REALTIME_ALARM) &&\n(flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\nif (!ctx->might_cancel) {\nctx->might_cancel = true;\nspin_lock(&cancel_lock);\nlist_add_rcu(&ctx->clist, &cancel_list);\nspin_unlock(&cancel_lock);\n}\n} else {\n__timerfd_remove_cancel(ctx);\n}\nspin_unlock(&ctx->cancel_lock);\n}", "label": 0}
{"index": 177236, "code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\nvoid *dummy,\nconst char *arg)\n{\nconst char *endp = ap_strrchr_c(arg, '>');\nconst char *limited_methods;\nvoid *tog = cmd->cmd->cmd_data;\napr_int64_t limited = 0;\napr_int64_t old_limited = cmd->limited;\nconst char *errmsg;\nif (endp == NULL) {\nreturn unclosed_directive(cmd);\n}\nlimited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\nif (!limited_methods[0]) {\nreturn missing_container_arg(cmd);\n}\nwhile (limited_methods[0]) {\nchar *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\nint methnum;\nmethnum = ap_method_number_of(method);\nif (methnum == M_TRACE && !tog) {\nreturn \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n}\nelse if (methnum == M_INVALID) {\nmethnum = ap_method_register(cmd->pool,\napr_pstrdup(cmd->pool, method));\n}\nlimited |= (AP_METHOD_BIT << methnum);\n}\nlimited = tog ? ~limited : limited;\nif (!(old_limited & limited)) {\nreturn apr_pstrcat(cmd->pool, cmd->cmd->name,\n\"> directive excludes all methods\", NULL);\n}\nelse if ((old_limited & limited) == old_limited) {\nreturn apr_pstrcat(cmd->pool, cmd->cmd->name,\n\"> directive specifies methods already excluded\",\nNULL);\n}\ncmd->limited &= limited;\nerrmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\ncmd->limited = old_limited;\nreturn errmsg;\n}", "contrast": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\nvoid *dummy,\nconst char *arg)\n{\nconst char *endp = ap_strrchr_c(arg, '>');\nconst char *limited_methods;\nvoid *tog = cmd->cmd->cmd_data;\napr_int64_t limited = 0;\napr_int64_t old_limited = cmd->limited;\nconst char *errmsg;\nif (endp == NULL) {\nreturn unclosed_directive(cmd);\n}\nlimited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\nif (!limited_methods[0]) {\nreturn missing_container_arg(cmd);\n}\nwhile (limited_methods[0]) {\nchar *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\nint methnum;\nmethnum = ap_method_number_of(method);\nif (methnum == M_TRACE && !tog) {\nreturn \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n}\nelse if (methnum == M_INVALID) {\nif (cmd->pool == cmd->temp_pool) {\nreturn apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n\"for %s from .htaccess configuration\",\nmethod, cmd->cmd->name);\n}\nmethnum = ap_method_register(cmd->pool,\napr_pstrdup(cmd->pool, method));\n}\nlimited |= (AP_METHOD_BIT << methnum);\n}\nlimited = tog ? ~limited : limited;\nif (!(old_limited & limited)) {\nreturn apr_pstrcat(cmd->pool, cmd->cmd->name,\n\"> directive excludes all methods\", NULL);\n}\nelse if ((old_limited & limited) == old_limited) {\nreturn apr_pstrcat(cmd->pool, cmd->cmd->name,\n\"> directive specifies methods already excluded\",\nNULL);\n}\ncmd->limited &= limited;\nerrmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\ncmd->limited = old_limited;\nreturn errmsg;\n}", "label": 0}
{"index": 177238, "code": "grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\nstruct grub_ext2_data *data = node->data;\nstruct grub_ext2_inode *inode = &node->inode;\nint blknr = -1;\nunsigned int blksz = EXT2_BLOCK_SIZE (data);\nint log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\nif (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n{\n#ifndef _MSC_VER\nchar buf[EXT2_BLOCK_SIZE (data)];\n#else\nchar * buf = grub_malloc (EXT2_BLOCK_SIZE(data));\n#endif\nstruct grub_ext4_extent_header *leaf;\nstruct grub_ext4_extent *ext;\nint i;\nleaf = grub_ext4_find_leaf (data, buf,\n(struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\nfileblock);\nif (! leaf)\n{\ngrub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\nreturn -1;\n}\next = (struct grub_ext4_extent *) (leaf + 1);\nfor (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n{\nif (fileblock < grub_le_to_cpu32 (ext[i].block))\nbreak;\n}\nif (--i >= 0)\n{\nfileblock -= grub_le_to_cpu32 (ext[i].block);\nif (fileblock >= grub_le_to_cpu16 (ext[i].len))\nreturn 0;\nelse\n{\ngrub_disk_addr_t start;\nstart = grub_le_to_cpu16 (ext[i].start_hi);\nstart = (start << 32) + grub_le_to_cpu32 (ext[i].start);\nreturn fileblock + start;\n}\n}\nelse\n{\ngrub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\nreturn -1;\n}\n}\nif (fileblock < INDIRECT_BLOCKS) {\nblknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n} else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n{\ngrub_uint32_t *indir;\nindir = grub_malloc (blksz);\nif (! indir)\nreturn grub_errno;\nif (grub_disk_read (data->disk,\n((grub_disk_addr_t)\ngrub_le_to_cpu32 (inode->blocks.indir_block))\n<< log2_blksz,\n0, blksz, indir))\nreturn grub_errno;\nblknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\ngrub_free (indir);\n}\nelse if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n* (grub_disk_addr_t)(blksz / 4 + 1))\n{\nunsigned int perblock = blksz / 4;\nunsigned int rblock = fileblock - (INDIRECT_BLOCKS\n+ blksz / 4);\ngrub_uint32_t *indir;\nindir = grub_malloc (blksz);\nif (! indir)\nreturn grub_errno;\nif (grub_disk_read (data->disk,\n((grub_disk_addr_t)\ngrub_le_to_cpu32 (inode->blocks.double_indir_block))\n<< log2_blksz,\n0, blksz, indir))\nreturn grub_errno;\nif (grub_disk_read (data->disk,\n((grub_disk_addr_t)\ngrub_le_to_cpu32 (indir[rblock / perblock]))\n<< log2_blksz,\n0, blksz, indir))\nreturn grub_errno;\nblknr = grub_le_to_cpu32 (indir[rblock % perblock]);\ngrub_free (indir);\n}\nelse\n{\ngrub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\"ext2fs doesn't support triple indirect blocks\");\n}\nreturn blknr;\n}", "contrast": "grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\nstruct grub_ext2_data *data = node->data;\nstruct grub_ext2_inode *inode = &node->inode;\nint blknr = -1;\nunsigned int blksz = EXT2_BLOCK_SIZE (data);\nint log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\nif (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n{\nchar * buf = grub_malloc (EXT2_BLOCK_SIZE (data));\nif (!buf) {\nreturn -1;\n}\nstruct grub_ext4_extent_header *leaf;\nstruct grub_ext4_extent *ext;\nint i;\nleaf = grub_ext4_find_leaf (data, buf,\n(struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\nfileblock);\nif (! leaf)\n{\ngrub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\nfree (buf);\nreturn -1;\n}\next = (struct grub_ext4_extent *) (leaf + 1);\nfor (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n{\nif (fileblock < grub_le_to_cpu32 (ext[i].block))\nbreak;\n}\nif (--i >= 0)\n{\nfileblock -= grub_le_to_cpu32 (ext[i].block);\nif (fileblock >= grub_le_to_cpu16 (ext[i].len)) {\nfree (buf);\nreturn 0;\n} else\n{\ngrub_disk_addr_t start;\nstart = grub_le_to_cpu16 (ext[i].start_hi);\nstart = (start << 32) + grub_le_to_cpu32 (ext[i].start);\nfree (buf);\nreturn fileblock + start;\n}\n}\nelse\n{\ngrub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\nfree (buf);\nreturn -1;\n}\nfree (buf);\n}\nif (fileblock < INDIRECT_BLOCKS) {\nblknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n} else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n{\ngrub_uint32_t *indir;\nindir = grub_malloc (blksz);\nif (! indir) {\nreturn grub_errno;\n}\nif (grub_disk_read (data->disk,\n((grub_disk_addr_t)\ngrub_le_to_cpu32 (inode->blocks.indir_block))\n<< log2_blksz,\n0, blksz, indir)) {\nreturn grub_errno;\n}\nblknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\ngrub_free (indir);\n}\nelse if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n* (grub_disk_addr_t)(blksz / 4 + 1))\n{\nunsigned int perblock = blksz / 4;\nunsigned int rblock = fileblock - (INDIRECT_BLOCKS\n+ blksz / 4);\ngrub_uint32_t *indir;\nindir = grub_malloc (blksz);\nif (! indir) {\nreturn grub_errno;\n}\nif (grub_disk_read (data->disk,\n((grub_disk_addr_t)\ngrub_le_to_cpu32 (inode->blocks.double_indir_block))\n<< log2_blksz,\n0, blksz, indir)) {\nreturn grub_errno;\n}\nif (grub_disk_read (data->disk,\n((grub_disk_addr_t)\ngrub_le_to_cpu32 (indir[rblock / perblock]))\n<< log2_blksz,\n0, blksz, indir)) {\nreturn grub_errno;\n}\nblknr = grub_le_to_cpu32 (indir[rblock % perblock]);\ngrub_free (indir);\n}\nelse\n{\ngrub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\"ext2fs doesn't support triple indirect blocks\");\n}\nreturn blknr;\n}", "label": 0}
{"index": 177269, "code": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\nchar\nmagick[12];\nImage\n*image;\nint\nopcode,\noperand,\nstatus;\nMagickStatusType\nflags;\nMagickSizeType\nnumber_pixels;\nMemoryInfo\n*pixel_info;\nQuantum\nindex;\nregister ssize_t\nx;\nregister Quantum\n*q;\nregister ssize_t\ni;\nregister unsigned char\n*p;\nsize_t\nbits_per_pixel,\nmap_length,\nnumber_colormaps,\nnumber_planes,\nnumber_planes_filled,\none,\npixel_info_length;\nssize_t\ncount,\noffset,\ny;\nunsigned char\nbackground_color[256],\n*colormap,\npixel,\nplane,\n*pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\ndo\n{\nimage->page.x=ReadBlobLSBShort(image);\nimage->page.y=ReadBlobLSBShort(image);\nimage->columns=ReadBlobLSBShort(image);\nimage->rows=ReadBlobLSBShort(image);\nflags=(MagickStatusType) ReadBlobByte(image);\nimage->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\nnumber_planes=(size_t) ReadBlobByte(image);\nbits_per_pixel=(size_t) ReadBlobByte(image);\nnumber_colormaps=(size_t) ReadBlobByte(image);\nmap_length=(unsigned char) ReadBlobByte(image);\nif (map_length >= 22)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\none=1;\nmap_length=one << map_length;\nif ((number_planes == 0) || (number_planes == 2) ||\n((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n(image->columns == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (flags & 0x02)\n{\nfor (i=0; i < (ssize_t) number_planes; i++)\nbackground_color[i]=0;\n(void) ReadBlobByte(image);\n}\nelse\n{\np=background_color;\nfor (i=0; i < (ssize_t) number_planes; i++)\n*p++=(unsigned char) ReadBlobByte(image);\n}\nif ((number_planes & 0x01) == 0)\n(void) ReadBlobByte(image);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\ncolormap=(unsigned char *) NULL;\nif (number_colormaps != 0)\n{\ncolormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n3*map_length*sizeof(*colormap));\nif (colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nfor (i=0; i < (ssize_t) number_colormaps; i++)\nfor (x=0; x < (ssize_t) map_length; x++)\n*p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n}\nif ((flags & 0x08) != 0)\n{\nchar\n*comment;\nsize_t\nlength;\nlength=ReadBlobLSBShort(image);\nif (length != 0)\n{\ncomment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\nif (comment == (char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,length-1,(unsigned char *) comment);\ncomment[length-1]='\\0';\n(void) SetImageProperty(image,\"comment\",comment,exception);\ncomment=DestroyString(comment);\nif ((length & 0x01) == 0)\n(void) ReadBlobByte(image);\n}\n}\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nstatus=SetImageExtent(image,image->columns,image->rows,exception);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\nif (image->alpha_trait != UndefinedPixelTrait)\nnumber_planes++;\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nnumber_planes_filled=(number_planes % 2 == 0) ? number_planes :\nnumber_planes+1;\nif ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\nnumber_planes_filled))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info=AcquireVirtualMemory(image->columns,image->rows*\nMagickMax(number_planes_filled,4)*sizeof(*pixels));\nif (pixel_info == (MemoryInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info_length=image->columns*image->rows*\nMagickMax(number_planes_filled,4);\npixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\nif ((flags & 0x01) && !(flags & 0x02))\n{\nssize_t\nj;\np=pixels;\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nif (image->alpha_trait == UndefinedPixelTrait)\nfor (j=0; j < (ssize_t) number_planes; j++)\n*p++=background_color[j];\nelse\n{\nfor (j=0; j < (ssize_t) (number_planes-1); j++)\n*p++=background_color[j];\n*p++=0;\n}\n}\n}\nplane=0;\nx=0;\ny=0;\nopcode=ReadBlobByte(image);\ndo\n{\nswitch (opcode & 0x3f)\n{\ncase SkipLinesOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx=0;\ny+=operand;\nbreak;\n}\ncase SetColorOp:\n{\noperand=ReadBlobByte(image);\nplane=(unsigned char) operand;\nif (plane == 255)\nplane=(unsigned char) (number_planes-1);\nx=0;\nbreak;\n}\ncase SkipPixelsOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx+=operand;\nbreak;\n}\ncase ByteDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\noperand++;\nif ((offset < 0) ||\n(offset+((size_t) operand*number_planes) > pixel_info_length))\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\np=pixels+offset;\nfor (i=0; i < (ssize_t) operand; i++)\n{\npixel=(unsigned char) ReadBlobByte(image);\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nif (operand & 0x01)\n(void) ReadBlobByte(image);\nx+=operand;\nbreak;\n}\ncase RunDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\npixel=(unsigned char) ReadBlobByte(image);\n(void) ReadBlobByte(image);\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\noperand++;\nif ((offset < 0) ||\n(offset+((size_t) operand*number_planes) > pixel_info_length))\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\np=pixels+offset;\nfor (i=0; i < (ssize_t) operand; i++)\n{\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nx+=operand;\nbreak;\n}\ndefault:\nbreak;\n}\nopcode=ReadBlobByte(image);\n} while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\nif (number_colormaps != 0)\n{\nMagickStatusType\nmask;\nmask=(MagickStatusType) (map_length-1);\np=pixels;\nx=(ssize_t) number_planes;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nValidateColormapValue(image,*p & mask,&index,exception);\n*p=colormap[(ssize_t) index];\np++;\n}\nelse\nif ((number_planes >= 3) && (number_colormaps >= 3))\nfor (i=0; i < (ssize_t) number_pixels; i++)\nfor (x=0; x < (ssize_t) number_planes; x++)\n{\nValidateColormapValue(image,(size_t) (x*map_length+\n(*p & mask)),&index,exception);\n*p=colormap[(ssize_t) index];\np++;\n}\nif ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n{\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\n}\nif (number_planes >= 3)\n{\np=pixels;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(image,ScaleCharToQuantum(*p++),q);\nSetPixelGreen(image,ScaleCharToQuantum(*p++),q);\nSetPixelBlue(image,ScaleCharToQuantum(*p++),q);\nif (image->alpha_trait != UndefinedPixelTrait)\nSetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nelse\n{\nif (number_colormaps == 0)\nmap_length=256;\nif (AcquireImageColormap(image,map_length,exception) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=(MagickRealType)\nScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].green=(MagickRealType)\nScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].blue=(MagickRealType)\nScaleCharToQuantum((unsigned char) i);\n}\nelse\nif (number_colormaps > 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=(MagickRealType)\nScaleCharToQuantum(*p);\nimage->colormap[i].green=(MagickRealType)\nScaleCharToQuantum(*(p+map_length));\nimage->colormap[i].blue=(MagickRealType)\nScaleCharToQuantum(*(p+map_length*2));\np++;\n}\np=pixels;\nif (image->alpha_trait == UndefinedPixelTrait)\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelIndex(image,*p++,q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n(void) SyncImage(image,exception);\n}\nelse\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nValidateColormapValue(image,(ssize_t) *p++,&index,exception);\nSetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\nindex].red),q);\nValidateColormapValue(image,(ssize_t) *p++,&index,exception);\nSetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\nindex].green),q);\nValidateColormapValue(image,(ssize_t) *p++,&index,exception);\nSetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\nindex].blue),q);\nSetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\nq+=GetPixelChannels(image);\n}\nif (x < (ssize_t) image->columns)\nbreak;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nimage->colormap=(PixelInfo *) RelinquishMagickMemory(\nimage->colormap);\nimage->storage_class=DirectClass;\nimage->colors=0;\n}\n}\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\n(void) ReadBlobByte(image);\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n{\nAcquireNextImage(image_info,image,exception);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\nchar\nmagick[12];\nImage\n*image;\nint\nopcode,\noperand,\nstatus;\nMagickStatusType\nflags;\nMagickSizeType\nnumber_pixels;\nMemoryInfo\n*pixel_info;\nQuantum\nindex;\nregister ssize_t\nx;\nregister Quantum\n*q;\nregister ssize_t\ni;\nregister unsigned char\n*p;\nsize_t\nbits_per_pixel,\nmap_length,\nnumber_colormaps,\nnumber_planes,\nnumber_planes_filled,\none,\npixel_info_length;\nssize_t\ncount,\noffset,\ny;\nunsigned char\nbackground_color[256],\n*colormap,\npixel,\nplane,\n*pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\ndo\n{\nimage->page.x=ReadBlobLSBShort(image);\nimage->page.y=ReadBlobLSBShort(image);\nimage->columns=ReadBlobLSBShort(image);\nimage->rows=ReadBlobLSBShort(image);\nflags=(MagickStatusType) ReadBlobByte(image);\nimage->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\nnumber_planes=(size_t) ReadBlobByte(image);\nbits_per_pixel=(size_t) ReadBlobByte(image);\nnumber_colormaps=(size_t) ReadBlobByte(image);\nmap_length=(unsigned char) ReadBlobByte(image);\nif (map_length >= 22)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\none=1;\nmap_length=one << map_length;\nif ((number_planes == 0) || (number_planes == 2) ||\n((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n(image->columns == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (flags & 0x02)\n{\nfor (i=0; i < (ssize_t) number_planes; i++)\nbackground_color[i]=0;\n(void) ReadBlobByte(image);\n}\nelse\n{\np=background_color;\nfor (i=0; i < (ssize_t) number_planes; i++)\n*p++=(unsigned char) ReadBlobByte(image);\n}\nif ((number_planes & 0x01) == 0)\n(void) ReadBlobByte(image);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\ncolormap=(unsigned char *) NULL;\nif (number_colormaps != 0)\n{\ncolormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n3*map_length*sizeof(*colormap));\nif (colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nfor (i=0; i < (ssize_t) number_colormaps; i++)\nfor (x=0; x < (ssize_t) map_length; x++)\n*p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n}\nif ((flags & 0x08) != 0)\n{\nchar\n*comment;\nsize_t\nlength;\nlength=ReadBlobLSBShort(image);\nif (length != 0)\n{\ncomment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\nif (comment == (char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,length-1,(unsigned char *) comment);\ncomment[length-1]='\\0';\n(void) SetImageProperty(image,\"comment\",comment,exception);\ncomment=DestroyString(comment);\nif ((length & 0x01) == 0)\n(void) ReadBlobByte(image);\n}\n}\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nstatus=SetImageExtent(image,image->columns,image->rows,exception);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\nif (image->alpha_trait != UndefinedPixelTrait)\nnumber_planes++;\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nnumber_planes_filled=(number_planes % 2 == 0) ? number_planes :\nnumber_planes+1;\nif ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\nnumber_planes_filled))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info=AcquireVirtualMemory(image->columns,image->rows*\nMagickMax(number_planes_filled,4)*sizeof(*pixels));\nif (pixel_info == (MemoryInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info_length=image->columns*image->rows*\nMagickMax(number_planes_filled,4);\npixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n(void) ResetMagickMemory(pixels,0,pixel_info_length);\nif ((flags & 0x01) && !(flags & 0x02))\n{\nssize_t\nj;\np=pixels;\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nif (image->alpha_trait == UndefinedPixelTrait)\nfor (j=0; j < (ssize_t) number_planes; j++)\n*p++=background_color[j];\nelse\n{\nfor (j=0; j < (ssize_t) (number_planes-1); j++)\n*p++=background_color[j];\n*p++=0;\n}\n}\n}\nplane=0;\nx=0;\ny=0;\nopcode=ReadBlobByte(image);\ndo\n{\nswitch (opcode & 0x3f)\n{\ncase SkipLinesOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx=0;\ny+=operand;\nbreak;\n}\ncase SetColorOp:\n{\noperand=ReadBlobByte(image);\nplane=(unsigned char) operand;\nif (plane == 255)\nplane=(unsigned char) (number_planes-1);\nx=0;\nbreak;\n}\ncase SkipPixelsOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx+=operand;\nbreak;\n}\ncase ByteDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\noperand++;\nif ((offset < 0) ||\n(offset+((size_t) operand*number_planes) > pixel_info_length))\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\np=pixels+offset;\nfor (i=0; i < (ssize_t) operand; i++)\n{\npixel=(unsigned char) ReadBlobByte(image);\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nif (operand & 0x01)\n(void) ReadBlobByte(image);\nx+=operand;\nbreak;\n}\ncase RunDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\npixel=(unsigned char) ReadBlobByte(image);\n(void) ReadBlobByte(image);\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\noperand++;\nif ((offset < 0) ||\n(offset+((size_t) operand*number_planes) > pixel_info_length))\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\np=pixels+offset;\nfor (i=0; i < (ssize_t) operand; i++)\n{\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nx+=operand;\nbreak;\n}\ndefault:\nbreak;\n}\nopcode=ReadBlobByte(image);\n} while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\nif (number_colormaps != 0)\n{\nMagickStatusType\nmask;\nmask=(MagickStatusType) (map_length-1);\np=pixels;\nx=(ssize_t) number_planes;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nValidateColormapValue(image,*p & mask,&index,exception);\n*p=colormap[(ssize_t) index];\np++;\n}\nelse\nif ((number_planes >= 3) && (number_colormaps >= 3))\nfor (i=0; i < (ssize_t) number_pixels; i++)\nfor (x=0; x < (ssize_t) number_planes; x++)\n{\nValidateColormapValue(image,(size_t) (x*map_length+\n(*p & mask)),&index,exception);\n*p=colormap[(ssize_t) index];\np++;\n}\nif ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n{\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\n}\nif (number_planes >= 3)\n{\np=pixels;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(image,ScaleCharToQuantum(*p++),q);\nSetPixelGreen(image,ScaleCharToQuantum(*p++),q);\nSetPixelBlue(image,ScaleCharToQuantum(*p++),q);\nif (image->alpha_trait != UndefinedPixelTrait)\nSetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nelse\n{\nif (number_colormaps == 0)\nmap_length=256;\nif (AcquireImageColormap(image,map_length,exception) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=(MagickRealType)\nScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].green=(MagickRealType)\nScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].blue=(MagickRealType)\nScaleCharToQuantum((unsigned char) i);\n}\nelse\nif (number_colormaps > 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=(MagickRealType)\nScaleCharToQuantum(*p);\nimage->colormap[i].green=(MagickRealType)\nScaleCharToQuantum(*(p+map_length));\nimage->colormap[i].blue=(MagickRealType)\nScaleCharToQuantum(*(p+map_length*2));\np++;\n}\np=pixels;\nif (image->alpha_trait == UndefinedPixelTrait)\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelIndex(image,*p++,q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n(void) SyncImage(image,exception);\n}\nelse\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nValidateColormapValue(image,(ssize_t) *p++,&index,exception);\nSetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\nindex].red),q);\nValidateColormapValue(image,(ssize_t) *p++,&index,exception);\nSetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\nindex].green),q);\nValidateColormapValue(image,(ssize_t) *p++,&index,exception);\nSetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\nindex].blue),q);\nSetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\nq+=GetPixelChannels(image);\n}\nif (x < (ssize_t) image->columns)\nbreak;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nimage->colormap=(PixelInfo *) RelinquishMagickMemory(\nimage->colormap);\nimage->storage_class=DirectClass;\nimage->colors=0;\n}\n}\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\n(void) ReadBlobByte(image);\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n{\nAcquireNextImage(image_info,image,exception);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177275, "code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\nu16 offset = sizeof(struct ipv6hdr);\nstruct ipv6_opt_hdr *exthdr =\n(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\nunsigned int packet_len = skb_tail_pointer(skb) -\nskb_network_header(skb);\nint found_rhdr = 0;\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\nwhile (offset + 1 <= packet_len) {\nswitch (**nexthdr) {\ncase NEXTHDR_HOP:\nbreak;\ncase NEXTHDR_ROUTING:\nfound_rhdr = 1;\nbreak;\ncase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\nbreak;\n#endif\nif (found_rhdr)\nreturn offset;\nbreak;\ndefault:\nreturn offset;\n}\noffset += ipv6_optlen(exthdr);\n*nexthdr = &exthdr->nexthdr;\nexthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\noffset);\n}\nreturn offset;\n}", "contrast": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\nu16 offset = sizeof(struct ipv6hdr);\nunsigned int packet_len = skb_tail_pointer(skb) -\nskb_network_header(skb);\nint found_rhdr = 0;\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\nwhile (offset <= packet_len) {\nstruct ipv6_opt_hdr *exthdr;\nswitch (**nexthdr) {\ncase NEXTHDR_HOP:\nbreak;\ncase NEXTHDR_ROUTING:\nfound_rhdr = 1;\nbreak;\ncase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\nbreak;\n#endif\nif (found_rhdr)\nreturn offset;\nbreak;\ndefault:\nreturn offset;\n}\nif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\nreturn -EINVAL;\nexthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\noffset);\noffset += ipv6_optlen(exthdr);\n*nexthdr = &exthdr->nexthdr;\n}\nreturn -EINVAL;\n}", "label": 0}
{"index": 177307, "code": "static void svc_rdma_get_write_arrays(struct rpcrdma_msg *rmsgp,\nstruct rpcrdma_write_array **write,\nstruct rpcrdma_write_array **reply)\n{\n__be32 *p;\np = (__be32 *)&rmsgp->rm_body.rm_chunks[0];\nwhile (*p++ != xdr_zero)\np += 5;\nif (*p != xdr_zero) {\n*write = (struct rpcrdma_write_array *)p;\nwhile (*p++ != xdr_zero)\np += 1 + be32_to_cpu(*p) * 4;\n} else {\n*write = NULL;\np++;\n}\nif (*p != xdr_zero)\n*reply = (struct rpcrdma_write_array *)p;\nelse\n*reply = NULL;\n}", "contrast": "static void svc_rdma_get_write_arrays(struct rpcrdma_msg *rmsgp,\nstatic void svc_rdma_get_write_arrays(__be32 *rdma_argp,\n__be32 **write, __be32 **reply)\n{\n__be32 *p;\np = rdma_argp + rpcrdma_fixed_maxsz;\nwhile (*p++ != xdr_zero)\np += 5;\nif (*p != xdr_zero) {\n*write = p;\nwhile (*p++ != xdr_zero)\np += 1 + be32_to_cpu(*p) * 4;\n} else {\n*write = NULL;\np++;\n}\nif (*p != xdr_zero)\n*reply = p;\nelse\n*reply = NULL;\n}", "label": 0}
{"index": 177338, "code": "int yr_re_match(\nRE* re,\nconst char* target)\n{\nreturn yr_re_exec(\nre->code,\n(uint8_t*) target,\nstrlen(target),\nre->flags | RE_FLAGS_SCAN,\nNULL,\nNULL);\n}", "contrast": "int yr_re_match(\nRE* re,\nconst char* target)\n{\nreturn yr_re_exec(\nre->code,\n(uint8_t*) target,\nstrlen(target),\n0,\nre->flags | RE_FLAGS_SCAN,\nNULL,\nNULL);\n}", "label": 0}
{"index": 177339, "code": "int _yr_scan_verify_re_match(\nYR_SCAN_CONTEXT* context,\nYR_AC_MATCH* ac_match,\nuint8_t* data,\nsize_t data_size,\nsize_t data_base,\nsize_t offset)\n{\nCALLBACK_ARGS callback_args;\nRE_EXEC_FUNC exec;\nint forward_matches = -1;\nint backward_matches = -1;\nint flags = 0;\nif (STRING_IS_GREEDY_REGEXP(ac_match->string))\nflags |= RE_FLAGS_GREEDY;\nif (STRING_IS_NO_CASE(ac_match->string))\nflags |= RE_FLAGS_NO_CASE;\nif (STRING_IS_DOT_ALL(ac_match->string))\nflags |= RE_FLAGS_DOT_ALL;\nif (STRING_IS_FAST_REGEXP(ac_match->string))\nexec = yr_re_fast_exec;\nelse\nexec = yr_re_exec;\nif (STRING_IS_ASCII(ac_match->string))\n{\nforward_matches = exec(\nac_match->forward_code,\ndata + offset,\ndata_size - offset,\noffset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\nNULL,\nNULL);\n}\nif (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n{\nflags |= RE_FLAGS_WIDE;\nforward_matches = exec(\nac_match->forward_code,\ndata + offset,\ndata_size - offset,\noffset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\nNULL,\nNULL);\n}\nswitch(forward_matches)\n{\ncase -1:\nreturn ERROR_SUCCESS;\ncase -2:\nreturn ERROR_INSUFFICIENT_MEMORY;\ncase -3:\nreturn ERROR_TOO_MANY_MATCHES;\ncase -4:\nreturn ERROR_TOO_MANY_RE_FIBERS;\ncase -5:\nreturn ERROR_INTERNAL_FATAL_ERROR;\n}\nif (forward_matches == 0 && ac_match->backward_code == NULL)\nreturn ERROR_SUCCESS;\ncallback_args.string = ac_match->string;\ncallback_args.context = context;\ncallback_args.data = data;\ncallback_args.data_size = data_size;\ncallback_args.data_base = data_base;\ncallback_args.forward_matches = forward_matches;\ncallback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\nif (ac_match->backward_code != NULL)\n{\nbackward_matches = exec(\nac_match->backward_code,\ndata + offset,\noffset,\nflags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n_yr_scan_match_callback,\n(void*) &callback_args);\nswitch(backward_matches)\n{\ncase -2:\nreturn ERROR_INSUFFICIENT_MEMORY;\ncase -3:\nreturn ERROR_TOO_MANY_MATCHES;\ncase -4:\nreturn ERROR_TOO_MANY_RE_FIBERS;\ncase -5:\nreturn ERROR_INTERNAL_FATAL_ERROR;\n}\n}\nelse\n{\nFAIL_ON_ERROR(_yr_scan_match_callback(\ndata + offset, 0, flags, &callback_args));\n}\nreturn ERROR_SUCCESS;\n}", "contrast": "int _yr_scan_verify_re_match(\nYR_SCAN_CONTEXT* context,\nYR_AC_MATCH* ac_match,\nuint8_t* data,\nsize_t data_size,\nsize_t data_base,\nsize_t offset)\n{\nCALLBACK_ARGS callback_args;\nRE_EXEC_FUNC exec;\nint forward_matches = -1;\nint backward_matches = -1;\nint flags = 0;\nif (STRING_IS_GREEDY_REGEXP(ac_match->string))\nflags |= RE_FLAGS_GREEDY;\nif (STRING_IS_NO_CASE(ac_match->string))\nflags |= RE_FLAGS_NO_CASE;\nif (STRING_IS_DOT_ALL(ac_match->string))\nflags |= RE_FLAGS_DOT_ALL;\nif (STRING_IS_FAST_REGEXP(ac_match->string))\nexec = yr_re_fast_exec;\nelse\nexec = yr_re_exec;\nif (STRING_IS_ASCII(ac_match->string))\n{\nforward_matches = exec(\nac_match->forward_code,\ndata + offset,\ndata_size - offset,\noffset,\nflags,\nNULL,\nNULL);\n}\nif (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n{\nflags |= RE_FLAGS_WIDE;\nforward_matches = exec(\nac_match->forward_code,\ndata + offset,\ndata_size - offset,\noffset,\nflags,\nNULL,\nNULL);\n}\nswitch(forward_matches)\n{\ncase -1:\nreturn ERROR_SUCCESS;\ncase -2:\nreturn ERROR_INSUFFICIENT_MEMORY;\ncase -3:\nreturn ERROR_TOO_MANY_MATCHES;\ncase -4:\nreturn ERROR_TOO_MANY_RE_FIBERS;\ncase -5:\nreturn ERROR_INTERNAL_FATAL_ERROR;\n}\nif (forward_matches == 0 && ac_match->backward_code == NULL)\nreturn ERROR_SUCCESS;\ncallback_args.string = ac_match->string;\ncallback_args.context = context;\ncallback_args.data = data;\ncallback_args.data_size = data_size;\ncallback_args.data_base = data_base;\ncallback_args.forward_matches = forward_matches;\ncallback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\nif (ac_match->backward_code != NULL)\n{\nbackward_matches = exec(\nac_match->backward_code,\ndata + offset,\ndata_size - offset,\noffset,\nflags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n_yr_scan_match_callback,\n(void*) &callback_args);\nswitch(backward_matches)\n{\ncase -2:\nreturn ERROR_INSUFFICIENT_MEMORY;\ncase -3:\nreturn ERROR_TOO_MANY_MATCHES;\ncase -4:\nreturn ERROR_TOO_MANY_RE_FIBERS;\ncase -5:\nreturn ERROR_INTERNAL_FATAL_ERROR;\n}\n}\nelse\n{\nFAIL_ON_ERROR(_yr_scan_match_callback(\ndata + offset, 0, flags, &callback_args));\n}\nreturn ERROR_SUCCESS;\n}", "label": 0}
{"index": 177342, "code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\nstruct cp2112_device *dev = gpiochip_get_data(chip);\nstruct hid_device *hdev = dev->hdev;\nu8 *buf = dev->in_out_buffer;\nint ret;\nmutex_lock(&dev->lock);\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\nCP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_GET_REPORT);\nif (ret != CP2112_GPIO_CONFIG_LENGTH) {\nhid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\ngoto exit;\n}\nbuf[1] &= ~(1 << offset);\nbuf[2] = gpio_push_pull;\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\nCP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_SET_REPORT);\nif (ret < 0) {\nhid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\ngoto exit;\n}\nret = 0;\nexit:\nmutex_unlock(&dev->lock);\nreturn ret <= 0 ? ret : -EIO;\n}", "contrast": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\nstruct cp2112_device *dev = gpiochip_get_data(chip);\nstruct hid_device *hdev = dev->hdev;\nu8 *buf = dev->in_out_buffer;\nint ret;\nmutex_lock(&dev->lock);\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\nCP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_GET_REPORT);\nif (ret != CP2112_GPIO_CONFIG_LENGTH) {\nhid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\ngoto exit;\n}\nbuf[1] &= ~(1 << offset);\nbuf[2] = gpio_push_pull;\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\nCP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_SET_REPORT);\nif (ret < 0) {\nhid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\ngoto exit;\n}\nret = 0;\nexit:\nmutex_unlock(&dev->lock);\nreturn ret < 0 ? ret : -EIO;\n}", "label": 0}
{"index": 177345, "code": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\nstruct cp2112_device *dev = gpiochip_get_data(chip);\nstruct hid_device *hdev = dev->hdev;\nu8 *buf = dev->in_out_buffer;\nunsigned long flags;\nint ret;\nspin_lock_irqsave(&dev->lock, flags);\nret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\nCP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_GET_REPORT);\nif (ret != CP2112_GPIO_GET_LENGTH) {\nhid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\nret = ret < 0 ? ret : -EIO;\ngoto exit;\n}\nret = buf[1];\nexit:\nspin_unlock_irqrestore(&dev->lock, flags);\nreturn ret;\n}", "contrast": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\nstruct cp2112_device *dev = gpiochip_get_data(chip);\nstruct hid_device *hdev = dev->hdev;\nu8 *buf = dev->in_out_buffer;\nint ret;\nmutex_lock(&dev->lock);\nret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\nCP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_GET_REPORT);\nif (ret != CP2112_GPIO_GET_LENGTH) {\nhid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\nret = ret < 0 ? ret : -EIO;\ngoto exit;\n}\nret = buf[1];\nexit:\nmutex_unlock(&dev->lock);\nreturn ret;\n}", "label": 0}
{"index": 177346, "code": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\nstruct cp2112_device *dev = gpiochip_get_data(chip);\nstruct hid_device *hdev = dev->hdev;\nu8 *buf = dev->in_out_buffer;\nunsigned long flags;\nint ret;\nspin_lock_irqsave(&dev->lock, flags);\nbuf[0] = CP2112_GPIO_SET;\nbuf[1] = value ? 0xff : 0;\nbuf[2] = 1 << offset;\nret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\nCP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_SET_REPORT);\nif (ret < 0)\nhid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\nspin_unlock_irqrestore(&dev->lock, flags);\n}", "contrast": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\nstruct cp2112_device *dev = gpiochip_get_data(chip);\nstruct hid_device *hdev = dev->hdev;\nu8 *buf = dev->in_out_buffer;\nint ret;\nmutex_lock(&dev->lock);\nbuf[0] = CP2112_GPIO_SET;\nbuf[1] = value ? 0xff : 0;\nbuf[2] = 1 << offset;\nret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\nCP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\nHID_REQ_SET_REPORT);\nif (ret < 0)\nhid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\nmutex_unlock(&dev->lock);\n}", "label": 0}
{"index": 177347, "code": "static int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\nstruct cp2112_device *dev;\nu8 buf[3];\nstruct cp2112_smbus_config_report config;\nint ret;\ndev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\nif (!dev)\nreturn -ENOMEM;\ndev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\nGFP_KERNEL);\nif (!dev->in_out_buffer)\nreturn -ENOMEM;\nspin_lock_init(&dev->lock);\nret = hid_parse(hdev);\nif (ret) {\nhid_err(hdev, \"parse failed\\n\");\nreturn ret;\n}\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\nif (ret) {\nhid_err(hdev, \"hw start failed\\n\");\nreturn ret;\n}\nret = hid_hw_open(hdev);\nif (ret) {\nhid_err(hdev, \"hw open failed\\n\");\ngoto err_hid_stop;\n}\nret = hid_hw_power(hdev, PM_HINT_FULLON);\nif (ret < 0) {\nhid_err(hdev, \"power management error: %d\\n\", ret);\ngoto err_hid_close;\n}\nret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\nHID_FEATURE_REPORT);\nif (ret != sizeof(buf)) {\nhid_err(hdev, \"error requesting version\\n\");\nif (ret >= 0)\nret = -EIO;\ngoto err_power_normal;\n}\nhid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\nbuf[1], buf[2]);\nret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\nsizeof(config), HID_FEATURE_REPORT);\nif (ret != sizeof(config)) {\nhid_err(hdev, \"error requesting SMBus config\\n\");\nif (ret >= 0)\nret = -EIO;\ngoto err_power_normal;\n}\nconfig.retry_time = cpu_to_be16(1);\nret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\nHID_FEATURE_REPORT);\nif (ret != sizeof(config)) {\nhid_err(hdev, \"error setting SMBus config\\n\");\nif (ret >= 0)\nret = -EIO;\ngoto err_power_normal;\n}\nhid_set_drvdata(hdev, (void *)dev);\ndev->hdev\t\t= hdev;\ndev->adap.owner\t\t= THIS_MODULE;\ndev->adap.class\t\t= I2C_CLASS_HWMON;\ndev->adap.algo\t\t= &smbus_algorithm;\ndev->adap.algo_data\t= dev;\ndev->adap.dev.parent\t= &hdev->dev;\nsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\"CP2112 SMBus Bridge on hiddev%d\", hdev->minor);\ndev->hwversion = buf[2];\ninit_waitqueue_head(&dev->wait);\nhid_device_io_start(hdev);\nret = i2c_add_adapter(&dev->adap);\nhid_device_io_stop(hdev);\nif (ret) {\nhid_err(hdev, \"error registering i2c adapter\\n\");\ngoto err_power_normal;\n}\nhid_dbg(hdev, \"adapter registered\\n\");\ndev->gc.label\t\t\t= \"cp2112_gpio\";\ndev->gc.direction_input\t\t= cp2112_gpio_direction_input;\ndev->gc.direction_output\t= cp2112_gpio_direction_output;\ndev->gc.set\t\t\t= cp2112_gpio_set;\ndev->gc.get\t\t\t= cp2112_gpio_get;\ndev->gc.base\t\t\t= -1;\ndev->gc.ngpio\t\t\t= 8;\ndev->gc.can_sleep\t\t= 1;\ndev->gc.parent\t\t\t= &hdev->dev;\nret = gpiochip_add_data(&dev->gc, dev);\nif (ret < 0) {\nhid_err(hdev, \"error registering gpio chip\\n\");\ngoto err_free_i2c;\n}\nret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\nif (ret < 0) {\nhid_err(hdev, \"error creating sysfs attrs\\n\");\ngoto err_gpiochip_remove;\n}\nchmod_sysfs_attrs(hdev);\nhid_hw_power(hdev, PM_HINT_NORMAL);\nret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0,\nhandle_simple_irq, IRQ_TYPE_NONE);\nif (ret) {\ndev_err(dev->gc.parent, \"failed to add IRQ chip\\n\");\ngoto err_sysfs_remove;\n}\nreturn ret;\nerr_sysfs_remove:\nsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\nerr_gpiochip_remove:\ngpiochip_remove(&dev->gc);\nerr_free_i2c:\ni2c_del_adapter(&dev->adap);\nerr_power_normal:\nhid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\nhid_hw_close(hdev);\nerr_hid_stop:\nhid_hw_stop(hdev);\nreturn ret;\n}", "contrast": "static int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\nstruct cp2112_device *dev;\nu8 buf[3];\nstruct cp2112_smbus_config_report config;\nint ret;\ndev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\nif (!dev)\nreturn -ENOMEM;\ndev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\nGFP_KERNEL);\nif (!dev->in_out_buffer)\nreturn -ENOMEM;\nmutex_init(&dev->lock);\nret = hid_parse(hdev);\nif (ret) {\nhid_err(hdev, \"parse failed\\n\");\nreturn ret;\n}\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\nif (ret) {\nhid_err(hdev, \"hw start failed\\n\");\nreturn ret;\n}\nret = hid_hw_open(hdev);\nif (ret) {\nhid_err(hdev, \"hw open failed\\n\");\ngoto err_hid_stop;\n}\nret = hid_hw_power(hdev, PM_HINT_FULLON);\nif (ret < 0) {\nhid_err(hdev, \"power management error: %d\\n\", ret);\ngoto err_hid_close;\n}\nret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\nHID_FEATURE_REPORT);\nif (ret != sizeof(buf)) {\nhid_err(hdev, \"error requesting version\\n\");\nif (ret >= 0)\nret = -EIO;\ngoto err_power_normal;\n}\nhid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\nbuf[1], buf[2]);\nret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\nsizeof(config), HID_FEATURE_REPORT);\nif (ret != sizeof(config)) {\nhid_err(hdev, \"error requesting SMBus config\\n\");\nif (ret >= 0)\nret = -EIO;\ngoto err_power_normal;\n}\nconfig.retry_time = cpu_to_be16(1);\nret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\nHID_FEATURE_REPORT);\nif (ret != sizeof(config)) {\nhid_err(hdev, \"error setting SMBus config\\n\");\nif (ret >= 0)\nret = -EIO;\ngoto err_power_normal;\n}\nhid_set_drvdata(hdev, (void *)dev);\ndev->hdev\t\t= hdev;\ndev->adap.owner\t\t= THIS_MODULE;\ndev->adap.class\t\t= I2C_CLASS_HWMON;\ndev->adap.algo\t\t= &smbus_algorithm;\ndev->adap.algo_data\t= dev;\ndev->adap.dev.parent\t= &hdev->dev;\nsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\"CP2112 SMBus Bridge on hiddev%d\", hdev->minor);\ndev->hwversion = buf[2];\ninit_waitqueue_head(&dev->wait);\nhid_device_io_start(hdev);\nret = i2c_add_adapter(&dev->adap);\nhid_device_io_stop(hdev);\nif (ret) {\nhid_err(hdev, \"error registering i2c adapter\\n\");\ngoto err_power_normal;\n}\nhid_dbg(hdev, \"adapter registered\\n\");\ndev->gc.label\t\t\t= \"cp2112_gpio\";\ndev->gc.direction_input\t\t= cp2112_gpio_direction_input;\ndev->gc.direction_output\t= cp2112_gpio_direction_output;\ndev->gc.set\t\t\t= cp2112_gpio_set;\ndev->gc.get\t\t\t= cp2112_gpio_get;\ndev->gc.base\t\t\t= -1;\ndev->gc.ngpio\t\t\t= 8;\ndev->gc.can_sleep\t\t= 1;\ndev->gc.parent\t\t\t= &hdev->dev;\nret = gpiochip_add_data(&dev->gc, dev);\nif (ret < 0) {\nhid_err(hdev, \"error registering gpio chip\\n\");\ngoto err_free_i2c;\n}\nret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\nif (ret < 0) {\nhid_err(hdev, \"error creating sysfs attrs\\n\");\ngoto err_gpiochip_remove;\n}\nchmod_sysfs_attrs(hdev);\nhid_hw_power(hdev, PM_HINT_NORMAL);\nret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0,\nhandle_simple_irq, IRQ_TYPE_NONE);\nif (ret) {\ndev_err(dev->gc.parent, \"failed to add IRQ chip\\n\");\ngoto err_sysfs_remove;\n}\nreturn ret;\nerr_sysfs_remove:\nsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\nerr_gpiochip_remove:\ngpiochip_remove(&dev->gc);\nerr_free_i2c:\ni2c_del_adapter(&dev->adap);\nerr_power_normal:\nhid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\nhid_hw_close(hdev);\nerr_hid_stop:\nhid_hw_stop(hdev);\nreturn ret;\n}", "label": 0}
{"index": 177349, "code": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\nreturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\nRTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\nindx, 0, data, size, 500);\n}", "contrast": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\nvoid *buf;\nint ret;\nbuf = kmalloc(size, GFP_NOIO);\nif (!buf)\nreturn -ENOMEM;\nret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\nRTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\nindx, 0, buf, size, 500);\nif (ret > 0 && ret <= size)\nmemcpy(data, buf, ret);\nkfree(buf);\nreturn ret;\n}", "label": 0}
{"index": 177357, "code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\nconst char *name = d->name;\nstruct device dev = d->udev->dev;\ndev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\nintf->cur_altsetting->desc.bInterfaceNumber);\nif (d->props->exit)\nd->props->exit(d);\ndvb_usbv2_exit(d);\ndev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\nKBUILD_MODNAME, name);\n}", "contrast": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\nconst char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);\nconst char *drvname = d->name;\ndev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\nintf->cur_altsetting->desc.bInterfaceNumber);\nif (d->props->exit)\nd->props->exit(d);\ndvb_usbv2_exit(d);\npr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\",\nKBUILD_MODNAME, drvname, devname);\nkfree(devname);\n}", "label": 0}
{"index": 177365, "code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\nstruct hexline *hx;\nu8 reset;\nint ret,pos=0;\nhx = kmalloc(sizeof(*hx), GFP_KERNEL);\nif (!hx)\nreturn -ENOMEM;\nreset = 1;\nif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\nerr(\"could not stop the USB controller CPU.\");\nwhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\ndeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\nret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\nif (ret != hx->len) {\nerr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\nret, hx->len);\nret = -EINVAL;\nbreak;\n}\n}\nif (ret < 0) {\nerr(\"firmware download failed at %d with %d\",pos,ret);\nkfree(hx);\nreturn ret;\n}\nif (ret == 0) {\nreset = 0;\nif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\nerr(\"could not restart the USB controller CPU.\");\nret = -EINVAL;\n}\n} else\nret = -EIO;\nkfree(hx);\nreturn ret;\n}", "contrast": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\nstruct hexline *hx;\nu8 *buf;\nint ret, pos = 0;\nu16 cpu_cs_register = cypress[type].cpu_cs_register;\nbuf = kmalloc(sizeof(*hx), GFP_KERNEL);\nif (!buf)\nreturn -ENOMEM;\nhx = (struct hexline *)buf;\nbuf[0] = 1;\nif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)\nerr(\"could not stop the USB controller CPU.\");\nwhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\ndeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\nret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\nif (ret != hx->len) {\nerr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\nret, hx->len);\nret = -EINVAL;\nbreak;\n}\n}\nif (ret < 0) {\nerr(\"firmware download failed at %d with %d\",pos,ret);\nkfree(buf);\nreturn ret;\n}\nif (ret == 0) {\nbuf[0] = 0;\nif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {\nerr(\"could not restart the USB controller CPU.\");\nret = -EINVAL;\n}\n} else\nret = -EIO;\nkfree(buf);\nreturn ret;\n}", "label": 0}
{"index": 177374, "code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\nstruct nfsd_writeargs *args)\n{\nunsigned int len, hdr, dlen;\nstruct kvec *head = rqstp->rq_arg.head;\nint v;\np = decode_fh(p, &args->fh);\nif (!p)\nreturn 0;\np++;\nargs->offset = ntohl(*p++);\np++;\nlen = args->len = ntohl(*p++);\nif (len > NFSSVC_MAXBLKSIZE_V2)\nreturn 0;\nhdr = (void*)p - head->iov_base;\ndlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\nif (dlen < XDR_QUADLEN(len)*4)\nreturn 0;\nrqstp->rq_vec[0].iov_base = (void*)p;\nrqstp->rq_vec[0].iov_len = head->iov_len - hdr;\nv = 0;\nwhile (len > rqstp->rq_vec[v].iov_len) {\nlen -= rqstp->rq_vec[v].iov_len;\nv++;\nrqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\nrqstp->rq_vec[v].iov_len = PAGE_SIZE;\n}\nrqstp->rq_vec[v].iov_len = len;\nargs->vlen = v + 1;\nreturn 1;\n}", "contrast": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\nstruct nfsd_writeargs *args)\n{\nunsigned int len, hdr, dlen;\nstruct kvec *head = rqstp->rq_arg.head;\nint v;\np = decode_fh(p, &args->fh);\nif (!p)\nreturn 0;\np++;\nargs->offset = ntohl(*p++);\np++;\nlen = args->len = ntohl(*p++);\nif (len > NFSSVC_MAXBLKSIZE_V2)\nreturn 0;\nhdr = (void*)p - head->iov_base;\nif (hdr > head->iov_len)\nreturn 0;\ndlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\nif (dlen < XDR_QUADLEN(len)*4)\nreturn 0;\nrqstp->rq_vec[0].iov_base = (void*)p;\nrqstp->rq_vec[0].iov_len = head->iov_len - hdr;\nv = 0;\nwhile (len > rqstp->rq_vec[v].iov_len) {\nlen -= rqstp->rq_vec[v].iov_len;\nv++;\nrqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\nrqstp->rq_vec[v].iov_len = PAGE_SIZE;\n}\nrqstp->rq_vec[v].iov_len = len;\nargs->vlen = v + 1;\nreturn 1;\n}", "label": 0}
{"index": 177379, "code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\nconst uint8_t *data_end)\n{\nz_stream zstream;\nunsigned char *buf;\nunsigned buf_size;\nint ret;\nzstream.zalloc = ff_png_zalloc;\nzstream.zfree  = ff_png_zfree;\nzstream.opaque = NULL;\nif (inflateInit(&zstream) != Z_OK)\nreturn AVERROR_EXTERNAL;\nzstream.next_in  = (unsigned char *)data;\nzstream.avail_in = data_end - data;\nav_bprint_init(bp, 0, -1);\nwhile (zstream.avail_in > 0) {\nav_bprint_get_buffer(bp, 1, &buf, &buf_size);\nif (!buf_size) {\nret = AVERROR(ENOMEM);\ngoto fail;\n}\nzstream.next_out  = buf;\nzstream.avail_out = buf_size;\nret = inflate(&zstream, Z_PARTIAL_FLUSH);\nif (ret != Z_OK && ret != Z_STREAM_END) {\nret = AVERROR_EXTERNAL;\ngoto fail;\n}\nbp->len += zstream.next_out - buf;\nif (ret == Z_STREAM_END)\nbreak;\n}\ninflateEnd(&zstream);\nbp->str[bp->len] = 0;\nreturn 0;\nfail:\ninflateEnd(&zstream);\nav_bprint_finalize(bp, NULL);\nreturn ret;\n}", "contrast": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\nconst uint8_t *data_end)\n{\nz_stream zstream;\nunsigned char *buf;\nunsigned buf_size;\nint ret;\nzstream.zalloc = ff_png_zalloc;\nzstream.zfree  = ff_png_zfree;\nzstream.opaque = NULL;\nif (inflateInit(&zstream) != Z_OK)\nreturn AVERROR_EXTERNAL;\nzstream.next_in  = (unsigned char *)data;\nzstream.avail_in = data_end - data;\nav_bprint_init(bp, 0, -1);\nwhile (zstream.avail_in > 0) {\nav_bprint_get_buffer(bp, 2, &buf, &buf_size);\nif (buf_size < 2) {\nret = AVERROR(ENOMEM);\ngoto fail;\n}\nzstream.next_out  = buf;\nzstream.avail_out = buf_size - 1;\nret = inflate(&zstream, Z_PARTIAL_FLUSH);\nif (ret != Z_OK && ret != Z_STREAM_END) {\nret = AVERROR_EXTERNAL;\ngoto fail;\n}\nbp->len += zstream.next_out - buf;\nif (ret == Z_STREAM_END)\nbreak;\n}\ninflateEnd(&zstream);\nbp->str[bp->len] = 0;\nreturn 0;\nfail:\ninflateEnd(&zstream);\nav_bprint_finalize(bp, NULL);\nreturn ret;\n}", "label": 0}
{"index": 177394, "code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\nstruct dentry *new_dir, const char *new_name)\n{\nint error;\nstruct dentry *dentry = NULL, *trap;\nconst char *old_name;\ntrap = lock_rename(new_dir, old_dir);\nif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\ngoto exit;\nif (d_really_is_negative(old_dentry) || old_dentry == trap ||\nd_mountpoint(old_dentry))\ngoto exit;\ndentry = lookup_one_len(new_name, new_dir, strlen(new_name));\nif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\ngoto exit;\nold_name = fsnotify_oldname_init(old_dentry->d_name.name);\nerror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\ndentry, 0);\nif (error) {\nfsnotify_oldname_free(old_name);\ngoto exit;\n}\nd_move(old_dentry, dentry);\nfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\nd_is_dir(old_dentry),\nNULL, old_dentry);\nfsnotify_oldname_free(old_name);\nunlock_rename(new_dir, old_dir);\ndput(dentry);\nreturn old_dentry;\nexit:\nif (dentry && !IS_ERR(dentry))\ndput(dentry);\nunlock_rename(new_dir, old_dir);\nreturn NULL;\n}", "contrast": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\nstruct dentry *new_dir, const char *new_name)\n{\nint error;\nstruct dentry *dentry = NULL, *trap;\nstruct name_snapshot old_name;\ntrap = lock_rename(new_dir, old_dir);\nif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\ngoto exit;\nif (d_really_is_negative(old_dentry) || old_dentry == trap ||\nd_mountpoint(old_dentry))\ngoto exit;\ndentry = lookup_one_len(new_name, new_dir, strlen(new_name));\nif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\ngoto exit;\ntake_dentry_name_snapshot(&old_name, old_dentry);\nerror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\ndentry, 0);\nif (error) {\nrelease_dentry_name_snapshot(&old_name);\ngoto exit;\n}\nd_move(old_dentry, dentry);\nfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\nd_is_dir(old_dentry),\nNULL, old_dentry);\nrelease_dentry_name_snapshot(&old_name);\nunlock_rename(new_dir, old_dir);\ndput(dentry);\nreturn old_dentry;\nexit:\nif (dentry && !IS_ERR(dentry))\ndput(dentry);\nunlock_rename(new_dir, old_dir);\nreturn NULL;\n}", "label": 0}
{"index": 177398, "code": "static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )\n{\nTPM_RC rval;\nTPM2B_ENCRYPTED_SECRET key;\nchar label[] = \"ATH\";\nUINT16 bytes;\nint i;\nkey.t.size = 0;\nif( session->nonceOlder.t.size == 0 )\n{\nsession->nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );\nfor( i = 0; i < session->nonceOlder.t.size; i++ )\nsession->nonceOlder.t.buffer[i] = 0;\n}\nsession->nonceNewer.t.size = session->nonceOlder.t.size;\nrval = Tss2_Sys_StartAuthSession( sapi_context, session->tpmKey, session->bind, 0,\n&( session->nonceOlder ), &( session->encryptedSalt ), session->sessionType,\n&( session->symmetric ), session->authHash, &( session->sessionHandle ),\n&( session->nonceNewer ), 0 );\nif( rval == TPM_RC_SUCCESS )\n{\nif( session->tpmKey == TPM_RH_NULL )\nsession->salt.t.size = 0;\nif( session->bind == TPM_RH_NULL )\nsession->authValueBind.t.size = 0;\nif( session->tpmKey == TPM_RH_NULL && session->bind == TPM_RH_NULL )\n{\nsession->sessionKey.b.size = 0;\n}\nelse\n{\nbool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->authValueBind.b ) );\nif (!result)\n{\nreturn TSS2_SYS_RC_BAD_VALUE;\n}\nresult = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->salt.b ) );\nif (!result)\n{\nreturn TSS2_SYS_RC_BAD_VALUE;\n}\nbytes = GetDigestSize( session->authHash );\nif( key.t.size == 0 )\n{\nsession->sessionKey.t.size = 0;\n}\nelse\n{\nrval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n&( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n}\nif( rval != TPM_RC_SUCCESS )\n{\nreturn( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n}\n}\nsession->nonceTpmDecrypt.b.size = 0;\nsession->nonceTpmEncrypt.b.size = 0;\nsession->nvNameChanged = 0;\n}\nreturn rval;\n}", "contrast": "static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )\n{\nTPM_RC rval;\nTPM2B_ENCRYPTED_SECRET key;\nchar label[] = \"ATH\";\nUINT16 bytes;\nint i;\nkey.t.size = 0;\nif( session->nonceOlder.t.size == 0 )\n{\nsession->nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );\nfor( i = 0; i < session->nonceOlder.t.size; i++ )\nsession->nonceOlder.t.buffer[i] = 0;\n}\nsession->nonceNewer.t.size = session->nonceOlder.t.size;\nrval = Tss2_Sys_StartAuthSession( sapi_context, session->tpmKey, session->bind, 0,\n&( session->nonceOlder ), &( session->encryptedSalt ), session->sessionType,\n&( session->symmetric ), session->authHash, &( session->sessionHandle ),\n&( session->nonceNewer ), 0 );\nif( rval == TPM_RC_SUCCESS )\n{\nif( session->tpmKey == TPM_RH_NULL )\nsession->salt.t.size = 0;\nif( session->bind == TPM_RH_NULL )\nsession->authValueBind.t.size = 0;\nif( session->tpmKey == TPM_RH_NULL && session->bind == TPM_RH_NULL )\n{\nsession->sessionKey.b.size = 0;\n}\nelse\n{\nbool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->authValueBind.b ) );\nif (!result)\n{\nreturn TSS2_SYS_RC_BAD_VALUE;\n}\nresult = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->salt.b ) );\nif (!result)\n{\nreturn TSS2_SYS_RC_BAD_VALUE;\n}\nbytes = GetDigestSize( session->authHash );\nif( key.t.size == 0 )\n{\nsession->sessionKey.t.size = 0;\n}\nelse\n{\nrval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n&( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n}\nif( rval != TPM_RC_SUCCESS )\n{\nreturn( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n}\n}\nsession->nonceTpmDecrypt.b.size = 0;\nsession->nonceTpmEncrypt.b.size = 0;\nsession->nvNameChanged = 0;\n}\nreturn rval;\n}", "label": 0}
{"index": 177399, "code": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\nFD_t wfd = NULL;\nint rc = 0;\n{\nmode_t old_umask = umask(0577);\nwfd = Fopen(dest, \"w.ufdio\");\numask(old_umask);\n}\nif (Ferror(wfd)) {\nrc = RPMERR_OPEN_FAILED;\ngoto exit;\n}\nif (!nocontent)\nrc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\nif (wfd) {\nint myerrno = errno;\nFclose(wfd);\nerrno = myerrno;\n}\nreturn rc;\n}", "contrast": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\nstatic int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)\n{\nFD_t wfd = NULL;\nint rc = 0;\n{\nmode_t old_umask = umask(0577);\nwfd = Fopen(dest, exclusive ? \"wx.ufdio\" : \"a.ufdio\");\numask(old_umask);\nif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {\nrc = RPMERR_OPEN_FAILED;\ngoto exit;\n}\n}\nif (Ferror(wfd)) {\nrc = RPMERR_OPEN_FAILED;\ngoto exit;\n}\nif (!nocontent)\nrc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\nif (wfd) {\nint myerrno = errno;\nFclose(wfd);\nerrno = myerrno;\n}\nreturn rc;\n}", "label": 0}
{"index": 177410, "code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\nstruct fscrypt_info *ci = inode->i_crypt_info;\nif (!ci ||\n(ci->ci_keyring_key &&\n(ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n(1 << KEY_FLAG_REVOKED) |\n(1 << KEY_FLAG_DEAD)))))\nreturn fscrypt_get_crypt_info(inode);\nreturn 0;\n}", "contrast": "int fscrypt_get_encryption_info(struct inode *inode)", "label": 0}
{"index": 177416, "code": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\nunsigned int *rsize)\n{\nunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\nunsigned int i;\nif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\nreturn rdesc;\nfor (i = 0; i < *rsize - 4; i++)\nif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\nrdesc[i] = 0x19;\nrdesc[i + 2] = 0x29;\nswap(rdesc[i + 3], rdesc[i + 1]);\n}\nreturn rdesc;\n}", "contrast": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\nunsigned int *rsize)\n{\nunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\nunsigned int i;\nif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\nreturn rdesc;\nif (*rsize < 4)\nreturn rdesc;\nfor (i = 0; i < *rsize - 4; i++)\nif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\nrdesc[i] = 0x19;\nrdesc[i + 2] = 0x29;\nswap(rdesc[i + 3], rdesc[i + 1]);\n}\nreturn rdesc;\n}", "label": 0}
{"index": 177417, "code": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\nchar *colon;\nchar *host = NULL;\n#ifdef HAVE_IPV6\nchar *p;\nif (*(str) == '[' && str_len > 1) {\np = memchr(str + 1, ']', str_len - 2);\nif (!p || *(p + 1) != ':') {\nif (get_err) {\n*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n}\nreturn NULL;\n}\n*portno = atoi(p + 2);\nreturn estrndup(str + 1, p - str - 1);\n}\n#endif\nif (str_len) {\ncolon = memchr(str, ':', str_len - 1);\n} else {\ncolon = NULL;\n}\nif (colon) {\n*portno = atoi(colon + 1);\nhost = estrndup(str, colon - str);\n} else {\nif (get_err) {\n*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n}\nreturn NULL;\n}\nreturn host;\n}", "contrast": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\nchar *colon;\nchar *host = NULL;\n#ifdef HAVE_IPV6\nif (*(str) == '[' && str_len > 1) {\nchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;\nif (!p || *(p + 1) != ':') {\nif (get_err) {\n*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n}\nreturn NULL;\n}\n*portno = strtol(p + 2, &e, 10);\nif (e && *e) {\nif (get_err) {\n*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n}\nreturn NULL;\n}\nreturn estrndup(str + 1, p - str - 1);\n}\n#endif\nif (str_len) {\ncolon = memchr(str, ':', str_len - 1);\n} else {\ncolon = NULL;\n}\nif (colon) {\nchar *e = NULL;\n*portno = strtol(colon + 1, &e, 10);\nif (!e || !*e) {\nreturn estrndup(str, colon - str);\n}\n}\nif (get_err) {\n*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n}\nreturn NULL;\n}", "label": 0}
{"index": 177452, "code": "static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {\nint vA, vB, vC, payload = 0, i = (int) buf[0];\nint size = dalvik_opcodes[i].len;\nchar str[1024], *strasm;\nut64 offset;\nconst char *flag_str;\nop->buf_asm[0] = 0;\nif (buf[0] == 0x00) {\nswitch (buf[1]) {\ncase 0x01:\n{\nunsigned short array_size = buf[2] | (buf[3] << 8);\nint first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\nsprintf (op->buf_asm, \"packed-switch-payload %d, %d\", array_size, first_key);\nsize = 8;\npayload = 2 * (array_size * 2);\nlen = 0;\n}\nbreak;\ncase 0x02:\n{\nunsigned short array_size = buf[2] | (buf[3] << 8);\nsprintf (op->buf_asm, \"sparse-switch-payload %d\", array_size);\nsize = 4;\npayload = 2 * (array_size*4);\nlen = 0;\n}\nbreak;\ncase 0x03:\nif (len > 7) {\nunsigned short elem_width = buf[2] | (buf[3] << 8);\nunsigned int array_size = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\nsnprintf (op->buf_asm, sizeof (op->buf_asm),\n\"fill-array-data-payload %d, %d\",\nelem_width, array_size);\npayload = 2 * ((array_size * elem_width+1)/2);\n}\nsize = 8;\nlen = 0;\nbreak;\ndefault:\nbreak;\n}\n}\nstrasm = NULL;\nif (size <= len) {\nstrncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);\nstrasm = strdup (op->buf_asm);\nsize = dalvik_opcodes[i].len;\nswitch (dalvik_opcodes[i].fmt) {\ncase fmtop: break;\ncase fmtopvAvB:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nsprintf (str, \" v%i, v%i\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAvBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nsprintf (str, \" v%i, v%i\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAAAvBBBB:\nvA = (buf[3] << 8) | buf[2];\nvB = (buf[5] << 8) | buf[4];\nsprintf (str, \" v%i, v%i\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAA:\nvA = (int) buf[1];\nsprintf (str, \" v%i\", vA);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAcB:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nsprintf (str, \" v%i, %#x\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAcBBBB:\nvA = (int) buf[1];\n{\nshort sB = (buf[3] << 8) | buf[2];\nsprintf (str, \" v%i, %#04hx\", vA, sB);\nstrasm = r_str_concat (strasm, str);\n}\nbreak;\ncase fmtopvAAcBBBBBBBB:\nvA = (int) buf[1];\nvB = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);\nif (buf[0] == 0x17) {\nsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAcBBBB0000:\nvA = (int) buf[1];\nvB = 0 | (buf[2] << 16) | (buf[3] << 24);\nif (buf[0] == 0x19) {\nsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAcBBBBBBBBBBBBBBBB:\nvA = (int) buf[1];\n#define llint long long int\nllint lB = (llint)buf[2] | ((llint)buf[3] << 8)|\n((llint)buf[4] << 16) | ((llint)buf[5] << 24)|\n((llint)buf[6] << 32) | ((llint)buf[7] << 40)|\n((llint)buf[8] << 48) | ((llint)buf[9] << 56);\n#undef llint\nsprintf (str, \" v%i:v%i, 0x%\"PFMT64x, vA, vA + 1, lB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAvBBvCC:\nvA = (int) buf[1];\nvB = (int) buf[2];\nvC = (int) buf[3];\nsprintf (str, \" v%i, v%i, v%i\", vA, vB, vC);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAvBBcCC:\nvA = (int) buf[1];\nvB = (int) buf[2];\nvC = (int) buf[3];\nsprintf (str, \" v%i, v%i, %#x\", vA, vB, vC);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAvBcCCCC:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nvC = (buf[3] << 8) | buf[2];\nsprintf (str, \" v%i, v%i, %#x\", vA, vB, vC);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoppAA:\nvA = (char) buf[1];\nsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoppAAAA:\nvA = (short) (buf[3] << 8 | buf[2]);\nsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAApBBBB:\nvA = (int) buf[1];\nvB = (int) (buf[3] << 8 | buf[2]);\nsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + (vB * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoppAAAAAAAA:\nvA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\nsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA*2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAvBpCCCC:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nvC = (int) (buf[3] << 8 | buf[2]);\nsnprintf (str, sizeof (str),\" v%i, v%i, 0x%08\"PFMT64x, vA, vB, a->pc + (vC * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAApBBBBBBBB:\nvA = (int) buf[1];\nvB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\nsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinlineI:\nvA = (int) (buf[1] & 0x0f);\nvB = (buf[3] << 8) | buf[2];\n*str = 0;\nswitch (vA) {\ncase 1:\nsprintf (str, \" {v%i}\", buf[4] & 0x0f);\nbreak;\ncase 2:\nsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\nbreak;\ncase 3:\nsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\nbreak;\ncase 4:\nsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\nbreak;\ndefault:\nsprintf (str, \" {}\");\n}\nstrasm = r_str_concat (strasm, str);\nsprintf (str, \", [%04x]\", vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinlineIR:\ncase fmtoptinvokeVSR:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nvC = (buf[5] << 8) | buf[4];\nsprintf (str, \" {v%i..v%i}, [%04x]\", vC, vC + vA - 1, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinvokeVS:\nvA = (int) (buf[1] & 0xf0) >> 4;\nvB = (buf[3] << 8) | buf[2];\nswitch (vA) {\ncase 1:\nsprintf (str, \" {v%i}\", buf[4] & 0x0f);\nbreak;\ncase 2:\nsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\nbreak;\ncase 3:\nsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\nbreak;\ncase 4:\nsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\nbreak;\ndefault:\nsprintf (str, \" {}\");\nbreak;\n}\nstrasm = r_str_concat (strasm, str);\nsprintf (str, \", [%04x]\", vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAtBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nif (buf[0] == 0x1a) {\noffset = R_ASM_GET_OFFSET (a, 's', vB);\nif (offset == -1) {\nsprintf (str, \" v%i, string+%i\", vA, vB);\n} else {\nsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);\n}\n} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {\nflag_str = R_ASM_GET_NAME (a, 'c', vB);\nif (!flag_str) {\nsprintf (str, \" v%i, class+%i\", vA, vB);\n} else {\nsprintf (str, \" v%i, %s\", vA, flag_str);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'f', vB);\nif (!flag_str) {\nsprintf (str, \" v%i, field+%i\", vA, vB);\n} else {\nsprintf (str, \" v%i, %s\", vA, flag_str);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptopvAvBoCCCC:\nvA = (buf[1] & 0x0f);\nvB = (buf[1] & 0xf0) >> 4;\nvC = (buf[3]<<8) | buf[2];\noffset = R_ASM_GET_OFFSET (a, 'o', vC);\nif (offset == -1) {\nsprintf (str, \" v%i, v%i, [obj+%04x]\", vA, vB, vC);\n} else {\nsprintf (str, \" v%i, v%i, [0x%\"PFMT64x\"]\", vA, vB, offset);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopAAtBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\noffset = R_ASM_GET_OFFSET (a, 't', vB);\nif (offset == -1) {\nsprintf (str, \" v%i, thing+%i\", vA, vB);\n} else {\nsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAvBtCCCC:\nvA = (buf[1] & 0x0f);\nvB = (buf[1] & 0xf0) >> 4;\nvC = (buf[3] << 8) | buf[2];\nif (buf[0] == 0x20 || buf[0] == 0x23) {\nflag_str = R_ASM_GET_NAME (a, 'c', vC);\nif (flag_str) {\nsprintf (str, \" v%i, v%i, %s\", vA, vB, flag_str);\n}\nelse {\nsprintf (str, \" v%i, v%i, class+%i\", vA, vB, vC);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'f', vC);\nif (flag_str) {\nsprintf (str, \" v%i, v%i, %s\", vA, vB, flag_str);\n}\nelse {\nsprintf (str, \" v%i, v%i, field+%i\", vA, vB, vC);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAtBBBBBBBB:\nvA = (int) buf[1];\nvB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));\noffset = R_ASM_GET_OFFSET (a, 's', vB);\nif (offset == -1) {\nsprintf (str, \" v%i, string+%i\", vA, vB);\n}\nelse {\nsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvCCCCmBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nvC = (buf[5] << 8) | buf[4];\nif (buf[0] == 0x25) {\nflag_str = R_ASM_GET_NAME (a, 'c', vB);\nif (flag_str) {\nsprintf (str, \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n}\nelse {\nsprintf (str, \" {v%i..v%i}, class+%i\", vC, vC + vA - 1, vB);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'm', vB);\nif (flag_str) {\nsprintf (str, \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n}\nelse {\nsprintf (str, \" {v%i..v%i}, method+%i\", vC, vC + vA - 1, vB);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvXtBBBB:\nvA = (int) (buf[1] & 0xf0) >> 4;\nvB = (buf[3] << 8) | buf[2];\nswitch (vA) {\ncase 1:\nsprintf (str, \" {v%i}\", buf[4] & 0x0f);\nbreak;\ncase 2:\nsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\nbreak;\ncase 3:\nsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\nbreak;\ncase 4:\nsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\nbreak;\ncase 5:\nsprintf (str, \" {v%i, v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f);\nbreak;\ndefault:\nsprintf (str, \" {}\");\n}\nstrasm = r_str_concat (strasm, str);\nif (buf[0] == 0x24) {\nflag_str = R_ASM_GET_NAME (a, 'c', vB);\nif (flag_str) {\nsprintf (str, \", %s ; 0x%x\", flag_str, vB);\n} else {\nsprintf (str, \", class+%i\", vB);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'm', vB);\nif (flag_str) {\nsprintf (str, \", %s ; 0x%x\", flag_str, vB);\n} else {\nsprintf (str, \", method+%i\", vB);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinvokeI:\ncase fmtoptinvokeIR:\ncase fmt00:\ndefault:\nstrcpy (op->buf_asm, \"invalid \");\nfree (strasm);\nstrasm = NULL;\nsize = 2;\n}\nif (strasm) {\nstrncpy (op->buf_asm, strasm, sizeof (op->buf_asm) - 1);\nop->buf_asm[sizeof (op->buf_asm) - 1] = 0;\n} else {\nstrcpy (op->buf_asm , \"invalid\");\n}\n} else if (len > 0) {\nstrcpy (op->buf_asm, \"invalid \");\nop->size = len;\nsize = len;\n}\nop->payload = payload;\nsize += payload;\nop->size = size;\nfree (strasm);\nreturn size;\n}", "contrast": "static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {\nint vA, vB, vC, payload = 0, i = (int) buf[0];\nint size = dalvik_opcodes[i].len;\nchar str[1024], *strasm;\nut64 offset;\nconst char *flag_str;\nop->buf_asm[0] = 0;\nif (buf[0] == 0x00) {\nswitch (buf[1]) {\ncase 0x01:\n{\nunsigned short array_size = buf[2] | (buf[3] << 8);\nint first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\nsnprintf (op->buf_asm, sizeof(op->buf_asm), \"packed-switch-payload %d, %d\", array_size, first_key);\nsize = 8;\npayload = 2 * (array_size * 2);\nlen = 0;\n}\nbreak;\ncase 0x02:\n{\nunsigned short array_size = buf[2] | (buf[3] << 8);\nsnprintf (op->buf_asm, sizeof (op->buf_asm), \"sparse-switch-payload %d\", array_size);\nsize = 4;\npayload = 2 * (array_size*4);\nlen = 0;\n}\nbreak;\ncase 0x03:\nif (len > 7) {\nunsigned short elem_width = buf[2] | (buf[3] << 8);\nunsigned int array_size = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\nsnprintf (op->buf_asm, sizeof (op->buf_asm),\n\"fill-array-data-payload %d, %d\",\nelem_width, array_size);\npayload = 2 * ((array_size * elem_width+1)/2);\n}\nsize = 8;\nlen = 0;\nbreak;\ndefault:\nbreak;\n}\n}\nstrasm = NULL;\nif (size <= len) {\nstrncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);\nstrasm = strdup (op->buf_asm);\nsize = dalvik_opcodes[i].len;\nswitch (dalvik_opcodes[i].fmt) {\ncase fmtop: break;\ncase fmtopvAvB:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAvBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAAAvBBBB:\nvA = (buf[3] << 8) | buf[2];\nvB = (buf[5] << 8) | buf[4];\nsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAA:\nvA = (int) buf[1];\nsnprintf (str, sizeof (str), \" v%i\", vA);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAcB:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nsnprintf (str, sizeof (str), \" v%i, %#x\", vA, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAcBBBB:\nvA = (int) buf[1];\n{\nshort sB = (buf[3] << 8) | buf[2];\nsnprintf (str, sizeof (str), \" v%i, %#04hx\", vA, sB);\nstrasm = r_str_concat (strasm, str);\n}\nbreak;\ncase fmtopvAAcBBBBBBBB:\nvA = (int) buf[1];\nvB = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);\nif (buf[0] == 0x17) {\nsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAcBBBB0000:\nvA = (int) buf[1];\nvB = 0 | (buf[2] << 16) | (buf[3] << 24);\nif (buf[0] == 0x19) {\nsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAcBBBBBBBBBBBBBBBB:\nvA = (int) buf[1];\n#define llint long long int\nllint lB = (llint)buf[2] | ((llint)buf[3] << 8)|\n((llint)buf[4] << 16) | ((llint)buf[5] << 24)|\n((llint)buf[6] << 32) | ((llint)buf[7] << 40)|\n((llint)buf[8] << 48) | ((llint)buf[9] << 56);\n#undef llint\nsnprintf (str, sizeof (str), \" v%i:v%i, 0x%\"PFMT64x, vA, vA + 1, lB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAvBBvCC:\nvA = (int) buf[1];\nvB = (int) buf[2];\nvC = (int) buf[3];\nsnprintf (str, sizeof (str), \" v%i, v%i, v%i\", vA, vB, vC);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAvBBcCC:\nvA = (int) buf[1];\nvB = (int) buf[2];\nvC = (int) buf[3];\nsnprintf (str, sizeof (str), \" v%i, v%i, %#x\", vA, vB, vC);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAvBcCCCC:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nvC = (buf[3] << 8) | buf[2];\nsnprintf (str, sizeof (str), \" v%i, v%i, %#x\", vA, vB, vC);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoppAA:\nvA = (char) buf[1];\nsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoppAAAA:\nvA = (short) (buf[3] << 8 | buf[2]);\nsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAApBBBB:\nvA = (int) buf[1];\nvB = (int) (buf[3] << 8 | buf[2]);\nsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + (vB * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoppAAAAAAAA:\nvA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\nsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA*2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAvBpCCCC:\nvA = buf[1] & 0x0f;\nvB = (buf[1] & 0xf0) >> 4;\nvC = (int) (buf[3] << 8 | buf[2]);\nsnprintf (str, sizeof (str),\" v%i, v%i, 0x%08\"PFMT64x, vA, vB, a->pc + (vC * 2));\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAApBBBBBBBB:\nvA = (int) buf[1];\nvB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\nsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinlineI:\nvA = (int) (buf[1] & 0x0f);\nvB = (buf[3] << 8) | buf[2];\n*str = 0;\nswitch (vA) {\ncase 1:\nsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);\nbreak;\ncase 2:\nsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\nbreak;\ncase 3:\nsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\nbreak;\ncase 4:\nsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\nbreak;\ndefault:\nsnprintf (str, sizeof (str), \" {}\");\n}\nstrasm = r_str_concat (strasm, str);\nsnprintf (str, sizeof (str), \", [%04x]\", vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinlineIR:\ncase fmtoptinvokeVSR:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nvC = (buf[5] << 8) | buf[4];\nsnprintf (str, sizeof (str), \" {v%i..v%i}, [%04x]\", vC, vC + vA - 1, vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinvokeVS:\nvA = (int) (buf[1] & 0xf0) >> 4;\nvB = (buf[3] << 8) | buf[2];\nswitch (vA) {\ncase 1:\nsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);\nbreak;\ncase 2:\nsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\nbreak;\ncase 3:\nsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\nbreak;\ncase 4:\nsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\nbreak;\ndefault:\nsnprintf (str, sizeof (str), \" {}\");\nbreak;\n}\nstrasm = r_str_concat (strasm, str);\nsnprintf (str, sizeof (str), \", [%04x]\", vB);\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAtBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nif (buf[0] == 0x1a) {\noffset = R_ASM_GET_OFFSET (a, 's', vB);\nif (offset == -1) {\nsnprintf (str, sizeof (str), \" v%i, string+%i\", vA, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);\n}\n} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {\nflag_str = R_ASM_GET_NAME (a, 'c', vB);\nif (!flag_str) {\nsnprintf (str, sizeof (str), \" v%i, class+%i\", vA, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, %s\", vA, flag_str);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'f', vB);\nif (!flag_str) {\nsnprintf (str, sizeof (str), \" v%i, field+%i\", vA, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, %s\", vA, flag_str);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptopvAvBoCCCC:\nvA = (buf[1] & 0x0f);\nvB = (buf[1] & 0xf0) >> 4;\nvC = (buf[3]<<8) | buf[2];\noffset = R_ASM_GET_OFFSET (a, 'o', vC);\nif (offset == -1) {\nsnprintf (str, sizeof (str), \" v%i, v%i, [obj+%04x]\", vA, vB, vC);\n} else {\nsnprintf (str, sizeof (str), \" v%i, v%i, [0x%\"PFMT64x\"]\", vA, vB, offset);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopAAtBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\noffset = R_ASM_GET_OFFSET (a, 't', vB);\nif (offset == -1) {\nsnprintf (str, sizeof (str), \" v%i, thing+%i\", vA, vB);\n} else {\nsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAvBtCCCC:\nvA = (buf[1] & 0x0f);\nvB = (buf[1] & 0xf0) >> 4;\nvC = (buf[3] << 8) | buf[2];\nif (buf[0] == 0x20 || buf[0] == 0x23) {\nflag_str = R_ASM_GET_NAME (a, 'c', vC);\nif (flag_str) {\nsnprintf (str, sizeof (str), \" v%i, v%i, %s\", vA, vB, flag_str);\n}\nelse {\nsnprintf (str, sizeof (str), \" v%i, v%i, class+%i\", vA, vB, vC);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'f', vC);\nif (flag_str) {\nsnprintf (str, sizeof (str), \" v%i, v%i, %s\", vA, vB, flag_str);\n}\nelse {\nsnprintf (str, sizeof (str), \" v%i, v%i, field+%i\", vA, vB, vC);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvAAtBBBBBBBB:\nvA = (int) buf[1];\nvB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));\noffset = R_ASM_GET_OFFSET (a, 's', vB);\nif (offset == -1) {\nsnprintf (str, sizeof (str), \" v%i, string+%i\", vA, vB);\n}\nelse {\nsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvCCCCmBBBB:\nvA = (int) buf[1];\nvB = (buf[3] << 8) | buf[2];\nvC = (buf[5] << 8) | buf[4];\nif (buf[0] == 0x25) {\nflag_str = R_ASM_GET_NAME (a, 'c', vB);\nif (flag_str) {\nsnprintf (str, sizeof (str), \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n}\nelse {\nsnprintf (str, sizeof (str), \" {v%i..v%i}, class+%i\", vC, vC + vA - 1, vB);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'm', vB);\nif (flag_str) {\nsnprintf (str, sizeof (str), \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n}\nelse {\nsnprintf (str, sizeof (str), \" {v%i..v%i}, method+%i\", vC, vC + vA - 1, vB);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtopvXtBBBB:\nvA = (int) (buf[1] & 0xf0) >> 4;\nvB = (buf[3] << 8) | buf[2];\nswitch (vA) {\ncase 1:\nsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);\nbreak;\ncase 2:\nsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\nbreak;\ncase 3:\nsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\nbreak;\ncase 4:\nsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\nbreak;\ncase 5:\nsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f);\nbreak;\ndefault:\nsnprintf (str, sizeof (str), \" {}\");\n}\nstrasm = r_str_concat (strasm, str);\nif (buf[0] == 0x24) {\nflag_str = R_ASM_GET_NAME (a, 'c', vB);\nif (flag_str) {\nsnprintf (str, sizeof (str), \", %s ; 0x%x\", flag_str, vB);\n} else {\nsnprintf (str, sizeof (str), \", class+%i\", vB);\n}\n} else {\nflag_str = R_ASM_GET_NAME (a, 'm', vB);\nif (flag_str) {\nsnprintf (str, sizeof (str), \", %s ; 0x%x\", flag_str, vB);\n} else {\nsnprintf (str, sizeof (str), \", method+%i\", vB);\n}\n}\nstrasm = r_str_concat (strasm, str);\nbreak;\ncase fmtoptinvokeI:\ncase fmtoptinvokeIR:\ncase fmt00:\ndefault:\nstrcpy (op->buf_asm, \"invalid \");\nfree (strasm);\nstrasm = NULL;\nsize = 2;\n}\nif (strasm) {\nstrncpy (op->buf_asm, strasm, sizeof (op->buf_asm) - 1);\nop->buf_asm[sizeof (op->buf_asm) - 1] = 0;\n} else {\nstrcpy (op->buf_asm , \"invalid\");\n}\n} else if (len > 0) {\nstrcpy (op->buf_asm, \"invalid \");\nop->size = len;\nsize = len;\n}\nop->payload = payload;\nsize += payload;\nop->size = size;\nfree (strasm);\nreturn size;\n}", "label": 0}
{"index": 177464, "code": "get_html_data (MAPI_Attr *a)\n{\nVarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\nint j;\nfor (j = 0; j < a->num_values; j++)\n{\nbody[j] = XMALLOC(VarLenData, 1);\nbody[j]->len = a->values[j].len;\nbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\nmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n}\nreturn body;\n}", "contrast": "get_html_data (MAPI_Attr *a)\n{\nVarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\nint j;\nfor (j = 0; j < a->num_values; j++)\n{\nif (a->type == szMAPI_BINARY) {\nbody[j] = XMALLOC(VarLenData, 1);\nbody[j]->len = a->values[j].len;\nbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\nmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n}\n}\nreturn body;\n}", "label": 0}
{"index": 177481, "code": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\nint yychar;\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\nint yynerrs;\nint yystate;\nint yyerrstatus;\nyytype_int16 yyssa[YYINITDEPTH];\nyytype_int16 *yyss;\nyytype_int16 *yyssp;\nYYSTYPE yyvsa[YYINITDEPTH];\nYYSTYPE *yyvs;\nYYSTYPE *yyvsp;\nYYSIZE_T yystacksize;\nint yyn;\nint yyresult;\nint yytoken = 0;\nYYSTYPE yyval;\n#if YYERROR_VERBOSE\nchar yymsgbuf[128];\nchar *yymsg = yymsgbuf;\nYYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\nint yylen = 0;\nyyssp = yyss = yyssa;\nyyvsp = yyvs = yyvsa;\nyystacksize = YYINITDEPTH;\nYYDPRINTF ((stderr, \"Starting parse\\n\"));\nyystate = 0;\nyyerrstatus = 0;\nyynerrs = 0;\nyychar = YYEMPTY;\ngoto yysetstate;\nyynewstate:\nyyssp++;\nyysetstate:\n*yyssp = yystate;\nif (yyss + yystacksize - 1 <= yyssp)\n{\nYYSIZE_T yysize = yyssp - yyss + 1;\n#ifdef yyoverflow\n{\nYYSTYPE *yyvs1 = yyvs;\nyytype_int16 *yyss1 = yyss;\nyyoverflow (YY_(\"memory exhausted\"),\n&yyss1, yysize * sizeof (*yyssp),\n&yyvs1, yysize * sizeof (*yyvsp),\n&yystacksize);\nyyss = yyss1;\nyyvs = yyvs1;\n}\n#else\n# ifndef YYSTACK_RELOCATE\ngoto yyexhaustedlab;\n# else\nif (YYMAXDEPTH <= yystacksize)\ngoto yyexhaustedlab;\nyystacksize *= 2;\nif (YYMAXDEPTH < yystacksize)\nyystacksize = YYMAXDEPTH;\n{\nyytype_int16 *yyss1 = yyss;\nunion yyalloc *yyptr =\n(union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\nif (! yyptr)\ngoto yyexhaustedlab;\nYYSTACK_RELOCATE (yyss_alloc, yyss);\nYYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\nif (yyss1 != yyssa)\nYYSTACK_FREE (yyss1);\n}\n# endif\n#endif\nyyssp = yyss + yysize - 1;\nyyvsp = yyvs + yysize - 1;\nYYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n(unsigned long int) yystacksize));\nif (yyss + yystacksize - 1 <= yyssp)\nYYABORT;\n}\nYYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\nif (yystate == YYFINAL)\nYYACCEPT;\ngoto yybackup;\nyybackup:\nyyn = yypact[yystate];\nif (yypact_value_is_default (yyn))\ngoto yydefault;\nif (yychar == YYEMPTY)\n{\nYYDPRINTF ((stderr, \"Reading a token: \"));\nyychar = yylex (&yylval, yyscanner, compiler);\n}\nif (yychar <= YYEOF)\n{\nyychar = yytoken = YYEOF;\nYYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n}\nelse\n{\nyytoken = YYTRANSLATE (yychar);\nYY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n}\nyyn += yytoken;\nif (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\ngoto yydefault;\nyyn = yytable[yyn];\nif (yyn <= 0)\n{\nif (yytable_value_is_error (yyn))\ngoto yyerrlab;\nyyn = -yyn;\ngoto yyreduce;\n}\nif (yyerrstatus)\nyyerrstatus--;\nYY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\nyychar = YYEMPTY;\nyystate = yyn;\nYY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n*++yyvsp = yylval;\nYY_IGNORE_MAYBE_UNINITIALIZED_END\ngoto yynewstate;\nyydefault:\nyyn = yydefact[yystate];\nif (yyn == 0)\ngoto yyerrlab;\ngoto yyreduce;\nyyreduce:\nyylen = yyr2[yyn];\nyyval = yyvsp[1-yylen];\nYY_REDUCE_PRINT (yyn);\nswitch (yyn)\n{\ncase 8:\n#line 230 \"grammar.y\"\n{\nint result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\nyr_free((yyvsp[0].sized_string));\nERROR_IF(result != ERROR_SUCCESS);\n}\n#line 1661 \"grammar.c\"\nbreak;\ncase 9:\n#line 242 \"grammar.y\"\n{\nYR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\nyyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\nERROR_IF(rule == NULL);\n(yyval.rule) = rule;\n}\n#line 1674 \"grammar.c\"\nbreak;\ncase 10:\n#line 251 \"grammar.y\"\n{\nYR_RULE* rule = (yyvsp[-4].rule);\nrule->tags = (yyvsp[-3].c_string);\nrule->metas = (yyvsp[-1].meta);\nrule->strings = (yyvsp[0].string);\n}\n#line 1686 \"grammar.c\"\nbreak;\ncase 11:\n#line 259 \"grammar.y\"\n{\nYR_RULE* rule = (yyvsp[-7].rule);\ncompiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\nyyscanner, rule);\nyr_free((yyvsp[-8].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 1701 \"grammar.c\"\nbreak;\ncase 12:\n#line 274 \"grammar.y\"\n{\n(yyval.meta) = NULL;\n}\n#line 1709 \"grammar.c\"\nbreak;\ncase 13:\n#line 278 \"grammar.y\"\n{\nYR_META null_meta;\nmemset(&null_meta, 0xFF, sizeof(YR_META));\nnull_meta.type = META_TYPE_NULL;\ncompiler->last_result = yr_arena_write_data(\ncompiler->metas_arena,\n&null_meta,\nsizeof(YR_META),\nNULL);\n(yyval.meta) = (yyvsp[0].meta);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 1736 \"grammar.c\"\nbreak;\ncase 14:\n#line 305 \"grammar.y\"\n{\n(yyval.string) = NULL;\n}\n#line 1744 \"grammar.c\"\nbreak;\ncase 15:\n#line 309 \"grammar.y\"\n{\nYR_STRING null_string;\nmemset(&null_string, 0xFF, sizeof(YR_STRING));\nnull_string.g_flags = STRING_GFLAGS_NULL;\ncompiler->last_result = yr_arena_write_data(\ncompiler->strings_arena,\n&null_string,\nsizeof(YR_STRING),\nNULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.string) = (yyvsp[0].string);\n}\n#line 1771 \"grammar.c\"\nbreak;\ncase 17:\n#line 340 \"grammar.y\"\n{ (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\"\nbreak;\ncase 18:\n#line 341 \"grammar.y\"\n{ (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\"\nbreak;\ncase 19:\n#line 346 \"grammar.y\"\n{ (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\"\nbreak;\ncase 20:\n#line 347 \"grammar.y\"\n{ (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\"\nbreak;\ncase 21:\n#line 353 \"grammar.y\"\n{\n(yyval.c_string) = NULL;\n}\n#line 1803 \"grammar.c\"\nbreak;\ncase 22:\n#line 357 \"grammar.y\"\n{\ncompiler->last_result = yr_arena_write_string(\nyyget_extra(yyscanner)->sz_arena, \"\", NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = (yyvsp[0].c_string);\n}\n#line 1821 \"grammar.c\"\nbreak;\ncase 23:\n#line 375 \"grammar.y\"\n{\nchar* identifier;\ncompiler->last_result = yr_arena_write_string(\nyyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = identifier;\n}\n#line 1838 \"grammar.c\"\nbreak;\ncase 24:\n#line 388 \"grammar.y\"\n{\nchar* tag_name = (yyvsp[-1].c_string);\nsize_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\nwhile (tag_length > 0)\n{\nif (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n{\nyr_compiler_set_error_extra_info(compiler, tag_name);\ncompiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\nbreak;\n}\ntag_name = (char*) yr_arena_next_address(\nyyget_extra(yyscanner)->sz_arena,\ntag_name,\ntag_length + 1);\ntag_length = tag_name != NULL ? strlen(tag_name) : 0;\n}\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_arena_write_string(\nyyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = (yyvsp[-1].c_string);\n}\n#line 1874 \"grammar.c\"\nbreak;\ncase 25:\n#line 424 \"grammar.y\"\n{  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\"\nbreak;\ncase 26:\n#line 425 \"grammar.y\"\n{  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\"\nbreak;\ncase 27:\n#line 431 \"grammar.y\"\n{\nSIZED_STRING* sized_string = (yyvsp[0].sized_string);\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_STRING,\n(yyvsp[-2].c_string),\nsized_string->c_string,\n0);\nyr_free((yyvsp[-2].c_string));\nyr_free((yyvsp[0].sized_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1906 \"grammar.c\"\nbreak;\ncase 28:\n#line 447 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_INTEGER,\n(yyvsp[-2].c_string),\nNULL,\n(yyvsp[0].integer));\nyr_free((yyvsp[-2].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1923 \"grammar.c\"\nbreak;\ncase 29:\n#line 460 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_INTEGER,\n(yyvsp[-3].c_string),\nNULL,\n-(yyvsp[0].integer));\nyr_free((yyvsp[-3].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1940 \"grammar.c\"\nbreak;\ncase 30:\n#line 473 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_BOOLEAN,\n(yyvsp[-2].c_string),\nNULL,\nTRUE);\nyr_free((yyvsp[-2].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1957 \"grammar.c\"\nbreak;\ncase 31:\n#line 486 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_BOOLEAN,\n(yyvsp[-2].c_string),\nNULL,\nFALSE);\nyr_free((yyvsp[-2].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1974 \"grammar.c\"\nbreak;\ncase 32:\n#line 502 \"grammar.y\"\n{ (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\"\nbreak;\ncase 33:\n#line 503 \"grammar.y\"\n{ (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\"\nbreak;\ncase 34:\n#line 509 \"grammar.y\"\n{\ncompiler->error_line = yyget_lineno(yyscanner);\n}\n#line 1994 \"grammar.c\"\nbreak;\ncase 35:\n#line 513 \"grammar.y\"\n{\n(yyval.string) = yr_parser_reduce_string_declaration(\nyyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\nyr_free((yyvsp[-4].c_string));\nyr_free((yyvsp[-1].sized_string));\nERROR_IF((yyval.string) == NULL);\ncompiler->error_line = 0;\n}\n#line 2009 \"grammar.c\"\nbreak;\ncase 36:\n#line 524 \"grammar.y\"\n{\ncompiler->error_line = yyget_lineno(yyscanner);\n}\n#line 2017 \"grammar.c\"\nbreak;\ncase 37:\n#line 528 \"grammar.y\"\n{\n(yyval.string) = yr_parser_reduce_string_declaration(\nyyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\nyr_free((yyvsp[-4].c_string));\nyr_free((yyvsp[-1].sized_string));\nERROR_IF((yyval.string) == NULL);\ncompiler->error_line = 0;\n}\n#line 2033 \"grammar.c\"\nbreak;\ncase 38:\n#line 540 \"grammar.y\"\n{\n(yyval.string) = yr_parser_reduce_string_declaration(\nyyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\nyr_free((yyvsp[-2].c_string));\nyr_free((yyvsp[0].sized_string));\nERROR_IF((yyval.string) == NULL);\n}\n#line 2047 \"grammar.c\"\nbreak;\ncase 39:\n#line 553 \"grammar.y\"\n{ (yyval.integer) = 0; }\n#line 2053 \"grammar.c\"\nbreak;\ncase 40:\n#line 554 \"grammar.y\"\n{ (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\"\nbreak;\ncase 41:\n#line 559 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\"\nbreak;\ncase 42:\n#line 560 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\"\nbreak;\ncase 43:\n#line 561 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\"\nbreak;\ncase 44:\n#line 562 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\"\nbreak;\ncase 45:\n#line 568 \"grammar.y\"\n{\nint var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\nif (var_index >= 0)\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner,\nOP_PUSH_M,\nLOOP_LOCAL_VARS * var_index,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n(yyval.expression).identifier = compiler->loop_identifier[var_index];\n}\nelse\n{\nYR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\ncompiler->objects_table, (yyvsp[0].c_string), NULL);\nif (object == NULL)\n{\nchar* ns = compiler->current_namespace->name;\nobject = (YR_OBJECT*) yr_hash_table_lookup(\ncompiler->objects_table, (yyvsp[0].c_string), ns);\n}\nif (object != NULL)\n{\nchar* id;\ncompiler->last_result = yr_arena_write_string(\ncompiler->sz_arena, (yyvsp[0].c_string), &id);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_OBJ_LOAD,\nid,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = object;\n(yyval.expression).identifier = object->identifier;\n}\nelse\n{\nYR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\ncompiler->rules_table,\n(yyvsp[0].c_string),\ncompiler->current_namespace->name);\nif (rule != NULL)\n{\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_PUSH_RULE,\nrule,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n(yyval.expression).value.integer = UNDEFINED;\n(yyval.expression).identifier = rule->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\ncompiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n}\n}\n}\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2172 \"grammar.c\"\nbreak;\ncase 46:\n#line 653 \"grammar.y\"\n{\nYR_OBJECT* field = NULL;\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n{\nfield = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\nif (field != NULL)\n{\nchar* ident;\ncompiler->last_result = yr_arena_write_string(\ncompiler->sz_arena, (yyvsp[0].c_string), &ident);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_OBJ_FIELD,\nident,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = field;\n(yyval.expression).identifier = field->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\ncompiler->last_result = ERROR_INVALID_FIELD_NAME;\n}\n}\nelse\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-2].expression).identifier);\ncompiler->last_result = ERROR_NOT_A_STRUCTURE;\n}\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2222 \"grammar.c\"\nbreak;\ncase 47:\n#line 699 \"grammar.y\"\n{\nYR_OBJECT_ARRAY* array;\nYR_OBJECT_DICTIONARY* dict;\nif ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n{\nif ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"array indexes must be of integer type\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_INDEX_ARRAY, NULL);\narray = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = array->prototype_item;\n(yyval.expression).identifier = array->identifier;\n}\nelse if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n{\nif ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"dictionary keys must be of string type\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_LOOKUP_DICT, NULL);\ndict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = dict->prototype_item;\n(yyval.expression).identifier = dict->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-3].expression).identifier);\ncompiler->last_result = ERROR_NOT_INDEXABLE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2283 \"grammar.c\"\nbreak;\ncase 48:\n#line 757 \"grammar.y\"\n{\nYR_OBJECT_FUNCTION* function;\nchar* args_fmt;\nif ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n{\ncompiler->last_result = yr_parser_check_types(\ncompiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_arena_write_string(\ncompiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_CALL,\nargs_fmt,\nNULL,\nNULL);\nfunction = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = function->return_obj;\n(yyval.expression).identifier = function->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-3].expression).identifier);\ncompiler->last_result = ERROR_NOT_A_FUNCTION;\n}\nyr_free((yyvsp[-1].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2328 \"grammar.c\"\nbreak;\ncase 49:\n#line 801 \"grammar.y\"\n{ (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\"\nbreak;\ncase 50:\n#line 802 \"grammar.y\"\n{ (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\"\nbreak;\ncase 51:\n#line 807 \"grammar.y\"\n{\n(yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\nswitch((yyvsp[0].expression).type)\n{\ncase EXPRESSION_TYPE_INTEGER:\nstrlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_FLOAT:\nstrlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_BOOLEAN:\nstrlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_STRING:\nstrlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_REGEXP:\nstrlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\nbreak;\n}\nERROR_IF((yyval.c_string) == NULL);\n}\n#line 2369 \"grammar.c\"\nbreak;\ncase 52:\n#line 832 \"grammar.y\"\n{\nif (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n{\ncompiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n}\nelse\n{\nswitch((yyvsp[0].expression).type)\n{\ncase EXPRESSION_TYPE_INTEGER:\nstrlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_FLOAT:\nstrlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_BOOLEAN:\nstrlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_STRING:\nstrlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_REGEXP:\nstrlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\nbreak;\n}\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = (yyvsp[-2].c_string);\n}\n#line 2405 \"grammar.c\"\nbreak;\ncase 53:\n#line 868 \"grammar.y\"\n{\nSIZED_STRING* sized_string = (yyvsp[0].sized_string);\nRE* re;\nRE_ERROR error;\nint re_flags = 0;\nif (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\nre_flags |= RE_FLAGS_NO_CASE;\nif (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\nre_flags |= RE_FLAGS_DOT_ALL;\ncompiler->last_result = yr_re_compile(\nsized_string->c_string,\nre_flags,\ncompiler->re_code_arena,\n&re,\n&error);\nyr_free((yyvsp[0].sized_string));\nif (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\nyr_compiler_set_error_extra_info(compiler, error.message);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_PUSH,\nre->root_node->forward_code,\nNULL,\nNULL);\nyr_re_destroy(re);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n}\n#line 2451 \"grammar.c\"\nbreak;\ncase 54:\n#line 914 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n{\nif ((yyvsp[0].expression).value.sized_string != NULL)\n{\nyywarning(yyscanner,\n\"Using literal string \\\"%s\\\" in a boolean operation.\",\n(yyvsp[0].expression).value.sized_string->c_string);\n}\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_STR_TO_BOOL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2474 \"grammar.c\"\nbreak;\ncase 55:\n#line 936 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 1, NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2487 \"grammar.c\"\nbreak;\ncase 56:\n#line 945 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 0, NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2500 \"grammar.c\"\nbreak;\ncase 57:\n#line 954 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit(\nyyscanner,\nOP_MATCHES,\nNULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2519 \"grammar.c\"\nbreak;\ncase 58:\n#line 969 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_CONTAINS, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2535 \"grammar.c\"\nbreak;\ncase 59:\n#line 981 \"grammar.y\"\n{\nint result = yr_parser_reduce_string_identifier(\nyyscanner,\n(yyvsp[0].c_string),\nOP_FOUND,\nUNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2553 \"grammar.c\"\nbreak;\ncase 60:\n#line 995 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\nyr_free((yyvsp[-2].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2570 \"grammar.c\"\nbreak;\ncase 61:\n#line 1008 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\nyr_free((yyvsp[-2].c_string));\nERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2585 \"grammar.c\"\nbreak;\ncase 62:\n#line 1019 \"grammar.y\"\n{\nif (compiler->loop_depth > 0)\n{\ncompiler->loop_depth--;\ncompiler->loop_identifier[compiler->loop_depth] = NULL;\n}\n}\n#line 2597 \"grammar.c\"\nbreak;\ncase 63:\n#line 1027 \"grammar.y\"\n{\nint var_index;\nif (compiler->loop_depth == MAX_LOOP_NESTING)\ncompiler->last_result = \\\nERROR_LOOP_NESTING_LIMIT_EXCEEDED;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nvar_index = yr_parser_lookup_loop_variable(\nyyscanner, (yyvsp[-1].c_string));\nif (var_index >= 0)\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-1].c_string));\ncompiler->last_result = \\\nERROR_DUPLICATED_LOOP_IDENTIFIER;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2631 \"grammar.c\"\nbreak;\ncase 64:\n#line 1057 \"grammar.y\"\n{\nint mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nuint8_t* addr;\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\nif ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n{\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset, &addr, NULL);\n}\nelse\n{\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset, NULL, NULL);\n}\ncompiler->loop_address[compiler->loop_depth] = addr;\ncompiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\ncompiler->loop_depth++;\n}\n#line 2670 \"grammar.c\"\nbreak;\ncase 65:\n#line 1092 \"grammar.y\"\n{\nint mem_offset;\ncompiler->loop_depth--;\nmem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nyr_parser_emit_with_arg(\nyyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\nif ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n{\nyr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JNUNDEF,\ncompiler->loop_address[compiler->loop_depth],\nNULL,\nNULL);\n}\nelse\n{\nyr_parser_emit_with_arg(\nyyscanner, OP_INCR_M, mem_offset, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\nyr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JLE,\ncompiler->loop_address[compiler->loop_depth],\nNULL,\nNULL);\nyr_parser_emit(yyscanner, OP_POP, NULL);\nyr_parser_emit(yyscanner, OP_POP, NULL);\n}\nyr_parser_emit(yyscanner, OP_POP, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit(yyscanner, OP_INT_LE, NULL);\ncompiler->loop_identifier[compiler->loop_depth] = NULL;\nyr_free((yyvsp[-8].c_string));\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2753 \"grammar.c\"\nbreak;\ncase 66:\n#line 1171 \"grammar.y\"\n{\nint mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nuint8_t* addr;\nif (compiler->loop_depth == MAX_LOOP_NESTING)\ncompiler->last_result = \\\nERROR_LOOP_NESTING_LIMIT_EXCEEDED;\nif (compiler->loop_for_of_mem_offset != -1)\ncompiler->last_result = \\\nERROR_NESTED_FOR_OF_LOOP;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset, &addr, NULL);\ncompiler->loop_for_of_mem_offset = mem_offset;\ncompiler->loop_address[compiler->loop_depth] = addr;\ncompiler->loop_identifier[compiler->loop_depth] = NULL;\ncompiler->loop_depth++;\n}\n#line 2787 \"grammar.c\"\nbreak;\ncase 67:\n#line 1201 \"grammar.y\"\n{\nint mem_offset;\ncompiler->loop_depth--;\ncompiler->loop_for_of_mem_offset = -1;\nmem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nyr_parser_emit_with_arg(\nyyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JNUNDEF,\ncompiler->loop_address[compiler->loop_depth],\nNULL,\nNULL);\nyr_parser_emit(yyscanner, OP_POP, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit(yyscanner, OP_INT_LE, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2840 \"grammar.c\"\nbreak;\ncase 68:\n#line 1250 \"grammar.y\"\n{\nyr_parser_emit(yyscanner, OP_OF, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2850 \"grammar.c\"\nbreak;\ncase 69:\n#line 1256 \"grammar.y\"\n{\nyr_parser_emit(yyscanner, OP_NOT, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2860 \"grammar.c\"\nbreak;\ncase 70:\n#line 1262 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nvoid* jmp_destination_addr;\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JFALSE,\n0,\nNULL,\n&jmp_destination_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\nif (fixup == NULL)\ncompiler->last_error = ERROR_INSUFFICIENT_MEMORY;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup->address = jmp_destination_addr;\nfixup->next = compiler->fixup_stack_head;\ncompiler->fixup_stack_head = fixup;\n}\n#line 2890 \"grammar.c\"\nbreak;\ncase 71:\n#line 1288 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nuint8_t* and_addr;\ncompiler->last_result = yr_arena_reserve_memory(\ncompiler->code_arena, 2);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = compiler->fixup_stack_head;\n*(void**)(fixup->address) = (void*)(and_addr + 1);\ncompiler->fixup_stack_head = fixup->next;\nyr_free(fixup);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2930 \"grammar.c\"\nbreak;\ncase 72:\n#line 1324 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nvoid* jmp_destination_addr;\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JTRUE,\n0,\nNULL,\n&jmp_destination_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\nif (fixup == NULL)\ncompiler->last_error = ERROR_INSUFFICIENT_MEMORY;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup->address = jmp_destination_addr;\nfixup->next = compiler->fixup_stack_head;\ncompiler->fixup_stack_head = fixup;\n}\n#line 2959 \"grammar.c\"\nbreak;\ncase 73:\n#line 1349 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nuint8_t* or_addr;\ncompiler->last_result = yr_arena_reserve_memory(\ncompiler->code_arena, 2);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = compiler->fixup_stack_head;\n*(void**)(fixup->address) = (void*)(or_addr + 1);\ncompiler->fixup_stack_head = fixup->next;\nyr_free(fixup);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2999 \"grammar.c\"\nbreak;\ncase 74:\n#line 1385 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3012 \"grammar.c\"\nbreak;\ncase 75:\n#line 1394 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3025 \"grammar.c\"\nbreak;\ncase 76:\n#line 1403 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3038 \"grammar.c\"\nbreak;\ncase 77:\n#line 1412 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3051 \"grammar.c\"\nbreak;\ncase 78:\n#line 1421 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3064 \"grammar.c\"\nbreak;\ncase 79:\n#line 1430 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3077 \"grammar.c\"\nbreak;\ncase 80:\n#line 1439 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[0].expression);\n}\n#line 3085 \"grammar.c\"\nbreak;\ncase 81:\n#line 1443 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[-1].expression);\n}\n#line 3093 \"grammar.c\"\nbreak;\ncase 82:\n#line 1450 \"grammar.y\"\n{ (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3099 \"grammar.c\"\nbreak;\ncase 83:\n#line 1451 \"grammar.y\"\n{ (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3105 \"grammar.c\"\nbreak;\ncase 84:\n#line 1457 \"grammar.y\"\n{\nif ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for range's lower bound\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nif ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for range's upper bound\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3127 \"grammar.c\"\nbreak;\ncase 85:\n#line 1479 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for enumeration item\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3143 \"grammar.c\"\nbreak;\ncase 86:\n#line 1491 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for enumeration item\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3158 \"grammar.c\"\nbreak;\ncase 87:\n#line 1506 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n}\n#line 3167 \"grammar.c\"\nbreak;\ncase 89:\n#line 1512 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\nyr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3178 \"grammar.c\"\nbreak;\ncase 92:\n#line 1529 \"grammar.y\"\n{\nyr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3189 \"grammar.c\"\nbreak;\ncase 93:\n#line 1536 \"grammar.y\"\n{\nyr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3200 \"grammar.c\"\nbreak;\ncase 95:\n#line 1548 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n}\n#line 3208 \"grammar.c\"\nbreak;\ncase 96:\n#line 1552 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n}\n#line 3216 \"grammar.c\"\nbreak;\ncase 97:\n#line 1560 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[-1].expression);\n}\n#line 3224 \"grammar.c\"\nbreak;\ncase 98:\n#line 1564 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_FILESIZE, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3238 \"grammar.c\"\nbreak;\ncase 99:\n#line 1574 \"grammar.y\"\n{\nyywarning(yyscanner,\n\"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n\"function from PE module instead.\");\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_ENTRYPOINT, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3256 \"grammar.c\"\nbreak;\ncase 100:\n#line 1588 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\ncompiler->last_result = yr_parser_emit(\nyyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3276 \"grammar.c\"\nbreak;\ncase 101:\n#line 1604 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = (yyvsp[0].integer);\n}\n#line 3290 \"grammar.c\"\nbreak;\ncase 102:\n#line 1614 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg_double(\nyyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n#line 3303 \"grammar.c\"\nbreak;\ncase 103:\n#line 1623 \"grammar.y\"\n{\nSIZED_STRING* sized_string;\ncompiler->last_result = yr_arena_write_data(\ncompiler->sz_arena,\n(yyvsp[0].sized_string),\n(yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n(void**) &sized_string);\nyr_free((yyvsp[0].sized_string));\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_PUSH,\nsized_string,\nNULL,\nNULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_STRING;\n(yyval.expression).value.sized_string = sized_string;\n}\n#line 3332 \"grammar.c\"\nbreak;\ncase 104:\n#line 1648 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3348 \"grammar.c\"\nbreak;\ncase 105:\n#line 1660 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\nyr_free((yyvsp[-3].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3364 \"grammar.c\"\nbreak;\ncase 106:\n#line 1672 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 1, NULL, NULL);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3384 \"grammar.c\"\nbreak;\ncase 107:\n#line 1688 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\nyr_free((yyvsp[-3].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3400 \"grammar.c\"\nbreak;\ncase 108:\n#line 1700 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 1, NULL, NULL);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3420 \"grammar.c\"\nbreak;\ncase 109:\n#line 1716 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\nelse if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)\n{\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n(yyval.expression).value.integer = UNDEFINED;\n}\nelse if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n{\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_OBJ_VALUE, NULL);\nswitch((yyvsp[0].expression).value.object->type)\n{\ncase OBJECT_TYPE_INTEGER:\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\nbreak;\ncase OBJECT_TYPE_FLOAT:\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\nbreak;\ncase OBJECT_TYPE_STRING:\n(yyval.expression).type = EXPRESSION_TYPE_STRING;\n(yyval.expression).value.sized_string = NULL;\nbreak;\ndefault:\nyr_compiler_set_error_extra_info_fmt(\ncompiler,\n\"wrong usage of identifier \\\"%s\\\"\",\n(yyvsp[0].expression).identifier);\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\n}\nelse\n{\nassert(FALSE);\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3469 \"grammar.c\"\nbreak;\ncase 110:\n#line 1761 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\nif ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\nUNDEFINED : -((yyvsp[0].expression).value.integer);\ncompiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n}\nelse if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\ncompiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3492 \"grammar.c\"\nbreak;\ncase 111:\n#line 1780 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3514 \"grammar.c\"\nbreak;\ncase 112:\n#line 1798 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3536 \"grammar.c\"\nbreak;\ncase 113:\n#line 1816 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3558 \"grammar.c\"\nbreak;\ncase 114:\n#line 1834 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\nif ((yyvsp[0].expression).value.integer != 0)\n{\n(yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\ncompiler->last_result = ERROR_DIVISION_BY_ZERO;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3588 \"grammar.c\"\nbreak;\ncase 115:\n#line 1860 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\nyr_parser_emit(yyscanner, OP_MOD, NULL);\nif ((yyvsp[0].expression).value.integer != 0)\n{\n(yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\ncompiler->last_result = ERROR_DIVISION_BY_ZERO;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n}\n#line 3610 \"grammar.c\"\nbreak;\ncase 116:\n#line 1878 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nyr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3624 \"grammar.c\"\nbreak;\ncase 117:\n#line 1888 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nyr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3638 \"grammar.c\"\nbreak;\ncase 118:\n#line 1898 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\nyr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3652 \"grammar.c\"\nbreak;\ncase 119:\n#line 1908 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\nyr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\nUNDEFINED : ~((yyvsp[0].expression).value.integer);\n}\n#line 3666 \"grammar.c\"\nbreak;\ncase 120:\n#line 1918 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\nyr_parser_emit(yyscanner, OP_SHL, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3680 \"grammar.c\"\nbreak;\ncase 121:\n#line 1928 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\nyr_parser_emit(yyscanner, OP_SHR, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3694 \"grammar.c\"\nbreak;\ncase 122:\n#line 1938 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[0].expression);\n}\n#line 3702 \"grammar.c\"\nbreak;\n#line 3706 \"grammar.c\"\ndefault: break;\n}\nYY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\nYYPOPSTACK (yylen);\nyylen = 0;\nYY_STACK_PRINT (yyss, yyssp);\n*++yyvsp = yyval;\nyyn = yyr1[yyn];\nyystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\nif (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\nyystate = yytable[yystate];\nelse\nyystate = yydefgoto[yyn - YYNTOKENS];\ngoto yynewstate;\nyyerrlab:\nyytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\nif (!yyerrstatus)\n{\n++yynerrs;\n#if ! YYERROR_VERBOSE\nyyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\nyyssp, yytoken)\n{\nchar const *yymsgp = YY_(\"syntax error\");\nint yysyntax_error_status;\nyysyntax_error_status = YYSYNTAX_ERROR;\nif (yysyntax_error_status == 0)\nyymsgp = yymsg;\nelse if (yysyntax_error_status == 1)\n{\nif (yymsg != yymsgbuf)\nYYSTACK_FREE (yymsg);\nyymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\nif (!yymsg)\n{\nyymsg = yymsgbuf;\nyymsg_alloc = sizeof yymsgbuf;\nyysyntax_error_status = 2;\n}\nelse\n{\nyysyntax_error_status = YYSYNTAX_ERROR;\nyymsgp = yymsg;\n}\n}\nyyerror (yyscanner, compiler, yymsgp);\nif (yysyntax_error_status == 2)\ngoto yyexhaustedlab;\n}\n# undef YYSYNTAX_ERROR\n#endif\n}\nif (yyerrstatus == 3)\n{\nif (yychar <= YYEOF)\n{\nif (yychar == YYEOF)\nYYABORT;\n}\nelse\n{\nyydestruct (\"Error: discarding\",\nyytoken, &yylval, yyscanner, compiler);\nyychar = YYEMPTY;\n}\n}\ngoto yyerrlab1;\nyyerrorlab:\nif (  0)\ngoto yyerrorlab;\nYYPOPSTACK (yylen);\nyylen = 0;\nYY_STACK_PRINT (yyss, yyssp);\nyystate = *yyssp;\ngoto yyerrlab1;\nyyerrlab1:\nyyerrstatus = 3;\nfor (;;)\n{\nyyn = yypact[yystate];\nif (!yypact_value_is_default (yyn))\n{\nyyn += YYTERROR;\nif (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n{\nyyn = yytable[yyn];\nif (0 < yyn)\nbreak;\n}\n}\nif (yyssp == yyss)\nYYABORT;\nyydestruct (\"Error: popping\",\nyystos[yystate], yyvsp, yyscanner, compiler);\nYYPOPSTACK (1);\nyystate = *yyssp;\nYY_STACK_PRINT (yyss, yyssp);\n}\nYY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n*++yyvsp = yylval;\nYY_IGNORE_MAYBE_UNINITIALIZED_END\nYY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\nyystate = yyn;\ngoto yynewstate;\nyyacceptlab:\nyyresult = 0;\ngoto yyreturn;\nyyabortlab:\nyyresult = 1;\ngoto yyreturn;\n#if !defined yyoverflow || YYERROR_VERBOSE\nyyexhaustedlab:\nyyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\nyyresult = 2;\n#endif\nyyreturn:\nif (yychar != YYEMPTY)\n{\nyytoken = YYTRANSLATE (yychar);\nyydestruct (\"Cleanup: discarding lookahead\",\nyytoken, &yylval, yyscanner, compiler);\n}\nYYPOPSTACK (yylen);\nYY_STACK_PRINT (yyss, yyssp);\nwhile (yyssp != yyss)\n{\nyydestruct (\"Cleanup: popping\",\nyystos[*yyssp], yyvsp, yyscanner, compiler);\nYYPOPSTACK (1);\n}\n#ifndef yyoverflow\nif (yyss != yyssa)\nYYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\nif (yymsg != yymsgbuf)\nYYSTACK_FREE (yymsg);\n#endif\nreturn yyresult;\n}", "contrast": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\nint yychar;\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\nint yynerrs;\nint yystate;\nint yyerrstatus;\nyytype_int16 yyssa[YYINITDEPTH];\nyytype_int16 *yyss;\nyytype_int16 *yyssp;\nYYSTYPE yyvsa[YYINITDEPTH];\nYYSTYPE *yyvs;\nYYSTYPE *yyvsp;\nYYSIZE_T yystacksize;\nint yyn;\nint yyresult;\nint yytoken = 0;\nYYSTYPE yyval;\n#if YYERROR_VERBOSE\nchar yymsgbuf[128];\nchar *yymsg = yymsgbuf;\nYYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\nint yylen = 0;\nyyssp = yyss = yyssa;\nyyvsp = yyvs = yyvsa;\nyystacksize = YYINITDEPTH;\nYYDPRINTF ((stderr, \"Starting parse\\n\"));\nyystate = 0;\nyyerrstatus = 0;\nyynerrs = 0;\nyychar = YYEMPTY;\ngoto yysetstate;\nyynewstate:\nyyssp++;\nyysetstate:\n*yyssp = yystate;\nif (yyss + yystacksize - 1 <= yyssp)\n{\nYYSIZE_T yysize = yyssp - yyss + 1;\n#ifdef yyoverflow\n{\nYYSTYPE *yyvs1 = yyvs;\nyytype_int16 *yyss1 = yyss;\nyyoverflow (YY_(\"memory exhausted\"),\n&yyss1, yysize * sizeof (*yyssp),\n&yyvs1, yysize * sizeof (*yyvsp),\n&yystacksize);\nyyss = yyss1;\nyyvs = yyvs1;\n}\n#else\n# ifndef YYSTACK_RELOCATE\ngoto yyexhaustedlab;\n# else\nif (YYMAXDEPTH <= yystacksize)\ngoto yyexhaustedlab;\nyystacksize *= 2;\nif (YYMAXDEPTH < yystacksize)\nyystacksize = YYMAXDEPTH;\n{\nyytype_int16 *yyss1 = yyss;\nunion yyalloc *yyptr =\n(union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\nif (! yyptr)\ngoto yyexhaustedlab;\nYYSTACK_RELOCATE (yyss_alloc, yyss);\nYYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\nif (yyss1 != yyssa)\nYYSTACK_FREE (yyss1);\n}\n# endif\n#endif\nyyssp = yyss + yysize - 1;\nyyvsp = yyvs + yysize - 1;\nYYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n(unsigned long int) yystacksize));\nif (yyss + yystacksize - 1 <= yyssp)\nYYABORT;\n}\nYYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\nif (yystate == YYFINAL)\nYYACCEPT;\ngoto yybackup;\nyybackup:\nyyn = yypact[yystate];\nif (yypact_value_is_default (yyn))\ngoto yydefault;\nif (yychar == YYEMPTY)\n{\nYYDPRINTF ((stderr, \"Reading a token: \"));\nyychar = yylex (&yylval, yyscanner, compiler);\n}\nif (yychar <= YYEOF)\n{\nyychar = yytoken = YYEOF;\nYYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n}\nelse\n{\nyytoken = YYTRANSLATE (yychar);\nYY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n}\nyyn += yytoken;\nif (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\ngoto yydefault;\nyyn = yytable[yyn];\nif (yyn <= 0)\n{\nif (yytable_value_is_error (yyn))\ngoto yyerrlab;\nyyn = -yyn;\ngoto yyreduce;\n}\nif (yyerrstatus)\nyyerrstatus--;\nYY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\nyychar = YYEMPTY;\nyystate = yyn;\nYY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n*++yyvsp = yylval;\nYY_IGNORE_MAYBE_UNINITIALIZED_END\ngoto yynewstate;\nyydefault:\nyyn = yydefact[yystate];\nif (yyn == 0)\ngoto yyerrlab;\ngoto yyreduce;\nyyreduce:\nyylen = yyr2[yyn];\nyyval = yyvsp[1-yylen];\nYY_REDUCE_PRINT (yyn);\nswitch (yyn)\n{\ncase 8:\n#line 230 \"grammar.y\"\n{\nint result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\nyr_free((yyvsp[0].sized_string));\nERROR_IF(result != ERROR_SUCCESS);\n}\n#line 1661 \"grammar.c\"\nbreak;\ncase 9:\n#line 242 \"grammar.y\"\n{\nYR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\nyyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\nERROR_IF(rule == NULL);\n(yyval.rule) = rule;\n}\n#line 1674 \"grammar.c\"\nbreak;\ncase 10:\n#line 251 \"grammar.y\"\n{\nYR_RULE* rule = (yyvsp[-4].rule);\nrule->tags = (yyvsp[-3].c_string);\nrule->metas = (yyvsp[-1].meta);\nrule->strings = (yyvsp[0].string);\n}\n#line 1686 \"grammar.c\"\nbreak;\ncase 11:\n#line 259 \"grammar.y\"\n{\nYR_RULE* rule = (yyvsp[-7].rule);\ncompiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\nyyscanner, rule);\nyr_free((yyvsp[-8].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 1701 \"grammar.c\"\nbreak;\ncase 12:\n#line 274 \"grammar.y\"\n{\n(yyval.meta) = NULL;\n}\n#line 1709 \"grammar.c\"\nbreak;\ncase 13:\n#line 278 \"grammar.y\"\n{\nYR_META null_meta;\nmemset(&null_meta, 0xFF, sizeof(YR_META));\nnull_meta.type = META_TYPE_NULL;\ncompiler->last_result = yr_arena_write_data(\ncompiler->metas_arena,\n&null_meta,\nsizeof(YR_META),\nNULL);\n(yyval.meta) = (yyvsp[0].meta);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 1736 \"grammar.c\"\nbreak;\ncase 14:\n#line 305 \"grammar.y\"\n{\n(yyval.string) = NULL;\n}\n#line 1744 \"grammar.c\"\nbreak;\ncase 15:\n#line 309 \"grammar.y\"\n{\nYR_STRING null_string;\nmemset(&null_string, 0xFF, sizeof(YR_STRING));\nnull_string.g_flags = STRING_GFLAGS_NULL;\ncompiler->last_result = yr_arena_write_data(\ncompiler->strings_arena,\n&null_string,\nsizeof(YR_STRING),\nNULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.string) = (yyvsp[0].string);\n}\n#line 1771 \"grammar.c\"\nbreak;\ncase 17:\n#line 340 \"grammar.y\"\n{ (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\"\nbreak;\ncase 18:\n#line 341 \"grammar.y\"\n{ (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\"\nbreak;\ncase 19:\n#line 346 \"grammar.y\"\n{ (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\"\nbreak;\ncase 20:\n#line 347 \"grammar.y\"\n{ (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\"\nbreak;\ncase 21:\n#line 353 \"grammar.y\"\n{\n(yyval.c_string) = NULL;\n}\n#line 1803 \"grammar.c\"\nbreak;\ncase 22:\n#line 357 \"grammar.y\"\n{\ncompiler->last_result = yr_arena_write_string(\nyyget_extra(yyscanner)->sz_arena, \"\", NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = (yyvsp[0].c_string);\n}\n#line 1821 \"grammar.c\"\nbreak;\ncase 23:\n#line 375 \"grammar.y\"\n{\nchar* identifier;\ncompiler->last_result = yr_arena_write_string(\nyyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = identifier;\n}\n#line 1838 \"grammar.c\"\nbreak;\ncase 24:\n#line 388 \"grammar.y\"\n{\nchar* tag_name = (yyvsp[-1].c_string);\nsize_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\nwhile (tag_length > 0)\n{\nif (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n{\nyr_compiler_set_error_extra_info(compiler, tag_name);\ncompiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\nbreak;\n}\ntag_name = (char*) yr_arena_next_address(\nyyget_extra(yyscanner)->sz_arena,\ntag_name,\ntag_length + 1);\ntag_length = tag_name != NULL ? strlen(tag_name) : 0;\n}\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_arena_write_string(\nyyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = (yyvsp[-1].c_string);\n}\n#line 1874 \"grammar.c\"\nbreak;\ncase 25:\n#line 424 \"grammar.y\"\n{  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\"\nbreak;\ncase 26:\n#line 425 \"grammar.y\"\n{  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\"\nbreak;\ncase 27:\n#line 431 \"grammar.y\"\n{\nSIZED_STRING* sized_string = (yyvsp[0].sized_string);\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_STRING,\n(yyvsp[-2].c_string),\nsized_string->c_string,\n0);\nyr_free((yyvsp[-2].c_string));\nyr_free((yyvsp[0].sized_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1906 \"grammar.c\"\nbreak;\ncase 28:\n#line 447 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_INTEGER,\n(yyvsp[-2].c_string),\nNULL,\n(yyvsp[0].integer));\nyr_free((yyvsp[-2].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1923 \"grammar.c\"\nbreak;\ncase 29:\n#line 460 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_INTEGER,\n(yyvsp[-3].c_string),\nNULL,\n-(yyvsp[0].integer));\nyr_free((yyvsp[-3].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1940 \"grammar.c\"\nbreak;\ncase 30:\n#line 473 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_BOOLEAN,\n(yyvsp[-2].c_string),\nNULL,\nTRUE);\nyr_free((yyvsp[-2].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1957 \"grammar.c\"\nbreak;\ncase 31:\n#line 486 \"grammar.y\"\n{\n(yyval.meta) = yr_parser_reduce_meta_declaration(\nyyscanner,\nMETA_TYPE_BOOLEAN,\n(yyvsp[-2].c_string),\nNULL,\nFALSE);\nyr_free((yyvsp[-2].c_string));\nERROR_IF((yyval.meta) == NULL);\n}\n#line 1974 \"grammar.c\"\nbreak;\ncase 32:\n#line 502 \"grammar.y\"\n{ (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\"\nbreak;\ncase 33:\n#line 503 \"grammar.y\"\n{ (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\"\nbreak;\ncase 34:\n#line 509 \"grammar.y\"\n{\ncompiler->error_line = yyget_lineno(yyscanner);\n}\n#line 1994 \"grammar.c\"\nbreak;\ncase 35:\n#line 513 \"grammar.y\"\n{\n(yyval.string) = yr_parser_reduce_string_declaration(\nyyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\nyr_free((yyvsp[-4].c_string));\nyr_free((yyvsp[-1].sized_string));\nERROR_IF((yyval.string) == NULL);\ncompiler->error_line = 0;\n}\n#line 2009 \"grammar.c\"\nbreak;\ncase 36:\n#line 524 \"grammar.y\"\n{\ncompiler->error_line = yyget_lineno(yyscanner);\n}\n#line 2017 \"grammar.c\"\nbreak;\ncase 37:\n#line 528 \"grammar.y\"\n{\n(yyval.string) = yr_parser_reduce_string_declaration(\nyyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\nyr_free((yyvsp[-4].c_string));\nyr_free((yyvsp[-1].sized_string));\nERROR_IF((yyval.string) == NULL);\ncompiler->error_line = 0;\n}\n#line 2033 \"grammar.c\"\nbreak;\ncase 38:\n#line 540 \"grammar.y\"\n{\n(yyval.string) = yr_parser_reduce_string_declaration(\nyyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\nyr_free((yyvsp[-2].c_string));\nyr_free((yyvsp[0].sized_string));\nERROR_IF((yyval.string) == NULL);\n}\n#line 2047 \"grammar.c\"\nbreak;\ncase 39:\n#line 553 \"grammar.y\"\n{ (yyval.integer) = 0; }\n#line 2053 \"grammar.c\"\nbreak;\ncase 40:\n#line 554 \"grammar.y\"\n{ (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\"\nbreak;\ncase 41:\n#line 559 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\"\nbreak;\ncase 42:\n#line 560 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\"\nbreak;\ncase 43:\n#line 561 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\"\nbreak;\ncase 44:\n#line 562 \"grammar.y\"\n{ (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\"\nbreak;\ncase 45:\n#line 568 \"grammar.y\"\n{\nint var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\nif (var_index >= 0)\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner,\nOP_PUSH_M,\nLOOP_LOCAL_VARS * var_index,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n(yyval.expression).identifier = compiler->loop_identifier[var_index];\n}\nelse\n{\nYR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\ncompiler->objects_table, (yyvsp[0].c_string), NULL);\nif (object == NULL)\n{\nchar* ns = compiler->current_namespace->name;\nobject = (YR_OBJECT*) yr_hash_table_lookup(\ncompiler->objects_table, (yyvsp[0].c_string), ns);\n}\nif (object != NULL)\n{\nchar* id;\ncompiler->last_result = yr_arena_write_string(\ncompiler->sz_arena, (yyvsp[0].c_string), &id);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_OBJ_LOAD,\nid,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = object;\n(yyval.expression).identifier = object->identifier;\n}\nelse\n{\nYR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\ncompiler->rules_table,\n(yyvsp[0].c_string),\ncompiler->current_namespace->name);\nif (rule != NULL)\n{\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_PUSH_RULE,\nrule,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n(yyval.expression).value.integer = UNDEFINED;\n(yyval.expression).identifier = rule->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\ncompiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n}\n}\n}\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2172 \"grammar.c\"\nbreak;\ncase 46:\n#line 653 \"grammar.y\"\n{\nYR_OBJECT* field = NULL;\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n{\nfield = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\nif (field != NULL)\n{\nchar* ident;\ncompiler->last_result = yr_arena_write_string(\ncompiler->sz_arena, (yyvsp[0].c_string), &ident);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_OBJ_FIELD,\nident,\nNULL,\nNULL);\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = field;\n(yyval.expression).identifier = field->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\ncompiler->last_result = ERROR_INVALID_FIELD_NAME;\n}\n}\nelse\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-2].expression).identifier);\ncompiler->last_result = ERROR_NOT_A_STRUCTURE;\n}\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2222 \"grammar.c\"\nbreak;\ncase 47:\n#line 699 \"grammar.y\"\n{\nYR_OBJECT_ARRAY* array;\nYR_OBJECT_DICTIONARY* dict;\nif ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n{\nif ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"array indexes must be of integer type\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_INDEX_ARRAY, NULL);\narray = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = array->prototype_item;\n(yyval.expression).identifier = array->identifier;\n}\nelse if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n{\nif ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"dictionary keys must be of string type\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_LOOKUP_DICT, NULL);\ndict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = dict->prototype_item;\n(yyval.expression).identifier = dict->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-3].expression).identifier);\ncompiler->last_result = ERROR_NOT_INDEXABLE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2283 \"grammar.c\"\nbreak;\ncase 48:\n#line 757 \"grammar.y\"\n{\nYR_OBJECT_FUNCTION* function;\nchar* args_fmt;\nif ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n(yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n{\ncompiler->last_result = yr_parser_check_types(\ncompiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_arena_write_string(\ncompiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_CALL,\nargs_fmt,\nNULL,\nNULL);\nfunction = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n(yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n(yyval.expression).value.object = function->return_obj;\n(yyval.expression).identifier = function->identifier;\n}\nelse\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-3].expression).identifier);\ncompiler->last_result = ERROR_NOT_A_FUNCTION;\n}\nyr_free((yyvsp[-1].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2328 \"grammar.c\"\nbreak;\ncase 49:\n#line 801 \"grammar.y\"\n{ (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\"\nbreak;\ncase 50:\n#line 802 \"grammar.y\"\n{ (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\"\nbreak;\ncase 51:\n#line 807 \"grammar.y\"\n{\n(yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\nswitch((yyvsp[0].expression).type)\n{\ncase EXPRESSION_TYPE_INTEGER:\nstrlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_FLOAT:\nstrlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_BOOLEAN:\nstrlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_STRING:\nstrlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_REGEXP:\nstrlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\nbreak;\ndefault:\nassert(FALSE);\n}\nERROR_IF((yyval.c_string) == NULL);\n}\n#line 2371 \"grammar.c\"\nbreak;\ncase 52:\n#line 834 \"grammar.y\"\n{\nif (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n{\ncompiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n}\nelse\n{\nswitch((yyvsp[0].expression).type)\n{\ncase EXPRESSION_TYPE_INTEGER:\nstrlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_FLOAT:\nstrlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_BOOLEAN:\nstrlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_STRING:\nstrlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\nbreak;\ncase EXPRESSION_TYPE_REGEXP:\nstrlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\nbreak;\ndefault:\nassert(FALSE);\n}\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.c_string) = (yyvsp[-2].c_string);\n}\n#line 2409 \"grammar.c\"\nbreak;\ncase 53:\n#line 872 \"grammar.y\"\n{\nSIZED_STRING* sized_string = (yyvsp[0].sized_string);\nRE* re;\nRE_ERROR error;\nint re_flags = 0;\nif (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\nre_flags |= RE_FLAGS_NO_CASE;\nif (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\nre_flags |= RE_FLAGS_DOT_ALL;\ncompiler->last_result = yr_re_compile(\nsized_string->c_string,\nre_flags,\ncompiler->re_code_arena,\n&re,\n&error);\nyr_free((yyvsp[0].sized_string));\nif (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\nyr_compiler_set_error_extra_info(compiler, error.message);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_PUSH,\nre->root_node->forward_code,\nNULL,\nNULL);\nyr_re_destroy(re);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n}\n#line 2455 \"grammar.c\"\nbreak;\ncase 54:\n#line 918 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n{\nif ((yyvsp[0].expression).value.sized_string != NULL)\n{\nyywarning(yyscanner,\n\"Using literal string \\\"%s\\\" in a boolean operation.\",\n(yyvsp[0].expression).value.sized_string->c_string);\n}\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_STR_TO_BOOL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2478 \"grammar.c\"\nbreak;\ncase 55:\n#line 940 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 1, NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2491 \"grammar.c\"\nbreak;\ncase 56:\n#line 949 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 0, NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2504 \"grammar.c\"\nbreak;\ncase 57:\n#line 958 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit(\nyyscanner,\nOP_MATCHES,\nNULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2523 \"grammar.c\"\nbreak;\ncase 58:\n#line 973 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_CONTAINS, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2539 \"grammar.c\"\nbreak;\ncase 59:\n#line 985 \"grammar.y\"\n{\nint result = yr_parser_reduce_string_identifier(\nyyscanner,\n(yyvsp[0].c_string),\nOP_FOUND,\nUNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2557 \"grammar.c\"\nbreak;\ncase 60:\n#line 999 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\nyr_free((yyvsp[-2].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2574 \"grammar.c\"\nbreak;\ncase 61:\n#line 1012 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\nyr_free((yyvsp[-2].c_string));\nERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2589 \"grammar.c\"\nbreak;\ncase 62:\n#line 1023 \"grammar.y\"\n{\nif (compiler->loop_depth > 0)\n{\ncompiler->loop_depth--;\ncompiler->loop_identifier[compiler->loop_depth] = NULL;\n}\nYYERROR;\n}\n#line 2603 \"grammar.c\"\nbreak;\ncase 63:\n#line 1033 \"grammar.y\"\n{\nint var_index;\nif (compiler->loop_depth == MAX_LOOP_NESTING)\ncompiler->last_result = \\\nERROR_LOOP_NESTING_LIMIT_EXCEEDED;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nvar_index = yr_parser_lookup_loop_variable(\nyyscanner, (yyvsp[-1].c_string));\nif (var_index >= 0)\n{\nyr_compiler_set_error_extra_info(\ncompiler, (yyvsp[-1].c_string));\ncompiler->last_result = \\\nERROR_DUPLICATED_LOOP_IDENTIFIER;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 2637 \"grammar.c\"\nbreak;\ncase 64:\n#line 1063 \"grammar.y\"\n{\nint mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nuint8_t* addr;\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\nif ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n{\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset, &addr, NULL);\n}\nelse\n{\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset, NULL, NULL);\n}\ncompiler->loop_address[compiler->loop_depth] = addr;\ncompiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\ncompiler->loop_depth++;\n}\n#line 2676 \"grammar.c\"\nbreak;\ncase 65:\n#line 1098 \"grammar.y\"\n{\nint mem_offset;\ncompiler->loop_depth--;\nmem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nyr_parser_emit_with_arg(\nyyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\nif ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n{\nyr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JNUNDEF,\ncompiler->loop_address[compiler->loop_depth],\nNULL,\nNULL);\n}\nelse\n{\nyr_parser_emit_with_arg(\nyyscanner, OP_INCR_M, mem_offset, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\nyr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JLE,\ncompiler->loop_address[compiler->loop_depth],\nNULL,\nNULL);\nyr_parser_emit(yyscanner, OP_POP, NULL);\nyr_parser_emit(yyscanner, OP_POP, NULL);\n}\nyr_parser_emit(yyscanner, OP_POP, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit(yyscanner, OP_INT_LE, NULL);\ncompiler->loop_identifier[compiler->loop_depth] = NULL;\nyr_free((yyvsp[-8].c_string));\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2759 \"grammar.c\"\nbreak;\ncase 66:\n#line 1177 \"grammar.y\"\n{\nint mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nuint8_t* addr;\nif (compiler->loop_depth == MAX_LOOP_NESTING)\ncompiler->last_result = \\\nERROR_LOOP_NESTING_LIMIT_EXCEEDED;\nif (compiler->loop_for_of_mem_offset != -1)\ncompiler->last_result = \\\nERROR_NESTED_FOR_OF_LOOP;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_POP_M, mem_offset, &addr, NULL);\ncompiler->loop_for_of_mem_offset = mem_offset;\ncompiler->loop_address[compiler->loop_depth] = addr;\ncompiler->loop_identifier[compiler->loop_depth] = NULL;\ncompiler->loop_depth++;\n}\n#line 2793 \"grammar.c\"\nbreak;\ncase 67:\n#line 1207 \"grammar.y\"\n{\nint mem_offset;\ncompiler->loop_depth--;\ncompiler->loop_for_of_mem_offset = -1;\nmem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\nyr_parser_emit_with_arg(\nyyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JNUNDEF,\ncompiler->loop_address[compiler->loop_depth],\nNULL,\nNULL);\nyr_parser_emit(yyscanner, OP_POP, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\nyr_parser_emit_with_arg(\nyyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\nyr_parser_emit(yyscanner, OP_INT_LE, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2846 \"grammar.c\"\nbreak;\ncase 68:\n#line 1256 \"grammar.y\"\n{\nyr_parser_emit(yyscanner, OP_OF, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2856 \"grammar.c\"\nbreak;\ncase 69:\n#line 1262 \"grammar.y\"\n{\nyr_parser_emit(yyscanner, OP_NOT, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2866 \"grammar.c\"\nbreak;\ncase 70:\n#line 1268 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nvoid* jmp_destination_addr;\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JFALSE,\n0,\nNULL,\n&jmp_destination_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\nif (fixup == NULL)\ncompiler->last_error = ERROR_INSUFFICIENT_MEMORY;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup->address = jmp_destination_addr;\nfixup->next = compiler->fixup_stack_head;\ncompiler->fixup_stack_head = fixup;\n}\n#line 2896 \"grammar.c\"\nbreak;\ncase 71:\n#line 1294 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nuint8_t* and_addr;\ncompiler->last_result = yr_arena_reserve_memory(\ncompiler->code_arena, 2);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = compiler->fixup_stack_head;\n*(void**)(fixup->address) = (void*)(and_addr + 1);\ncompiler->fixup_stack_head = fixup->next;\nyr_free(fixup);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 2936 \"grammar.c\"\nbreak;\ncase 72:\n#line 1330 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nvoid* jmp_destination_addr;\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_JTRUE,\n0,\nNULL,\n&jmp_destination_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\nif (fixup == NULL)\ncompiler->last_error = ERROR_INSUFFICIENT_MEMORY;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup->address = jmp_destination_addr;\nfixup->next = compiler->fixup_stack_head;\ncompiler->fixup_stack_head = fixup;\n}\n#line 2965 \"grammar.c\"\nbreak;\ncase 73:\n#line 1355 \"grammar.y\"\n{\nYR_FIXUP* fixup;\nuint8_t* or_addr;\ncompiler->last_result = yr_arena_reserve_memory(\ncompiler->code_arena, 2);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\ncompiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nfixup = compiler->fixup_stack_head;\n*(void**)(fixup->address) = (void*)(or_addr + 1);\ncompiler->fixup_stack_head = fixup->next;\nyr_free(fixup);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3005 \"grammar.c\"\nbreak;\ncase 74:\n#line 1391 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3018 \"grammar.c\"\nbreak;\ncase 75:\n#line 1400 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3031 \"grammar.c\"\nbreak;\ncase 76:\n#line 1409 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3044 \"grammar.c\"\nbreak;\ncase 77:\n#line 1418 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3057 \"grammar.c\"\nbreak;\ncase 78:\n#line 1427 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3070 \"grammar.c\"\nbreak;\ncase 79:\n#line 1436 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n}\n#line 3083 \"grammar.c\"\nbreak;\ncase 80:\n#line 1445 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[0].expression);\n}\n#line 3091 \"grammar.c\"\nbreak;\ncase 81:\n#line 1449 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[-1].expression);\n}\n#line 3099 \"grammar.c\"\nbreak;\ncase 82:\n#line 1456 \"grammar.y\"\n{ (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3105 \"grammar.c\"\nbreak;\ncase 83:\n#line 1457 \"grammar.y\"\n{ (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3111 \"grammar.c\"\nbreak;\ncase 84:\n#line 1463 \"grammar.y\"\n{\nif ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for range's lower bound\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nif ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for range's upper bound\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3133 \"grammar.c\"\nbreak;\ncase 85:\n#line 1485 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for enumeration item\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3149 \"grammar.c\"\nbreak;\ncase 86:\n#line 1497 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n{\nyr_compiler_set_error_extra_info(\ncompiler, \"wrong type for enumeration item\");\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3164 \"grammar.c\"\nbreak;\ncase 87:\n#line 1512 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n}\n#line 3173 \"grammar.c\"\nbreak;\ncase 89:\n#line 1518 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\nyr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3184 \"grammar.c\"\nbreak;\ncase 92:\n#line 1535 \"grammar.y\"\n{\nyr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3195 \"grammar.c\"\nbreak;\ncase 93:\n#line 1542 \"grammar.y\"\n{\nyr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3206 \"grammar.c\"\nbreak;\ncase 95:\n#line 1554 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n}\n#line 3214 \"grammar.c\"\nbreak;\ncase 96:\n#line 1558 \"grammar.y\"\n{\nyr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n}\n#line 3222 \"grammar.c\"\nbreak;\ncase 97:\n#line 1566 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[-1].expression);\n}\n#line 3230 \"grammar.c\"\nbreak;\ncase 98:\n#line 1570 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_FILESIZE, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3244 \"grammar.c\"\nbreak;\ncase 99:\n#line 1580 \"grammar.y\"\n{\nyywarning(yyscanner,\n\"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n\"function from PE module instead.\");\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_ENTRYPOINT, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3262 \"grammar.c\"\nbreak;\ncase 100:\n#line 1594 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\ncompiler->last_result = yr_parser_emit(\nyyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3282 \"grammar.c\"\nbreak;\ncase 101:\n#line 1610 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = (yyvsp[0].integer);\n}\n#line 3296 \"grammar.c\"\nbreak;\ncase 102:\n#line 1620 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg_double(\nyyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n#line 3309 \"grammar.c\"\nbreak;\ncase 103:\n#line 1629 \"grammar.y\"\n{\nSIZED_STRING* sized_string;\ncompiler->last_result = yr_arena_write_data(\ncompiler->sz_arena,\n(yyvsp[0].sized_string),\n(yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n(void**) &sized_string);\nyr_free((yyvsp[0].sized_string));\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_emit_with_arg_reloc(\nyyscanner,\nOP_PUSH,\nsized_string,\nNULL,\nNULL);\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_STRING;\n(yyval.expression).value.sized_string = sized_string;\n}\n#line 3338 \"grammar.c\"\nbreak;\ncase 104:\n#line 1654 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3354 \"grammar.c\"\nbreak;\ncase 105:\n#line 1666 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\nyr_free((yyvsp[-3].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3370 \"grammar.c\"\nbreak;\ncase 106:\n#line 1678 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 1, NULL, NULL);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3390 \"grammar.c\"\nbreak;\ncase 107:\n#line 1694 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\nyr_free((yyvsp[-3].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3406 \"grammar.c\"\nbreak;\ncase 108:\n#line 1706 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_emit_with_arg(\nyyscanner, OP_PUSH, 1, NULL, NULL);\nif (compiler->last_result == ERROR_SUCCESS)\ncompiler->last_result = yr_parser_reduce_string_identifier(\nyyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\nyr_free((yyvsp[0].c_string));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\n#line 3426 \"grammar.c\"\nbreak;\ncase 109:\n#line 1722 \"grammar.y\"\n{\nif ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\n}\nelse if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)\n{\n(yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n(yyval.expression).value.integer = UNDEFINED;\n}\nelse if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n{\ncompiler->last_result = yr_parser_emit(\nyyscanner, OP_OBJ_VALUE, NULL);\nswitch((yyvsp[0].expression).value.object->type)\n{\ncase OBJECT_TYPE_INTEGER:\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = UNDEFINED;\nbreak;\ncase OBJECT_TYPE_FLOAT:\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\nbreak;\ncase OBJECT_TYPE_STRING:\n(yyval.expression).type = EXPRESSION_TYPE_STRING;\n(yyval.expression).value.sized_string = NULL;\nbreak;\ndefault:\nyr_compiler_set_error_extra_info_fmt(\ncompiler,\n\"wrong usage of identifier \\\"%s\\\"\",\n(yyvsp[0].expression).identifier);\ncompiler->last_result = ERROR_WRONG_TYPE;\n}\n}\nelse\n{\nassert(FALSE);\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3475 \"grammar.c\"\nbreak;\ncase 110:\n#line 1767 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\nif ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\nUNDEFINED : -((yyvsp[0].expression).value.integer);\ncompiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n}\nelse if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\ncompiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n}\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n#line 3498 \"grammar.c\"\nbreak;\ncase 111:\n#line 1786 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3520 \"grammar.c\"\nbreak;\ncase 112:\n#line 1804 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3542 \"grammar.c\"\nbreak;\ncase 113:\n#line 1822 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\n(yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3564 \"grammar.c\"\nbreak;\ncase 114:\n#line 1840 \"grammar.y\"\n{\ncompiler->last_result = yr_parser_reduce_operation(\nyyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\nif ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n(yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n{\nif ((yyvsp[0].expression).value.integer != 0)\n{\n(yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\ncompiler->last_result = ERROR_DIVISION_BY_ZERO;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n}\nelse\n{\n(yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n}\n}\n#line 3594 \"grammar.c\"\nbreak;\ncase 115:\n#line 1866 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\nyr_parser_emit(yyscanner, OP_MOD, NULL);\nif ((yyvsp[0].expression).value.integer != 0)\n{\n(yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n}\nelse\n{\ncompiler->last_result = ERROR_DIVISION_BY_ZERO;\nERROR_IF(compiler->last_result != ERROR_SUCCESS);\n}\n}\n#line 3616 \"grammar.c\"\nbreak;\ncase 116:\n#line 1884 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nyr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3630 \"grammar.c\"\nbreak;\ncase 117:\n#line 1894 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\nyr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3644 \"grammar.c\"\nbreak;\ncase 118:\n#line 1904 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\nyr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3658 \"grammar.c\"\nbreak;\ncase 119:\n#line 1914 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\nyr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\nUNDEFINED : ~((yyvsp[0].expression).value.integer);\n}\n#line 3672 \"grammar.c\"\nbreak;\ncase 120:\n#line 1924 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\nyr_parser_emit(yyscanner, OP_SHL, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3686 \"grammar.c\"\nbreak;\ncase 121:\n#line 1934 \"grammar.y\"\n{\nCHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\nCHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\nyr_parser_emit(yyscanner, OP_SHR, NULL);\n(yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n(yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n}\n#line 3700 \"grammar.c\"\nbreak;\ncase 122:\n#line 1944 \"grammar.y\"\n{\n(yyval.expression) = (yyvsp[0].expression);\n}\n#line 3708 \"grammar.c\"\nbreak;\n#line 3712 \"grammar.c\"\ndefault: break;\n}\nYY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\nYYPOPSTACK (yylen);\nyylen = 0;\nYY_STACK_PRINT (yyss, yyssp);\n*++yyvsp = yyval;\nyyn = yyr1[yyn];\nyystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\nif (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\nyystate = yytable[yystate];\nelse\nyystate = yydefgoto[yyn - YYNTOKENS];\ngoto yynewstate;\nyyerrlab:\nyytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\nif (!yyerrstatus)\n{\n++yynerrs;\n#if ! YYERROR_VERBOSE\nyyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\nyyssp, yytoken)\n{\nchar const *yymsgp = YY_(\"syntax error\");\nint yysyntax_error_status;\nyysyntax_error_status = YYSYNTAX_ERROR;\nif (yysyntax_error_status == 0)\nyymsgp = yymsg;\nelse if (yysyntax_error_status == 1)\n{\nif (yymsg != yymsgbuf)\nYYSTACK_FREE (yymsg);\nyymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\nif (!yymsg)\n{\nyymsg = yymsgbuf;\nyymsg_alloc = sizeof yymsgbuf;\nyysyntax_error_status = 2;\n}\nelse\n{\nyysyntax_error_status = YYSYNTAX_ERROR;\nyymsgp = yymsg;\n}\n}\nyyerror (yyscanner, compiler, yymsgp);\nif (yysyntax_error_status == 2)\ngoto yyexhaustedlab;\n}\n# undef YYSYNTAX_ERROR\n#endif\n}\nif (yyerrstatus == 3)\n{\nif (yychar <= YYEOF)\n{\nif (yychar == YYEOF)\nYYABORT;\n}\nelse\n{\nyydestruct (\"Error: discarding\",\nyytoken, &yylval, yyscanner, compiler);\nyychar = YYEMPTY;\n}\n}\ngoto yyerrlab1;\nyyerrorlab:\nif (  0)\ngoto yyerrorlab;\nYYPOPSTACK (yylen);\nyylen = 0;\nYY_STACK_PRINT (yyss, yyssp);\nyystate = *yyssp;\ngoto yyerrlab1;\nyyerrlab1:\nyyerrstatus = 3;\nfor (;;)\n{\nyyn = yypact[yystate];\nif (!yypact_value_is_default (yyn))\n{\nyyn += YYTERROR;\nif (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n{\nyyn = yytable[yyn];\nif (0 < yyn)\nbreak;\n}\n}\nif (yyssp == yyss)\nYYABORT;\nyydestruct (\"Error: popping\",\nyystos[yystate], yyvsp, yyscanner, compiler);\nYYPOPSTACK (1);\nyystate = *yyssp;\nYY_STACK_PRINT (yyss, yyssp);\n}\nYY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n*++yyvsp = yylval;\nYY_IGNORE_MAYBE_UNINITIALIZED_END\nYY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\nyystate = yyn;\ngoto yynewstate;\nyyacceptlab:\nyyresult = 0;\ngoto yyreturn;\nyyabortlab:\nyyresult = 1;\ngoto yyreturn;\n#if !defined yyoverflow || YYERROR_VERBOSE\nyyexhaustedlab:\nyyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\nyyresult = 2;\n#endif\nyyreturn:\nif (yychar != YYEMPTY)\n{\nyytoken = YYTRANSLATE (yychar);\nyydestruct (\"Cleanup: discarding lookahead\",\nyytoken, &yylval, yyscanner, compiler);\n}\nYYPOPSTACK (yylen);\nYY_STACK_PRINT (yyss, yyssp);\nwhile (yyssp != yyss)\n{\nyydestruct (\"Cleanup: popping\",\nyystos[*yyssp], yyvsp, yyscanner, compiler);\nYYPOPSTACK (1);\n}\n#ifndef yyoverflow\nif (yyss != yyssa)\nYYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\nif (yymsg != yymsgbuf)\nYYSTACK_FREE (yymsg);\n#endif\nreturn yyresult;\n}", "label": 0}
{"index": 177533, "code": "key_ref_t key_create_or_update(key_ref_t keyring_ref,\nconst char *type,\nconst char *description,\nconst void *payload,\nsize_t plen,\nkey_perm_t perm,\nunsigned long flags)\n{\nstruct keyring_index_key index_key = {\n.description\t= description,\n};\nstruct key_preparsed_payload prep;\nstruct assoc_array_edit *edit;\nconst struct cred *cred = current_cred();\nstruct key *keyring, *key = NULL;\nkey_ref_t key_ref;\nint ret;\nindex_key.type = key_type_lookup(type);\nif (IS_ERR(index_key.type)) {\nkey_ref = ERR_PTR(-ENODEV);\ngoto error;\n}\nkey_ref = ERR_PTR(-EINVAL);\nif (!index_key.type->match || !index_key.type->instantiate ||\n(!index_key.description && !index_key.type->preparse))\ngoto error_put_type;\nkeyring = key_ref_to_ptr(keyring_ref);\nkey_check(keyring);\nkey_ref = ERR_PTR(-ENOTDIR);\nif (keyring->type != &key_type_keyring)\ngoto error_put_type;\nmemset(&prep, 0, sizeof(prep));\nprep.data = payload;\nprep.datalen = plen;\nprep.quotalen = index_key.type->def_datalen;\nprep.trusted = flags & KEY_ALLOC_TRUSTED;\nprep.expiry = TIME_T_MAX;\nif (index_key.type->preparse) {\nret = index_key.type->preparse(&prep);\nif (ret < 0) {\nkey_ref = ERR_PTR(ret);\ngoto error_free_prep;\n}\nif (!index_key.description)\nindex_key.description = prep.description;\nkey_ref = ERR_PTR(-EINVAL);\nif (!index_key.description)\ngoto error_free_prep;\n}\nindex_key.desc_len = strlen(index_key.description);\nkey_ref = ERR_PTR(-EPERM);\nif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\ngoto error_free_prep;\nflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\nret = __key_link_begin(keyring, &index_key, &edit);\nif (ret < 0) {\nkey_ref = ERR_PTR(ret);\ngoto error_free_prep;\n}\nret = key_permission(keyring_ref, KEY_NEED_WRITE);\nif (ret < 0) {\nkey_ref = ERR_PTR(ret);\ngoto error_link_end;\n}\nif (index_key.type->update) {\nkey_ref = find_key_to_update(keyring_ref, &index_key);\nif (key_ref)\ngoto found_matching_key;\n}\nif (perm == KEY_PERM_UNDEF) {\nperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\nperm |= KEY_USR_VIEW;\nif (index_key.type->read)\nperm |= KEY_POS_READ;\nif (index_key.type == &key_type_keyring ||\nindex_key.type->update)\nperm |= KEY_POS_WRITE;\n}\nkey = key_alloc(index_key.type, index_key.description,\ncred->fsuid, cred->fsgid, cred, perm, flags);\nif (IS_ERR(key)) {\nkey_ref = ERR_CAST(key);\ngoto error_link_end;\n}\nret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\nif (ret < 0) {\nkey_put(key);\nkey_ref = ERR_PTR(ret);\ngoto error_link_end;\n}\nkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\nerror_link_end:\n__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\nif (index_key.type->preparse)\nindex_key.type->free_preparse(&prep);\nerror_put_type:\nkey_type_put(index_key.type);\nerror:\nreturn key_ref;\nfound_matching_key:\n__key_link_end(keyring, &index_key, edit);\nkey_ref = __key_update(key_ref, &prep);\ngoto error_free_prep;\n}", "contrast": "key_ref_t key_create_or_update(key_ref_t keyring_ref,\nconst char *type,\nconst char *description,\nconst void *payload,\nsize_t plen,\nkey_perm_t perm,\nunsigned long flags)\n{\nstruct keyring_index_key index_key = {\n.description\t= description,\n};\nstruct key_preparsed_payload prep;\nstruct assoc_array_edit *edit;\nconst struct cred *cred = current_cred();\nstruct key *keyring, *key = NULL;\nkey_ref_t key_ref;\nint ret;\nindex_key.type = key_type_lookup(type);\nif (IS_ERR(index_key.type)) {\nkey_ref = ERR_PTR(-ENODEV);\ngoto error;\n}\nkey_ref = ERR_PTR(-EINVAL);\nif (!index_key.type->instantiate ||\n(!index_key.description && !index_key.type->preparse))\ngoto error_put_type;\nkeyring = key_ref_to_ptr(keyring_ref);\nkey_check(keyring);\nkey_ref = ERR_PTR(-ENOTDIR);\nif (keyring->type != &key_type_keyring)\ngoto error_put_type;\nmemset(&prep, 0, sizeof(prep));\nprep.data = payload;\nprep.datalen = plen;\nprep.quotalen = index_key.type->def_datalen;\nprep.trusted = flags & KEY_ALLOC_TRUSTED;\nprep.expiry = TIME_T_MAX;\nif (index_key.type->preparse) {\nret = index_key.type->preparse(&prep);\nif (ret < 0) {\nkey_ref = ERR_PTR(ret);\ngoto error_free_prep;\n}\nif (!index_key.description)\nindex_key.description = prep.description;\nkey_ref = ERR_PTR(-EINVAL);\nif (!index_key.description)\ngoto error_free_prep;\n}\nindex_key.desc_len = strlen(index_key.description);\nkey_ref = ERR_PTR(-EPERM);\nif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\ngoto error_free_prep;\nflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\nret = __key_link_begin(keyring, &index_key, &edit);\nif (ret < 0) {\nkey_ref = ERR_PTR(ret);\ngoto error_free_prep;\n}\nret = key_permission(keyring_ref, KEY_NEED_WRITE);\nif (ret < 0) {\nkey_ref = ERR_PTR(ret);\ngoto error_link_end;\n}\nif (index_key.type->update) {\nkey_ref = find_key_to_update(keyring_ref, &index_key);\nif (key_ref)\ngoto found_matching_key;\n}\nif (perm == KEY_PERM_UNDEF) {\nperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\nperm |= KEY_USR_VIEW;\nif (index_key.type->read)\nperm |= KEY_POS_READ;\nif (index_key.type == &key_type_keyring ||\nindex_key.type->update)\nperm |= KEY_POS_WRITE;\n}\nkey = key_alloc(index_key.type, index_key.description,\ncred->fsuid, cred->fsgid, cred, perm, flags);\nif (IS_ERR(key)) {\nkey_ref = ERR_CAST(key);\ngoto error_link_end;\n}\nret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\nif (ret < 0) {\nkey_put(key);\nkey_ref = ERR_PTR(ret);\ngoto error_link_end;\n}\nkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\nerror_link_end:\n__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\nif (index_key.type->preparse)\nindex_key.type->free_preparse(&prep);\nerror_put_type:\nkey_type_put(index_key.type);\nerror:\nreturn key_ref;\nfound_matching_key:\n__key_link_end(keyring, &index_key, edit);\nkey_ref = __key_update(key_ref, &prep);\ngoto error_free_prep;\n}", "label": 0}
{"index": 177537, "code": "int user_match(const struct key *key, const struct key_match_data *match_data)\n{\nreturn strcmp(key->description, match_data->raw_data) == 0;\n}", "contrast": "int user_match(const struct key *key, const struct key_match_data *match_data)", "label": 0}
{"index": 177544, "code": "connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ,\nedge_connection_t *conn,\ncrypt_path_t *layer_hint)\n{\nstatic int num_seen=0;\nrelay_header_t rh;\nunsigned domain = layer_hint?LD_APP:LD_EXIT;\nint reason;\nint optimistic_data = 0;\ntor_assert(cell);\ntor_assert(circ);\nrelay_header_unpack(&rh, cell->payload);\nnum_seen++;\nlog_debug(domain, \"Now seen %d relay cells here (command %d, stream %d).\",\nnum_seen, rh.command, rh.stream_id);\nif (rh.length > RELAY_PAYLOAD_SIZE) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Relay cell length field too long. Closing circuit.\");\nreturn - END_CIRC_REASON_TORPROTOCOL;\n}\nif (rh.stream_id == 0) {\nswitch (rh.command) {\ncase RELAY_COMMAND_BEGIN:\ncase RELAY_COMMAND_CONNECTED:\ncase RELAY_COMMAND_DATA:\ncase RELAY_COMMAND_END:\ncase RELAY_COMMAND_RESOLVE:\ncase RELAY_COMMAND_RESOLVED:\ncase RELAY_COMMAND_BEGIN_DIR:\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL, \"Relay command %d with zero \"\n\"stream_id. Dropping.\", (int)rh.command);\nreturn 0;\ndefault:\n;\n}\n}\nif (conn && !connection_state_is_open(TO_CONN(conn))) {\nif (conn->base_.type == CONN_TYPE_EXIT &&\n(conn->base_.state == EXIT_CONN_STATE_CONNECTING ||\nconn->base_.state == EXIT_CONN_STATE_RESOLVING) &&\nrh.command == RELAY_COMMAND_DATA) {\noptimistic_data = 1;\n} else {\nreturn connection_edge_process_relay_cell_not_open(\n&rh, cell, circ, conn, layer_hint);\n}\n}\nswitch (rh.command) {\ncase RELAY_COMMAND_DROP:\nreturn 0;\ncase RELAY_COMMAND_BEGIN:\ncase RELAY_COMMAND_BEGIN_DIR:\nif (layer_hint &&\ncirc->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"Relay begin request unsupported at AP. Dropping.\");\nreturn 0;\n}\nif (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED &&\nlayer_hint != TO_ORIGIN_CIRCUIT(circ)->cpath->prev) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"Relay begin request to Hidden Service \"\n\"from intermediary node. Dropping.\");\nreturn 0;\n}\nif (conn) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"Begin cell for known stream. Dropping.\");\nreturn 0;\n}\nif (rh.command == RELAY_COMMAND_BEGIN_DIR) {\nstatic uint64_t next_id = 0;\ncirc->dirreq_id = ++next_id;\nTO_OR_CIRCUIT(circ)->p_chan->dirreq_id = circ->dirreq_id;\n}\nreturn connection_exit_begin_conn(cell, circ);\ncase RELAY_COMMAND_DATA:\n++stats_n_data_cells_received;\nif (( layer_hint && --layer_hint->deliver_window < 0) ||\n(!layer_hint && --circ->deliver_window < 0)) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"(relay data) circ deliver_window below 0. Killing.\");\nif (conn) {\nconnection_edge_end(conn, END_STREAM_REASON_TORPROTOCOL);\nconnection_mark_for_close(TO_CONN(conn));\n}\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlog_debug(domain,\"circ deliver_window now %d.\", layer_hint ?\nlayer_hint->deliver_window : circ->deliver_window);\ncircuit_consider_sending_sendme(circ, layer_hint);\nif (!conn) {\nlog_info(domain,\"data cell dropped, unknown stream (streamid %d).\",\nrh.stream_id);\nreturn 0;\n}\nif (--conn->deliver_window < 0) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"(relay data) conn deliver_window below 0. Killing.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nstats_n_data_bytes_received += rh.length;\nconnection_write_to_buf((char*)(cell->payload + RELAY_HEADER_SIZE),\nrh.length, TO_CONN(conn));\nif (!optimistic_data) {\nconnection_edge_consider_sending_sendme(conn);\n}\nreturn 0;\ncase RELAY_COMMAND_END:\nreason = rh.length > 0 ?\nget_uint8(cell->payload+RELAY_HEADER_SIZE) : END_STREAM_REASON_MISC;\nif (!conn) {\nlog_info(domain,\"end cell (%s) dropped, unknown stream.\",\nstream_end_reason_to_string(reason));\nreturn 0;\n}\nlog_info(domain,TOR_SOCKET_T_FORMAT\": end cell (%s) for stream %d. \"\n\"Removing stream.\",\nconn->base_.s,\nstream_end_reason_to_string(reason),\nconn->stream_id);\nif (conn->base_.type == CONN_TYPE_AP) {\nentry_connection_t *entry_conn = EDGE_TO_ENTRY_CONN(conn);\nif (entry_conn->socks_request &&\n!entry_conn->socks_request->has_finished)\nlog_warn(LD_BUG,\n\"open stream hasn't sent socks answer yet? Closing.\");\n}\nconn->edge_has_sent_end = 1;\nif (!conn->end_reason)\nconn->end_reason = reason | END_STREAM_REASON_FLAG_REMOTE;\nif (!conn->base_.marked_for_close) {\nconnection_mark_and_flush(TO_CONN(conn));\n}\nreturn 0;\ncase RELAY_COMMAND_EXTEND:\ncase RELAY_COMMAND_EXTEND2: {\nstatic uint64_t total_n_extend=0, total_nonearly=0;\ntotal_n_extend++;\nif (rh.stream_id) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"'extend' cell received for non-zero stream. Dropping.\");\nreturn 0;\n}\nif (cell->command != CELL_RELAY_EARLY &&\n!networkstatus_get_param(NULL,\"AllowNonearlyExtend\",0,0,1)) {\n#define EARLY_WARNING_INTERVAL 3600\nstatic ratelim_t early_warning_limit =\nRATELIM_INIT(EARLY_WARNING_INTERVAL);\nchar *m;\nif (cell->command == CELL_RELAY) {\n++total_nonearly;\nif ((m = rate_limit_log(&early_warning_limit, approx_time()))) {\ndouble percentage = ((double)total_nonearly)/total_n_extend;\npercentage *= 100;\nlog_fn(LOG_PROTOCOL_WARN, domain, \"EXTEND cell received, \"\n\"but not via RELAY_EARLY. Dropping.%s\", m);\nlog_fn(LOG_PROTOCOL_WARN, domain, \"  (We have dropped %.02f%% of \"\n\"all EXTEND cells for this reason)\", percentage);\ntor_free(m);\n}\n} else {\nlog_fn(LOG_WARN, domain,\n\"EXTEND cell received, in a cell with type %d! Dropping.\",\ncell->command);\n}\nreturn 0;\n}\nreturn circuit_extend(cell, circ);\n}\ncase RELAY_COMMAND_EXTENDED:\ncase RELAY_COMMAND_EXTENDED2:\nif (!layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"'extended' unsupported at non-origin. Dropping.\");\nreturn 0;\n}\nlog_debug(domain,\"Got an extended cell! Yay.\");\n{\nextended_cell_t extended_cell;\nif (extended_cell_parse(&extended_cell, rh.command,\n(const uint8_t*)cell->payload+RELAY_HEADER_SIZE,\nrh.length)<0) {\nlog_warn(LD_PROTOCOL,\n\"Can't parse EXTENDED cell; killing circuit.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nif ((reason = circuit_finish_handshake(TO_ORIGIN_CIRCUIT(circ),\n&extended_cell.created_cell)) < 0) {\nlog_warn(domain,\"circuit_finish_handshake failed.\");\nreturn reason;\n}\n}\nif ((reason=circuit_send_next_onion_skin(TO_ORIGIN_CIRCUIT(circ)))<0) {\nlog_info(domain,\"circuit_send_next_onion_skin() failed.\");\nreturn reason;\n}\nreturn 0;\ncase RELAY_COMMAND_TRUNCATE:\nif (layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"'truncate' unsupported at origin. Dropping.\");\nreturn 0;\n}\nif (circ->n_hop) {\nif (circ->n_chan)\nlog_warn(LD_BUG, \"n_chan and n_hop set on the same circuit!\");\nextend_info_free(circ->n_hop);\ncirc->n_hop = NULL;\ntor_free(circ->n_chan_create_cell);\ncircuit_set_state(circ, CIRCUIT_STATE_OPEN);\n}\nif (circ->n_chan) {\nuint8_t trunc_reason = get_uint8(cell->payload + RELAY_HEADER_SIZE);\ncircuit_clear_cell_queue(circ, circ->n_chan);\nchannel_send_destroy(circ->n_circ_id, circ->n_chan,\ntrunc_reason);\ncircuit_set_n_circid_chan(circ, 0, NULL);\n}\nlog_debug(LD_EXIT, \"Processed 'truncate', replying.\");\n{\nchar payload[1];\npayload[0] = (char)END_CIRC_REASON_REQUESTED;\nrelay_send_command_from_edge(0, circ, RELAY_COMMAND_TRUNCATED,\npayload, sizeof(payload), NULL);\n}\nreturn 0;\ncase RELAY_COMMAND_TRUNCATED:\nif (!layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_EXIT,\n\"'truncated' unsupported at non-origin. Dropping.\");\nreturn 0;\n}\ncircuit_truncated(TO_ORIGIN_CIRCUIT(circ), layer_hint,\nget_uint8(cell->payload + RELAY_HEADER_SIZE));\nreturn 0;\ncase RELAY_COMMAND_CONNECTED:\nif (conn) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"'connected' unsupported while open. Closing circ.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlog_info(domain,\n\"'connected' received, no conn attached anymore. Ignoring.\");\nreturn 0;\ncase RELAY_COMMAND_SENDME:\nif (!rh.stream_id) {\nif (layer_hint) {\nif (layer_hint->package_window + CIRCWINDOW_INCREMENT >\nCIRCWINDOW_START_MAX) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Unexpected sendme cell from exit relay. \"\n\"Closing circ.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlayer_hint->package_window += CIRCWINDOW_INCREMENT;\nlog_debug(LD_APP,\"circ-level sendme at origin, packagewindow %d.\",\nlayer_hint->package_window);\ncircuit_resume_edge_reading(circ, layer_hint);\n} else {\nif (circ->package_window + CIRCWINDOW_INCREMENT >\nCIRCWINDOW_START_MAX) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Unexpected sendme cell from client. \"\n\"Closing circ (window %d).\",\ncirc->package_window);\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\ncirc->package_window += CIRCWINDOW_INCREMENT;\nlog_debug(LD_APP,\n\"circ-level sendme at non-origin, packagewindow %d.\",\ncirc->package_window);\ncircuit_resume_edge_reading(circ, layer_hint);\n}\nreturn 0;\n}\nif (!conn) {\nlog_info(domain,\"sendme cell dropped, unknown stream (streamid %d).\",\nrh.stream_id);\nreturn 0;\n}\nconn->package_window += STREAMWINDOW_INCREMENT;\nlog_debug(domain,\"stream-level sendme, packagewindow now %d.\",\nconn->package_window);\nif (circuit_queue_streams_are_blocked(circ)) {\nreturn 0;\n}\nconnection_start_reading(TO_CONN(conn));\nif (connection_edge_package_raw_inbuf(conn, 1, NULL) < 0) {\nconnection_mark_for_close(TO_CONN(conn));\nreturn 0;\n}\nreturn 0;\ncase RELAY_COMMAND_RESOLVE:\nif (layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"resolve request unsupported at AP; dropping.\");\nreturn 0;\n} else if (conn) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"resolve request for known stream; dropping.\");\nreturn 0;\n} else if (circ->purpose != CIRCUIT_PURPOSE_OR) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"resolve request on circ with purpose %d; dropping\",\ncirc->purpose);\nreturn 0;\n}\nconnection_exit_begin_resolve(cell, TO_OR_CIRCUIT(circ));\nreturn 0;\ncase RELAY_COMMAND_RESOLVED:\nif (conn) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"'resolved' unsupported while open. Closing circ.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlog_info(domain,\n\"'resolved' received, no conn attached anymore. Ignoring.\");\nreturn 0;\ncase RELAY_COMMAND_ESTABLISH_INTRO:\ncase RELAY_COMMAND_ESTABLISH_RENDEZVOUS:\ncase RELAY_COMMAND_INTRODUCE1:\ncase RELAY_COMMAND_INTRODUCE2:\ncase RELAY_COMMAND_INTRODUCE_ACK:\ncase RELAY_COMMAND_RENDEZVOUS1:\ncase RELAY_COMMAND_RENDEZVOUS2:\ncase RELAY_COMMAND_INTRO_ESTABLISHED:\ncase RELAY_COMMAND_RENDEZVOUS_ESTABLISHED:\nrend_process_relay_cell(circ, layer_hint,\nrh.command, rh.length,\ncell->payload+RELAY_HEADER_SIZE);\nreturn 0;\n}\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Received unknown relay command %d. Perhaps the other side is using \"\n\"a newer version of Tor? Dropping.\",\nrh.command);\nreturn 0;\n}", "contrast": "connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ,\nedge_connection_t *conn,\ncrypt_path_t *layer_hint)\n{\nstatic int num_seen=0;\nrelay_header_t rh;\nunsigned domain = layer_hint?LD_APP:LD_EXIT;\nint reason;\nint optimistic_data = 0;\ntor_assert(cell);\ntor_assert(circ);\nrelay_header_unpack(&rh, cell->payload);\nnum_seen++;\nlog_debug(domain, \"Now seen %d relay cells here (command %d, stream %d).\",\nnum_seen, rh.command, rh.stream_id);\nif (rh.length > RELAY_PAYLOAD_SIZE) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Relay cell length field too long. Closing circuit.\");\nreturn - END_CIRC_REASON_TORPROTOCOL;\n}\nif (rh.stream_id == 0) {\nswitch (rh.command) {\ncase RELAY_COMMAND_BEGIN:\ncase RELAY_COMMAND_CONNECTED:\ncase RELAY_COMMAND_DATA:\ncase RELAY_COMMAND_END:\ncase RELAY_COMMAND_RESOLVE:\ncase RELAY_COMMAND_RESOLVED:\ncase RELAY_COMMAND_BEGIN_DIR:\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL, \"Relay command %d with zero \"\n\"stream_id. Dropping.\", (int)rh.command);\nreturn 0;\ndefault:\n;\n}\n}\nif (conn && !connection_state_is_open(TO_CONN(conn))) {\nif (conn->base_.type == CONN_TYPE_EXIT &&\n(conn->base_.state == EXIT_CONN_STATE_CONNECTING ||\nconn->base_.state == EXIT_CONN_STATE_RESOLVING) &&\nrh.command == RELAY_COMMAND_DATA) {\noptimistic_data = 1;\n} else {\nreturn connection_edge_process_relay_cell_not_open(\n&rh, cell, circ, conn, layer_hint);\n}\n}\nswitch (rh.command) {\ncase RELAY_COMMAND_DROP:\nreturn 0;\ncase RELAY_COMMAND_BEGIN:\ncase RELAY_COMMAND_BEGIN_DIR:\nif (layer_hint &&\ncirc->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"Relay begin request unsupported at AP. Dropping.\");\nreturn 0;\n}\nif (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED &&\nlayer_hint != TO_ORIGIN_CIRCUIT(circ)->cpath->prev) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"Relay begin request to Hidden Service \"\n\"from intermediary node. Dropping.\");\nreturn 0;\n}\nif (conn) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"Begin cell for known stream. Dropping.\");\nreturn 0;\n}\nif (rh.command == RELAY_COMMAND_BEGIN_DIR &&\ncirc->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\nstatic uint64_t next_id = 0;\ncirc->dirreq_id = ++next_id;\nTO_OR_CIRCUIT(circ)->p_chan->dirreq_id = circ->dirreq_id;\n}\nreturn connection_exit_begin_conn(cell, circ);\ncase RELAY_COMMAND_DATA:\n++stats_n_data_cells_received;\nif (( layer_hint && --layer_hint->deliver_window < 0) ||\n(!layer_hint && --circ->deliver_window < 0)) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"(relay data) circ deliver_window below 0. Killing.\");\nif (conn) {\nconnection_edge_end(conn, END_STREAM_REASON_TORPROTOCOL);\nconnection_mark_for_close(TO_CONN(conn));\n}\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlog_debug(domain,\"circ deliver_window now %d.\", layer_hint ?\nlayer_hint->deliver_window : circ->deliver_window);\ncircuit_consider_sending_sendme(circ, layer_hint);\nif (!conn) {\nlog_info(domain,\"data cell dropped, unknown stream (streamid %d).\",\nrh.stream_id);\nreturn 0;\n}\nif (--conn->deliver_window < 0) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"(relay data) conn deliver_window below 0. Killing.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nstats_n_data_bytes_received += rh.length;\nconnection_write_to_buf((char*)(cell->payload + RELAY_HEADER_SIZE),\nrh.length, TO_CONN(conn));\nif (!optimistic_data) {\nconnection_edge_consider_sending_sendme(conn);\n}\nreturn 0;\ncase RELAY_COMMAND_END:\nreason = rh.length > 0 ?\nget_uint8(cell->payload+RELAY_HEADER_SIZE) : END_STREAM_REASON_MISC;\nif (!conn) {\nlog_info(domain,\"end cell (%s) dropped, unknown stream.\",\nstream_end_reason_to_string(reason));\nreturn 0;\n}\nlog_info(domain,TOR_SOCKET_T_FORMAT\": end cell (%s) for stream %d. \"\n\"Removing stream.\",\nconn->base_.s,\nstream_end_reason_to_string(reason),\nconn->stream_id);\nif (conn->base_.type == CONN_TYPE_AP) {\nentry_connection_t *entry_conn = EDGE_TO_ENTRY_CONN(conn);\nif (entry_conn->socks_request &&\n!entry_conn->socks_request->has_finished)\nlog_warn(LD_BUG,\n\"open stream hasn't sent socks answer yet? Closing.\");\n}\nconn->edge_has_sent_end = 1;\nif (!conn->end_reason)\nconn->end_reason = reason | END_STREAM_REASON_FLAG_REMOTE;\nif (!conn->base_.marked_for_close) {\nconnection_mark_and_flush(TO_CONN(conn));\n}\nreturn 0;\ncase RELAY_COMMAND_EXTEND:\ncase RELAY_COMMAND_EXTEND2: {\nstatic uint64_t total_n_extend=0, total_nonearly=0;\ntotal_n_extend++;\nif (rh.stream_id) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"'extend' cell received for non-zero stream. Dropping.\");\nreturn 0;\n}\nif (cell->command != CELL_RELAY_EARLY &&\n!networkstatus_get_param(NULL,\"AllowNonearlyExtend\",0,0,1)) {\n#define EARLY_WARNING_INTERVAL 3600\nstatic ratelim_t early_warning_limit =\nRATELIM_INIT(EARLY_WARNING_INTERVAL);\nchar *m;\nif (cell->command == CELL_RELAY) {\n++total_nonearly;\nif ((m = rate_limit_log(&early_warning_limit, approx_time()))) {\ndouble percentage = ((double)total_nonearly)/total_n_extend;\npercentage *= 100;\nlog_fn(LOG_PROTOCOL_WARN, domain, \"EXTEND cell received, \"\n\"but not via RELAY_EARLY. Dropping.%s\", m);\nlog_fn(LOG_PROTOCOL_WARN, domain, \"  (We have dropped %.02f%% of \"\n\"all EXTEND cells for this reason)\", percentage);\ntor_free(m);\n}\n} else {\nlog_fn(LOG_WARN, domain,\n\"EXTEND cell received, in a cell with type %d! Dropping.\",\ncell->command);\n}\nreturn 0;\n}\nreturn circuit_extend(cell, circ);\n}\ncase RELAY_COMMAND_EXTENDED:\ncase RELAY_COMMAND_EXTENDED2:\nif (!layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"'extended' unsupported at non-origin. Dropping.\");\nreturn 0;\n}\nlog_debug(domain,\"Got an extended cell! Yay.\");\n{\nextended_cell_t extended_cell;\nif (extended_cell_parse(&extended_cell, rh.command,\n(const uint8_t*)cell->payload+RELAY_HEADER_SIZE,\nrh.length)<0) {\nlog_warn(LD_PROTOCOL,\n\"Can't parse EXTENDED cell; killing circuit.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nif ((reason = circuit_finish_handshake(TO_ORIGIN_CIRCUIT(circ),\n&extended_cell.created_cell)) < 0) {\nlog_warn(domain,\"circuit_finish_handshake failed.\");\nreturn reason;\n}\n}\nif ((reason=circuit_send_next_onion_skin(TO_ORIGIN_CIRCUIT(circ)))<0) {\nlog_info(domain,\"circuit_send_next_onion_skin() failed.\");\nreturn reason;\n}\nreturn 0;\ncase RELAY_COMMAND_TRUNCATE:\nif (layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"'truncate' unsupported at origin. Dropping.\");\nreturn 0;\n}\nif (circ->n_hop) {\nif (circ->n_chan)\nlog_warn(LD_BUG, \"n_chan and n_hop set on the same circuit!\");\nextend_info_free(circ->n_hop);\ncirc->n_hop = NULL;\ntor_free(circ->n_chan_create_cell);\ncircuit_set_state(circ, CIRCUIT_STATE_OPEN);\n}\nif (circ->n_chan) {\nuint8_t trunc_reason = get_uint8(cell->payload + RELAY_HEADER_SIZE);\ncircuit_clear_cell_queue(circ, circ->n_chan);\nchannel_send_destroy(circ->n_circ_id, circ->n_chan,\ntrunc_reason);\ncircuit_set_n_circid_chan(circ, 0, NULL);\n}\nlog_debug(LD_EXIT, \"Processed 'truncate', replying.\");\n{\nchar payload[1];\npayload[0] = (char)END_CIRC_REASON_REQUESTED;\nrelay_send_command_from_edge(0, circ, RELAY_COMMAND_TRUNCATED,\npayload, sizeof(payload), NULL);\n}\nreturn 0;\ncase RELAY_COMMAND_TRUNCATED:\nif (!layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_EXIT,\n\"'truncated' unsupported at non-origin. Dropping.\");\nreturn 0;\n}\ncircuit_truncated(TO_ORIGIN_CIRCUIT(circ), layer_hint,\nget_uint8(cell->payload + RELAY_HEADER_SIZE));\nreturn 0;\ncase RELAY_COMMAND_CONNECTED:\nif (conn) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"'connected' unsupported while open. Closing circ.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlog_info(domain,\n\"'connected' received, no conn attached anymore. Ignoring.\");\nreturn 0;\ncase RELAY_COMMAND_SENDME:\nif (!rh.stream_id) {\nif (layer_hint) {\nif (layer_hint->package_window + CIRCWINDOW_INCREMENT >\nCIRCWINDOW_START_MAX) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Unexpected sendme cell from exit relay. \"\n\"Closing circ.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlayer_hint->package_window += CIRCWINDOW_INCREMENT;\nlog_debug(LD_APP,\"circ-level sendme at origin, packagewindow %d.\",\nlayer_hint->package_window);\ncircuit_resume_edge_reading(circ, layer_hint);\n} else {\nif (circ->package_window + CIRCWINDOW_INCREMENT >\nCIRCWINDOW_START_MAX) {\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Unexpected sendme cell from client. \"\n\"Closing circ (window %d).\",\ncirc->package_window);\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\ncirc->package_window += CIRCWINDOW_INCREMENT;\nlog_debug(LD_APP,\n\"circ-level sendme at non-origin, packagewindow %d.\",\ncirc->package_window);\ncircuit_resume_edge_reading(circ, layer_hint);\n}\nreturn 0;\n}\nif (!conn) {\nlog_info(domain,\"sendme cell dropped, unknown stream (streamid %d).\",\nrh.stream_id);\nreturn 0;\n}\nconn->package_window += STREAMWINDOW_INCREMENT;\nlog_debug(domain,\"stream-level sendme, packagewindow now %d.\",\nconn->package_window);\nif (circuit_queue_streams_are_blocked(circ)) {\nreturn 0;\n}\nconnection_start_reading(TO_CONN(conn));\nif (connection_edge_package_raw_inbuf(conn, 1, NULL) < 0) {\nconnection_mark_for_close(TO_CONN(conn));\nreturn 0;\n}\nreturn 0;\ncase RELAY_COMMAND_RESOLVE:\nif (layer_hint) {\nlog_fn(LOG_PROTOCOL_WARN, LD_APP,\n\"resolve request unsupported at AP; dropping.\");\nreturn 0;\n} else if (conn) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"resolve request for known stream; dropping.\");\nreturn 0;\n} else if (circ->purpose != CIRCUIT_PURPOSE_OR) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"resolve request on circ with purpose %d; dropping\",\ncirc->purpose);\nreturn 0;\n}\nconnection_exit_begin_resolve(cell, TO_OR_CIRCUIT(circ));\nreturn 0;\ncase RELAY_COMMAND_RESOLVED:\nif (conn) {\nlog_fn(LOG_PROTOCOL_WARN, domain,\n\"'resolved' unsupported while open. Closing circ.\");\nreturn -END_CIRC_REASON_TORPROTOCOL;\n}\nlog_info(domain,\n\"'resolved' received, no conn attached anymore. Ignoring.\");\nreturn 0;\ncase RELAY_COMMAND_ESTABLISH_INTRO:\ncase RELAY_COMMAND_ESTABLISH_RENDEZVOUS:\ncase RELAY_COMMAND_INTRODUCE1:\ncase RELAY_COMMAND_INTRODUCE2:\ncase RELAY_COMMAND_INTRODUCE_ACK:\ncase RELAY_COMMAND_RENDEZVOUS1:\ncase RELAY_COMMAND_RENDEZVOUS2:\ncase RELAY_COMMAND_INTRO_ESTABLISHED:\ncase RELAY_COMMAND_RENDEZVOUS_ESTABLISHED:\nrend_process_relay_cell(circ, layer_hint,\nrh.command, rh.length,\ncell->payload+RELAY_HEADER_SIZE);\nreturn 0;\n}\nlog_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n\"Received unknown relay command %d. Perhaps the other side is using \"\n\"a newer version of Tor? Dropping.\",\nrh.command);\nreturn 0;\n}", "label": 0}
{"index": 177551, "code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\nregister char *cp;\nsize_t memory_length;\nsize_t available_length;\nsize_t begin_length;\nsize_t n_begin;\nsize_t q_length;\nif (!extra_length)\nreturn;\nmemory_length    = qp->d_memory_end - qp->d_memory;\nq_length =\nqp->d_read <= qp->d_write ?\n(size_t)(qp->d_write - qp->d_read)\n:\nmemory_length - (qp->d_read - qp->d_write);\navailable_length = memory_length - q_length - 1;\nif (message_show(MSG_INFO))\nmessage(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\nif (extra_length > available_length)\n{\nmemory_length += extra_length - available_length + BLOCK_QUEUE;\ncp = new_memory(memory_length, sizeof(char));\nif (message_show(MSG_INFO))\nmessage(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\nif (qp->d_read > qp->d_write)\n{\nsize_t tail_len = qp->d_memory_end - qp->d_read;\nmemcpy(cp, qp->d_read, tail_len);\nmemcpy(cp + tail_len, qp->d_memory,\n(size_t)(qp->d_write - qp->d_memory));\nqp->d_write = cp + q_length;\nqp->d_read = cp;\n}\nelse\n{\nmemcpy(cp, qp->d_memory, memory_length);\nqp->d_read = cp + (qp->d_read - qp->d_memory);\nqp->d_write = cp + (qp->d_write - qp->d_memory);\n}\nfree(qp->d_memory);\nqp->d_memory_end = cp + memory_length;\nqp->d_memory = cp;\n}\nbegin_length = qp->d_read - qp->d_memory;\nn_begin = extra_length <= begin_length ?\nextra_length\n:\nbegin_length;\nmemcpy\n(\nqp->d_read -= n_begin,\ninfo + extra_length - n_begin,\nn_begin\n);\nif (extra_length > begin_length)\n{\nextra_length -= begin_length;\nmemcpy\n(\nqp->d_read = qp->d_memory_end - extra_length,\ninfo,\nextra_length\n);\n}\n}", "contrast": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\nregister char *cp;\nsize_t memory_length;\nsize_t available_length;\nsize_t begin_length;\nsize_t n_begin;\nsize_t q_length;\nif (!extra_length)\nreturn;\nmemory_length    = qp->d_memory_end - qp->d_memory;\nq_length =\nqp->d_read <= qp->d_write ?\n(size_t)(qp->d_write - qp->d_read)\n:\nmemory_length - (qp->d_read - qp->d_write);\navailable_length = memory_length - q_length - 1;\nif (message_show(MSG_INFO))\nmessage(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\nif (extra_length > available_length)\n{\nsize_t original_length = memory_length;\nmemory_length += extra_length - available_length + BLOCK_QUEUE;\ncp = new_memory(memory_length, sizeof(char));\nif (message_show(MSG_INFO))\nmessage(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\nif (qp->d_read > qp->d_write)\n{\nsize_t tail_len = qp->d_memory_end - qp->d_read;\nmemcpy(cp, qp->d_read, tail_len);\nmemcpy(cp + tail_len, qp->d_memory,\n(size_t)(qp->d_write - qp->d_memory));\nqp->d_write = cp + q_length;\nqp->d_read = cp;\n}\nelse\n{\nmemcpy(cp, qp->d_memory, original_length);\nqp->d_read = cp + (qp->d_read - qp->d_memory);\nqp->d_write = cp + (qp->d_write - qp->d_memory);\n}\nfree(qp->d_memory);\nqp->d_memory_end = cp + memory_length;\nqp->d_memory = cp;\n}\nbegin_length = qp->d_read - qp->d_memory;\nn_begin = extra_length <= begin_length ?\nextra_length\n:\nbegin_length;\nmemcpy\n(\nqp->d_read -= n_begin,\ninfo + extra_length - n_begin,\nn_begin\n);\nif (extra_length > begin_length)\n{\nextra_length -= begin_length;\nmemcpy\n(\nqp->d_read = qp->d_memory_end - extra_length,\ninfo,\nextra_length\n);\n}\n}", "label": 0}
{"index": 177564, "code": "void *jas_realloc(void *ptr, size_t size)\n{\nvoid *result;\nJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\nresult = realloc(ptr, size);\nJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\nreturn result;\n}", "contrast": "void *jas_realloc(void *ptr, size_t size)\n{\nvoid *result;\nJAS_DBGLOG(101, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\nresult = realloc(ptr, size);\nJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\nreturn result;\n}", "label": 0}
{"index": 177565, "code": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\njas_matrix_t *matrix;\nint i;\nif (numrows < 0 || numcols < 0) {\nreturn 0;\n}\nif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\nreturn 0;\n}\nmatrix->flags_ = 0;\nmatrix->numrows_ = numrows;\nmatrix->numcols_ = numcols;\nmatrix->rows_ = 0;\nmatrix->maxrows_ = numrows;\nmatrix->data_ = 0;\nmatrix->datasize_ = numrows * numcols;\nif (matrix->maxrows_ > 0) {\nif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\nsizeof(jas_seqent_t *)))) {\njas_matrix_destroy(matrix);\nreturn 0;\n}\n}\nif (matrix->datasize_ > 0) {\nif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\nsizeof(jas_seqent_t)))) {\njas_matrix_destroy(matrix);\nreturn 0;\n}\n}\nfor (i = 0; i < numrows; ++i) {\nmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n}\nfor (i = 0; i < matrix->datasize_; ++i) {\nmatrix->data_[i] = 0;\n}\nmatrix->xstart_ = 0;\nmatrix->ystart_ = 0;\nmatrix->xend_ = matrix->numcols_;\nmatrix->yend_ = matrix->numrows_;\nreturn matrix;\n}", "contrast": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\njas_matrix_t *matrix;\nint i;\nsize_t size;\nmatrix = 0;\nif (numrows < 0 || numcols < 0) {\ngoto error;\n}\nif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\ngoto error;\n}\nmatrix->flags_ = 0;\nmatrix->numrows_ = numrows;\nmatrix->numcols_ = numcols;\nmatrix->rows_ = 0;\nmatrix->maxrows_ = numrows;\nmatrix->data_ = 0;\nmatrix->datasize_ = 0;\nif (!jas_safe_size_mul(numrows, numcols, &size)) {\ngoto error;\n}\nmatrix->datasize_ = size;\nif (matrix->maxrows_ > 0) {\nif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\nsizeof(jas_seqent_t *)))) {\ngoto error;\n}\n}\nif (matrix->datasize_ > 0) {\nif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\nsizeof(jas_seqent_t)))) {\ngoto error;\n}\n}\nfor (i = 0; i < numrows; ++i) {\nmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n}\nfor (i = 0; i < matrix->datasize_; ++i) {\nmatrix->data_[i] = 0;\n}\nmatrix->xstart_ = 0;\nmatrix->ystart_ = 0;\nmatrix->xend_ = matrix->numcols_;\nmatrix->yend_ = matrix->numrows_;\nreturn matrix;\nerror:\nif (matrix) {\njas_matrix_destroy(matrix);\n}\nreturn 0;\n}", "label": 0}
{"index": 177585, "code": "static int process_line(URLContext *h, char *line, int line_count,\nint *new_location)\n{\nHTTPContext *s = h->priv_data;\nconst char *auto_method =  h->flags & AVIO_FLAG_READ ? \"POST\" : \"GET\";\nchar *tag, *p, *end, *method, *resource, *version;\nint ret;\nif (line[0] == '\\0') {\ns->end_header = 1;\nreturn 0;\n}\np = line;\nif (line_count == 0) {\nif (s->is_connected_server) {\nmethod = p;\nwhile (*p && !av_isspace(*p))\np++;\n*(p++) = '\\0';\nav_log(h, AV_LOG_TRACE, \"Received method: %s\\n\", method);\nif (s->method) {\nif (av_strcasecmp(s->method, method)) {\nav_log(h, AV_LOG_ERROR, \"Received and expected HTTP method do not match. (%s expected, %s received)\\n\",\ns->method, method);\nreturn ff_http_averror(400, AVERROR(EIO));\n}\n} else {\nav_log(h, AV_LOG_TRACE, \"Autodetected %s HTTP method\\n\", auto_method);\nif (av_strcasecmp(auto_method, method)) {\nav_log(h, AV_LOG_ERROR, \"Received and autodetected HTTP method did not match \"\n\"(%s autodetected %s received)\\n\", auto_method, method);\nreturn ff_http_averror(400, AVERROR(EIO));\n}\nif (!(s->method = av_strdup(method)))\nreturn AVERROR(ENOMEM);\n}\nwhile (av_isspace(*p))\np++;\nresource = p;\nwhile (!av_isspace(*p))\np++;\n*(p++) = '\\0';\nav_log(h, AV_LOG_TRACE, \"Requested resource: %s\\n\", resource);\nif (!(s->resource = av_strdup(resource)))\nreturn AVERROR(ENOMEM);\nwhile (av_isspace(*p))\np++;\nversion = p;\nwhile (*p && !av_isspace(*p))\np++;\n*p = '\\0';\nif (av_strncasecmp(version, \"HTTP/\", 5)) {\nav_log(h, AV_LOG_ERROR, \"Malformed HTTP version string.\\n\");\nreturn ff_http_averror(400, AVERROR(EIO));\n}\nav_log(h, AV_LOG_TRACE, \"HTTP version string: %s\\n\", version);\n} else {\nwhile (!av_isspace(*p) && *p != '\\0')\np++;\nwhile (av_isspace(*p))\np++;\ns->http_code = strtol(p, &end, 10);\nav_log(h, AV_LOG_TRACE, \"http_code=%d\\n\", s->http_code);\nif ((ret = check_http_code(h, s->http_code, end)) < 0)\nreturn ret;\n}\n} else {\nwhile (*p != '\\0' && *p != ':')\np++;\nif (*p != ':')\nreturn 1;\n*p  = '\\0';\ntag = line;\np++;\nwhile (av_isspace(*p))\np++;\nif (!av_strcasecmp(tag, \"Location\")) {\nif ((ret = parse_location(s, p)) < 0)\nreturn ret;\n*new_location = 1;\n} else if (!av_strcasecmp(tag, \"Content-Length\") && s->filesize == -1) {\ns->filesize = strtoll(p, NULL, 10);\n} else if (!av_strcasecmp(tag, \"Content-Range\")) {\nparse_content_range(h, p);\n} else if (!av_strcasecmp(tag, \"Accept-Ranges\") &&\n!strncmp(p, \"bytes\", 5) &&\ns->seekable == -1) {\nh->is_streamed = 0;\n} else if (!av_strcasecmp(tag, \"Transfer-Encoding\") &&\n!av_strncasecmp(p, \"chunked\", 7)) {\ns->filesize  = -1;\ns->chunksize = 0;\n} else if (!av_strcasecmp(tag, \"WWW-Authenticate\")) {\nff_http_auth_handle_header(&s->auth_state, tag, p);\n} else if (!av_strcasecmp(tag, \"Authentication-Info\")) {\nff_http_auth_handle_header(&s->auth_state, tag, p);\n} else if (!av_strcasecmp(tag, \"Proxy-Authenticate\")) {\nff_http_auth_handle_header(&s->proxy_auth_state, tag, p);\n} else if (!av_strcasecmp(tag, \"Connection\")) {\nif (!strcmp(p, \"close\"))\ns->willclose = 1;\n} else if (!av_strcasecmp(tag, \"Server\")) {\nif (!av_strcasecmp(p, \"AkamaiGHost\")) {\ns->is_akamai = 1;\n} else if (!av_strncasecmp(p, \"MediaGateway\", 12)) {\ns->is_mediagateway = 1;\n}\n} else if (!av_strcasecmp(tag, \"Content-Type\")) {\nav_free(s->mime_type);\ns->mime_type = av_strdup(p);\n} else if (!av_strcasecmp(tag, \"Set-Cookie\")) {\nif (parse_cookie(s, p, &s->cookie_dict))\nav_log(h, AV_LOG_WARNING, \"Unable to parse '%s'\\n\", p);\n} else if (!av_strcasecmp(tag, \"Icy-MetaInt\")) {\ns->icy_metaint = strtoll(p, NULL, 10);\n} else if (!av_strncasecmp(tag, \"Icy-\", 4)) {\nif ((ret = parse_icy(s, tag, p)) < 0)\nreturn ret;\n} else if (!av_strcasecmp(tag, \"Content-Encoding\")) {\nif ((ret = parse_content_encoding(h, p)) < 0)\nreturn ret;\n}\n}\nreturn 1;\n}", "contrast": "static int process_line(URLContext *h, char *line, int line_count,\nint *new_location)\n{\nHTTPContext *s = h->priv_data;\nconst char *auto_method =  h->flags & AVIO_FLAG_READ ? \"POST\" : \"GET\";\nchar *tag, *p, *end, *method, *resource, *version;\nint ret;\nif (line[0] == '\\0') {\ns->end_header = 1;\nreturn 0;\n}\np = line;\nif (line_count == 0) {\nif (s->is_connected_server) {\nmethod = p;\nwhile (*p && !av_isspace(*p))\np++;\n*(p++) = '\\0';\nav_log(h, AV_LOG_TRACE, \"Received method: %s\\n\", method);\nif (s->method) {\nif (av_strcasecmp(s->method, method)) {\nav_log(h, AV_LOG_ERROR, \"Received and expected HTTP method do not match. (%s expected, %s received)\\n\",\ns->method, method);\nreturn ff_http_averror(400, AVERROR(EIO));\n}\n} else {\nav_log(h, AV_LOG_TRACE, \"Autodetected %s HTTP method\\n\", auto_method);\nif (av_strcasecmp(auto_method, method)) {\nav_log(h, AV_LOG_ERROR, \"Received and autodetected HTTP method did not match \"\n\"(%s autodetected %s received)\\n\", auto_method, method);\nreturn ff_http_averror(400, AVERROR(EIO));\n}\nif (!(s->method = av_strdup(method)))\nreturn AVERROR(ENOMEM);\n}\nwhile (av_isspace(*p))\np++;\nresource = p;\nwhile (!av_isspace(*p))\np++;\n*(p++) = '\\0';\nav_log(h, AV_LOG_TRACE, \"Requested resource: %s\\n\", resource);\nif (!(s->resource = av_strdup(resource)))\nreturn AVERROR(ENOMEM);\nwhile (av_isspace(*p))\np++;\nversion = p;\nwhile (*p && !av_isspace(*p))\np++;\n*p = '\\0';\nif (av_strncasecmp(version, \"HTTP/\", 5)) {\nav_log(h, AV_LOG_ERROR, \"Malformed HTTP version string.\\n\");\nreturn ff_http_averror(400, AVERROR(EIO));\n}\nav_log(h, AV_LOG_TRACE, \"HTTP version string: %s\\n\", version);\n} else {\nwhile (!av_isspace(*p) && *p != '\\0')\np++;\nwhile (av_isspace(*p))\np++;\ns->http_code = strtol(p, &end, 10);\nav_log(h, AV_LOG_TRACE, \"http_code=%d\\n\", s->http_code);\nif ((ret = check_http_code(h, s->http_code, end)) < 0)\nreturn ret;\n}\n} else {\nwhile (*p != '\\0' && *p != ':')\np++;\nif (*p != ':')\nreturn 1;\n*p  = '\\0';\ntag = line;\np++;\nwhile (av_isspace(*p))\np++;\nif (!av_strcasecmp(tag, \"Location\")) {\nif ((ret = parse_location(s, p)) < 0)\nreturn ret;\n*new_location = 1;\n} else if (!av_strcasecmp(tag, \"Content-Length\") &&\ns->filesize == UINT64_MAX) {\ns->filesize = strtoull(p, NULL, 10);\n} else if (!av_strcasecmp(tag, \"Content-Range\")) {\nparse_content_range(h, p);\n} else if (!av_strcasecmp(tag, \"Accept-Ranges\") &&\n!strncmp(p, \"bytes\", 5) &&\ns->seekable == -1) {\nh->is_streamed = 0;\n} else if (!av_strcasecmp(tag, \"Transfer-Encoding\") &&\n!av_strncasecmp(p, \"chunked\", 7)) {\ns->filesize  = UINT64_MAX;\ns->chunksize = 0;\n} else if (!av_strcasecmp(tag, \"WWW-Authenticate\")) {\nff_http_auth_handle_header(&s->auth_state, tag, p);\n} else if (!av_strcasecmp(tag, \"Authentication-Info\")) {\nff_http_auth_handle_header(&s->auth_state, tag, p);\n} else if (!av_strcasecmp(tag, \"Proxy-Authenticate\")) {\nff_http_auth_handle_header(&s->proxy_auth_state, tag, p);\n} else if (!av_strcasecmp(tag, \"Connection\")) {\nif (!strcmp(p, \"close\"))\ns->willclose = 1;\n} else if (!av_strcasecmp(tag, \"Server\")) {\nif (!av_strcasecmp(p, \"AkamaiGHost\")) {\ns->is_akamai = 1;\n} else if (!av_strncasecmp(p, \"MediaGateway\", 12)) {\ns->is_mediagateway = 1;\n}\n} else if (!av_strcasecmp(tag, \"Content-Type\")) {\nav_free(s->mime_type);\ns->mime_type = av_strdup(p);\n} else if (!av_strcasecmp(tag, \"Set-Cookie\")) {\nif (parse_cookie(s, p, &s->cookie_dict))\nav_log(h, AV_LOG_WARNING, \"Unable to parse '%s'\\n\", p);\n} else if (!av_strcasecmp(tag, \"Icy-MetaInt\")) {\ns->icy_metaint = strtoull(p, NULL, 10);\n} else if (!av_strncasecmp(tag, \"Icy-\", 4)) {\nif ((ret = parse_icy(s, tag, p)) < 0)\nreturn ret;\n} else if (!av_strcasecmp(tag, \"Content-Encoding\")) {\nif ((ret = parse_content_encoding(h, p)) < 0)\nreturn ret;\n}\n}\nreturn 1;\n}", "label": 0}
{"index": 177586, "code": "static int store_icy(URLContext *h, int size)\n{\nHTTPContext *s = h->priv_data;\nint remaining = s->icy_metaint - s->icy_data_read;\nif (remaining < 0)\nreturn AVERROR_INVALIDDATA;\nif (!remaining) {\nuint8_t ch;\nint len = http_read_stream_all(h, &ch, 1);\nif (len < 0)\nreturn len;\nif (ch > 0) {\nchar data[255 * 16 + 1];\nint ret;\nlen = ch * 16;\nret = http_read_stream_all(h, data, len);\nif (ret < 0)\nreturn ret;\ndata[len + 1] = 0;\nif ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\nreturn ret;\nupdate_metadata(s, data);\n}\ns->icy_data_read = 0;\nremaining        = s->icy_metaint;\n}\nreturn FFMIN(size, remaining);\n}", "contrast": "static int store_icy(URLContext *h, int size)\n{\nHTTPContext *s = h->priv_data;\nuint64_t remaining;\nif (s->icy_metaint < s->icy_data_read)\nreturn AVERROR_INVALIDDATA;\nremaining = s->icy_metaint - s->icy_data_read;\nif (!remaining) {\nuint8_t ch;\nint len = http_read_stream_all(h, &ch, 1);\nif (len < 0)\nreturn len;\nif (ch > 0) {\nchar data[255 * 16 + 1];\nint ret;\nlen = ch * 16;\nret = http_read_stream_all(h, data, len);\nif (ret < 0)\nreturn ret;\ndata[len + 1] = 0;\nif ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\nreturn ret;\nupdate_metadata(s, data);\n}\ns->icy_data_read = 0;\nremaining        = s->icy_metaint;\n}\nreturn FFMIN(size, remaining);\n}", "label": 0}
{"index": 177596, "code": "smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\nint rc;\nunsigned char key2[8];\nstruct crypto_skcipher *tfm_des;\nstruct scatterlist sgin, sgout;\nstruct skcipher_request *req;\nstr_to_key(key, key2);\ntfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\nif (IS_ERR(tfm_des)) {\nrc = PTR_ERR(tfm_des);\ncifs_dbg(VFS, \"could not allocate des crypto API\\n\");\ngoto smbhash_err;\n}\nreq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\nif (!req) {\nrc = -ENOMEM;\ncifs_dbg(VFS, \"could not allocate des crypto API\\n\");\ngoto smbhash_free_skcipher;\n}\ncrypto_skcipher_setkey(tfm_des, key2, 8);\nsg_init_one(&sgin, in, 8);\nsg_init_one(&sgout, out, 8);\nskcipher_request_set_callback(req, 0, NULL, NULL);\nskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\nrc = crypto_skcipher_encrypt(req);\nif (rc)\ncifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\nskcipher_request_free(req);\nsmbhash_free_skcipher:\ncrypto_free_skcipher(tfm_des);\nsmbhash_err:\nreturn rc;\n}", "contrast": "smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\nunsigned char key2[8];\nstruct crypto_cipher *tfm_des;\nstr_to_key(key, key2);\ntfm_des = crypto_alloc_cipher(\"des\", 0, 0);\nif (IS_ERR(tfm_des)) {\ncifs_dbg(VFS, \"could not allocate des crypto API\\n\");\nreturn PTR_ERR(tfm_des);\n}\ncrypto_cipher_setkey(tfm_des, key2, 8);\ncrypto_cipher_encrypt_one(tfm_des, out, in);\ncrypto_free_cipher(tfm_des);\nreturn 0;\n}", "label": 0}
{"index": 177608, "code": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\nuint16 edge=0;\ntsize_t written=0;\nunsigned char* buffer=NULL;\ntsize_t bufferoffset=0;\nunsigned char* samplebuffer=NULL;\ntsize_t samplebufferoffset=0;\ntsize_t read=0;\nuint16 i=0;\nttile_t tilecount=0;\nttile_t septilecount=0;\ntsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\nunsigned char* jpt;\nfloat* xfloatp;\nuint32 xuint32=0;\n#endif\nif (t2p->t2p_error != T2P_ERR_OK)\nreturn(0);\nedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\nedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\nif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n)\n){\n#ifdef CCITT_SUPPORT\nif(t2p->pdf_compression == T2P_COMPRESS_G4){\nbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\nif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\nTIFFReverseBits(buffer, t2p->tiff_datasize);\n}\nt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n_TIFFfree(buffer);\nreturn(t2p->tiff_datasize);\n}\n#endif\n#ifdef ZIP_SUPPORT\nif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\nbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\nif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\nTIFFReverseBits(buffer, t2p->tiff_datasize);\n}\nt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n_TIFFfree(buffer);\nreturn(t2p->tiff_datasize);\n}\n#endif\n#ifdef OJPEG_SUPPORT\nif(t2p->tiff_compression == COMPRESSION_OJPEG){\nif(! t2p->pdf_ojpegdata){\nTIFFError(TIFF2PDF_MODULE,\n\"No support for OJPEG image %s with \"\n\"bad tables\",\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\n_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\nif(edge!=0){\nif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\nbuffer[7]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\nbuffer[8]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n}\nif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\nbuffer[9]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\nbuffer[10]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n}\n}\nbufferoffset=t2p->pdf_ojpegdatalength;\nbufferoffset+=TIFFReadRawTile(input,\ntile,\n(tdata_t) &(((unsigned char*)buffer)[bufferoffset]),\n-1);\n((unsigned char*)buffer)[bufferoffset++]=0xff;\n((unsigned char*)buffer)[bufferoffset++]=0xd9;\nt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n_TIFFfree(buffer);\nreturn(bufferoffset);\n}\n#endif\n#ifdef JPEG_SUPPORT\nif(t2p->tiff_compression == COMPRESSION_JPEG){\nunsigned char table_end[2];\nuint32 count = 0;\nbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(TIFF_SIZE_T) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\nif (count >= 4) {\nint retTIFFReadRawTile;\n_TIFFmemcpy(buffer, jpt, count - 2);\nbufferoffset += count - 2;\ntable_end[0] = buffer[bufferoffset-2];\ntable_end[1] = buffer[bufferoffset-1];\nxuint32 = bufferoffset;\nbufferoffset -= 2;\nretTIFFReadRawTile= TIFFReadRawTile(\ninput,\ntile,\n(tdata_t) &(((unsigned char*)buffer)[bufferoffset]),\n-1);\nif( retTIFFReadRawTile < 0 )\n{\n_TIFFfree(buffer);\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nbufferoffset += retTIFFReadRawTile;\nbuffer[xuint32-2]=table_end[0];\nbuffer[xuint32-1]=table_end[1];\n}\n}\nt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n_TIFFfree(buffer);\nreturn(bufferoffset);\n}\n#endif\n(void)0;\n}\nif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\nbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory for \"\n\"t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nread = TIFFReadEncodedTile(\ninput,\ntile,\n(tdata_t) &buffer[bufferoffset],\nt2p->tiff_datasize);\nif(read==-1){\nTIFFError(TIFF2PDF_MODULE,\n\"Error on decoding tile %u of %s\",\ntile,\nTIFFFileName(input));\n_TIFFfree(buffer);\nt2p->t2p_error=T2P_ERR_ERROR;\nreturn(0);\n}\n} else {\nif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\nseptilesize=TIFFTileSize(input);\nseptilecount=TIFFNumberOfTiles(input);\ntilecount=septilecount/t2p->tiff_samplesperpixel;\nbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(samplebuffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nsamplebufferoffset=0;\nfor(i=0;i<t2p->tiff_samplesperpixel;i++){\nread =\nTIFFReadEncodedTile(input,\ntile + i*tilecount,\n(tdata_t) &(samplebuffer[samplebufferoffset]),\nseptilesize);\nif(read==-1){\nTIFFError(TIFF2PDF_MODULE,\n\"Error on decoding tile %u of %s\",\ntile + i*tilecount,\nTIFFFileName(input));\n_TIFFfree(samplebuffer);\n_TIFFfree(buffer);\nt2p->t2p_error=T2P_ERR_ERROR;\nreturn(0);\n}\nsamplebufferoffset+=read;\n}\nt2p_sample_planar_separate_to_contig(\nt2p,\n&(buffer[bufferoffset]),\nsamplebuffer,\nsamplebufferoffset);\nbufferoffset+=samplebufferoffset;\n_TIFFfree(samplebuffer);\n}\nif(buffer==NULL){\nbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nread = TIFFReadEncodedTile(\ninput,\ntile,\n(tdata_t) &buffer[bufferoffset],\nt2p->tiff_datasize);\nif(read==-1){\nTIFFError(TIFF2PDF_MODULE,\n\"Error on decoding tile %u of %s\",\ntile,\nTIFFFileName(input));\n_TIFFfree(buffer);\nt2p->t2p_error=T2P_ERR_ERROR;\nreturn(0);\n}\n}\nif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\nt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n(tdata_t)buffer,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\nif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\nt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n(tdata_t)buffer,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\nif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\nTIFFError(TIFF2PDF_MODULE,\n\"No support for YCbCr to RGB in tile for %s\",\nTIFFFileName(input));\n_TIFFfree(buffer);\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\nt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n(tdata_t)buffer,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\n}\nif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\nt2p_tile_collapse_left(\nbuffer,\nTIFFTileRowSize(input),\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\nt2p_disable(output);\nTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\nTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\nTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\nif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\nTIFFSetField(\noutput,\nTIFFTAG_IMAGEWIDTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n} else {\nTIFFSetField(\noutput,\nTIFFTAG_IMAGEWIDTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n}\nif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\nTIFFSetField(\noutput,\nTIFFTAG_IMAGELENGTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\nTIFFSetField(\noutput,\nTIFFTAG_ROWSPERSTRIP,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n} else {\nTIFFSetField(\noutput,\nTIFFTAG_IMAGELENGTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\nTIFFSetField(\noutput,\nTIFFTAG_ROWSPERSTRIP,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n}\nTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\nTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\nswitch(t2p->pdf_compression){\ncase T2P_COMPRESS_NONE:\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\nbreak;\n#ifdef CCITT_SUPPORT\ncase T2P_COMPRESS_G4:\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\nbreak;\n#endif\n#ifdef JPEG_SUPPORT\ncase T2P_COMPRESS_JPEG:\nif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\nuint16 hor = 0, ver = 0;\nif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\nif (hor != 0 && ver != 0) {\nTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n}\n}\nif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\nTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n}\n}\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\nTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);\nif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\nTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\nif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\nTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n} else {\nTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n}\n}\nif(t2p->pdf_colorspace & T2P_CS_GRAY){\n(void)0;\n}\nif(t2p->pdf_colorspace & T2P_CS_CMYK){\n(void)0;\n}\nif(t2p->pdf_defaultcompressionquality != 0){\nTIFFSetField(output,\nTIFFTAG_JPEGQUALITY,\nt2p->pdf_defaultcompressionquality);\n}\nbreak;\n#endif\n#ifdef ZIP_SUPPORT\ncase T2P_COMPRESS_ZIP:\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\nif(t2p->pdf_defaultcompressionquality%100 != 0){\nTIFFSetField(output,\nTIFFTAG_PREDICTOR,\nt2p->pdf_defaultcompressionquality % 100);\n}\nif(t2p->pdf_defaultcompressionquality/100 != 0){\nTIFFSetField(output,\nTIFFTAG_ZIPQUALITY,\n(t2p->pdf_defaultcompressionquality / 100));\n}\nbreak;\n#endif\ndefault:\nbreak;\n}\nt2p_enable(output);\nt2p->outputwritten = 0;\nbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\nTIFFStripSize(output));\nif (buffer != NULL) {\n_TIFFfree(buffer);\nbuffer = NULL;\n}\nif (bufferoffset == -1) {\nTIFFError(TIFF2PDF_MODULE,\n\"Error writing encoded tile to output PDF %s\",\nTIFFFileName(output));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nwritten = t2p->outputwritten;\nreturn(written);\n}", "contrast": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\nuint16 edge=0;\ntsize_t written=0;\nunsigned char* buffer=NULL;\ntsize_t bufferoffset=0;\nunsigned char* samplebuffer=NULL;\ntsize_t samplebufferoffset=0;\ntsize_t read=0;\nuint16 i=0;\nttile_t tilecount=0;\nttile_t septilecount=0;\ntsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\nunsigned char* jpt;\nfloat* xfloatp;\nuint32 xuint32=0;\n#endif\nif (t2p->t2p_error != T2P_ERR_OK)\nreturn(0);\nedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\nedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\nif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n)\n){\n#ifdef CCITT_SUPPORT\nif(t2p->pdf_compression == T2P_COMPRESS_G4){\nbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\nif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\nTIFFReverseBits(buffer, t2p->tiff_datasize);\n}\nt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n_TIFFfree(buffer);\nreturn(t2p->tiff_datasize);\n}\n#endif\n#ifdef ZIP_SUPPORT\nif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\nbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\nif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\nTIFFReverseBits(buffer, t2p->tiff_datasize);\n}\nt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n_TIFFfree(buffer);\nreturn(t2p->tiff_datasize);\n}\n#endif\n#ifdef OJPEG_SUPPORT\nif(t2p->tiff_compression == COMPRESSION_OJPEG){\nif(! t2p->pdf_ojpegdata){\nTIFFError(TIFF2PDF_MODULE,\n\"No support for OJPEG image %s with \"\n\"bad tables\",\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\n_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\nif(edge!=0){\nif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\nbuffer[7]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\nbuffer[8]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n}\nif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\nbuffer[9]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\nbuffer[10]=\n(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n}\n}\nbufferoffset=t2p->pdf_ojpegdatalength;\nbufferoffset+=TIFFReadRawTile(input,\ntile,\n(tdata_t) &(((unsigned char*)buffer)[bufferoffset]),\n-1);\n((unsigned char*)buffer)[bufferoffset++]=0xff;\n((unsigned char*)buffer)[bufferoffset++]=0xd9;\nt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n_TIFFfree(buffer);\nreturn(bufferoffset);\n}\n#endif\n#ifdef JPEG_SUPPORT\nif(t2p->tiff_compression == COMPRESSION_JPEG){\nunsigned char table_end[2];\nuint32 count = 0;\nbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(TIFF_SIZE_T) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\nif (count > 4) {\nint retTIFFReadRawTile;\n_TIFFmemcpy(buffer, jpt, count - 2);\nbufferoffset += count - 2;\ntable_end[0] = buffer[bufferoffset-2];\ntable_end[1] = buffer[bufferoffset-1];\nxuint32 = bufferoffset;\nbufferoffset -= 2;\nretTIFFReadRawTile= TIFFReadRawTile(\ninput,\ntile,\n(tdata_t) &(((unsigned char*)buffer)[bufferoffset]),\n-1);\nif( retTIFFReadRawTile < 0 )\n{\n_TIFFfree(buffer);\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nbufferoffset += retTIFFReadRawTile;\nbuffer[xuint32-2]=table_end[0];\nbuffer[xuint32-1]=table_end[1];\n}\n}\nt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n_TIFFfree(buffer);\nreturn(bufferoffset);\n}\n#endif\n(void)0;\n}\nif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\nbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory for \"\n\"t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nread = TIFFReadEncodedTile(\ninput,\ntile,\n(tdata_t) &buffer[bufferoffset],\nt2p->tiff_datasize);\nif(read==-1){\nTIFFError(TIFF2PDF_MODULE,\n\"Error on decoding tile %u of %s\",\ntile,\nTIFFFileName(input));\n_TIFFfree(buffer);\nt2p->t2p_error=T2P_ERR_ERROR;\nreturn(0);\n}\n} else {\nif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\nseptilesize=TIFFTileSize(input);\nseptilecount=TIFFNumberOfTiles(input);\ntilecount=septilecount/t2p->tiff_samplesperpixel;\nbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(samplebuffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nsamplebufferoffset=0;\nfor(i=0;i<t2p->tiff_samplesperpixel;i++){\nread =\nTIFFReadEncodedTile(input,\ntile + i*tilecount,\n(tdata_t) &(samplebuffer[samplebufferoffset]),\nseptilesize);\nif(read==-1){\nTIFFError(TIFF2PDF_MODULE,\n\"Error on decoding tile %u of %s\",\ntile + i*tilecount,\nTIFFFileName(input));\n_TIFFfree(samplebuffer);\n_TIFFfree(buffer);\nt2p->t2p_error=T2P_ERR_ERROR;\nreturn(0);\n}\nsamplebufferoffset+=read;\n}\nt2p_sample_planar_separate_to_contig(\nt2p,\n&(buffer[bufferoffset]),\nsamplebuffer,\nsamplebufferoffset);\nbufferoffset+=samplebufferoffset;\n_TIFFfree(samplebuffer);\n}\nif(buffer==NULL){\nbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\nif(buffer==NULL){\nTIFFError(TIFF2PDF_MODULE,\n\"Can't allocate %lu bytes of memory \"\n\"for t2p_readwrite_pdf_image_tile, %s\",\n(unsigned long) t2p->tiff_datasize,\nTIFFFileName(input));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nread = TIFFReadEncodedTile(\ninput,\ntile,\n(tdata_t) &buffer[bufferoffset],\nt2p->tiff_datasize);\nif(read==-1){\nTIFFError(TIFF2PDF_MODULE,\n\"Error on decoding tile %u of %s\",\ntile,\nTIFFFileName(input));\n_TIFFfree(buffer);\nt2p->t2p_error=T2P_ERR_ERROR;\nreturn(0);\n}\n}\nif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\nt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n(tdata_t)buffer,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\nif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\nt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n(tdata_t)buffer,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\nif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\nTIFFError(TIFF2PDF_MODULE,\n\"No support for YCbCr to RGB in tile for %s\",\nTIFFFileName(input));\n_TIFFfree(buffer);\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\nt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n(tdata_t)buffer,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\n}\nif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\nt2p_tile_collapse_left(\nbuffer,\nTIFFTileRowSize(input),\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n}\nt2p_disable(output);\nTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\nTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\nTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\nif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\nTIFFSetField(\noutput,\nTIFFTAG_IMAGEWIDTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n} else {\nTIFFSetField(\noutput,\nTIFFTAG_IMAGEWIDTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n}\nif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\nTIFFSetField(\noutput,\nTIFFTAG_IMAGELENGTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\nTIFFSetField(\noutput,\nTIFFTAG_ROWSPERSTRIP,\nt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n} else {\nTIFFSetField(\noutput,\nTIFFTAG_IMAGELENGTH,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\nTIFFSetField(\noutput,\nTIFFTAG_ROWSPERSTRIP,\nt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n}\nTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\nTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\nswitch(t2p->pdf_compression){\ncase T2P_COMPRESS_NONE:\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\nbreak;\n#ifdef CCITT_SUPPORT\ncase T2P_COMPRESS_G4:\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\nbreak;\n#endif\n#ifdef JPEG_SUPPORT\ncase T2P_COMPRESS_JPEG:\nif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\nuint16 hor = 0, ver = 0;\nif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\nif (hor != 0 && ver != 0) {\nTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n}\n}\nif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\nTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n}\n}\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\nTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);\nif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\nTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\nif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\nTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n} else {\nTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n}\n}\nif(t2p->pdf_colorspace & T2P_CS_GRAY){\n(void)0;\n}\nif(t2p->pdf_colorspace & T2P_CS_CMYK){\n(void)0;\n}\nif(t2p->pdf_defaultcompressionquality != 0){\nTIFFSetField(output,\nTIFFTAG_JPEGQUALITY,\nt2p->pdf_defaultcompressionquality);\n}\nbreak;\n#endif\n#ifdef ZIP_SUPPORT\ncase T2P_COMPRESS_ZIP:\nTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\nif(t2p->pdf_defaultcompressionquality%100 != 0){\nTIFFSetField(output,\nTIFFTAG_PREDICTOR,\nt2p->pdf_defaultcompressionquality % 100);\n}\nif(t2p->pdf_defaultcompressionquality/100 != 0){\nTIFFSetField(output,\nTIFFTAG_ZIPQUALITY,\n(t2p->pdf_defaultcompressionquality / 100));\n}\nbreak;\n#endif\ndefault:\nbreak;\n}\nt2p_enable(output);\nt2p->outputwritten = 0;\nbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\nTIFFStripSize(output));\nif (buffer != NULL) {\n_TIFFfree(buffer);\nbuffer = NULL;\n}\nif (bufferoffset == -1) {\nTIFFError(TIFF2PDF_MODULE,\n\"Error writing encoded tile to output PDF %s\",\nTIFFFileName(output));\nt2p->t2p_error = T2P_ERR_ERROR;\nreturn(0);\n}\nwritten = t2p->outputwritten;\nreturn(written);\n}", "label": 0}
{"index": 177611, "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nImage *image, *image2=NULL,\n*rotated_image;\nPixelPacket *q;\nunsigned int status;\nMATHeader MATLAB_HDR;\nsize_t size;\nsize_t CellType;\nQuantumInfo *quantum_info;\nImageInfo *clone_info;\nint i;\nssize_t ldblk;\nunsigned char *BImgBuff = NULL;\ndouble MinVal, MaxVal;\nsize_t Unknown6;\nunsigned z, z2;\nunsigned Frames;\nint logging;\nint sample_size;\nMagickOffsetType filepos=0x80;\nBlobInfo *blob;\nsize_t one;\nunsigned int (*ReadBlobXXXLong)(Image *image);\nunsigned short (*ReadBlobXXXShort)(Image *image);\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nlogging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\nimage = AcquireImage(image_info);\nstatus = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nclone_info=CloneImageInfo(image_info);\nif(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n{\nimage2=ReadMATImageV4(image_info,image,exception);\nif (image2  == NULL)\ngoto MATLAB_KO;\nimage=image2;\ngoto END_OF_READING;\n}\nMATLAB_HDR.Version = ReadBlobLSBShort(image);\nif(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\nMATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\nif (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n{\nReadBlobXXXLong = ReadBlobLSBLong;\nReadBlobXXXShort = ReadBlobLSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesLSB;\nReadBlobFloatsXXX = ReadBlobFloatsLSB;\nimage->endian = LSBEndian;\n}\nelse if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n{\nReadBlobXXXLong = ReadBlobMSBLong;\nReadBlobXXXShort = ReadBlobMSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesMSB;\nReadBlobFloatsXXX = ReadBlobFloatsMSB;\nimage->endian = MSBEndian;\n}\nelse\ngoto MATLAB_KO;\nif (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nfilepos = TellBlob(image);\nwhile(!EOFBlob(image))\n{\nFrames = 1;\n(void) SeekBlob(image,filepos,SEEK_SET);\nMATLAB_HDR.DataType = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nMATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nfilepos += MATLAB_HDR.ObjectSize + 4 + 4;\nimage2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nif(MATLAB_HDR.DataType == miCOMPRESSED)\n{\nimage2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\nif(image2==NULL) continue;\nMATLAB_HDR.DataType = ReadBlobXXXLong(image2);\n}\n#endif\nif(MATLAB_HDR.DataType!=miMATRIX) continue;\nMATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\nMATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\nMATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\nMATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\nif(image!=image2)\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\nswitch(MATLAB_HDR.DimFlag)\n{\ncase  8: z2=z=1; break;\ncase 12: z2=z = ReadBlobXXXLong(image2);\nUnknown6 = ReadBlobXXXLong(image2);\n(void) Unknown6;\nif(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nbreak;\ncase 16: z2=z = ReadBlobXXXLong(image2);\nif(z!=3 && z!=1)\nThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nFrames = ReadBlobXXXLong(image2);\nbreak;\ndefault: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n}\nMATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\nMATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\nif (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\nMATLAB_HDR.StructureClass != mxSINGLE_CLASS &&\nMATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&\nMATLAB_HDR.StructureClass != mxINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxINT64_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT64_CLASS)\nThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\nswitch (MATLAB_HDR.NameFlag)\n{\ncase 0:\nsize = ReadBlobXXXLong(image2);\nsize = 4 * (ssize_t) ((size + 3 + 1) / 4);\n(void) SeekBlob(image2, size, SEEK_CUR);\nbreak;\ncase 1:\ncase 2:\ncase 3:\ncase 4:\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nbreak;\ndefault:\ngoto MATLAB_KO;\n}\nCellType = ReadBlobXXXLong(image2);\nif (logging)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nNEXT_FRAME:\nswitch (CellType)\n{\ncase miINT8:\ncase miUINT8:\nsample_size = 8;\nif(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\nimage->depth = 1;\nelse\nimage->depth = 8;\nldblk = (ssize_t) MATLAB_HDR.SizeX;\nbreak;\ncase miINT16:\ncase miUINT16:\nsample_size = 16;\nimage->depth = 16;\nldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT32:\ncase miUINT32:\nsample_size = 32;\nimage->depth = 32;\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT64:\ncase miUINT64:\nsample_size = 64;\nimage->depth = 64;\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ncase miSINGLE:\nsample_size = 32;\nimage->depth = 32;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miDOUBLE:\nsample_size = 64;\nimage->depth = 64;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\nif (sizeof(double) != 8)\nRestoreMSCWarning\nThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ndefault:\nThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n}\n(void) sample_size;\nimage->columns = MATLAB_HDR.SizeX;\nimage->rows = MATLAB_HDR.SizeY;\nquantum_info=AcquireQuantumInfo(clone_info,image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\none=1;\nimage->colors = one << image->depth;\nif (image->columns == 0 || image->rows == 0)\ngoto MATLAB_KO;\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n{\nSetImageColorspace(image,GRAYColorspace);\nimage->type=GrayscaleType;\n}\nif (image_info->ping)\n{\nsize_t temp = image->columns;\nimage->columns = image->rows;\nimage->rows = temp;\ngoto done_reading;\n}\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nBImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));\nif (BImgBuff == NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nMinVal = 0;\nMaxVal = 0;\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n}\nif(z==1) z=0;\ndo\n{\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nq=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto done_reading;\n}\nif(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\nif((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n{\nFixLogical((unsigned char *)BImgBuff,ldblk);\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n{\nImportQuantumPixelsFailed:\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\nbreak;\n}\n}\nelse\n{\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\ngoto ImportQuantumPixelsFailed;\nif (z<=1 &&\n(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\nFixSignedValues(q,MATLAB_HDR.SizeX);\n}\nif (!SyncAuthenticPixels(image,exception))\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\n}\n} while(z-- >= 2);\nquantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\nCellType = ReadBlobXXXLong(image2);\ni = ReadBlobXXXLong(image2);\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n}\nif (CellType==miDOUBLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\nInsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n}\nif (CellType==miSINGLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\nInsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n}\n}\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\nimage->type=GrayscaleType;\nif (image->depth == 1)\nimage->type=BilevelType;\nif(image2==image)\nimage2 = NULL;\nrotated_image = RotateImage(image, 90.0, exception);\nif (rotated_image != (Image *) NULL)\n{\nrotated_image->page.x=0;\nrotated_image->page.y=0;\nblob = rotated_image->blob;\nrotated_image->blob = image->blob;\nrotated_image->colors = image->colors;\nimage->blob = blob;\nAppendImageToList(&image,rotated_image);\nDeleteImageFromList(&image);\n}\ndone_reading:\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\n}\n}\nAcquireNextImage(image_info,image);\nif (image->next == (Image *) NULL) break;\nimage=SyncNextImageInList(image);\nimage->columns=image->rows=0;\nimage->colors=0;\nRelinquishMagickMemory(BImgBuff);\nBImgBuff = NULL;\nif(--Frames>0)\n{\nz = z2;\nif(image2==NULL) image2 = image;\ngoto NEXT_FRAME;\n}\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) unlink(clone_info->filename);\n}\n}\n}\n}\nRelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\nclone_info=DestroyImageInfo(clone_info);\nCloseBlob(image);\n{\nImage *p;\nssize_t scene=0;\np=image;\nimage=NULL;\nwhile (p != (Image *) NULL)\n{\nImage *tmp=p;\nif ((p->rows == 0) || (p->columns == 0)) {\np=p->previous;\nDeleteImageFromList(&tmp);\n} else {\nimage=p;\np=p->previous;\n}\n}\nfor (p=image; p != (Image *) NULL; p=p->next)\np->scene=scene++;\n}\nif(clone_info != NULL)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\nDestroyImageInfo(clone_info);\nclone_info = NULL;\n}\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\nif(image==NULL)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nreturn (image);\n}", "contrast": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nImage *image, *image2=NULL,\n*rotated_image;\nPixelPacket *q;\nunsigned int status;\nMATHeader MATLAB_HDR;\nsize_t size;\nsize_t CellType;\nQuantumInfo *quantum_info;\nImageInfo *clone_info;\nint i;\nssize_t ldblk;\nunsigned char *BImgBuff = NULL;\ndouble MinVal, MaxVal;\nsize_t Unknown6;\nunsigned z, z2;\nunsigned Frames;\nint logging;\nint sample_size;\nMagickOffsetType filepos=0x80;\nBlobInfo *blob;\nsize_t one;\nunsigned int (*ReadBlobXXXLong)(Image *image);\nunsigned short (*ReadBlobXXXShort)(Image *image);\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nlogging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\nimage = AcquireImage(image_info);\nstatus = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nclone_info=CloneImageInfo(image_info);\nif(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n{\nimage2=ReadMATImageV4(image_info,image,exception);\nif (image2  == NULL)\ngoto MATLAB_KO;\nimage=image2;\ngoto END_OF_READING;\n}\nMATLAB_HDR.Version = ReadBlobLSBShort(image);\nif(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\nMATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\nif (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n{\nReadBlobXXXLong = ReadBlobLSBLong;\nReadBlobXXXShort = ReadBlobLSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesLSB;\nReadBlobFloatsXXX = ReadBlobFloatsLSB;\nimage->endian = LSBEndian;\n}\nelse if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n{\nReadBlobXXXLong = ReadBlobMSBLong;\nReadBlobXXXShort = ReadBlobMSBShort;\nReadBlobDoublesXXX = ReadBlobDoublesMSB;\nReadBlobFloatsXXX = ReadBlobFloatsMSB;\nimage->endian = MSBEndian;\n}\nelse\ngoto MATLAB_KO;\nif (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nfilepos = TellBlob(image);\nwhile(!EOFBlob(image))\n{\nFrames = 1;\n(void) SeekBlob(image,filepos,SEEK_SET);\nMATLAB_HDR.DataType = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nMATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\nif(EOFBlob(image)) break;\nfilepos += MATLAB_HDR.ObjectSize + 4 + 4;\nimage2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nif(MATLAB_HDR.DataType == miCOMPRESSED)\n{\nimage2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\nif(image2==NULL) continue;\nMATLAB_HDR.DataType = ReadBlobXXXLong(image2);\n}\n#endif\nif(MATLAB_HDR.DataType!=miMATRIX) continue;\nMATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\nMATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\nMATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\nMATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\nif(image!=image2)\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\nMATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\nMATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\nswitch(MATLAB_HDR.DimFlag)\n{\ncase  8: z2=z=1; break;\ncase 12: z2=z = ReadBlobXXXLong(image2);\nUnknown6 = ReadBlobXXXLong(image2);\n(void) Unknown6;\nif(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nbreak;\ncase 16: z2=z = ReadBlobXXXLong(image2);\nif(z!=3 && z!=1)\nThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\nFrames = ReadBlobXXXLong(image2);\nif (Frames == 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\ndefault: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n}\nMATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\nMATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\nif (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\nMATLAB_HDR.StructureClass != mxSINGLE_CLASS &&\nMATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&\nMATLAB_HDR.StructureClass != mxINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT8_CLASS &&\nMATLAB_HDR.StructureClass != mxINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT16_CLASS &&\nMATLAB_HDR.StructureClass != mxINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT32_CLASS &&\nMATLAB_HDR.StructureClass != mxINT64_CLASS &&\nMATLAB_HDR.StructureClass != mxUINT64_CLASS)\nThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\nswitch (MATLAB_HDR.NameFlag)\n{\ncase 0:\nsize = ReadBlobXXXLong(image2);\nsize = 4 * (ssize_t) ((size + 3 + 1) / 4);\n(void) SeekBlob(image2, size, SEEK_CUR);\nbreak;\ncase 1:\ncase 2:\ncase 3:\ncase 4:\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nbreak;\ndefault:\ngoto MATLAB_KO;\n}\nCellType = ReadBlobXXXLong(image2);\nif (logging)\n(void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n(void) ReadBlob(image2, 4, (unsigned char *) &size);\nNEXT_FRAME:\nswitch (CellType)\n{\ncase miINT8:\ncase miUINT8:\nsample_size = 8;\nif(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\nimage->depth = 1;\nelse\nimage->depth = 8;\nldblk = (ssize_t) MATLAB_HDR.SizeX;\nbreak;\ncase miINT16:\ncase miUINT16:\nsample_size = 16;\nimage->depth = 16;\nldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT32:\ncase miUINT32:\nsample_size = 32;\nimage->depth = 32;\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miINT64:\ncase miUINT64:\nsample_size = 64;\nimage->depth = 64;\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ncase miSINGLE:\nsample_size = 32;\nimage->depth = 32;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\nbreak;\ncase miDOUBLE:\nsample_size = 64;\nimage->depth = 64;\n(void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\nif (sizeof(double) != 8)\nRestoreMSCWarning\nThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\n}\nldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\nbreak;\ndefault:\nThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n}\n(void) sample_size;\nimage->columns = MATLAB_HDR.SizeX;\nimage->rows = MATLAB_HDR.SizeY;\nquantum_info=AcquireQuantumInfo(clone_info,image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\none=1;\nimage->colors = one << image->depth;\nif (image->columns == 0 || image->rows == 0)\ngoto MATLAB_KO;\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n{\nSetImageColorspace(image,GRAYColorspace);\nimage->type=GrayscaleType;\n}\nif (image_info->ping)\n{\nsize_t temp = image->columns;\nimage->columns = image->rows;\nimage->rows = temp;\ngoto done_reading;\n}\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nBImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));\nif (BImgBuff == NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nMinVal = 0;\nMaxVal = 0;\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n}\nif(z==1) z=0;\ndo\n{\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nq=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto done_reading;\n}\nif(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\nif((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n{\nFixLogical((unsigned char *)BImgBuff,ldblk);\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n{\nImportQuantumPixelsFailed:\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\nbreak;\n}\n}\nelse\n{\nif(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\ngoto ImportQuantumPixelsFailed;\nif (z<=1 &&\n(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\nFixSignedValues(q,MATLAB_HDR.SizeX);\n}\nif (!SyncAuthenticPixels(image,exception))\n{\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n\"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\ngoto ExitLoop;\n}\n}\n} while(z-- >= 2);\nquantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\nif (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n{\nCellType = ReadBlobXXXLong(image2);\ni = ReadBlobXXXLong(image2);\nif (CellType==miDOUBLE || CellType==miSINGLE)\n{\nCalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n}\nif (CellType==miDOUBLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\nInsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n}\nif (CellType==miSINGLE)\nfor (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n{\nReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\nInsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n}\n}\nif ((MATLAB_HDR.DimFlag == 8) &&\n((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\nimage->type=GrayscaleType;\nif (image->depth == 1)\nimage->type=BilevelType;\nif(image2==image)\nimage2 = NULL;\nrotated_image = RotateImage(image, 90.0, exception);\nif (rotated_image != (Image *) NULL)\n{\nrotated_image->page.x=0;\nrotated_image->page.y=0;\nblob = rotated_image->blob;\nrotated_image->blob = image->blob;\nrotated_image->colors = image->colors;\nimage->blob = blob;\nAppendImageToList(&image,rotated_image);\nDeleteImageFromList(&image);\n}\ndone_reading:\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\n}\n}\nAcquireNextImage(image_info,image);\nif (image->next == (Image *) NULL) break;\nimage=SyncNextImageInList(image);\nimage->columns=image->rows=0;\nimage->colors=0;\nRelinquishMagickMemory(BImgBuff);\nBImgBuff = NULL;\nif(--Frames>0)\n{\nz = z2;\nif(image2==NULL) image2 = image;\ngoto NEXT_FRAME;\n}\nif(image2!=NULL)\nif(image2!=image)\n{\nDeleteImageFromList(&image2);\nif(clone_info)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) unlink(clone_info->filename);\n}\n}\n}\n}\nRelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\nclone_info=DestroyImageInfo(clone_info);\nCloseBlob(image);\n{\nImage *p;\nssize_t scene=0;\np=image;\nimage=NULL;\nwhile (p != (Image *) NULL)\n{\nImage *tmp=p;\nif ((p->rows == 0) || (p->columns == 0)) {\np=p->previous;\nDeleteImageFromList(&tmp);\n} else {\nimage=p;\np=p->previous;\n}\n}\nfor (p=image; p != (Image *) NULL; p=p->next)\np->scene=scene++;\n}\nif(clone_info != NULL)\n{\nif(clone_info->file)\n{\nfclose(clone_info->file);\nclone_info->file = NULL;\n(void) remove_utf8(clone_info->filename);\n}\nDestroyImageInfo(clone_info);\nclone_info = NULL;\n}\nif (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\nif(image==NULL)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nreturn (image);\n}", "label": 0}
{"index": 177624, "code": "static Image *ReadCMYKImage(const ImageInfo *image_info,\nExceptionInfo *exception)\n{\nImage\n*canvas_image,\n*image;\nMagickBooleanType\nstatus;\nMagickOffsetType\nscene;\nQuantumInfo\n*quantum_info;\nQuantumType\nquantum_type;\nregister ssize_t\ni;\nsize_t\nlength;\nssize_t\ncount,\ny;\nunsigned char\n*pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nif ((image->columns == 0) || (image->rows == 0))\nThrowReaderException(OptionError,\"MustSpecifyImageSize\");\nSetImageColorspace(image,CMYKColorspace);\nif (image_info->interlace != PartitionInterlace)\n{\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nif (DiscardBlobBytes(image,image->offset) == MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n}\ncanvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,\nexception);\n(void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod);\nquantum_info=AcquireQuantumInfo(image_info,canvas_image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixels=GetQuantumPixels(quantum_info);\nquantum_type=CMYKQuantum;\nif (LocaleCompare(image_info->magick,\"CMYKA\") == 0)\n{\nquantum_type=CMYKAQuantum;\nimage->matte=MagickTrue;\n}\nif (image_info->number_scenes != 0)\nwhile (image->scene < image_info->scene)\n{\nimage->scene++;\nlength=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\ncount=ReadBlob(image,length,pixels);\nif (count != (ssize_t) length)\nbreak;\n}\n}\ncount=0;\nlength=0;\nscene=0;\ndo\n{\nif ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nSetImageColorspace(image,CMYKColorspace);\nswitch (image_info->interlace)\n{\ncase NoInterlace:\ndefault:\n{\nif (scene == 0)\n{\nlength=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\ncount=ReadBlob(image,length,pixels);\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,quantum_type,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=QueueAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,GetPixelRed(p));\nSetPixelGreen(q,GetPixelGreen(p));\nSetPixelBlue(q,GetPixelBlue(p));\nSetPixelBlack(indexes+x,GetPixelBlack(\ncanvas_indexes+image->extract_info.x+x));\nSetPixelOpacity(q,OpaqueOpacity);\nif (image->matte != MagickFalse)\nSetPixelOpacity(q,GetPixelOpacity(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nbreak;\n}\ncase LineInterlace:\n{\nstatic QuantumType\nquantum_types[5] =\n{\nCyanQuantum,\nMagentaQuantum,\nYellowQuantum,\nBlackQuantum,\nOpacityQuantum\n};\nif (scene == 0)\n{\nlength=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\ncount=ReadBlob(image,length,pixels);\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nfor (i=0; i < (image->matte != MagickFalse ? 5 : 4); i++)\n{\nquantum_type=quantum_types[i];\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,quantum_type,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n0,canvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nswitch (quantum_type)\n{\ncase CyanQuantum:\n{\nSetPixelCyan(q,GetPixelCyan(p));\nbreak;\n}\ncase MagentaQuantum:\n{\nSetPixelMagenta(q,GetPixelMagenta(p));\nbreak;\n}\ncase YellowQuantum:\n{\nSetPixelYellow(q,GetPixelYellow(p));\nbreak;\n}\ncase BlackQuantum:\n{\nSetPixelIndex(indexes+x,GetPixelIndex(\ncanvas_indexes+image->extract_info.x+x));\nbreak;\n}\ncase OpacityQuantum:\n{\nSetPixelOpacity(q,GetPixelOpacity(p));\nbreak;\n}\ndefault:\nbreak;\n}\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nbreak;\n}\ncase PlaneInterlace:\n{\nif (scene == 0)\n{\nlength=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\ncount=ReadBlob(image,length,pixels);\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,CyanQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,GetPixelRed(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,1,6);\nif (status == MagickFalse)\nbreak;\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,MagentaQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelGreen(q,GetPixelGreen(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,2,6);\nif (status == MagickFalse)\nbreak;\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,YellowQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelBlue(q,GetPixelBlue(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,3,6);\nif (status == MagickFalse)\nbreak;\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,BlackQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelIndex(indexes+x,GetPixelIndex(\ncanvas_indexes+image->extract_info.x+x));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,4,6);\nif (status == MagickFalse)\nbreak;\n}\nif (image->matte != MagickFalse)\n{\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,AlphaQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,\ncanvas_image->extract_info.x,0,canvas_image->columns,1,\nexception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelOpacity(q,GetPixelOpacity(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,5,6);\nif (status == MagickFalse)\nbreak;\n}\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,6,6);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\ncase PartitionInterlace:\n{\nAppendImageFormat(\"C\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nif (DiscardBlobBytes(image,image->offset) == MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nlength=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,CyanQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,GetPixelRed(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,1,5);\nif (status == MagickFalse)\nbreak;\n}\n(void) CloseBlob(image);\nAppendImageFormat(\"M\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,MagentaQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,MagentaQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelGreen(q,GetPixelGreen(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,2,5);\nif (status == MagickFalse)\nbreak;\n}\n(void) CloseBlob(image);\nAppendImageFormat(\"Y\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,YellowQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,YellowQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelBlue(q,GetPixelBlue(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,3,5);\nif (status == MagickFalse)\nbreak;\n}\n(void) CloseBlob(image);\nAppendImageFormat(\"K\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,BlackQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,BlackQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelIndex(indexes+x,GetPixelIndex(\ncanvas_indexes+image->extract_info.x+x));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,3,5);\nif (status == MagickFalse)\nbreak;\n}\nif (image->matte != MagickFalse)\n{\n(void) CloseBlob(image);\nAppendImageFormat(\"A\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,AlphaQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,YellowQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n0,canvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelOpacity(q,GetPixelOpacity(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,4,5);\nif (status == MagickFalse)\nbreak;\n}\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,5,5);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\n}\nSetQuantumImageType(image,quantum_type);\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nif (count == (ssize_t) length)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\nscene++;\n} while (count == (ssize_t) length);\nquantum_info=DestroyQuantumInfo(quantum_info);\nInheritException(&image->exception,&canvas_image->exception);\ncanvas_image=DestroyImage(canvas_image);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadCMYKImage(const ImageInfo *image_info,\nExceptionInfo *exception)\n{\nImage\n*canvas_image,\n*image;\nMagickBooleanType\nstatus;\nMagickOffsetType\nscene;\nQuantumInfo\n*quantum_info;\nQuantumType\nquantum_type;\nregister ssize_t\ni;\nsize_t\nlength;\nssize_t\ncount,\ny;\nunsigned char\n*pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nif ((image->columns == 0) || (image->rows == 0))\nThrowReaderException(OptionError,\"MustSpecifyImageSize\");\nSetImageColorspace(image,CMYKColorspace);\nif (image_info->interlace != PartitionInterlace)\n{\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nif (DiscardBlobBytes(image,image->offset) == MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n}\ncanvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,\nexception);\n(void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod);\nquantum_info=AcquireQuantumInfo(image_info,canvas_image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixels=GetQuantumPixels(quantum_info);\nquantum_type=CMYKQuantum;\nif (LocaleCompare(image_info->magick,\"CMYKA\") == 0)\n{\nquantum_type=CMYKAQuantum;\nimage->matte=MagickTrue;\n}\nif (image_info->number_scenes != 0)\nwhile (image->scene < image_info->scene)\n{\nimage->scene++;\nlength=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\ncount=ReadBlob(image,length,pixels);\nif (count != (ssize_t) length)\nbreak;\n}\n}\ncount=0;\nlength=0;\nscene=0;\ndo\n{\nif ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nSetImageColorspace(image,CMYKColorspace);\nswitch (image_info->interlace)\n{\ncase NoInterlace:\ndefault:\n{\nif (scene == 0)\n{\nlength=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\ncount=ReadBlob(image,length,pixels);\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,quantum_type,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=QueueAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,GetPixelRed(p));\nSetPixelGreen(q,GetPixelGreen(p));\nSetPixelBlue(q,GetPixelBlue(p));\nSetPixelBlack(indexes+x,GetPixelBlack(\ncanvas_indexes+image->extract_info.x+x));\nSetPixelOpacity(q,OpaqueOpacity);\nif (image->matte != MagickFalse)\nSetPixelOpacity(q,GetPixelOpacity(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nbreak;\n}\ncase LineInterlace:\n{\nstatic QuantumType\nquantum_types[5] =\n{\nCyanQuantum,\nMagentaQuantum,\nYellowQuantum,\nBlackQuantum,\nOpacityQuantum\n};\nif (scene == 0)\n{\nlength=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\ncount=ReadBlob(image,length,pixels);\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nfor (i=0; i < (image->matte != MagickFalse ? 5 : 4); i++)\n{\nquantum_type=quantum_types[i];\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,quantum_type,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n0,canvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nswitch (quantum_type)\n{\ncase CyanQuantum:\n{\nSetPixelCyan(q,GetPixelCyan(p));\nbreak;\n}\ncase MagentaQuantum:\n{\nSetPixelMagenta(q,GetPixelMagenta(p));\nbreak;\n}\ncase YellowQuantum:\n{\nSetPixelYellow(q,GetPixelYellow(p));\nbreak;\n}\ncase BlackQuantum:\n{\nSetPixelIndex(indexes+x,GetPixelIndex(\ncanvas_indexes+image->extract_info.x+x));\nbreak;\n}\ncase OpacityQuantum:\n{\nSetPixelOpacity(q,GetPixelOpacity(p));\nbreak;\n}\ndefault:\nbreak;\n}\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nbreak;\n}\ncase PlaneInterlace:\n{\nif (scene == 0)\n{\nlength=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\ncount=ReadBlob(image,length,pixels);\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,CyanQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,GetPixelRed(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,1,6);\nif (status == MagickFalse)\nbreak;\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,MagentaQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelGreen(q,GetPixelGreen(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,2,6);\nif (status == MagickFalse)\nbreak;\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,YellowQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelBlue(q,GetPixelBlue(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,3,6);\nif (status == MagickFalse)\nbreak;\n}\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,BlackQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelIndex(indexes+x,GetPixelIndex(\ncanvas_indexes+image->extract_info.x+x));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,4,6);\nif (status == MagickFalse)\nbreak;\n}\nif (image->matte != MagickFalse)\n{\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,AlphaQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,\ncanvas_image->extract_info.x,0,canvas_image->columns,1,\nexception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelOpacity(q,GetPixelOpacity(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,5,6);\nif (status == MagickFalse)\nbreak;\n}\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,6,6);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\ncase PartitionInterlace:\n{\nAppendImageFormat(\"C\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nif (DiscardBlobBytes(image,image->offset) == MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nlength=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,CyanQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,GetPixelRed(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,1,5);\nif (status == MagickFalse)\nbreak;\n}\n(void) CloseBlob(image);\nAppendImageFormat(\"M\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,MagentaQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,MagentaQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelGreen(q,GetPixelGreen(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,2,5);\nif (status == MagickFalse)\nbreak;\n}\n(void) CloseBlob(image);\nAppendImageFormat(\"Y\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,YellowQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,YellowQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelBlue(q,GetPixelBlue(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,3,5);\nif (status == MagickFalse)\nbreak;\n}\n(void) CloseBlob(image);\nAppendImageFormat(\"K\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,BlackQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const IndexPacket\n*restrict canvas_indexes;\nregister const PixelPacket\n*restrict p;\nregister IndexPacket\n*restrict indexes;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,BlackQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\ncanvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\ncanvas_indexes=GetVirtualIndexQueue(canvas_image);\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelIndex(indexes+x,GetPixelIndex(\ncanvas_indexes+image->extract_info.x+x));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,3,5);\nif (status == MagickFalse)\nbreak;\n}\nif (image->matte != MagickFalse)\n{\n(void) CloseBlob(image);\nAppendImageFormat(\"A\",image->filename);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\ncanvas_image=DestroyImageList(canvas_image);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=GetQuantumExtent(canvas_image,quantum_info,AlphaQuantum);\nfor (i=0; i < (ssize_t) scene; i++)\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\nif (ReadBlob(image,length,pixels) != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\nfor (y=0; y < (ssize_t) image->extract_info.height; y++)\n{\nregister const PixelPacket\n*restrict p;\nregister PixelPacket\n*restrict q;\nregister ssize_t\nx;\nif (count != (ssize_t) length)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nq=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\nexception);\nif (q == (PixelPacket *) NULL)\nbreak;\nlength=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\nquantum_info,YellowQuantum,pixels,exception);\nif (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\nbreak;\nif (((y-image->extract_info.y) >= 0) &&\n((y-image->extract_info.y) < (ssize_t) image->rows))\n{\np=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n0,canvas_image->columns,1,exception);\nq=GetAuthenticPixels(image,0,y-image->extract_info.y,\nimage->columns,1,exception);\nif ((p == (const PixelPacket *) NULL) ||\n(q == (PixelPacket *) NULL))\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelOpacity(q,GetPixelOpacity(p));\np++;\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\ncount=ReadBlob(image,length,pixels);\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,4,5);\nif (status == MagickFalse)\nbreak;\n}\n}\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,5,5);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\n}\nSetQuantumImageType(image,quantum_type);\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nif (count == (ssize_t) length)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\nscene++;\n} while (count == (ssize_t) length);\nquantum_info=DestroyQuantumInfo(quantum_info);\nInheritException(&image->exception,&canvas_image->exception);\ncanvas_image=DestroyImage(canvas_image);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177634, "code": "static Image *ReadEXRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nconst ImfHeader\n*hdr_info;\nImage\n*image;\nImageInfo\n*read_info;\nImfInputFile\n*file;\nImfRgba\n*scanline;\nint\nmax_x,\nmax_y,\nmin_x,\nmin_y;\nMagickBooleanType\nstatus;\nregister ssize_t\nx;\nregister PixelPacket\n*q;\nssize_t\ny;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nread_info=CloneImageInfo(image_info);\nif (IsPathAccessible(read_info->filename) == MagickFalse)\n{\n(void) AcquireUniqueFilename(read_info->filename);\n(void) ImageToFile(image,read_info->filename,exception);\n}\nfile=ImfOpenInputFile(read_info->filename);\nif (file == (ImfInputFile *) NULL)\n{\nThrowFileException(exception,BlobError,\"UnableToOpenBlob\",\nImfErrorMessage());\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\nreturn((Image *) NULL);\n}\nhdr_info=ImfInputHeader(file);\nImfHeaderDisplayWindow(hdr_info,&min_x,&min_y,&max_x,&max_y);\nimage->columns=max_x-min_x+1UL;\nimage->rows=max_y-min_y+1UL;\nimage->matte=MagickTrue;\nSetImageColorspace(image,RGBColorspace);\nif (image_info->ping != MagickFalse)\n{\n(void) ImfCloseInputFile(file);\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}\nscanline=(ImfRgba *) AcquireQuantumMemory(image->columns,sizeof(*scanline));\nif (scanline == (ImfRgba *) NULL)\n{\n(void) ImfCloseInputFile(file);\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nResetMagickMemory(scanline,0,image->columns*sizeof(*scanline));\nImfInputSetFrameBuffer(file,scanline-min_x-image->columns*(min_y+y),1,\nimage->columns);\nImfInputReadPixels(file,min_y+y,min_y+y);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].r)));\nSetPixelGreen(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].g)));\nSetPixelBlue(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].b)));\nSetPixelAlpha(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].a)));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\nscanline=(ImfRgba *) RelinquishMagickMemory(scanline);\n(void) ImfCloseInputFile(file);\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadEXRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nconst ImfHeader\n*hdr_info;\nImage\n*image;\nImageInfo\n*read_info;\nImfInputFile\n*file;\nImfRgba\n*scanline;\nint\nmax_x,\nmax_y,\nmin_x,\nmin_y;\nMagickBooleanType\nstatus;\nregister ssize_t\nx;\nregister PixelPacket\n*q;\nssize_t\ny;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nread_info=CloneImageInfo(image_info);\nif (IsPathAccessible(read_info->filename) == MagickFalse)\n{\n(void) AcquireUniqueFilename(read_info->filename);\n(void) ImageToFile(image,read_info->filename,exception);\n}\nfile=ImfOpenInputFile(read_info->filename);\nif (file == (ImfInputFile *) NULL)\n{\nThrowFileException(exception,BlobError,\"UnableToOpenBlob\",\nImfErrorMessage());\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\nreturn((Image *) NULL);\n}\nhdr_info=ImfInputHeader(file);\nImfHeaderDisplayWindow(hdr_info,&min_x,&min_y,&max_x,&max_y);\nimage->columns=max_x-min_x+1UL;\nimage->rows=max_y-min_y+1UL;\nimage->matte=MagickTrue;\nSetImageColorspace(image,RGBColorspace);\nif (image_info->ping != MagickFalse)\n{\n(void) ImfCloseInputFile(file);\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nscanline=(ImfRgba *) AcquireQuantumMemory(image->columns,sizeof(*scanline));\nif (scanline == (ImfRgba *) NULL)\n{\n(void) ImfCloseInputFile(file);\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nResetMagickMemory(scanline,0,image->columns*sizeof(*scanline));\nImfInputSetFrameBuffer(file,scanline-min_x-image->columns*(min_y+y),1,\nimage->columns);\nImfInputReadPixels(file,min_y+y,min_y+y);\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].r)));\nSetPixelGreen(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].g)));\nSetPixelBlue(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].b)));\nSetPixelAlpha(q,ClampToQuantum((MagickRealType) QuantumRange*\nImfHalfToFloat(scanline[x].a)));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\nscanline=(ImfRgba *) RelinquishMagickMemory(scanline);\n(void) ImfCloseInputFile(file);\nif (LocaleCompare(image_info->filename,read_info->filename) != 0)\n(void) RelinquishUniqueFileResource(read_info->filename);\nread_info=DestroyImageInfo(read_info);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177661, "code": "static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nImage\n*image;\nMagickBooleanType\nstatus;\nMagickOffsetType\noffset;\nMagickSizeType\nnumber_pixels;\nregister ssize_t\ni,\ny;\nregister PixelPacket\n*q;\nregister unsigned char\n*c1,\n*c2,\n*yy;\nsize_t\nheight,\nnumber_images,\nrotate,\nscene,\nwidth;\nssize_t\ncount,\nx;\nunsigned char\n*chroma1,\n*chroma2,\n*header,\n*luma;\nunsigned int\noverview;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nheader=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\nif (header == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,3*0x800,header);\noverview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\nif ((count == 0) ||\n((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview == 0)))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nrotate=header[0x0e02] & 0x03;\nnumber_images=(header[10] << 8) | header[11];\nif (number_images > 65535)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nheader=(unsigned char *) RelinquishMagickMemory(header);\nif ((image->columns == 0) || (image->rows == 0))\nscene=3;\nelse\n{\nwidth=192;\nheight=128;\nfor (scene=1; scene < 6; scene++)\n{\nif ((width >= image->columns) && (height >= image->rows))\nbreak;\nwidth<<=1;\nheight<<=1;\n}\n}\nif (image_info->number_scenes != 0)\nscene=(size_t) MagickMin(image_info->scene,6);\nif (overview != 0)\nscene=1;\nwidth=192;\nheight=128;\nfor (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n{\nwidth<<=1;\nheight<<=1;\n}\nimage->columns=width;\nimage->rows=height;\nimage->depth=8;\nfor ( ; i < (ssize_t) scene; i++)\n{\nimage->columns<<=1;\nimage->rows<<=1;\n}\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nif (number_pixels != (size_t) number_pixels)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nchroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\nsizeof(*chroma1));\nchroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\nsizeof(*chroma2));\nluma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\nsizeof(*luma));\nif ((chroma1 == (unsigned char *) NULL) ||\n(chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\noffset=93;\nif (overview != 0)\noffset=2;\nelse\nif (scene == 2)\noffset=20;\nelse\nif (scene <= 1)\noffset=1;\nfor (i=0; i < (ssize_t) (offset*0x800); i++)\n(void) ReadBlobByte(image);\nif (overview != 0)\n{\nImage\n*overview_image;\nMagickProgressMonitor\nprogress_monitor;\nregister ssize_t\nj;\nfor (j=1; j <= (ssize_t) number_images; j++)\n{\nprogress_monitor=SetImageProgressMonitor(image,\n(MagickProgressMonitor) NULL,image->client_data);\n(void) FormatLocaleString(image->filename,MaxTextExtent,\n\"images/img%04ld.pcd\",(long) j);\n(void) FormatLocaleString(image->magick_filename,MaxTextExtent,\n\"images/img%04ld.pcd\",(long) j);\nimage->scene=(size_t) j;\nimage->columns=width;\nimage->rows=height;\nimage->depth=8;\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) height; y+=2)\n{\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width >> 1,c1);\nc1+=image->columns;\ncount=ReadBlob(image,width >> 1,c2);\nc2+=image->columns;\n}\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ScaleCharToQuantum(*yy++));\nSetPixelGreen(q,ScaleCharToQuantum(*c1++));\nSetPixelBlue(q,ScaleCharToQuantum(*c2++));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\nimage->colorspace=YCCColorspace;\nif (LocaleCompare(image_info->magick,\"PCDS\") == 0)\nSetImageColorspace(image,sRGBColorspace);\nif (j < (ssize_t) number_images)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\n}\n(void) SetImageProgressMonitor(image,progress_monitor,\nimage->client_data);\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,j-1,number_images);\nif (status == MagickFalse)\nbreak;\n}\n}\nchroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\nchroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\nluma=(unsigned char *) RelinquishMagickMemory(luma);\nimage=GetFirstImageInList(image);\noverview_image=OverviewImage(image_info,image,exception);\nreturn(overview_image);\n}\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) height; y+=2)\n{\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width >> 1,c1);\nc1+=image->columns;\ncount=ReadBlob(image,width >> 1,c2);\nc2+=image->columns;\n}\nif (scene >= 4)\n{\nUpsample(768,512,image->columns,luma);\nUpsample(384,256,image->columns,chroma1);\nUpsample(384,256,image->columns,chroma2);\nimage->rows=1024;\nfor (i=0; i < (4*0x800); i++)\n(void) ReadBlobByte(image);\nstatus=DecodeImage(image,luma,chroma1,chroma2);\nif ((scene >= 5) && status)\n{\nUpsample(1536,1024,image->columns,luma);\nUpsample(768,512,image->columns,chroma1);\nUpsample(768,512,image->columns,chroma2);\nimage->rows=2048;\noffset=TellBlob(image)/0x800+12;\noffset=SeekBlob(image,offset*0x800,SEEK_SET);\nstatus=DecodeImage(image,luma,chroma1,chroma2);\nif ((scene >= 6) && (status != MagickFalse))\n{\nUpsample(3072,2048,image->columns,luma);\nUpsample(1536,1024,image->columns,chroma1);\nUpsample(1536,1024,image->columns,chroma2);\nimage->rows=4096;\n}\n}\n}\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ScaleCharToQuantum(*yy++));\nSetPixelGreen(q,ScaleCharToQuantum(*c1++));\nSetPixelBlue(q,ScaleCharToQuantum(*c2++));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nchroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\nchroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\nluma=(unsigned char *) RelinquishMagickMemory(luma);\nif (EOFBlob(image) != MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n(void) CloseBlob(image);\nif (image_info->ping == MagickFalse)\nif ((rotate == 1) || (rotate == 3))\n{\ndouble\ndegrees;\nImage\n*rotate_image;\ndegrees=rotate == 1 ? -90.0 : 90.0;\nrotate_image=RotateImage(image,degrees,exception);\nif (rotate_image != (Image *) NULL)\n{\nimage=DestroyImage(image);\nimage=rotate_image;\n}\n}\nimage->chromaticity.red_primary.x=0.6400f;\nimage->chromaticity.red_primary.y=0.3300f;\nimage->chromaticity.green_primary.x=0.3000f;\nimage->chromaticity.green_primary.y=0.6000f;\nimage->chromaticity.blue_primary.x=0.1500f;\nimage->chromaticity.blue_primary.y=0.0600f;\nimage->chromaticity.white_point.x=0.3127f;\nimage->chromaticity.white_point.y=0.3290f;\nimage->gamma=1.000f/2.200f;\nimage->colorspace=YCCColorspace;\nif (LocaleCompare(image_info->magick,\"PCDS\") == 0)\nSetImageColorspace(image,sRGBColorspace);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nImage\n*image;\nMagickBooleanType\nstatus;\nMagickOffsetType\noffset;\nMagickSizeType\nnumber_pixels;\nregister ssize_t\ni,\ny;\nregister PixelPacket\n*q;\nregister unsigned char\n*c1,\n*c2,\n*yy;\nsize_t\nheight,\nnumber_images,\nrotate,\nscene,\nwidth;\nssize_t\ncount,\nx;\nunsigned char\n*chroma1,\n*chroma2,\n*header,\n*luma;\nunsigned int\noverview;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nheader=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\nif (header == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,3*0x800,header);\noverview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\nif ((count == 0) ||\n((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview == 0)))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nrotate=header[0x0e02] & 0x03;\nnumber_images=(header[10] << 8) | header[11];\nif (number_images > 65535)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nheader=(unsigned char *) RelinquishMagickMemory(header);\nif ((image->columns == 0) || (image->rows == 0))\nscene=3;\nelse\n{\nwidth=192;\nheight=128;\nfor (scene=1; scene < 6; scene++)\n{\nif ((width >= image->columns) && (height >= image->rows))\nbreak;\nwidth<<=1;\nheight<<=1;\n}\n}\nif (image_info->number_scenes != 0)\nscene=(size_t) MagickMin(image_info->scene,6);\nif (overview != 0)\nscene=1;\nwidth=192;\nheight=128;\nfor (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n{\nwidth<<=1;\nheight<<=1;\n}\nimage->columns=width;\nimage->rows=height;\nimage->depth=8;\nfor ( ; i < (ssize_t) scene; i++)\n{\nimage->columns<<=1;\nimage->rows<<=1;\n}\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nif (number_pixels != (size_t) number_pixels)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nchroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\nsizeof(*chroma1));\nchroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\nsizeof(*chroma2));\nluma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\nsizeof(*luma));\nif ((chroma1 == (unsigned char *) NULL) ||\n(chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\noffset=93;\nif (overview != 0)\noffset=2;\nelse\nif (scene == 2)\noffset=20;\nelse\nif (scene <= 1)\noffset=1;\nfor (i=0; i < (ssize_t) (offset*0x800); i++)\n(void) ReadBlobByte(image);\nif (overview != 0)\n{\nImage\n*overview_image;\nMagickProgressMonitor\nprogress_monitor;\nregister ssize_t\nj;\nfor (j=1; j <= (ssize_t) number_images; j++)\n{\nprogress_monitor=SetImageProgressMonitor(image,\n(MagickProgressMonitor) NULL,image->client_data);\n(void) FormatLocaleString(image->filename,MaxTextExtent,\n\"images/img%04ld.pcd\",(long) j);\n(void) FormatLocaleString(image->magick_filename,MaxTextExtent,\n\"images/img%04ld.pcd\",(long) j);\nimage->scene=(size_t) j;\nimage->columns=width;\nimage->rows=height;\nimage->depth=8;\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) height; y+=2)\n{\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width >> 1,c1);\nc1+=image->columns;\ncount=ReadBlob(image,width >> 1,c2);\nc2+=image->columns;\n}\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ScaleCharToQuantum(*yy++));\nSetPixelGreen(q,ScaleCharToQuantum(*c1++));\nSetPixelBlue(q,ScaleCharToQuantum(*c2++));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\nimage->colorspace=YCCColorspace;\nif (LocaleCompare(image_info->magick,\"PCDS\") == 0)\nSetImageColorspace(image,sRGBColorspace);\nif (j < (ssize_t) number_images)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\n}\n(void) SetImageProgressMonitor(image,progress_monitor,\nimage->client_data);\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,j-1,number_images);\nif (status == MagickFalse)\nbreak;\n}\n}\nchroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\nchroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\nluma=(unsigned char *) RelinquishMagickMemory(luma);\nimage=GetFirstImageInList(image);\noverview_image=OverviewImage(image_info,image,exception);\nreturn(overview_image);\n}\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) height; y+=2)\n{\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width,yy);\nyy+=image->columns;\ncount=ReadBlob(image,width >> 1,c1);\nc1+=image->columns;\ncount=ReadBlob(image,width >> 1,c2);\nc2+=image->columns;\n}\nif (scene >= 4)\n{\nUpsample(768,512,image->columns,luma);\nUpsample(384,256,image->columns,chroma1);\nUpsample(384,256,image->columns,chroma2);\nimage->rows=1024;\nfor (i=0; i < (4*0x800); i++)\n(void) ReadBlobByte(image);\nstatus=DecodeImage(image,luma,chroma1,chroma2);\nif ((scene >= 5) && status)\n{\nUpsample(1536,1024,image->columns,luma);\nUpsample(768,512,image->columns,chroma1);\nUpsample(768,512,image->columns,chroma2);\nimage->rows=2048;\noffset=TellBlob(image)/0x800+12;\noffset=SeekBlob(image,offset*0x800,SEEK_SET);\nstatus=DecodeImage(image,luma,chroma1,chroma2);\nif ((scene >= 6) && (status != MagickFalse))\n{\nUpsample(3072,2048,image->columns,luma);\nUpsample(1536,1024,image->columns,chroma1);\nUpsample(1536,1024,image->columns,chroma2);\nimage->rows=4096;\n}\n}\n}\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\nUpsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\nyy=luma;\nc1=chroma1;\nc2=chroma2;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ScaleCharToQuantum(*yy++));\nSetPixelGreen(q,ScaleCharToQuantum(*c1++));\nSetPixelBlue(q,ScaleCharToQuantum(*c2++));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nchroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\nchroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\nluma=(unsigned char *) RelinquishMagickMemory(luma);\nif (EOFBlob(image) != MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n(void) CloseBlob(image);\nif (image_info->ping == MagickFalse)\nif ((rotate == 1) || (rotate == 3))\n{\ndouble\ndegrees;\nImage\n*rotate_image;\ndegrees=rotate == 1 ? -90.0 : 90.0;\nrotate_image=RotateImage(image,degrees,exception);\nif (rotate_image != (Image *) NULL)\n{\nimage=DestroyImage(image);\nimage=rotate_image;\n}\n}\nimage->chromaticity.red_primary.x=0.6400f;\nimage->chromaticity.red_primary.y=0.3300f;\nimage->chromaticity.green_primary.x=0.3000f;\nimage->chromaticity.green_primary.y=0.6000f;\nimage->chromaticity.blue_primary.x=0.1500f;\nimage->chromaticity.blue_primary.y=0.0600f;\nimage->chromaticity.white_point.x=0.3127f;\nimage->chromaticity.white_point.y=0.3290f;\nimage->gamma=1.000f/2.200f;\nimage->colorspace=YCCColorspace;\nif (LocaleCompare(image_info->magick,\"PCDS\") == 0)\nSetImageColorspace(image,sRGBColorspace);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177677, "code": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\ntypedef struct _SUNInfo\n{\nunsigned int\nmagic,\nwidth,\nheight,\ndepth,\nlength,\ntype,\nmaptype,\nmaplength;\n} SUNInfo;\nImage\n*image;\nint\nbit;\nMagickBooleanType\nstatus;\nMagickSizeType\nnumber_pixels;\nregister IndexPacket\n*indexes;\nregister PixelPacket\n*q;\nregister ssize_t\ni,\nx;\nregister unsigned char\n*p;\nsize_t\nbytes_per_line,\nextent,\nlength;\nssize_t\ncount,\ny;\nSUNInfo\nsun_info;\nunsigned char\n*sun_data,\n*sun_pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\n(void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\nsun_info.magic=ReadBlobMSBLong(image);\ndo\n{\nif (sun_info.magic != 0x59a66a95)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nsun_info.width=ReadBlobMSBLong(image);\nsun_info.height=ReadBlobMSBLong(image);\nsun_info.depth=ReadBlobMSBLong(image);\nsun_info.length=ReadBlobMSBLong(image);\nsun_info.type=ReadBlobMSBLong(image);\nsun_info.maptype=ReadBlobMSBLong(image);\nsun_info.maplength=ReadBlobMSBLong(image);\nextent=sun_info.height*sun_info.width;\nif ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n(sun_info.type != RT_FORMAT_RGB))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.depth == 0) || (sun_info.depth > 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n(sun_info.maptype != RMT_RAW))\nThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\nimage->columns=sun_info.width;\nimage->rows=sun_info.height;\nimage->depth=sun_info.depth <= 8 ? sun_info.depth :\nMAGICKCORE_QUANTUM_DEPTH;\nif (sun_info.depth < 24)\n{\nsize_t\none;\nimage->storage_class=PseudoClass;\nimage->colors=sun_info.maplength;\none=1;\nif (sun_info.maptype == RMT_NONE)\nimage->colors=one << sun_info.depth;\nif (sun_info.maptype == RMT_EQUAL_RGB)\nimage->colors=sun_info.maplength/3;\n}\nswitch (sun_info.maptype)\n{\ncase RMT_NONE:\n{\nif (sun_info.depth < 24)\n{\nif (AcquireImageColormap(image,image->colors) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nbreak;\n}\ncase RMT_EQUAL_RGB:\n{\nunsigned char\n*sun_colormap;\nif (AcquireImageColormap(image,image->colors) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nsun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\nsizeof(*sun_colormap));\nif (sun_colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,image->colors,sun_colormap);\nif (count != (ssize_t) image->colors)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nfor (i=0; i < (ssize_t) image->colors; i++)\nimage->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);\ncount=ReadBlob(image,image->colors,sun_colormap);\nif (count != (ssize_t) image->colors)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nfor (i=0; i < (ssize_t) image->colors; i++)\nimage->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);\ncount=ReadBlob(image,image->colors,sun_colormap);\nif (count != (ssize_t) image->colors)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nfor (i=0; i < (ssize_t) image->colors; i++)\nimage->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);\nsun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\nbreak;\n}\ncase RMT_RAW:\n{\nunsigned char\n*sun_colormap;\nsun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\nsizeof(*sun_colormap));\nif (sun_colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,sun_info.maplength,sun_colormap);\nif (count != (ssize_t) sun_info.maplength)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nsun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\nbreak;\n}\ndefault:\nbreak;\n}\nimage->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;\nimage->columns=sun_info.width;\nimage->rows=sun_info.height;\nif (image_info->ping != MagickFalse)\n{\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}\nif ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\nsun_info.length || !sun_info.length)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nif ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nsun_data=(unsigned char *) AcquireQuantumMemory((size_t) sun_info.length,\nsizeof(*sun_data));\nif (sun_data == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\nif (count != (ssize_t) sun_info.length)\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\nsun_pixels=sun_data;\nbytes_per_line=0;\nif (sun_info.type == RT_ENCODED)\n{\nsize_t\nheight;\nheight=sun_info.height;\nbytes_per_line=sun_info.width*sun_info.depth;\nif ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n((bytes_per_line/sun_info.depth) != sun_info.width))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nbytes_per_line+=15;\nbytes_per_line<<=1;\nif ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nbytes_per_line>>=4;\nsun_pixels=(unsigned char *) AcquireQuantumMemory(height,\nbytes_per_line*sizeof(*sun_pixels));\nif (sun_pixels == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\nheight);\nsun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n}\np=sun_pixels;\nif (sun_info.depth == 1)\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < ((ssize_t) image->columns-7); x+=8)\n{\nfor (bit=7; bit >= 0; bit--)\nSetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));\np++;\n}\nif ((image->columns % 8) != 0)\n{\nfor (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\nSetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);\np++;\n}\nif ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\np++;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nelse\nif (image->storage_class == PseudoClass)\n{\nif (bytes_per_line == 0)\nbytes_per_line=image->columns;\nlength=image->rows*(image->columns+image->columns % 2);\nif (((sun_info.type == RT_ENCODED) &&\n(length > (bytes_per_line*image->rows))) ||\n((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\nSetPixelIndex(indexes+x,*p++);\nif ((image->columns % 2) != 0)\np++;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nelse\n{\nsize_t\nbytes_per_pixel;\nbytes_per_pixel=3;\nif (image->matte != MagickFalse)\nbytes_per_pixel++;\nif (bytes_per_line == 0)\nbytes_per_line=bytes_per_pixel*image->columns;\nlength=image->rows*(bytes_per_line+image->columns % 2);\nif (((sun_info.type == RT_ENCODED) &&\n(length > (bytes_per_line*image->rows))) ||\n((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,ScaleCharToQuantum(*p++));\nif (sun_info.type == RT_STANDARD)\n{\nSetPixelBlue(q,ScaleCharToQuantum(*p++));\nSetPixelGreen(q,ScaleCharToQuantum(*p++));\nSetPixelRed(q,ScaleCharToQuantum(*p++));\n}\nelse\n{\nSetPixelRed(q,ScaleCharToQuantum(*p++));\nSetPixelGreen(q,ScaleCharToQuantum(*p++));\nSetPixelBlue(q,ScaleCharToQuantum(*p++));\n}\nif (image->colors != 0)\n{\nSetPixelRed(q,image->colormap[(ssize_t)\nGetPixelRed(q)].red);\nSetPixelGreen(q,image->colormap[(ssize_t)\nGetPixelGreen(q)].green);\nSetPixelBlue(q,image->colormap[(ssize_t)\nGetPixelBlue(q)].blue);\n}\nq++;\n}\nif (((bytes_per_pixel*image->columns) % 2) != 0)\np++;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nif (image->storage_class == PseudoClass)\n(void) SyncImage(image);\nsun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nsun_info.magic=ReadBlobMSBLong(image);\nif (sun_info.magic == 0x59a66a95)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while (sun_info.magic == 0x59a66a95);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\ntypedef struct _SUNInfo\n{\nunsigned int\nmagic,\nwidth,\nheight,\ndepth,\nlength,\ntype,\nmaptype,\nmaplength;\n} SUNInfo;\nImage\n*image;\nint\nbit;\nMagickBooleanType\nstatus;\nMagickSizeType\nnumber_pixels;\nregister IndexPacket\n*indexes;\nregister PixelPacket\n*q;\nregister ssize_t\ni,\nx;\nregister unsigned char\n*p;\nsize_t\nbytes_per_line,\nextent,\nlength;\nssize_t\ncount,\ny;\nSUNInfo\nsun_info;\nunsigned char\n*sun_data,\n*sun_pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\n(void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\nsun_info.magic=ReadBlobMSBLong(image);\ndo\n{\nif (sun_info.magic != 0x59a66a95)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nsun_info.width=ReadBlobMSBLong(image);\nsun_info.height=ReadBlobMSBLong(image);\nsun_info.depth=ReadBlobMSBLong(image);\nsun_info.length=ReadBlobMSBLong(image);\nsun_info.type=ReadBlobMSBLong(image);\nsun_info.maptype=ReadBlobMSBLong(image);\nsun_info.maplength=ReadBlobMSBLong(image);\nextent=sun_info.height*sun_info.width;\nif ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n(sun_info.type != RT_FORMAT_RGB))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.depth == 0) || (sun_info.depth > 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n(sun_info.maptype != RMT_RAW))\nThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\nimage->columns=sun_info.width;\nimage->rows=sun_info.height;\nimage->depth=sun_info.depth <= 8 ? sun_info.depth :\nMAGICKCORE_QUANTUM_DEPTH;\nif (sun_info.depth < 24)\n{\nsize_t\none;\nimage->storage_class=PseudoClass;\nimage->colors=sun_info.maplength;\none=1;\nif (sun_info.maptype == RMT_NONE)\nimage->colors=one << sun_info.depth;\nif (sun_info.maptype == RMT_EQUAL_RGB)\nimage->colors=sun_info.maplength/3;\n}\nswitch (sun_info.maptype)\n{\ncase RMT_NONE:\n{\nif (sun_info.depth < 24)\n{\nif (AcquireImageColormap(image,image->colors) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nbreak;\n}\ncase RMT_EQUAL_RGB:\n{\nunsigned char\n*sun_colormap;\nif (AcquireImageColormap(image,image->colors) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nsun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\nsizeof(*sun_colormap));\nif (sun_colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,image->colors,sun_colormap);\nif (count != (ssize_t) image->colors)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nfor (i=0; i < (ssize_t) image->colors; i++)\nimage->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);\ncount=ReadBlob(image,image->colors,sun_colormap);\nif (count != (ssize_t) image->colors)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nfor (i=0; i < (ssize_t) image->colors; i++)\nimage->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);\ncount=ReadBlob(image,image->colors,sun_colormap);\nif (count != (ssize_t) image->colors)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nfor (i=0; i < (ssize_t) image->colors; i++)\nimage->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);\nsun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\nbreak;\n}\ncase RMT_RAW:\n{\nunsigned char\n*sun_colormap;\nsun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\nsizeof(*sun_colormap));\nif (sun_colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,sun_info.maplength,sun_colormap);\nif (count != (ssize_t) sun_info.maplength)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nsun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\nbreak;\n}\ndefault:\nbreak;\n}\nimage->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;\nimage->columns=sun_info.width;\nimage->rows=sun_info.height;\nif (image_info->ping != MagickFalse)\n{\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nif ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\nsun_info.length || !sun_info.length)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nif ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nsun_data=(unsigned char *) AcquireQuantumMemory((size_t) sun_info.length,\nsizeof(*sun_data));\nif (sun_data == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\nif (count != (ssize_t) sun_info.length)\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\nsun_pixels=sun_data;\nbytes_per_line=0;\nif (sun_info.type == RT_ENCODED)\n{\nsize_t\nheight;\nheight=sun_info.height;\nbytes_per_line=sun_info.width*sun_info.depth;\nif ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n((bytes_per_line/sun_info.depth) != sun_info.width))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nbytes_per_line+=15;\nbytes_per_line<<=1;\nif ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nbytes_per_line>>=4;\nsun_pixels=(unsigned char *) AcquireQuantumMemory(height,\nbytes_per_line*sizeof(*sun_pixels));\nif (sun_pixels == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\nheight);\nsun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n}\np=sun_pixels;\nif (sun_info.depth == 1)\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < ((ssize_t) image->columns-7); x+=8)\n{\nfor (bit=7; bit >= 0; bit--)\nSetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));\np++;\n}\nif ((image->columns % 8) != 0)\n{\nfor (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\nSetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);\np++;\n}\nif ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\np++;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nelse\nif (image->storage_class == PseudoClass)\n{\nif (bytes_per_line == 0)\nbytes_per_line=image->columns;\nlength=image->rows*(image->columns+image->columns % 2);\nif (((sun_info.type == RT_ENCODED) &&\n(length > (bytes_per_line*image->rows))) ||\n((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\nSetPixelIndex(indexes+x,*p++);\nif ((image->columns % 2) != 0)\np++;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nelse\n{\nsize_t\nbytes_per_pixel;\nbytes_per_pixel=3;\nif (image->matte != MagickFalse)\nbytes_per_pixel++;\nif (bytes_per_line == 0)\nbytes_per_line=bytes_per_pixel*image->columns;\nlength=image->rows*(bytes_per_line+image->columns % 2);\nif (((sun_info.type == RT_ENCODED) &&\n(length > (bytes_per_line*image->rows))) ||\n((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,ScaleCharToQuantum(*p++));\nif (sun_info.type == RT_STANDARD)\n{\nSetPixelBlue(q,ScaleCharToQuantum(*p++));\nSetPixelGreen(q,ScaleCharToQuantum(*p++));\nSetPixelRed(q,ScaleCharToQuantum(*p++));\n}\nelse\n{\nSetPixelRed(q,ScaleCharToQuantum(*p++));\nSetPixelGreen(q,ScaleCharToQuantum(*p++));\nSetPixelBlue(q,ScaleCharToQuantum(*p++));\n}\nif (image->colors != 0)\n{\nSetPixelRed(q,image->colormap[(ssize_t)\nGetPixelRed(q)].red);\nSetPixelGreen(q,image->colormap[(ssize_t)\nGetPixelGreen(q)].green);\nSetPixelBlue(q,image->colormap[(ssize_t)\nGetPixelBlue(q)].blue);\n}\nq++;\n}\nif (((bytes_per_pixel*image->columns) % 2) != 0)\np++;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nif (image->storage_class == PseudoClass)\n(void) SyncImage(image);\nsun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nsun_info.magic=ReadBlobMSBLong(image);\nif (sun_info.magic == 0x59a66a95)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while (sun_info.magic == 0x59a66a95);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177684, "code": "static Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\nchar *text,ExceptionInfo *exception)\n{\nchar\nfilename[MaxTextExtent],\ngeometry[MaxTextExtent],\n*p;\nDrawInfo\n*draw_info;\nImage\n*texture;\nMagickBooleanType\nstatus;\nPointInfo\ndelta;\nRectangleInfo\npage;\nssize_t\noffset;\nTypeMetric\nmetrics;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\ndelta.x=DefaultResolution;\ndelta.y=DefaultResolution;\nif ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))\n{\nGeometryInfo\ngeometry_info;\nMagickStatusType\nflags;\nflags=ParseGeometry(PSDensityGeometry,&geometry_info);\nimage->x_resolution=geometry_info.rho;\nimage->y_resolution=geometry_info.sigma;\nif ((flags & SigmaValue) == 0)\nimage->y_resolution=image->x_resolution;\n}\npage.width=612;\npage.height=792;\npage.x=43;\npage.y=43;\nif (image_info->page != (char *) NULL)\n(void) ParseAbsoluteGeometry(image_info->page,&page);\nimage->columns=(size_t) floor((((double) page.width*image->x_resolution)/\ndelta.x)+0.5);\nimage->rows=(size_t) floor((((double) page.height*image->y_resolution)/\ndelta.y)+0.5);\nimage->page.x=0;\nimage->page.y=0;\ntexture=(Image *) NULL;\nif (image_info->texture != (char *) NULL)\n{\nImageInfo\n*read_info;\nread_info=CloneImageInfo(image_info);\nSetImageInfoBlob(read_info,(void *) NULL,0);\n(void) CopyMagickString(read_info->filename,image_info->texture,\nMaxTextExtent);\ntexture=ReadImage(read_info,exception);\nread_info=DestroyImageInfo(read_info);\n}\n(void) SetImageBackgroundColor(image);\ndraw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n(void) CloneString(&draw_info->text,image_info->filename);\n(void) FormatLocaleString(geometry,MaxTextExtent,\"0x0%+ld%+ld\",(long) page.x,\n(long) page.y);\n(void) CloneString(&draw_info->geometry,geometry);\nstatus=GetTypeMetrics(image,draw_info,&metrics);\nif (status == MagickFalse)\nThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\npage.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n(void) FormatLocaleString(geometry,MaxTextExtent,\"0x0%+ld%+ld\",(long) page.x,\n(long) page.y);\n(void) CloneString(&draw_info->geometry,geometry);\n(void) CopyMagickString(filename,image_info->filename,MaxTextExtent);\nif (*draw_info->text != '\\0')\n*draw_info->text='\\0';\np=text;\nfor (offset=2*page.y; p != (char *) NULL; )\n{\n(void) ConcatenateString(&draw_info->text,text);\n(void) ConcatenateString(&draw_info->text,\"\\n\");\noffset+=(ssize_t) (metrics.ascent-metrics.descent);\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,offset,image->rows);\nif (status == MagickFalse)\nbreak;\n}\np=ReadBlobString(image,text);\nif ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\ncontinue;\nif (texture != (Image *) NULL)\n{\nMagickProgressMonitor\nprogress_monitor;\nprogress_monitor=SetImageProgressMonitor(image,\n(MagickProgressMonitor) NULL,image->client_data);\n(void) TextureImage(image,texture);\n(void) SetImageProgressMonitor(image,progress_monitor,\nimage->client_data);\n}\n(void) AnnotateImage(image,draw_info);\nif (p == (char *) NULL)\nbreak;\n*draw_info->text='\\0';\noffset=2*page.y;\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage->next->columns=image->columns;\nimage->next->rows=image->rows;\nimage=SyncNextImageInList(image);\n(void) CopyMagickString(image->filename,filename,MaxTextExtent);\n(void) SetImageBackgroundColor(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\nif (texture != (Image *) NULL)\n{\nMagickProgressMonitor\nprogress_monitor;\nprogress_monitor=SetImageProgressMonitor(image,\n(MagickProgressMonitor) NULL,image->client_data);\n(void) TextureImage(image,texture);\n(void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n}\n(void) AnnotateImage(image,draw_info);\nif (texture != (Image *) NULL)\ntexture=DestroyImage(texture);\ndraw_info=DestroyDrawInfo(draw_info);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\nchar *text,ExceptionInfo *exception)\n{\nchar\nfilename[MaxTextExtent],\ngeometry[MaxTextExtent],\n*p;\nDrawInfo\n*draw_info;\nImage\n*texture;\nMagickBooleanType\nstatus;\nPointInfo\ndelta;\nRectangleInfo\npage;\nssize_t\noffset;\nTypeMetric\nmetrics;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\ndelta.x=DefaultResolution;\ndelta.y=DefaultResolution;\nif ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))\n{\nGeometryInfo\ngeometry_info;\nMagickStatusType\nflags;\nflags=ParseGeometry(PSDensityGeometry,&geometry_info);\nimage->x_resolution=geometry_info.rho;\nimage->y_resolution=geometry_info.sigma;\nif ((flags & SigmaValue) == 0)\nimage->y_resolution=image->x_resolution;\n}\npage.width=612;\npage.height=792;\npage.x=43;\npage.y=43;\nif (image_info->page != (char *) NULL)\n(void) ParseAbsoluteGeometry(image_info->page,&page);\nimage->columns=(size_t) floor((((double) page.width*image->x_resolution)/\ndelta.x)+0.5);\nimage->rows=(size_t) floor((((double) page.height*image->y_resolution)/\ndelta.y)+0.5);\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nimage->page.x=0;\nimage->page.y=0;\ntexture=(Image *) NULL;\nif (image_info->texture != (char *) NULL)\n{\nImageInfo\n*read_info;\nread_info=CloneImageInfo(image_info);\nSetImageInfoBlob(read_info,(void *) NULL,0);\n(void) CopyMagickString(read_info->filename,image_info->texture,\nMaxTextExtent);\ntexture=ReadImage(read_info,exception);\nread_info=DestroyImageInfo(read_info);\n}\n(void) SetImageBackgroundColor(image);\ndraw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n(void) CloneString(&draw_info->text,image_info->filename);\n(void) FormatLocaleString(geometry,MaxTextExtent,\"0x0%+ld%+ld\",(long) page.x,\n(long) page.y);\n(void) CloneString(&draw_info->geometry,geometry);\nstatus=GetTypeMetrics(image,draw_info,&metrics);\nif (status == MagickFalse)\nThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\npage.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n(void) FormatLocaleString(geometry,MaxTextExtent,\"0x0%+ld%+ld\",(long) page.x,\n(long) page.y);\n(void) CloneString(&draw_info->geometry,geometry);\n(void) CopyMagickString(filename,image_info->filename,MaxTextExtent);\nif (*draw_info->text != '\\0')\n*draw_info->text='\\0';\np=text;\nfor (offset=2*page.y; p != (char *) NULL; )\n{\n(void) ConcatenateString(&draw_info->text,text);\n(void) ConcatenateString(&draw_info->text,\"\\n\");\noffset+=(ssize_t) (metrics.ascent-metrics.descent);\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,offset,image->rows);\nif (status == MagickFalse)\nbreak;\n}\np=ReadBlobString(image,text);\nif ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\ncontinue;\nif (texture != (Image *) NULL)\n{\nMagickProgressMonitor\nprogress_monitor;\nprogress_monitor=SetImageProgressMonitor(image,\n(MagickProgressMonitor) NULL,image->client_data);\n(void) TextureImage(image,texture);\n(void) SetImageProgressMonitor(image,progress_monitor,\nimage->client_data);\n}\n(void) AnnotateImage(image,draw_info);\nif (p == (char *) NULL)\nbreak;\n*draw_info->text='\\0';\noffset=2*page.y;\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage->next->columns=image->columns;\nimage->next->rows=image->rows;\nimage=SyncNextImageInList(image);\n(void) CopyMagickString(image->filename,filename,MaxTextExtent);\n(void) SetImageBackgroundColor(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\nif (texture != (Image *) NULL)\n{\nMagickProgressMonitor\nprogress_monitor;\nprogress_monitor=SetImageProgressMonitor(image,\n(MagickProgressMonitor) NULL,image->client_data);\n(void) TextureImage(image,texture);\n(void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n}\n(void) AnnotateImage(image,draw_info);\nif (texture != (Image *) NULL)\ntexture=DestroyImage(texture);\ndraw_info=DestroyDrawInfo(draw_info);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177685, "code": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nchar\ncolorspace[MaxTextExtent],\ntext[MaxTextExtent];\nImage\n*image;\nIndexPacket\n*indexes;\nlong\ntype,\nx_offset,\ny,\ny_offset;\nMagickBooleanType\nstatus;\nMagickPixelPacket\npixel;\nQuantumAny\nrange;\nregister ssize_t\ni,\nx;\nregister PixelPacket\n*q;\nssize_t\ncount;\nunsigned long\ndepth,\nheight,\nmax_value,\nwidth;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\n(void) ResetMagickMemory(text,0,sizeof(text));\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\nreturn(ReadTEXTImage(image_info,image,text,exception));\ndo\n{\nwidth=0;\nheight=0;\nmax_value=0;\n*colorspace='\\0';\ncount=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\ncolorspace);\nif ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->columns=width;\nimage->rows=height;\nfor (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\nimage->depth=depth;\nLocaleLower(colorspace);\ni=(ssize_t) strlen(colorspace)-1;\nimage->matte=MagickFalse;\nif ((i > 0) && (colorspace[i] == 'a'))\n{\ncolorspace[i]='\\0';\nimage->matte=MagickTrue;\n}\ntype=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\nif (type < 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->colorspace=(ColorspaceType) type;\n(void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n(void) SetImageBackgroundColor(image);\nrange=GetQuantumRange(image->depth);\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\ndouble\nblue,\ngreen,\nindex,\nopacity,\nred;\nred=0.0;\ngreen=0.0;\nblue=0.0;\nindex=0.0;\nopacity=0.0;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (ReadBlobString(image,text) == (char *) NULL)\nbreak;\nswitch (image->colorspace)\n{\ncase GRAYColorspace:\n{\nif (image->matte != MagickFalse)\n{\ncount=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&opacity);\ngreen=red;\nblue=red;\nbreak;\n}\ncount=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n&y_offset,&red);\ngreen=red;\nblue=red;\nbreak;\n}\ncase CMYKColorspace:\n{\nif (image->matte != MagickFalse)\n{\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\nbreak;\n}\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n&y_offset,&red,&green,&blue,&index);\nbreak;\n}\ndefault:\n{\nif (image->matte != MagickFalse)\n{\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&opacity);\nbreak;\n}\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,&y_offset,\n&red,&green,&blue);\nbreak;\n}\n}\nif (strchr(text,'%') != (char *) NULL)\n{\nred*=0.01*range;\ngreen*=0.01*range;\nblue*=0.01*range;\nindex*=0.01*range;\nopacity*=0.01*range;\n}\nif (image->colorspace == LabColorspace)\n{\ngreen+=(range+1)/2.0;\nblue+=(range+1)/2.0;\n}\npixel.red=ScaleAnyToQuantum((QuantumAny) (red+0.5),range);\npixel.green=ScaleAnyToQuantum((QuantumAny) (green+0.5),range);\npixel.blue=ScaleAnyToQuantum((QuantumAny) (blue+0.5),range);\npixel.index=ScaleAnyToQuantum((QuantumAny) (index+0.5),range);\npixel.opacity=ScaleAnyToQuantum((QuantumAny) (opacity+0.5),range);\nq=GetAuthenticPixels(image,x_offset,y_offset,1,1,exception);\nif (q == (PixelPacket *) NULL)\ncontinue;\nSetPixelRed(q,pixel.red);\nSetPixelGreen(q,pixel.green);\nSetPixelBlue(q,pixel.blue);\nif (image->colorspace == CMYKColorspace)\n{\nindexes=GetAuthenticIndexQueue(image);\nSetPixelIndex(indexes,pixel.index);\n}\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,pixel.opacity);\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\n}\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nchar\ncolorspace[MaxTextExtent],\ntext[MaxTextExtent];\nImage\n*image;\nIndexPacket\n*indexes;\nlong\ntype,\nx_offset,\ny,\ny_offset;\nMagickBooleanType\nstatus;\nMagickPixelPacket\npixel;\nQuantumAny\nrange;\nregister ssize_t\ni,\nx;\nregister PixelPacket\n*q;\nssize_t\ncount;\nunsigned long\ndepth,\nheight,\nmax_value,\nwidth;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\n(void) ResetMagickMemory(text,0,sizeof(text));\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\nreturn(ReadTEXTImage(image_info,image,text,exception));\ndo\n{\nwidth=0;\nheight=0;\nmax_value=0;\n*colorspace='\\0';\ncount=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\ncolorspace);\nif ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->columns=width;\nimage->rows=height;\nfor (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\nimage->depth=depth;\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nLocaleLower(colorspace);\ni=(ssize_t) strlen(colorspace)-1;\nimage->matte=MagickFalse;\nif ((i > 0) && (colorspace[i] == 'a'))\n{\ncolorspace[i]='\\0';\nimage->matte=MagickTrue;\n}\ntype=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\nif (type < 0)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nimage->colorspace=(ColorspaceType) type;\n(void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n(void) SetImageBackgroundColor(image);\nrange=GetQuantumRange(image->depth);\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\ndouble\nblue,\ngreen,\nindex,\nopacity,\nred;\nred=0.0;\ngreen=0.0;\nblue=0.0;\nindex=0.0;\nopacity=0.0;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (ReadBlobString(image,text) == (char *) NULL)\nbreak;\nswitch (image->colorspace)\n{\ncase GRAYColorspace:\n{\nif (image->matte != MagickFalse)\n{\ncount=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&opacity);\ngreen=red;\nblue=red;\nbreak;\n}\ncount=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n&y_offset,&red);\ngreen=red;\nblue=red;\nbreak;\n}\ncase CMYKColorspace:\n{\nif (image->matte != MagickFalse)\n{\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\nbreak;\n}\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n&y_offset,&red,&green,&blue,&index);\nbreak;\n}\ndefault:\n{\nif (image->matte != MagickFalse)\n{\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n&x_offset,&y_offset,&red,&green,&blue,&opacity);\nbreak;\n}\ncount=(ssize_t) sscanf(text,\n\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,&y_offset,\n&red,&green,&blue);\nbreak;\n}\n}\nif (strchr(text,'%') != (char *) NULL)\n{\nred*=0.01*range;\ngreen*=0.01*range;\nblue*=0.01*range;\nindex*=0.01*range;\nopacity*=0.01*range;\n}\nif (image->colorspace == LabColorspace)\n{\ngreen+=(range+1)/2.0;\nblue+=(range+1)/2.0;\n}\npixel.red=ScaleAnyToQuantum((QuantumAny) (red+0.5),range);\npixel.green=ScaleAnyToQuantum((QuantumAny) (green+0.5),range);\npixel.blue=ScaleAnyToQuantum((QuantumAny) (blue+0.5),range);\npixel.index=ScaleAnyToQuantum((QuantumAny) (index+0.5),range);\npixel.opacity=ScaleAnyToQuantum((QuantumAny) (opacity+0.5),range);\nq=GetAuthenticPixels(image,x_offset,y_offset,1,1,exception);\nif (q == (PixelPacket *) NULL)\ncontinue;\nSetPixelRed(q,pixel.red);\nSetPixelGreen(q,pixel.green);\nSetPixelBlue(q,pixel.blue);\nif (image->colorspace == CMYKColorspace)\n{\nindexes=GetAuthenticIndexQueue(image);\nSetPixelIndex(indexes,pixel.index);\n}\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,pixel.opacity);\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\n}\n}\n(void) ReadBlobString(image,text);\nif (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177702, "code": "static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\nconst char\n*comment;\nint\nbits;\nMagickBooleanType\nstatus;\nPDBImage\npdb_image;\nPDBInfo\npdb_info;\nQuantumInfo\n*quantum_info;\nregister const PixelPacket\n*p;\nregister ssize_t\nx;\nregister unsigned char\n*q;\nsize_t\nbits_per_pixel,\nliteral,\npackets,\npacket_size,\nrepeat;\nssize_t\ny;\nunsigned char\n*buffer,\n*runlength,\n*scanline;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nassert(image != (Image *) NULL);\nassert(image->signature == MagickSignature);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\nstatus=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\nif (status == MagickFalse)\nreturn(status);\n(void) TransformImageColorspace(image,sRGBColorspace);\nif ((image -> colors <= 2 ) ||\n(GetImageType(image,&image->exception ) == BilevelType)) {\nbits_per_pixel=1;\n} else if (image->colors <= 4) {\nbits_per_pixel=2;\n} else if (image->colors <= 8) {\nbits_per_pixel=3;\n} else {\nbits_per_pixel=4;\n}\n(void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));\n(void) CopyMagickString(pdb_info.name,image_info->filename,\nsizeof(pdb_info.name));\npdb_info.attributes=0;\npdb_info.version=0;\npdb_info.create_time=time(NULL);\npdb_info.modify_time=pdb_info.create_time;\npdb_info.archive_time=0;\npdb_info.modify_number=0;\npdb_info.application_info=0;\npdb_info.sort_info=0;\n(void) CopyMagickMemory(pdb_info.type,\"vIMG\",4);\n(void) CopyMagickMemory(pdb_info.id,\"View\",4);\npdb_info.seed=0;\npdb_info.next_record=0;\ncomment=GetImageProperty(image,\"comment\");\npdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n(void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n(void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n(void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n(void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\npdb_image.version=1;\nswitch (bits_per_pixel)\n{\ncase 1: pdb_image.type=(unsigned char) 0xff; break;\ncase 2: pdb_image.type=(unsigned char) 0x00; break;\ndefault: pdb_image.type=(unsigned char) 0x02;\n}\npdb_image.reserved_1=0;\npdb_image.note=0;\npdb_image.x_last=0;\npdb_image.y_last=0;\npdb_image.reserved_2=0;\npdb_image.x_anchor=(unsigned short) 0xffff;\npdb_image.y_anchor=(unsigned short) 0xffff;\npdb_image.width=(short) image->columns;\nif (image->columns % 16)\npdb_image.width=(short) (16*(image->columns/16+1));\npdb_image.height=(short) image->rows;\npackets=((bits_per_pixel*image->columns+7)/8);\nrunlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\nimage->rows*sizeof(*runlength));\nif (runlength == (unsigned char *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\nbuffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer));\nif (buffer == (unsigned char *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\npacket_size=(size_t) (image->depth > 8 ? 2: 1);\nscanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\nsizeof(*scanline));\nif (scanline == (unsigned char *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\nif (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n(void) TransformImageColorspace(image,sRGBColorspace);\nquantum_info=AcquireQuantumInfo(image_info,image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\nbits=8/(int) bits_per_pixel-1;\nliteral=0;\nrepeat=0;\nq=runlength;\nbuffer[0]=0x00;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\np=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\nif (p == (const PixelPacket *) NULL)\nbreak;\n(void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\nGrayQuantum,scanline,&image->exception);\nfor (x=0; x < (ssize_t) pdb_image.width; x++)\n{\nif (x < (ssize_t) image->columns)\nbuffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n(8-bits_per_pixel) << bits*bits_per_pixel;\nbits--;\nif (bits < 0)\n{\nif (((literal+repeat) > 0) &&\n(buffer[literal+repeat] == buffer[literal+repeat-1]))\n{\nif (repeat == 0)\n{\nliteral--;\nrepeat++;\n}\nrepeat++;\nif (0x7f < repeat)\n{\nq=EncodeRLE(q,buffer,literal,repeat);\nliteral=0;\nrepeat=0;\n}\n}\nelse\n{\nif (repeat >= 2)\nliteral+=repeat;\nelse\n{\nq=EncodeRLE(q,buffer,literal,repeat);\nbuffer[0]=buffer[literal+repeat];\nliteral=0;\n}\nliteral++;\nrepeat=0;\nif (0x7f < literal)\n{\nq=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n(void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);\nliteral-=0x80;\n}\n}\nbits=8/(int) bits_per_pixel-1;\nbuffer[literal+repeat]=0x00;\n}\n}\nstatus=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nq=EncodeRLE(q,buffer,literal,repeat);\nscanline=(unsigned char *) RelinquishMagickMemory(scanline);\nbuffer=(unsigned char *) RelinquishMagickMemory(buffer);\nquantum_info=DestroyQuantumInfo(quantum_info);\n(void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\npdb_info.number_records));\n(void) WriteBlobByte(image,0x40);\n(void) WriteBlobByte(image,0x6f);\n(void) WriteBlobByte(image,0x80);\n(void) WriteBlobByte(image,0);\nif (pdb_info.number_records > 1)\n{\n(void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\nrunlength));\n(void) WriteBlobByte(image,0x40);\n(void) WriteBlobByte(image,0x6f);\n(void) WriteBlobByte(image,0x80);\n(void) WriteBlobByte(image,1);\n}\n(void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\npdb_image.name);\n(void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n(void) WriteBlobByte(image,pdb_image.type);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n(void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n(void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n(void) WriteBlob(image,(size_t) (q-runlength),runlength);\nrunlength=(unsigned char *) RelinquishMagickMemory(runlength);\nif (pdb_info.number_records > 1)\n(void) WriteBlobString(image,comment);\n(void) CloseBlob(image);\nreturn(MagickTrue);\n}", "contrast": "static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\nconst char\n*comment;\nint\nbits;\nMagickBooleanType\nstatus;\nPDBImage\npdb_image;\nPDBInfo\npdb_info;\nQuantumInfo\n*quantum_info;\nregister const PixelPacket\n*p;\nregister ssize_t\nx;\nregister unsigned char\n*q;\nsize_t\nbits_per_pixel,\nliteral,\npackets,\npacket_size,\nrepeat;\nssize_t\ny;\nunsigned char\n*buffer,\n*runlength,\n*scanline;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nassert(image != (Image *) NULL);\nassert(image->signature == MagickSignature);\nif (image->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\nstatus=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\nif (status == MagickFalse)\nreturn(status);\n(void) TransformImageColorspace(image,sRGBColorspace);\nif ((image -> colors <= 2 ) ||\n(GetImageType(image,&image->exception ) == BilevelType)) {\nbits_per_pixel=1;\n} else if (image->colors <= 4) {\nbits_per_pixel=2;\n} else if (image->colors <= 8) {\nbits_per_pixel=3;\n} else {\nbits_per_pixel=4;\n}\n(void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));\n(void) CopyMagickString(pdb_info.name,image_info->filename,\nsizeof(pdb_info.name));\npdb_info.attributes=0;\npdb_info.version=0;\npdb_info.create_time=time(NULL);\npdb_info.modify_time=pdb_info.create_time;\npdb_info.archive_time=0;\npdb_info.modify_number=0;\npdb_info.application_info=0;\npdb_info.sort_info=0;\n(void) CopyMagickMemory(pdb_info.type,\"vIMG\",4);\n(void) CopyMagickMemory(pdb_info.id,\"View\",4);\npdb_info.seed=0;\npdb_info.next_record=0;\ncomment=GetImageProperty(image,\"comment\");\npdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n(void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n(void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n(void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n(void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\npdb_image.version=1;\nswitch (bits_per_pixel)\n{\ncase 1: pdb_image.type=(unsigned char) 0xff; break;\ncase 2: pdb_image.type=(unsigned char) 0x00; break;\ndefault: pdb_image.type=(unsigned char) 0x02;\n}\npdb_image.reserved_1=0;\npdb_image.note=0;\npdb_image.x_last=0;\npdb_image.y_last=0;\npdb_image.reserved_2=0;\npdb_image.x_anchor=(unsigned short) 0xffff;\npdb_image.y_anchor=(unsigned short) 0xffff;\npdb_image.width=(short) image->columns;\nif (image->columns % 16)\npdb_image.width=(short) (16*(image->columns/16+1));\npdb_image.height=(short) image->rows;\npackets=((bits_per_pixel*image->columns+7)/8);\nrunlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\nimage->rows*sizeof(*runlength));\nif (runlength == (unsigned char *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\nbuffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer));\nif (buffer == (unsigned char *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\npacket_size=(size_t) (image->depth > 8 ? 2 : 1);\nscanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\nsizeof(*scanline));\nif (scanline == (unsigned char *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\nif (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n(void) TransformImageColorspace(image,sRGBColorspace);\nquantum_info=AcquireQuantumInfo(image_info,image);\nif (quantum_info == (QuantumInfo *) NULL)\nThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\nstatus=SetQuantumDepth(image,quantum_info,image->depth > 8 ? 16 : 8);\nbits=8/(int) bits_per_pixel-1;\nliteral=0;\nrepeat=0;\nq=runlength;\nbuffer[0]=0x00;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\np=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\nif (p == (const PixelPacket *) NULL)\nbreak;\n(void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\nGrayQuantum,scanline,&image->exception);\nfor (x=0; x < (ssize_t) pdb_image.width; x++)\n{\nif (x < (ssize_t) image->columns)\nbuffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n(8-bits_per_pixel) << bits*bits_per_pixel;\nbits--;\nif (bits < 0)\n{\nif (((literal+repeat) > 0) &&\n(buffer[literal+repeat] == buffer[literal+repeat-1]))\n{\nif (repeat == 0)\n{\nliteral--;\nrepeat++;\n}\nrepeat++;\nif (0x7f < repeat)\n{\nq=EncodeRLE(q,buffer,literal,repeat);\nliteral=0;\nrepeat=0;\n}\n}\nelse\n{\nif (repeat >= 2)\nliteral+=repeat;\nelse\n{\nq=EncodeRLE(q,buffer,literal,repeat);\nbuffer[0]=buffer[literal+repeat];\nliteral=0;\n}\nliteral++;\nrepeat=0;\nif (0x7f < literal)\n{\nq=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n(void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);\nliteral-=0x80;\n}\n}\nbits=8/(int) bits_per_pixel-1;\nbuffer[literal+repeat]=0x00;\n}\n}\nstatus=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nq=EncodeRLE(q,buffer,literal,repeat);\nscanline=(unsigned char *) RelinquishMagickMemory(scanline);\nbuffer=(unsigned char *) RelinquishMagickMemory(buffer);\nquantum_info=DestroyQuantumInfo(quantum_info);\n(void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\npdb_info.number_records));\n(void) WriteBlobByte(image,0x40);\n(void) WriteBlobByte(image,0x6f);\n(void) WriteBlobByte(image,0x80);\n(void) WriteBlobByte(image,0);\nif (pdb_info.number_records > 1)\n{\n(void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\nrunlength));\n(void) WriteBlobByte(image,0x40);\n(void) WriteBlobByte(image,0x6f);\n(void) WriteBlobByte(image,0x80);\n(void) WriteBlobByte(image,1);\n}\n(void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\npdb_image.name);\n(void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n(void) WriteBlobByte(image,pdb_image.type);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n(void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n(void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n(void) WriteBlob(image,(size_t) (q-runlength),runlength);\nrunlength=(unsigned char *) RelinquishMagickMemory(runlength);\nif (pdb_info.number_records > 1)\n(void) WriteBlobString(image,comment);\n(void) CloseBlob(image);\nreturn(MagickTrue);\n}", "label": 0}
{"index": 177706, "code": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\nchar\nmagick[12];\nImage\n*image;\nIndexPacket\nindex;\nint\nopcode,\noperand,\nstatus;\nMagickStatusType\nflags;\nMagickSizeType\nnumber_pixels;\nMemoryInfo\n*pixel_info;\nregister IndexPacket\n*indexes;\nregister ssize_t\nx;\nregister PixelPacket\n*q;\nregister ssize_t\ni;\nregister unsigned char\n*p;\nsize_t\nbits_per_pixel,\nmap_length,\nnumber_colormaps,\nnumber_planes,\nnumber_planes_filled,\none,\noffset,\npixel_info_length;\nssize_t\ncount,\ny;\nunsigned char\nbackground_color[256],\n*colormap,\npixel,\nplane,\n*pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\ndo\n{\nimage->page.x=ReadBlobLSBShort(image);\nimage->page.y=ReadBlobLSBShort(image);\nimage->columns=ReadBlobLSBShort(image);\nimage->rows=ReadBlobLSBShort(image);\nflags=(MagickStatusType) ReadBlobByte(image);\nimage->matte=flags & 0x04 ? MagickTrue : MagickFalse;\nnumber_planes=(size_t) ReadBlobByte(image);\nbits_per_pixel=(size_t) ReadBlobByte(image);\nnumber_colormaps=(size_t) ReadBlobByte(image);\nmap_length=(unsigned char) ReadBlobByte(image);\nif (map_length >= 32)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\none=1;\nmap_length=one << map_length;\nif ((number_planes == 0) || (number_planes == 2) ||\n((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n(image->columns == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (flags & 0x02)\n{\nfor (i=0; i < (ssize_t) number_planes; i++)\nbackground_color[i]=0;\n(void) ReadBlobByte(image);\n}\nelse\n{\np=background_color;\nfor (i=0; i < (ssize_t) number_planes; i++)\n*p++=(unsigned char) ReadBlobByte(image);\n}\nif ((number_planes & 0x01) == 0)\n(void) ReadBlobByte(image);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\ncolormap=(unsigned char *) NULL;\nif (number_colormaps != 0)\n{\ncolormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n3*map_length*sizeof(*colormap));\nif (colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nfor (i=0; i < (ssize_t) number_colormaps; i++)\nfor (x=0; x < (ssize_t) map_length; x++)\n*p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n}\nif ((flags & 0x08) != 0)\n{\nchar\n*comment;\nsize_t\nlength;\nlength=ReadBlobLSBShort(image);\nif (length != 0)\n{\ncomment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\nif (comment == (char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) ReadBlob(image,length-1,(unsigned char *) comment);\ncomment[length-1]='\\0';\n(void) SetImageProperty(image,\"comment\",comment);\ncomment=DestroyString(comment);\nif ((length & 0x01) == 0)\n(void) ReadBlobByte(image);\n}\n}\nif ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nif (image->matte != MagickFalse)\nnumber_planes++;\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nnumber_planes_filled=(number_planes % 2 == 0) ? number_planes :\nnumber_planes+1;\nif ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\nnumber_planes_filled))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info=AcquireVirtualMemory(image->columns,image->rows*\nnumber_planes_filled*sizeof(*pixels));\nif (pixel_info == (MemoryInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info_length=image->columns*image->rows*number_planes_filled;\npixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\nif ((flags & 0x01) && !(flags & 0x02))\n{\nssize_t\nj;\np=pixels;\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nif (image->matte == MagickFalse)\nfor (j=0; j < (ssize_t) number_planes; j++)\n*p++=background_color[j];\nelse\n{\nfor (j=0; j < (ssize_t) (number_planes-1); j++)\n*p++=background_color[j];\n*p++=0;\n}\n}\n}\nplane=0;\nx=0;\ny=0;\nopcode=ReadBlobByte(image);\ndo\n{\nswitch (opcode & 0x3f)\n{\ncase SkipLinesOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx=0;\ny+=operand;\nbreak;\n}\ncase SetColorOp:\n{\noperand=ReadBlobByte(image);\nplane=(unsigned char) operand;\nif (plane == 255)\nplane=(unsigned char) (number_planes-1);\nx=0;\nbreak;\n}\ncase SkipPixelsOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx+=operand;\nbreak;\n}\ncase ByteDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\noperand++;\nif (offset+((size_t) operand*number_planes) > pixel_info_length)\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\np=pixels+offset;\nfor (i=0; i < (ssize_t) operand; i++)\n{\npixel=(unsigned char) ReadBlobByte(image);\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nif (operand & 0x01)\n(void) ReadBlobByte(image);\nx+=operand;\nbreak;\n}\ncase RunDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\npixel=(unsigned char) ReadBlobByte(image);\n(void) ReadBlobByte(image);\noperand++;\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\np=pixels+offset;\nif (offset+((size_t) operand*number_planes) > pixel_info_length)\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\nfor (i=0; i < (ssize_t) operand; i++)\n{\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nx+=operand;\nbreak;\n}\ndefault:\nbreak;\n}\nopcode=ReadBlobByte(image);\n} while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\nif (number_colormaps != 0)\n{\nMagickStatusType\nmask;\nmask=(MagickStatusType) (map_length-1);\np=pixels;\nx=(ssize_t) number_planes;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nif (IsValidColormapIndex(image,*p & mask,&index,exception) ==\nMagickFalse)\nbreak;\n*p=colormap[(ssize_t) index];\np++;\n}\nelse\nif ((number_planes >= 3) && (number_colormaps >= 3))\nfor (i=0; i < (ssize_t) number_pixels; i++)\nfor (x=0; x < (ssize_t) number_planes; x++)\n{\nif (IsValidColormapIndex(image,(size_t) (x*map_length+\n(*p & mask)),&index,exception) == MagickFalse)\nbreak;\n*p=colormap[(ssize_t) index];\np++;\n}\nif ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n{\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\n}\nif (number_planes >= 3)\n{\np=pixels;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ScaleCharToQuantum(*p++));\nSetPixelGreen(q,ScaleCharToQuantum(*p++));\nSetPixelBlue(q,ScaleCharToQuantum(*p++));\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,ScaleCharToQuantum(*p++));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nelse\n{\nif (number_colormaps == 0)\nmap_length=256;\nif (AcquireImageColormap(image,map_length) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n}\nelse\nif (number_colormaps > 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=ScaleCharToQuantum(*p);\nimage->colormap[i].green=ScaleCharToQuantum(*(p+map_length));\nimage->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));\np++;\n}\np=pixels;\nif (image->matte == MagickFalse)\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\nSetPixelIndex(indexes+x,*p++);\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n(void) SyncImage(image);\n}\nelse\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (IsValidColormapIndex(image,*p++,&index,exception) ==\nMagickFalse)\nbreak;\nSetPixelRed(q,image->colormap[(ssize_t) index].red);\nif (IsValidColormapIndex(image,*p++,&index,exception) ==\nMagickFalse)\nbreak;\nSetPixelGreen(q,image->colormap[(ssize_t) index].green);\nif (IsValidColormapIndex(image,*p++,&index,exception) ==\nMagickFalse)\nbreak;\nSetPixelBlue(q,image->colormap[(ssize_t) index].blue);\nSetPixelAlpha(q,ScaleCharToQuantum(*p++));\nq++;\n}\nif (x < (ssize_t) image->columns)\nbreak;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nimage->colormap=(PixelPacket *) RelinquishMagickMemory(\nimage->colormap);\nimage->storage_class=DirectClass;\nimage->colors=0;\n}\n}\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\n(void) ReadBlobByte(image);\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\nchar\nmagick[12];\nImage\n*image;\nIndexPacket\nindex;\nint\nopcode,\noperand,\nstatus;\nMagickStatusType\nflags;\nMagickSizeType\nnumber_pixels;\nMemoryInfo\n*pixel_info;\nregister IndexPacket\n*indexes;\nregister ssize_t\nx;\nregister PixelPacket\n*q;\nregister ssize_t\ni;\nregister unsigned char\n*p;\nsize_t\nbits_per_pixel,\nmap_length,\nnumber_colormaps,\nnumber_planes,\nnumber_planes_filled,\none,\noffset,\npixel_info_length;\nssize_t\ncount,\ny;\nunsigned char\nbackground_color[256],\n*colormap,\npixel,\nplane,\n*pixels;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickSignature);\nimage=AcquireImage(image_info);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\ndo\n{\nimage->page.x=ReadBlobLSBShort(image);\nimage->page.y=ReadBlobLSBShort(image);\nimage->columns=ReadBlobLSBShort(image);\nimage->rows=ReadBlobLSBShort(image);\nflags=(MagickStatusType) ReadBlobByte(image);\nimage->matte=flags & 0x04 ? MagickTrue : MagickFalse;\nnumber_planes=(size_t) ReadBlobByte(image);\nbits_per_pixel=(size_t) ReadBlobByte(image);\nnumber_colormaps=(size_t) ReadBlobByte(image);\nmap_length=(unsigned char) ReadBlobByte(image);\nif (map_length >= 32)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\none=1;\nmap_length=one << map_length;\nif ((number_planes == 0) || (number_planes == 2) ||\n((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n(image->columns == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (flags & 0x02)\n{\nfor (i=0; i < (ssize_t) number_planes; i++)\nbackground_color[i]=0;\n(void) ReadBlobByte(image);\n}\nelse\n{\np=background_color;\nfor (i=0; i < (ssize_t) number_planes; i++)\n*p++=(unsigned char) ReadBlobByte(image);\n}\nif ((number_planes & 0x01) == 0)\n(void) ReadBlobByte(image);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\ncolormap=(unsigned char *) NULL;\nif (number_colormaps != 0)\n{\ncolormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n3*map_length*sizeof(*colormap));\nif (colormap == (unsigned char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nfor (i=0; i < (ssize_t) number_colormaps; i++)\nfor (x=0; x < (ssize_t) map_length; x++)\n*p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n}\nif ((flags & 0x08) != 0)\n{\nchar\n*comment;\nsize_t\nlength;\nlength=ReadBlobLSBShort(image);\nif (length != 0)\n{\ncomment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\nif (comment == (char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) ReadBlob(image,length-1,(unsigned char *) comment);\ncomment[length-1]='\\0';\n(void) SetImageProperty(image,\"comment\",comment);\ncomment=DestroyString(comment);\nif ((length & 0x01) == 0)\n(void) ReadBlobByte(image);\n}\n}\nif ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nstatus=SetImageExtent(image,image->columns,image->rows);\nif (status == MagickFalse)\n{\nInheritException(exception,&image->exception);\nreturn(DestroyImageList(image));\n}\nif (image->matte != MagickFalse)\nnumber_planes++;\nnumber_pixels=(MagickSizeType) image->columns*image->rows;\nnumber_planes_filled=(number_planes % 2 == 0) ? number_planes :\nnumber_planes+1;\nif ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\nnumber_planes_filled))\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info=AcquireVirtualMemory(image->columns,image->rows*\nMagickMax(number_planes_filled,4)*sizeof(*pixels));\nif (pixel_info == (MemoryInfo *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\npixel_info_length=image->columns*image->rows*\nMagickMax(number_planes_filled,4);\npixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\nif ((flags & 0x01) && !(flags & 0x02))\n{\nssize_t\nj;\np=pixels;\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nif (image->matte == MagickFalse)\nfor (j=0; j < (ssize_t) number_planes; j++)\n*p++=background_color[j];\nelse\n{\nfor (j=0; j < (ssize_t) (number_planes-1); j++)\n*p++=background_color[j];\n*p++=0;\n}\n}\n}\nplane=0;\nx=0;\ny=0;\nopcode=ReadBlobByte(image);\ndo\n{\nswitch (opcode & 0x3f)\n{\ncase SkipLinesOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx=0;\ny+=operand;\nbreak;\n}\ncase SetColorOp:\n{\noperand=ReadBlobByte(image);\nplane=(unsigned char) operand;\nif (plane == 255)\nplane=(unsigned char) (number_planes-1);\nx=0;\nbreak;\n}\ncase SkipPixelsOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\nx+=operand;\nbreak;\n}\ncase ByteDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\noperand++;\nif (offset+((size_t) operand*number_planes) > pixel_info_length)\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\np=pixels+offset;\nfor (i=0; i < (ssize_t) operand; i++)\n{\npixel=(unsigned char) ReadBlobByte(image);\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nif (operand & 0x01)\n(void) ReadBlobByte(image);\nx+=operand;\nbreak;\n}\ncase RunDataOp:\n{\noperand=ReadBlobByte(image);\nif (opcode & 0x40)\noperand=ReadBlobLSBSignedShort(image);\npixel=(unsigned char) ReadBlobByte(image);\n(void) ReadBlobByte(image);\noperand++;\noffset=((image->rows-y-1)*image->columns*number_planes)+x*\nnumber_planes+plane;\np=pixels+offset;\nif (offset+((size_t) operand*number_planes) > pixel_info_length)\n{\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\nfor (i=0; i < (ssize_t) operand; i++)\n{\nif ((y < (ssize_t) image->rows) &&\n((x+i) < (ssize_t) image->columns))\n*p=pixel;\np+=number_planes;\n}\nx+=operand;\nbreak;\n}\ndefault:\nbreak;\n}\nopcode=ReadBlobByte(image);\n} while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\nif (number_colormaps != 0)\n{\nMagickStatusType\nmask;\nmask=(MagickStatusType) (map_length-1);\np=pixels;\nx=(ssize_t) number_planes;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) number_pixels; i++)\n{\nif (IsValidColormapIndex(image,*p & mask,&index,exception) ==\nMagickFalse)\nbreak;\n*p=colormap[(ssize_t) index];\np++;\n}\nelse\nif ((number_planes >= 3) && (number_colormaps >= 3))\nfor (i=0; i < (ssize_t) number_pixels; i++)\nfor (x=0; x < (ssize_t) number_planes; x++)\n{\nif (IsValidColormapIndex(image,(size_t) (x*map_length+\n(*p & mask)),&index,exception) == MagickFalse)\nbreak;\n*p=colormap[(ssize_t) index];\np++;\n}\nif ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n{\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\n}\nif (number_planes >= 3)\n{\np=pixels;\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nSetPixelRed(q,ScaleCharToQuantum(*p++));\nSetPixelGreen(q,ScaleCharToQuantum(*p++));\nSetPixelBlue(q,ScaleCharToQuantum(*p++));\nif (image->matte != MagickFalse)\nSetPixelAlpha(q,ScaleCharToQuantum(*p++));\nq++;\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\nelse\n{\nif (number_colormaps == 0)\nmap_length=256;\nif (AcquireImageColormap(image,map_length) == MagickFalse)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\np=colormap;\nif (number_colormaps == 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\nimage->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n}\nelse\nif (number_colormaps > 1)\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=ScaleCharToQuantum(*p);\nimage->colormap[i].green=ScaleCharToQuantum(*(p+map_length));\nimage->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));\np++;\n}\np=pixels;\nif (image->matte == MagickFalse)\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nindexes=GetAuthenticIndexQueue(image);\nfor (x=0; x < (ssize_t) image->columns; x++)\nSetPixelIndex(indexes+x,*p++);\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n(void) SyncImage(image);\n}\nelse\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (PixelPacket *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nif (IsValidColormapIndex(image,*p++,&index,exception) ==\nMagickFalse)\nbreak;\nSetPixelRed(q,image->colormap[(ssize_t) index].red);\nif (IsValidColormapIndex(image,*p++,&index,exception) ==\nMagickFalse)\nbreak;\nSetPixelGreen(q,image->colormap[(ssize_t) index].green);\nif (IsValidColormapIndex(image,*p++,&index,exception) ==\nMagickFalse)\nbreak;\nSetPixelBlue(q,image->colormap[(ssize_t) index].blue);\nSetPixelAlpha(q,ScaleCharToQuantum(*p++));\nq++;\n}\nif (x < (ssize_t) image->columns)\nbreak;\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\nimage->colormap=(PixelPacket *) RelinquishMagickMemory(\nimage->colormap);\nimage->storage_class=DirectClass;\nimage->colors=0;\n}\n}\nif (number_colormaps != 0)\ncolormap=(unsigned char *) RelinquishMagickMemory(colormap);\npixel_info=RelinquishVirtualMemory(pixel_info);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\n(void) ReadBlobByte(image);\ncount=ReadBlob(image,2,(unsigned char *) magick);\nif ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n{\nAcquireNextImage(image_info,image);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n} while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 177720, "code": "process_add_smartcard_key(SocketEntry *e)\n{\nchar *provider = NULL, *pin;\nint r, i, version, count = 0, success = 0, confirm = 0;\nu_int seconds;\ntime_t death = 0;\nu_char type;\nstruct sshkey **keys = NULL, *k;\nIdentity *id;\nIdtab *tab;\nif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n(r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\nfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\nwhile (sshbuf_len(e->request)) {\nif ((r = sshbuf_get_u8(e->request, &type)) != 0)\nfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\nswitch (type) {\ncase SSH_AGENT_CONSTRAIN_LIFETIME:\nif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\nfatal(\"%s: buffer error: %s\",\n__func__, ssh_err(r));\ndeath = monotime() + seconds;\nbreak;\ncase SSH_AGENT_CONSTRAIN_CONFIRM:\nconfirm = 1;\nbreak;\ndefault:\nerror(\"process_add_smartcard_key: \"\n\"Unknown constraint type %d\", type);\ngoto send;\n}\n}\nif (lifetime && !death)\ndeath = monotime() + lifetime;\ncount = pkcs11_add_provider(provider, pin, &keys);\nfor (i = 0; i < count; i++) {\nk = keys[i];\nversion = k->type == KEY_RSA1 ? 1 : 2;\ntab = idtab_lookup(version);\nif (lookup_identity(k, version) == NULL) {\nid = xcalloc(1, sizeof(Identity));\nid->key = k;\nid->provider = xstrdup(provider);\nid->comment = xstrdup(provider);\nid->death = death;\nid->confirm = confirm;\nTAILQ_INSERT_TAIL(&tab->idlist, id, next);\ntab->nentries++;\nsuccess = 1;\n} else {\nsshkey_free(k);\n}\nkeys[i] = NULL;\n}\nsend:\nfree(pin);\nfree(provider);\nfree(keys);\nsend_status(e, success);\n}", "contrast": "process_add_smartcard_key(SocketEntry *e)\n{\nchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\nint r, i, version, count = 0, success = 0, confirm = 0;\nu_int seconds;\ntime_t death = 0;\nu_char type;\nstruct sshkey **keys = NULL, *k;\nIdentity *id;\nIdtab *tab;\nif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n(r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\nfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\nwhile (sshbuf_len(e->request)) {\nif ((r = sshbuf_get_u8(e->request, &type)) != 0)\nfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\nswitch (type) {\ncase SSH_AGENT_CONSTRAIN_LIFETIME:\nif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\nfatal(\"%s: buffer error: %s\",\n__func__, ssh_err(r));\ndeath = monotime() + seconds;\nbreak;\ncase SSH_AGENT_CONSTRAIN_CONFIRM:\nconfirm = 1;\nbreak;\ndefault:\nerror(\"process_add_smartcard_key: \"\n\"Unknown constraint type %d\", type);\ngoto send;\n}\n}\nif (realpath(provider, canonical_provider) == NULL) {\nverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\nprovider, strerror(errno));\ngoto send;\n}\nif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\nverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\"provider not whitelisted\", canonical_provider);\ngoto send;\n}\ndebug(\"%s: add %.100s\", __func__, canonical_provider);\nif (lifetime && !death)\ndeath = monotime() + lifetime;\ncount = pkcs11_add_provider(canonical_provider, pin, &keys);\nfor (i = 0; i < count; i++) {\nk = keys[i];\nversion = k->type == KEY_RSA1 ? 1 : 2;\ntab = idtab_lookup(version);\nif (lookup_identity(k, version) == NULL) {\nid = xcalloc(1, sizeof(Identity));\nid->key = k;\nid->provider = xstrdup(canonical_provider);\nid->comment = xstrdup(canonical_provider);\nid->death = death;\nid->confirm = confirm;\nTAILQ_INSERT_TAIL(&tab->idlist, id, next);\ntab->nentries++;\nsuccess = 1;\n} else {\nsshkey_free(k);\n}\nkeys[i] = NULL;\n}\nsend:\nfree(pin);\nfree(provider);\nfree(keys);\nsend_status(e, success);\n}", "label": 0}
{"index": 177724, "code": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\nint lastBorder;\nint leftLimit = -1, rightLimit;\nint i, restoreAlphaBlending = 0;\nif (border < 0) {\nreturn;\n}\nif (!im->trueColor) {\nif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\nreturn;\n}\n}\nrestoreAlphaBlending = im->alphaBlendingFlag;\nim->alphaBlendingFlag = 0;\nif (x >= im->sx) {\nx = im->sx - 1;\n} else if (x < 0) {\nx = 0;\n}\nif (y >= im->sy) {\ny = im->sy - 1;\n} else if (y < 0) {\ny = 0;\n}\nfor (i = x; i >= 0; i--) {\nif (gdImageGetPixel(im, i, y) == border) {\nbreak;\n}\ngdImageSetPixel(im, i, y, color);\nleftLimit = i;\n}\nif (leftLimit == -1) {\nim->alphaBlendingFlag = restoreAlphaBlending;\nreturn;\n}\nrightLimit = x;\nfor (i = (x + 1); i < im->sx; i++) {\nif (gdImageGetPixel(im, i, y) == border) {\nbreak;\n}\ngdImageSetPixel(im, i, y, color);\nrightLimit = i;\n}\nif (y > 0) {\nlastBorder = 1;\nfor (i = leftLimit; i <= rightLimit; i++) {\nint c = gdImageGetPixel(im, i, y - 1);\nif (lastBorder) {\nif ((c != border) && (c != color)) {\ngdImageFillToBorder(im, i, y - 1, border, color);\nlastBorder = 0;\n}\n} else if ((c == border) || (c == color)) {\nlastBorder = 1;\n}\n}\n}\nif (y < ((im->sy) - 1)) {\nlastBorder = 1;\nfor (i = leftLimit; i <= rightLimit; i++) {\nint c = gdImageGetPixel(im, i, y + 1);\nif (lastBorder) {\nif ((c != border) && (c != color)) {\ngdImageFillToBorder(im, i, y + 1, border, color);\nlastBorder = 0;\n}\n} else if ((c == border) || (c == color)) {\nlastBorder = 1;\n}\n}\n}\nim->alphaBlendingFlag = restoreAlphaBlending;\n}", "contrast": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\nint lastBorder;\nint leftLimit = -1, rightLimit;\nint i, restoreAlphaBlending = 0;\nif (border < 0 || color < 0) {\nreturn;\n}\nif (!im->trueColor) {\nif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\nreturn;\n}\n}\nrestoreAlphaBlending = im->alphaBlendingFlag;\nim->alphaBlendingFlag = 0;\nif (x >= im->sx) {\nx = im->sx - 1;\n} else if (x < 0) {\nx = 0;\n}\nif (y >= im->sy) {\ny = im->sy - 1;\n} else if (y < 0) {\ny = 0;\n}\nfor (i = x; i >= 0; i--) {\nif (gdImageGetPixel(im, i, y) == border) {\nbreak;\n}\ngdImageSetPixel(im, i, y, color);\nleftLimit = i;\n}\nif (leftLimit == -1) {\nim->alphaBlendingFlag = restoreAlphaBlending;\nreturn;\n}\nrightLimit = x;\nfor (i = (x + 1); i < im->sx; i++) {\nif (gdImageGetPixel(im, i, y) == border) {\nbreak;\n}\ngdImageSetPixel(im, i, y, color);\nrightLimit = i;\n}\nif (y > 0) {\nlastBorder = 1;\nfor (i = leftLimit; i <= rightLimit; i++) {\nint c = gdImageGetPixel(im, i, y - 1);\nif (lastBorder) {\nif ((c != border) && (c != color)) {\ngdImageFillToBorder(im, i, y - 1, border, color);\nlastBorder = 0;\n}\n} else if ((c == border) || (c == color)) {\nlastBorder = 1;\n}\n}\n}\nif (y < ((im->sy) - 1)) {\nlastBorder = 1;\nfor (i = leftLimit; i <= rightLimit; i++) {\nint c = gdImageGetPixel(im, i, y + 1);\nif (lastBorder) {\nif ((c != border) && (c != color)) {\ngdImageFillToBorder(im, i, y + 1, border, color);\nlastBorder = 0;\n}\n} else if ((c == border) || (c == color)) {\nlastBorder = 1;\n}\n}\n}\nim->alphaBlendingFlag = restoreAlphaBlending;\n}", "label": 0}
{"index": 177729, "code": "int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\nint cpu_id)\n{\nstruct ring_buffer_per_cpu *cpu_buffer;\nunsigned long nr_pages;\nint cpu, err = 0;\nif (!buffer)\nreturn size;\nif (cpu_id != RING_BUFFER_ALL_CPUS &&\n!cpumask_test_cpu(cpu_id, buffer->cpumask))\nreturn size;\nsize = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\nsize *= BUF_PAGE_SIZE;\nif (size < BUF_PAGE_SIZE * 2)\nsize = BUF_PAGE_SIZE * 2;\nnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\nif (atomic_read(&buffer->resize_disabled))\nreturn -EBUSY;\nmutex_lock(&buffer->mutex);\nif (cpu_id == RING_BUFFER_ALL_CPUS) {\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\ncpu_buffer->nr_pages_to_update = nr_pages -\ncpu_buffer->nr_pages;\nif (cpu_buffer->nr_pages_to_update <= 0)\ncontinue;\nINIT_LIST_HEAD(&cpu_buffer->new_pages);\nif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n&cpu_buffer->new_pages, cpu)) {\nerr = -ENOMEM;\ngoto out_err;\n}\n}\nget_online_cpus();\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\nif (!cpu_buffer->nr_pages_to_update)\ncontinue;\nif (!cpu_online(cpu)) {\nrb_update_pages(cpu_buffer);\ncpu_buffer->nr_pages_to_update = 0;\n} else {\nschedule_work_on(cpu,\n&cpu_buffer->update_pages_work);\n}\n}\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\nif (!cpu_buffer->nr_pages_to_update)\ncontinue;\nif (cpu_online(cpu))\nwait_for_completion(&cpu_buffer->update_done);\ncpu_buffer->nr_pages_to_update = 0;\n}\nput_online_cpus();\n} else {\nif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\ngoto out;\ncpu_buffer = buffer->buffers[cpu_id];\nif (nr_pages == cpu_buffer->nr_pages)\ngoto out;\ncpu_buffer->nr_pages_to_update = nr_pages -\ncpu_buffer->nr_pages;\nINIT_LIST_HEAD(&cpu_buffer->new_pages);\nif (cpu_buffer->nr_pages_to_update > 0 &&\n__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n&cpu_buffer->new_pages, cpu_id)) {\nerr = -ENOMEM;\ngoto out_err;\n}\nget_online_cpus();\nif (!cpu_online(cpu_id))\nrb_update_pages(cpu_buffer);\nelse {\nschedule_work_on(cpu_id,\n&cpu_buffer->update_pages_work);\nwait_for_completion(&cpu_buffer->update_done);\n}\ncpu_buffer->nr_pages_to_update = 0;\nput_online_cpus();\n}\nout:\nif (atomic_read(&buffer->record_disabled)) {\natomic_inc(&buffer->record_disabled);\nsynchronize_sched();\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\nrb_check_pages(cpu_buffer);\n}\natomic_dec(&buffer->record_disabled);\n}\nmutex_unlock(&buffer->mutex);\nreturn size;\nout_err:\nfor_each_buffer_cpu(buffer, cpu) {\nstruct buffer_page *bpage, *tmp;\ncpu_buffer = buffer->buffers[cpu];\ncpu_buffer->nr_pages_to_update = 0;\nif (list_empty(&cpu_buffer->new_pages))\ncontinue;\nlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\nlist) {\nlist_del_init(&bpage->list);\nfree_buffer_page(bpage);\n}\n}\nmutex_unlock(&buffer->mutex);\nreturn err;\n}", "contrast": "int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\nint cpu_id)\n{\nstruct ring_buffer_per_cpu *cpu_buffer;\nunsigned long nr_pages;\nint cpu, err = 0;\nif (!buffer)\nreturn size;\nif (cpu_id != RING_BUFFER_ALL_CPUS &&\n!cpumask_test_cpu(cpu_id, buffer->cpumask))\nreturn size;\nnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\nif (nr_pages < 2)\nnr_pages = 2;\nsize = nr_pages * BUF_PAGE_SIZE;\nif (atomic_read(&buffer->resize_disabled))\nreturn -EBUSY;\nmutex_lock(&buffer->mutex);\nif (cpu_id == RING_BUFFER_ALL_CPUS) {\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\ncpu_buffer->nr_pages_to_update = nr_pages -\ncpu_buffer->nr_pages;\nif (cpu_buffer->nr_pages_to_update <= 0)\ncontinue;\nINIT_LIST_HEAD(&cpu_buffer->new_pages);\nif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n&cpu_buffer->new_pages, cpu)) {\nerr = -ENOMEM;\ngoto out_err;\n}\n}\nget_online_cpus();\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\nif (!cpu_buffer->nr_pages_to_update)\ncontinue;\nif (!cpu_online(cpu)) {\nrb_update_pages(cpu_buffer);\ncpu_buffer->nr_pages_to_update = 0;\n} else {\nschedule_work_on(cpu,\n&cpu_buffer->update_pages_work);\n}\n}\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\nif (!cpu_buffer->nr_pages_to_update)\ncontinue;\nif (cpu_online(cpu))\nwait_for_completion(&cpu_buffer->update_done);\ncpu_buffer->nr_pages_to_update = 0;\n}\nput_online_cpus();\n} else {\nif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\ngoto out;\ncpu_buffer = buffer->buffers[cpu_id];\nif (nr_pages == cpu_buffer->nr_pages)\ngoto out;\ncpu_buffer->nr_pages_to_update = nr_pages -\ncpu_buffer->nr_pages;\nINIT_LIST_HEAD(&cpu_buffer->new_pages);\nif (cpu_buffer->nr_pages_to_update > 0 &&\n__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n&cpu_buffer->new_pages, cpu_id)) {\nerr = -ENOMEM;\ngoto out_err;\n}\nget_online_cpus();\nif (!cpu_online(cpu_id))\nrb_update_pages(cpu_buffer);\nelse {\nschedule_work_on(cpu_id,\n&cpu_buffer->update_pages_work);\nwait_for_completion(&cpu_buffer->update_done);\n}\ncpu_buffer->nr_pages_to_update = 0;\nput_online_cpus();\n}\nout:\nif (atomic_read(&buffer->record_disabled)) {\natomic_inc(&buffer->record_disabled);\nsynchronize_sched();\nfor_each_buffer_cpu(buffer, cpu) {\ncpu_buffer = buffer->buffers[cpu];\nrb_check_pages(cpu_buffer);\n}\natomic_dec(&buffer->record_disabled);\n}\nmutex_unlock(&buffer->mutex);\nreturn size;\nout_err:\nfor_each_buffer_cpu(buffer, cpu) {\nstruct buffer_page *bpage, *tmp;\ncpu_buffer = buffer->buffers[cpu];\ncpu_buffer->nr_pages_to_update = 0;\nif (list_empty(&cpu_buffer->new_pages))\ncontinue;\nlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\nlist) {\nlist_del_init(&bpage->list);\nfree_buffer_page(bpage);\n}\n}\nmutex_unlock(&buffer->mutex);\nreturn err;\n}", "label": 0}
{"index": 177739, "code": "static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)\n{\nint i;\nint c;\nfor (i = n; i > 0; --i) {\nc = (val >> (8 * (i - 1))) & 0xff;\nif (jas_stream_putc(out, c) == EOF)\nreturn -1;\n}\nreturn 0;\n}", "contrast": "static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)\nstatic int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val)\n{\nint i;\nint c;\nfor (i = n; i > 0; --i) {\nc = (val >> (8 * (i - 1))) & 0xff;\nif (jas_stream_putc(out, c) == EOF)\nreturn -1;\n}\nreturn 0;\n}", "label": 0}
{"index": 177744, "code": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\njas_matrix_t *matrix;\nint i;\nsize_t size;\nmatrix = 0;\nif (numrows < 0 || numcols < 0) {\ngoto error;\n}\nif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\ngoto error;\n}\nmatrix->flags_ = 0;\nmatrix->numrows_ = numrows;\nmatrix->numcols_ = numcols;\nmatrix->rows_ = 0;\nmatrix->maxrows_ = numrows;\nmatrix->data_ = 0;\nmatrix->datasize_ = 0;\nif (!jas_safe_size_mul(numrows, numcols, &size)) {\ngoto error;\n}\nmatrix->datasize_ = size;\nif (matrix->maxrows_ > 0) {\nif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\nsizeof(jas_seqent_t *)))) {\ngoto error;\n}\n}\nif (matrix->datasize_ > 0) {\nif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\nsizeof(jas_seqent_t)))) {\ngoto error;\n}\n}\nfor (i = 0; i < numrows; ++i) {\nmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n}\nfor (i = 0; i < matrix->datasize_; ++i) {\nmatrix->data_[i] = 0;\n}\nmatrix->xstart_ = 0;\nmatrix->ystart_ = 0;\nmatrix->xend_ = matrix->numcols_;\nmatrix->yend_ = matrix->numrows_;\nreturn matrix;\nerror:\nif (matrix) {\njas_matrix_destroy(matrix);\n}\nreturn 0;\n}", "contrast": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\njas_matrix_t *jas_matrix_create(jas_matind_t numrows, jas_matind_t numcols)\n{\njas_matrix_t *matrix;\njas_matind_t i;\nsize_t size;\nmatrix = 0;\nif (numrows < 0 || numcols < 0) {\ngoto error;\n}\nif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\ngoto error;\n}\nmatrix->flags_ = 0;\nmatrix->numrows_ = numrows;\nmatrix->numcols_ = numcols;\nmatrix->rows_ = 0;\nmatrix->maxrows_ = numrows;\nmatrix->data_ = 0;\nmatrix->datasize_ = 0;\nif (!jas_safe_size_mul(numrows, numcols, &size)) {\ngoto error;\n}\nmatrix->datasize_ = size;\nif (matrix->maxrows_ > 0) {\nif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\nsizeof(jas_seqent_t *)))) {\ngoto error;\n}\n}\nif (matrix->datasize_ > 0) {\nif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\nsizeof(jas_seqent_t)))) {\ngoto error;\n}\n}\nfor (i = 0; i < numrows; ++i) {\nmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n}\nfor (i = 0; i < matrix->datasize_; ++i) {\nmatrix->data_[i] = 0;\n}\nmatrix->xstart_ = 0;\nmatrix->ystart_ = 0;\nmatrix->xend_ = matrix->numcols_;\nmatrix->yend_ = matrix->numrows_;\nreturn matrix;\nerror:\nif (matrix) {\njas_matrix_destroy(matrix);\n}\nreturn 0;\n}", "label": 0}
{"index": 177756, "code": "int jpg_validate(jas_stream_t *in)\n{\nuchar buf[JPG_MAGICLEN];\nint i;\nint n;\nassert(JAS_STREAM_MAXPUTBACK >= JPG_MAGICLEN);\nif ((n = jas_stream_read(in, buf, JPG_MAGICLEN)) < 0) {\nreturn -1;\n}\nfor (i = n - 1; i >= 0; --i) {\nif (jas_stream_ungetc(in, buf[i]) == EOF) {\nreturn -1;\n}\n}\nif (n < JPG_MAGICLEN) {\nreturn -1;\n}\nif (buf[0] != (JPG_MAGIC >> 8) || buf[1] != (JPG_MAGIC & 0xff)) {\nreturn -1;\n}\nreturn 0;\n}", "contrast": "int jpg_validate(jas_stream_t *in)\n{\njas_uchar buf[JPG_MAGICLEN];\nint i;\nint n;\nassert(JAS_STREAM_MAXPUTBACK >= JPG_MAGICLEN);\nif ((n = jas_stream_read(in, buf, JPG_MAGICLEN)) < 0) {\nreturn -1;\n}\nfor (i = n - 1; i >= 0; --i) {\nif (jas_stream_ungetc(in, buf[i]) == EOF) {\nreturn -1;\n}\n}\nif (n < JPG_MAGICLEN) {\nreturn -1;\n}\nif (buf[0] != (JPG_MAGIC >> 8) || buf[1] != (JPG_MAGIC & 0xff)) {\nreturn -1;\n}\nreturn 0;\n}", "label": 0}
{"index": 177765, "code": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\nint m;\nassert(n >= 0 && n < 32);\nassert(!(v & (~JAS_ONES(n))));\nm = n - 1;\nwhile (--n >= 0) {\nif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\nreturn EOF;\n}\nv <<= 1;\n}\nreturn 0;\n}", "contrast": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\nint m;\nif (n < 0 || n >= 32) {\nreturn EOF;\n}\nassert(!(v & (~JAS_ONES(n))));\nm = n - 1;\nwhile (--n >= 0) {\nif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\nreturn EOF;\n}\nv <<= 1;\n}\nreturn 0;\n}", "label": 0}
{"index": 177766, "code": "static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)\n{\nint i;\nint j;\nint x;\nint c;\nint numcolors;\nint actualnumcolors;\nswitch (hdr->maptype) {\ncase RAS_MT_NONE:\nbreak;\ncase RAS_MT_EQUALRGB:\n{\njas_eprintf(\"warning: palettized images not fully supported\\n\");\nnumcolors = 1 << hdr->depth;\nassert(numcolors <= RAS_CMAP_MAXSIZ);\nactualnumcolors = hdr->maplength / 3;\nfor (i = 0; i < numcolors; i++) {\ncmap->data[i] = 0;\n}\nif ((hdr->maplength % 3) || hdr->maplength < 0 ||\nhdr->maplength > 3 * numcolors) {\nreturn -1;\n}\nfor (i = 0; i < 3; i++) {\nfor (j = 0; j < actualnumcolors; j++) {\nif ((c = jas_stream_getc(in)) == EOF) {\nreturn -1;\n}\nx = 0;\nswitch (i) {\ncase 0:\nx = RAS_RED(c);\nbreak;\ncase 1:\nx = RAS_GREEN(c);\nbreak;\ncase 2:\nx = RAS_BLUE(c);\nbreak;\n}\ncmap->data[j] |= x;\n}\n}\n}\nbreak;\ndefault:\nreturn -1;\nbreak;\n}\nreturn 0;\n}", "contrast": "static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)\n{\nint i;\nint j;\nint x;\nint c;\nint numcolors;\nint actualnumcolors;\nswitch (hdr->maptype) {\ncase RAS_MT_NONE:\nbreak;\ncase RAS_MT_EQUALRGB:\n{\njas_eprintf(\"warning: palettized images not fully supported\\n\");\nnumcolors = 1 << hdr->depth;\nif (numcolors > RAS_CMAP_MAXSIZ) {\nreturn -1;\n}\nactualnumcolors = hdr->maplength / 3;\nfor (i = 0; i < numcolors; i++) {\ncmap->data[i] = 0;\n}\nif ((hdr->maplength % 3) || hdr->maplength < 0 ||\nhdr->maplength > 3 * numcolors) {\nreturn -1;\n}\nfor (i = 0; i < 3; i++) {\nfor (j = 0; j < actualnumcolors; j++) {\nif ((c = jas_stream_getc(in)) == EOF) {\nreturn -1;\n}\nx = 0;\nswitch (i) {\ncase 0:\nx = RAS_RED(c);\nbreak;\ncase 1:\nx = RAS_GREEN(c);\nbreak;\ncase 2:\nx = RAS_BLUE(c);\nbreak;\n}\ncmap->data[j] |= x;\n}\n}\n}\nbreak;\ndefault:\nreturn -1;\nbreak;\n}\nreturn 0;\n}", "label": 0}
{"index": 177774, "code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\njp2_box_t *box;\njp2_boxinfo_t *boxinfo;\njas_stream_t *tmpstream;\nuint_fast32_t len;\nuint_fast64_t extlen;\nbool dataflag;\nbox = 0;\ntmpstream = 0;\nif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\ngoto error;\n}\nbox->ops = &jp2_boxinfo_unk.ops;\nif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\ngoto error;\n}\nboxinfo = jp2_boxinfolookup(box->type);\nbox->info = boxinfo;\nbox->ops = &boxinfo->ops;\nbox->len = len;\nif (box->len == 1) {\nif (jp2_getuint64(in, &extlen)) {\ngoto error;\n}\nif (extlen > 0xffffffffUL) {\njas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\nextlen = 0xffffffffUL;\n}\nbox->len = extlen;\nbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n} else {\nbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n}\nif (box->len != 0 && box->len < 8) {\ngoto error;\n}\ndataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\nif (dataflag) {\nif (!(tmpstream = jas_stream_memopen(0, 0))) {\ngoto error;\n}\nif (jas_stream_copy(tmpstream, in, box->datalen)) {\njas_eprintf(\"cannot copy box data\\n\");\ngoto error;\n}\njas_stream_rewind(tmpstream);\nif (box->ops->getdata) {\nif ((*box->ops->getdata)(box, tmpstream)) {\njas_eprintf(\"cannot parse box data\\n\");\ngoto error;\n}\n}\njas_stream_close(tmpstream);\n}\nif (jas_getdbglevel() >= 1) {\njp2_box_dump(box, stderr);\n}\nreturn box;\nerror:\nif (box) {\njp2_box_destroy(box);\n}\nif (tmpstream) {\njas_stream_close(tmpstream);\n}\nreturn 0;\n}", "contrast": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\njp2_box_t *box;\njp2_boxinfo_t *boxinfo;\njas_stream_t *tmpstream;\nuint_fast32_t len;\nuint_fast64_t extlen;\nbool dataflag;\nbox = 0;\ntmpstream = 0;\nif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\ngoto error;\n}\nbox->ops = &jp2_boxinfo_unk.ops;\nif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\ngoto error;\n}\nboxinfo = jp2_boxinfolookup(box->type);\nbox->info = boxinfo;\nbox->ops = &boxinfo->ops;\nbox->len = len;\nJAS_DBGLOG(10, (\n\"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n'\"', boxinfo->name, '\"', box->type, box->len\n));\nif (box->len == 1) {\nif (jp2_getuint64(in, &extlen)) {\ngoto error;\n}\nif (extlen > 0xffffffffUL) {\njas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\nextlen = 0xffffffffUL;\n}\nbox->len = extlen;\nbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n} else {\nbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n}\nif (box->len != 0 && box->len < 8) {\ngoto error;\n}\ndataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\nif (dataflag) {\nif (!(tmpstream = jas_stream_memopen(0, 0))) {\ngoto error;\n}\nif (jas_stream_copy(tmpstream, in, box->datalen)) {\nbox->ops = &jp2_boxinfo_unk.ops;\njas_eprintf(\"cannot copy box data\\n\");\ngoto error;\n}\njas_stream_rewind(tmpstream);\nif (box->ops->getdata) {\nif ((*box->ops->getdata)(box, tmpstream)) {\njas_eprintf(\"cannot parse box data\\n\");\ngoto error;\n}\n}\njas_stream_close(tmpstream);\n}\nif (jas_getdbglevel() >= 1) {\njp2_box_dump(box, stderr);\n}\nreturn box;\nerror:\nif (box) {\njp2_box_destroy(box);\n}\nif (tmpstream) {\njas_stream_close(tmpstream);\n}\nreturn 0;\n}", "label": 0}
{"index": 177778, "code": "chunk_grow(chunk_t *chunk, size_t sz)\n{\noff_t offset;\nsize_t memlen_orig = chunk->memlen;\ntor_assert(sz > chunk->memlen);\noffset = chunk->data - chunk->mem;\nchunk = tor_realloc(chunk, CHUNK_ALLOC_SIZE(sz));\nchunk->memlen = sz;\nchunk->data = chunk->mem + offset;\n#ifdef DEBUG_CHUNK_ALLOC\ntor_assert(chunk->DBG_alloc == CHUNK_ALLOC_SIZE(memlen_orig));\nchunk->DBG_alloc = CHUNK_ALLOC_SIZE(sz);\n#endif\ntotal_bytes_allocated_in_chunks +=\nCHUNK_ALLOC_SIZE(sz) - CHUNK_ALLOC_SIZE(memlen_orig);\nreturn chunk;\n}", "contrast": "chunk_grow(chunk_t *chunk, size_t sz)\n{\noff_t offset;\nconst size_t memlen_orig = chunk->memlen;\nconst size_t orig_alloc = CHUNK_ALLOC_SIZE(memlen_orig);\nconst size_t new_alloc = CHUNK_ALLOC_SIZE(sz);\ntor_assert(sz > chunk->memlen);\noffset = chunk->data - chunk->mem;\nchunk = tor_realloc(chunk, new_alloc);\nchunk->memlen = sz;\nchunk->data = chunk->mem + offset;\n#ifdef DEBUG_CHUNK_ALLOC\ntor_assert(chunk->DBG_alloc == orig_alloc);\nchunk->DBG_alloc = new_alloc;\n#endif\ntotal_bytes_allocated_in_chunks += new_alloc - orig_alloc;\nCHUNK_SET_SENTINEL(chunk, new_alloc);\nreturn chunk;\n}", "label": 0}
{"index": 177793, "code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\nswitch (mem->type) {\ncase RXE_MEM_TYPE_DMA:\nreturn 0;\ncase RXE_MEM_TYPE_MR:\ncase RXE_MEM_TYPE_FMR:\nreturn ((iova < mem->iova) ||\n((iova + length) > (mem->iova + mem->length))) ?\n-EFAULT : 0;\ndefault:\nreturn -EFAULT;\n}\n}", "contrast": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\nswitch (mem->type) {\ncase RXE_MEM_TYPE_DMA:\nreturn 0;\ncase RXE_MEM_TYPE_MR:\ncase RXE_MEM_TYPE_FMR:\nif (iova < mem->iova ||\nlength > mem->length ||\niova > mem->iova + mem->length - length)\nreturn -EFAULT;\nreturn 0;\ndefault:\nreturn -EFAULT;\n}\n}", "label": 0}
{"index": 177794, "code": "static bool check_allocations(ASS_Shaper *shaper, size_t new_size)\n{\nif (new_size > shaper->n_glyphs) {\nif (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||\n!ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||\n!ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||\n!ASS_REALLOC_ARRAY(shaper->cmap, new_size))\nreturn false;\n}\nreturn true;\n}", "contrast": "static bool check_allocations(ASS_Shaper *shaper, size_t new_size)\n{\nif (new_size > shaper->n_glyphs) {\nif (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||\n!ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||\n!ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||\n!ASS_REALLOC_ARRAY(shaper->cmap, new_size))\nreturn false;\nshaper->n_glyphs = new_size;\n}\nreturn true;\n}", "label": 0}
{"index": 177824, "code": "int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\nstruct Client* acptr;\nint first = 0;\nchar realhost[HOSTLEN + 3];\nchar *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\nif (!CapActive(cptr, CAP_SASL))\nreturn 0;\nif (parc < 2)\nreturn need_more_params(cptr, \"AUTHENTICATE\");\nif (strlen(parv[1]) > 400)\nreturn send_reply(cptr, ERR_SASLTOOLONG);\nif (IsSASLComplete(cptr))\nreturn send_reply(cptr, ERR_SASLALREADY);\nif (!(acptr = cli_saslagent(cptr))) {\nif (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\nacptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\nelse\nacptr = NULL;\n}\nif (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\nreturn send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\nif (acptr && IsMe(acptr))\nreturn 0;\nif (!cli_saslcookie(cptr)) {\ndo {\ncli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n} while (!cli_saslcookie(cptr));\nfirst = 1;\n}\nif (strchr(hoststr, ':') != NULL)\nircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\nelse\nircd_strncpy(realhost, hoststr, sizeof(realhost));\nif (acptr) {\nif (first) {\nif (!EmptyString(cli_sslclifp(cptr)))\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr),\nparv[1], cli_sslclifp(cptr));\nelse\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\nif (feature_bool(FEAT_SASL_SENDHOST))\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\nrealhost, cli_sock_ip(cptr));\n} else {\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n}\n} else {\nif (first) {\nif (!EmptyString(cli_sslclifp(cptr)))\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr),\nparv[1], cli_sslclifp(cptr));\nelse\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\nif (feature_bool(FEAT_SASL_SENDHOST))\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\nrealhost, cli_sock_ip(cptr));\n} else {\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n}\n}\nif (!t_active(&cli_sasltimeout(cptr)))\ntimer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\nTT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\nreturn 0;\n}", "contrast": "int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\nstruct Client* acptr;\nint first = 0;\nchar realhost[HOSTLEN + 3];\nchar *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\nif (!CapActive(cptr, CAP_SASL))\nreturn 0;\nif (parc < 2)\nreturn need_more_params(cptr, \"AUTHENTICATE\");\nif (strlen(parv[1]) > 400)\nreturn send_reply(cptr, ERR_SASLTOOLONG);\nif (IsSASLComplete(cptr))\nreturn send_reply(cptr, ERR_SASLALREADY);\nif (!(acptr = cli_saslagent(cptr))) {\nif (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\nacptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\nelse\nacptr = NULL;\n}\nif (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\nreturn send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\nif (acptr && IsMe(acptr))\nreturn 0;\nif (!cli_saslcookie(cptr)) {\ndo {\ncli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n} while (!cli_saslcookie(cptr));\nfirst = 1;\n}\nif (strchr(hoststr, ':') != NULL)\nircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\nelse\nircd_strncpy(realhost, hoststr, sizeof(realhost));\nif (acptr) {\nif (first) {\nif (*parv[1] == ':' || strchr(parv[1], ' '))\nreturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\nif (!EmptyString(cli_sslclifp(cptr)))\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr),\nparv[1], cli_sslclifp(cptr));\nelse\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\nif (feature_bool(FEAT_SASL_SENDHOST))\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\nrealhost, cli_sock_ip(cptr));\n} else {\nsendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n}\n} else {\nif (first) {\nif (*parv[1] == ':' || strchr(parv[1], ' '))\nreturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\nif (!EmptyString(cli_sslclifp(cptr)))\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr),\nparv[1], cli_sslclifp(cptr));\nelse\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\nif (feature_bool(FEAT_SASL_SENDHOST))\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\nrealhost, cli_sock_ip(cptr));\n} else {\nsendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\ncli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n}\n}\nif (!t_active(&cli_sasltimeout(cptr)))\ntimer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\nTT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\nreturn 0;\n}", "label": 0}
{"index": 177852, "code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\nunsigned int header_len;\nif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\nreturn 0;\n}\nif (!extend_raw_data(header, stream,\nLEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\nreturn 0;\n}\nheader_len = lha_decode_uint32(&RAW_DATA(header, 24));\nif (header_len > LEVEL_3_MAX_HEADER_LEN) {\nreturn 0;\n}\nif (!extend_raw_data(header, stream,\nheader_len - RAW_DATA_LEN(header))) {\nreturn 0;\n}\nmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n(*header)->compress_method[5] = '\\0';\n(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n(*header)->os_type = RAW_DATA(header, 23);\nif (!decode_extended_headers(header, 28)) {\nreturn 0;\n}\nreturn 1;\n}", "contrast": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\nunsigned int header_len;\nif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\nreturn 0;\n}\nif (!extend_raw_data(header, stream,\nLEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\nreturn 0;\n}\nheader_len = lha_decode_uint32(&RAW_DATA(header, 24));\nif (header_len > LEVEL_3_MAX_HEADER_LEN\n|| header_len < RAW_DATA_LEN(header)) {\nreturn 0;\n}\nif (!extend_raw_data(header, stream,\nheader_len - RAW_DATA_LEN(header))) {\nreturn 0;\n}\nmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n(*header)->compress_method[5] = '\\0';\n(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n(*header)->os_type = RAW_DATA(header, 23);\nif (!decode_extended_headers(header, 28)) {\nreturn 0;\n}\nreturn 1;\n}", "label": 0}
{"index": 177853, "code": "static uint8_t *extend_raw_data(LHAFileHeader **header,\nLHAInputStream *stream,\nsize_t nbytes)\n{\nLHAFileHeader *new_header;\nsize_t new_raw_len;\nuint8_t *result;\nnew_raw_len = RAW_DATA_LEN(header) + nbytes;\nnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\nif (new_header == NULL) {\nreturn NULL;\n}\n*header = new_header;\nnew_header->raw_data = (uint8_t *) (new_header + 1);\nresult = new_header->raw_data + new_header->raw_data_len;\nif (!lha_input_stream_read(stream, result, nbytes)) {\nreturn NULL;\n}\nnew_header->raw_data_len = new_raw_len;\nreturn result;\n}", "contrast": "static uint8_t *extend_raw_data(LHAFileHeader **header,\nLHAInputStream *stream,\nsize_t nbytes)\n{\nLHAFileHeader *new_header;\nsize_t new_raw_len;\nuint8_t *result;\nif (nbytes > LEVEL_3_MAX_HEADER_LEN) {\nreturn NULL;\n}\nnew_raw_len = RAW_DATA_LEN(header) + nbytes;\nnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\nif (new_header == NULL) {\nreturn NULL;\n}\n*header = new_header;\nnew_header->raw_data = (uint8_t *) (new_header + 1);\nresult = new_header->raw_data + new_header->raw_data_len;\nif (!lha_input_stream_read(stream, result, nbytes)) {\nreturn NULL;\n}\nnew_header->raw_data_len = new_raw_len;\nreturn result;\n}", "label": 0}
{"index": 177867, "code": "MagickExport const char *GetMagickFeatures(void)\n{\nreturn \"DPC\"\n#if defined(MAGICKCORE_BUILD_MODULES) || defined(_DLL)\n\" Modules\"\n#endif\n#if defined(MAGICKCORE_HDRI_SUPPORT)\n\" HDRI\"\n#endif\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n\" OpenCL\"\n#endif\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n\" OpenMP\"\n#endif\n;\n}", "contrast": "MagickExport const char *GetMagickFeatures(void)\n{\nreturn \"DPC\"\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) && defined(_DEBUG)\n\" Debug\"\n#endif\n#if defined(MAGICKCORE_CIPHER_SUPPORT)\n\" Cipher\"\n#endif\n#if defined(MAGICKCORE_HDRI_SUPPORT)\n\" HDRI\"\n#endif\n#if defined(MAGICKCORE_BUILD_MODULES) || defined(_DLL)\n\" Modules\"\n#endif\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n\" OpenCL\"\n#endif\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n\" OpenMP\"\n#endif\n#if defined(ZERO_CONFIGURATION_SUPPORT)\n\" Zero-configuration\"\n#endif\n;\n}", "label": 0}
{"index": 177875, "code": "enum nss_status _nss_mymachines_getgrnam_r(\nconst char *name,\nstruct group *gr,\nchar *buffer, size_t buflen,\nint *errnop) {\n_cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n_cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n_cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\nconst char *p, *e, *machine;\nuint32_t mapped;\nuid_t gid;\nsize_t l;\nint r;\nassert(name);\nassert(gr);\np = startswith(name, \"vg-\");\nif (!p)\ngoto not_found;\ne = strrchr(p, '-');\nif (!e || e == p)\ngoto not_found;\nr = parse_gid(e + 1, &gid);\nif (r < 0)\ngoto not_found;\nmachine = strndupa(p, e - p);\nif (!machine_name_is_valid(machine))\ngoto not_found;\nr = sd_bus_open_system(&bus);\nif (r < 0)\ngoto fail;\nr = sd_bus_call_method(bus,\n\"org.freedesktop.machine1\",\n\"/org/freedesktop/machine1\",\n\"org.freedesktop.machine1.Manager\",\n\"MapFromMachineGroup\",\n&error,\n&reply,\n\"su\",\nmachine, (uint32_t) gid);\nif (r < 0) {\nif (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\ngoto not_found;\ngoto fail;\n}\nr = sd_bus_message_read(reply, \"u\", &mapped);\nif (r < 0)\ngoto fail;\nl = sizeof(char*) + strlen(name) + 1;\nif (buflen < l) {\n*errnop = ENOMEM;\nreturn NSS_STATUS_TRYAGAIN;\n}\nmemzero(buffer, sizeof(char*));\nstrcpy(buffer + sizeof(char*), name);\ngr->gr_name = buffer + sizeof(char*);\ngr->gr_gid = gid;\ngr->gr_passwd = (char*) \"*\";\ngr->gr_mem = (char**) buffer;\n*errnop = 0;\nreturn NSS_STATUS_SUCCESS;\nnot_found:\n*errnop = 0;\nreturn NSS_STATUS_NOTFOUND;\nfail:\n*errnop = -r;\nreturn NSS_STATUS_UNAVAIL;\n}", "contrast": "enum nss_status _nss_mymachines_getgrnam_r(\nconst char *name,\nstruct group *gr,\nchar *buffer, size_t buflen,\nint *errnop) {\n_cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n_cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n_cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\nconst char *p, *e, *machine;\nuint32_t mapped;\nuid_t gid;\nsize_t l;\nint r;\nassert(name);\nassert(gr);\np = startswith(name, \"vg-\");\nif (!p)\ngoto not_found;\ne = strrchr(p, '-');\nif (!e || e == p)\ngoto not_found;\nif (e - p > HOST_NAME_MAX - 1)\ngoto not_found;\nr = parse_gid(e + 1, &gid);\nif (r < 0)\ngoto not_found;\nmachine = strndupa(p, e - p);\nif (!machine_name_is_valid(machine))\ngoto not_found;\nr = sd_bus_open_system(&bus);\nif (r < 0)\ngoto fail;\nr = sd_bus_call_method(bus,\n\"org.freedesktop.machine1\",\n\"/org/freedesktop/machine1\",\n\"org.freedesktop.machine1.Manager\",\n\"MapFromMachineGroup\",\n&error,\n&reply,\n\"su\",\nmachine, (uint32_t) gid);\nif (r < 0) {\nif (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\ngoto not_found;\ngoto fail;\n}\nr = sd_bus_message_read(reply, \"u\", &mapped);\nif (r < 0)\ngoto fail;\nl = sizeof(char*) + strlen(name) + 1;\nif (buflen < l) {\n*errnop = ENOMEM;\nreturn NSS_STATUS_TRYAGAIN;\n}\nmemzero(buffer, sizeof(char*));\nstrcpy(buffer + sizeof(char*), name);\ngr->gr_name = buffer + sizeof(char*);\ngr->gr_gid = gid;\ngr->gr_passwd = (char*) \"*\";\ngr->gr_mem = (char**) buffer;\n*errnop = 0;\nreturn NSS_STATUS_SUCCESS;\nnot_found:\n*errnop = 0;\nreturn NSS_STATUS_NOTFOUND;\nfail:\n*errnop = -r;\nreturn NSS_STATUS_UNAVAIL;\n}", "label": 0}
{"index": 177876, "code": "enum nss_status _nss_mymachines_getpwnam_r(\nconst char *name,\nstruct passwd *pwd,\nchar *buffer, size_t buflen,\nint *errnop) {\n_cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n_cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n_cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\nconst char *p, *e, *machine;\nuint32_t mapped;\nuid_t uid;\nsize_t l;\nint r;\nassert(name);\nassert(pwd);\np = startswith(name, \"vu-\");\nif (!p)\ngoto not_found;\ne = strrchr(p, '-');\nif (!e || e == p)\ngoto not_found;\nr = parse_uid(e + 1, &uid);\nif (r < 0)\ngoto not_found;\nmachine = strndupa(p, e - p);\nif (!machine_name_is_valid(machine))\ngoto not_found;\nr = sd_bus_open_system(&bus);\nif (r < 0)\ngoto fail;\nr = sd_bus_call_method(bus,\n\"org.freedesktop.machine1\",\n\"/org/freedesktop/machine1\",\n\"org.freedesktop.machine1.Manager\",\n\"MapFromMachineUser\",\n&error,\n&reply,\n\"su\",\nmachine, (uint32_t) uid);\nif (r < 0) {\nif (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\ngoto not_found;\ngoto fail;\n}\nr = sd_bus_message_read(reply, \"u\", &mapped);\nif (r < 0)\ngoto fail;\nl = strlen(name);\nif (buflen < l+1) {\n*errnop = ENOMEM;\nreturn NSS_STATUS_TRYAGAIN;\n}\nmemcpy(buffer, name, l+1);\npwd->pw_name = buffer;\npwd->pw_uid = mapped;\npwd->pw_gid = 65534;\npwd->pw_gecos = buffer;\npwd->pw_passwd = (char*) \"*\";\npwd->pw_dir = (char*) \"/\";\npwd->pw_shell = (char*) \"/sbin/nologin\";\n*errnop = 0;\nreturn NSS_STATUS_SUCCESS;\nnot_found:\n*errnop = 0;\nreturn NSS_STATUS_NOTFOUND;\nfail:\n*errnop = -r;\nreturn NSS_STATUS_UNAVAIL;\n}", "contrast": "enum nss_status _nss_mymachines_getpwnam_r(\nconst char *name,\nstruct passwd *pwd,\nchar *buffer, size_t buflen,\nint *errnop) {\n_cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n_cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n_cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\nconst char *p, *e, *machine;\nuint32_t mapped;\nuid_t uid;\nsize_t l;\nint r;\nassert(name);\nassert(pwd);\np = startswith(name, \"vu-\");\nif (!p)\ngoto not_found;\ne = strrchr(p, '-');\nif (!e || e == p)\ngoto not_found;\nif (e - p > HOST_NAME_MAX - 1)\ngoto not_found;\nr = parse_uid(e + 1, &uid);\nif (r < 0)\ngoto not_found;\nmachine = strndupa(p, e - p);\nif (!machine_name_is_valid(machine))\ngoto not_found;\nr = sd_bus_open_system(&bus);\nif (r < 0)\ngoto fail;\nr = sd_bus_call_method(bus,\n\"org.freedesktop.machine1\",\n\"/org/freedesktop/machine1\",\n\"org.freedesktop.machine1.Manager\",\n\"MapFromMachineUser\",\n&error,\n&reply,\n\"su\",\nmachine, (uint32_t) uid);\nif (r < 0) {\nif (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\ngoto not_found;\ngoto fail;\n}\nr = sd_bus_message_read(reply, \"u\", &mapped);\nif (r < 0)\ngoto fail;\nl = strlen(name);\nif (buflen < l+1) {\n*errnop = ENOMEM;\nreturn NSS_STATUS_TRYAGAIN;\n}\nmemcpy(buffer, name, l+1);\npwd->pw_name = buffer;\npwd->pw_uid = mapped;\npwd->pw_gid = 65534;\npwd->pw_gecos = buffer;\npwd->pw_passwd = (char*) \"*\";\npwd->pw_dir = (char*) \"/\";\npwd->pw_shell = (char*) \"/sbin/nologin\";\n*errnop = 0;\nreturn NSS_STATUS_SUCCESS;\nnot_found:\n*errnop = 0;\nreturn NSS_STATUS_NOTFOUND;\nfail:\n*errnop = -r;\nreturn NSS_STATUS_UNAVAIL;\n}", "label": 0}
{"index": 177877, "code": "int main(void)\n{\nFILE *f;\nchar *tmpname;\nf = xfmkstemp(&tmpname, NULL);\nunlink(tmpname);\nfree(tmpname);\nfclose(f);\nreturn EXIT_FAILURE;\n}", "contrast": "int main(void)\n{\nFILE *f;\nchar *tmpname;\nf = xfmkstemp(&tmpname, NULL, \"test\");\nunlink(tmpname);\nfree(tmpname);\nfclose(f);\nreturn EXIT_FAILURE;\n}", "label": 0}
{"index": 177897, "code": "wb_id(netdissect_options *ndo,\nconst struct pkt_id *id, u_int len)\n{\nint i;\nconst char *cp;\nconst struct id_off *io;\nchar c;\nint nid;\nND_PRINT((ndo, \" wb-id:\"));\nif (len < sizeof(*id) || !ND_TTEST(*id))\nreturn (-1);\nlen -= sizeof(*id);\nND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\nEXTRACT_32BITS(&id->pi_ps.slot),\nipaddr_string(ndo, &id->pi_ps.page.p_sid),\nEXTRACT_32BITS(&id->pi_ps.page.p_uid),\nEXTRACT_32BITS(&id->pi_mslot),\nipaddr_string(ndo, &id->pi_mpage.p_sid),\nEXTRACT_32BITS(&id->pi_mpage.p_uid)));\nnid = EXTRACT_16BITS(&id->pi_ps.nid);\nlen -= sizeof(*io) * nid;\nio = (struct id_off *)(id + 1);\ncp = (char *)(io + nid);\nif (!ND_TTEST2(cp, len)) {\nND_PRINT((ndo, \"\\\"\"));\nfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\nND_PRINT((ndo, \"\\\"\"));\n}\nc = '<';\nfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\nND_PRINT((ndo, \"%c%s:%u\",\nc, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\nc = ',';\n}\nif (i >= nid) {\nND_PRINT((ndo, \">\"));\nreturn (0);\n}\nreturn (-1);\n}", "contrast": "wb_id(netdissect_options *ndo,\nconst struct pkt_id *id, u_int len)\n{\nint i;\nconst char *cp;\nconst struct id_off *io;\nchar c;\nint nid;\nND_PRINT((ndo, \" wb-id:\"));\nif (len < sizeof(*id) || !ND_TTEST(*id))\nreturn (-1);\nlen -= sizeof(*id);\nND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\nEXTRACT_32BITS(&id->pi_ps.slot),\nipaddr_string(ndo, &id->pi_ps.page.p_sid),\nEXTRACT_32BITS(&id->pi_ps.page.p_uid),\nEXTRACT_32BITS(&id->pi_mslot),\nipaddr_string(ndo, &id->pi_mpage.p_sid),\nEXTRACT_32BITS(&id->pi_mpage.p_uid)));\nnid = EXTRACT_16BITS(&id->pi_ps.nid);\nlen -= sizeof(*io) * nid;\nio = (struct id_off *)(id + 1);\ncp = (char *)(io + nid);\nif (ND_TTEST2(cp, len)) {\nND_PRINT((ndo, \"\\\"\"));\nfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\nND_PRINT((ndo, \"\\\"\"));\n}\nc = '<';\nfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\nND_PRINT((ndo, \"%c%s:%u\",\nc, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\nc = ',';\n}\nif (i >= nid) {\nND_PRINT((ndo, \">\"));\nreturn (0);\n}\nreturn (-1);\n}", "label": 0}
{"index": 177898, "code": "wb_prep(netdissect_options *ndo,\nconst struct pkt_prep *prep, u_int len)\n{\nint n;\nconst struct pgstate *ps;\nconst u_char *ep = ndo->ndo_snapend;\nND_PRINT((ndo, \" wb-prep:\"));\nif (len < sizeof(*prep)) {\nreturn (-1);\n}\nn = EXTRACT_32BITS(&prep->pp_n);\nps = (const struct pgstate *)(prep + 1);\nwhile (--n >= 0 && !ND_TTEST(*ps)) {\nconst struct id_off *io, *ie;\nchar c = '<';\nND_PRINT((ndo, \" %u/%s:%u\",\nEXTRACT_32BITS(&ps->slot),\nipaddr_string(ndo, &ps->page.p_sid),\nEXTRACT_32BITS(&ps->page.p_uid)));\nio = (struct id_off *)(ps + 1);\nfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\nND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\nEXTRACT_32BITS(&io->off)));\nc = ',';\n}\nND_PRINT((ndo, \">\"));\nps = (struct pgstate *)io;\n}\nreturn ((u_char *)ps <= ep? 0 : -1);\n}", "contrast": "wb_prep(netdissect_options *ndo,\nconst struct pkt_prep *prep, u_int len)\n{\nint n;\nconst struct pgstate *ps;\nconst u_char *ep = ndo->ndo_snapend;\nND_PRINT((ndo, \" wb-prep:\"));\nif (len < sizeof(*prep)) {\nreturn (-1);\n}\nn = EXTRACT_32BITS(&prep->pp_n);\nps = (const struct pgstate *)(prep + 1);\nwhile (--n >= 0 && ND_TTEST(*ps)) {\nconst struct id_off *io, *ie;\nchar c = '<';\nND_PRINT((ndo, \" %u/%s:%u\",\nEXTRACT_32BITS(&ps->slot),\nipaddr_string(ndo, &ps->page.p_sid),\nEXTRACT_32BITS(&ps->page.p_uid)));\nio = (struct id_off *)(ps + 1);\nfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\nND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\nEXTRACT_32BITS(&io->off)));\nc = ',';\n}\nND_PRINT((ndo, \">\"));\nps = (struct pgstate *)io;\n}\nreturn ((u_char *)ps <= ep? 0 : -1);\n}", "label": 0}
{"index": 177901, "code": "static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n{\nstruct path lowerpath;\nstruct path upperpath;\nstruct path workpath;\nstruct inode *root_inode;\nstruct dentry *root_dentry;\nstruct ovl_entry *oe;\nstruct ovl_fs *ufs;\nstruct kstatfs statfs;\nint err;\nerr = -ENOMEM;\nufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);\nif (!ufs)\ngoto out;\nerr = ovl_parse_opt((char *) data, &ufs->config);\nif (err)\ngoto out_free_config;\nerr = -EINVAL;\nif (!ufs->config.upperdir || !ufs->config.lowerdir ||\n!ufs->config.workdir) {\npr_err(\"overlayfs: missing upperdir or lowerdir or workdir\\n\");\ngoto out_free_config;\n}\nerr = -ENOMEM;\noe = ovl_alloc_entry();\nif (oe == NULL)\ngoto out_free_config;\nerr = ovl_mount_dir(ufs->config.upperdir, &upperpath);\nif (err)\ngoto out_free_oe;\nerr = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);\nif (err)\ngoto out_put_upperpath;\nerr = ovl_mount_dir(ufs->config.workdir, &workpath);\nif (err)\ngoto out_put_lowerpath;\nerr = -EINVAL;\nif (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||\n!S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||\n!S_ISDIR(workpath.dentry->d_inode->i_mode)) {\npr_err(\"overlayfs: upperdir or lowerdir or workdir not a directory\\n\");\ngoto out_put_workpath;\n}\nif (upperpath.mnt != workpath.mnt) {\npr_err(\"overlayfs: workdir and upperdir must reside under the same mount\\n\");\ngoto out_put_workpath;\n}\nif (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {\npr_err(\"overlayfs: workdir and upperdir must be separate subtrees\\n\");\ngoto out_put_workpath;\n}\nif (!ovl_is_allowed_fs_type(upperpath.dentry)) {\npr_err(\"overlayfs: filesystem of upperdir is not supported\\n\");\ngoto out_put_workpath;\n}\nif (!ovl_is_allowed_fs_type(lowerpath.dentry)) {\npr_err(\"overlayfs: filesystem of lowerdir is not supported\\n\");\ngoto out_put_workpath;\n}\nerr = vfs_statfs(&lowerpath, &statfs);\nif (err) {\npr_err(\"overlayfs: statfs failed on lowerpath\\n\");\ngoto out_put_workpath;\n}\nufs->lower_namelen = statfs.f_namelen;\nufs->upper_mnt = clone_private_mount(&upperpath);\nerr = PTR_ERR(ufs->upper_mnt);\nif (IS_ERR(ufs->upper_mnt)) {\npr_err(\"overlayfs: failed to clone upperpath\\n\");\ngoto out_put_workpath;\n}\nufs->lower_mnt = clone_private_mount(&lowerpath);\nerr = PTR_ERR(ufs->lower_mnt);\nif (IS_ERR(ufs->lower_mnt)) {\npr_err(\"overlayfs: failed to clone lowerpath\\n\");\ngoto out_put_upper_mnt;\n}\nufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);\nerr = PTR_ERR(ufs->workdir);\nif (IS_ERR(ufs->workdir)) {\npr_err(\"overlayfs: failed to create directory %s/%s\\n\",\nufs->config.workdir, OVL_WORKDIR_NAME);\ngoto out_put_lower_mnt;\n}\nufs->lower_mnt->mnt_flags |= MNT_READONLY;\nif (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)\nsb->s_flags |= MS_RDONLY;\nsb->s_d_op = &ovl_dentry_operations;\nerr = -ENOMEM;\nroot_inode = ovl_new_inode(sb, S_IFDIR, oe);\nif (!root_inode)\ngoto out_put_workdir;\nroot_dentry = d_make_root(root_inode);\nif (!root_dentry)\ngoto out_put_workdir;\nmntput(upperpath.mnt);\nmntput(lowerpath.mnt);\npath_put(&workpath);\noe->__upperdentry = upperpath.dentry;\noe->lowerdentry = lowerpath.dentry;\nroot_dentry->d_fsdata = oe;\nsb->s_magic = OVERLAYFS_SUPER_MAGIC;\nsb->s_op = &ovl_super_operations;\nsb->s_root = root_dentry;\nsb->s_fs_info = ufs;\nreturn 0;\nout_put_workdir:\ndput(ufs->workdir);\nout_put_lower_mnt:\nmntput(ufs->lower_mnt);\nout_put_upper_mnt:\nmntput(ufs->upper_mnt);\nout_put_workpath:\npath_put(&workpath);\nout_put_lowerpath:\npath_put(&lowerpath);\nout_put_upperpath:\npath_put(&upperpath);\nout_free_oe:\nkfree(oe);\nout_free_config:\nkfree(ufs->config.lowerdir);\nkfree(ufs->config.upperdir);\nkfree(ufs->config.workdir);\nkfree(ufs);\nout:\nreturn err;\n}", "contrast": "static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n{\nstruct path lowerpath;\nstruct path upperpath;\nstruct path workpath;\nstruct inode *root_inode;\nstruct dentry *root_dentry;\nstruct ovl_entry *oe;\nstruct ovl_fs *ufs;\nstruct kstatfs statfs;\nint err;\nerr = -ENOMEM;\nufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);\nif (!ufs)\ngoto out;\nerr = ovl_parse_opt((char *) data, &ufs->config);\nif (err)\ngoto out_free_config;\nerr = -EINVAL;\nif (!ufs->config.upperdir || !ufs->config.lowerdir ||\n!ufs->config.workdir) {\npr_err(\"overlayfs: missing upperdir or lowerdir or workdir\\n\");\ngoto out_free_config;\n}\nerr = -ENOMEM;\noe = ovl_alloc_entry();\nif (oe == NULL)\ngoto out_free_config;\nerr = ovl_mount_dir(ufs->config.upperdir, &upperpath);\nif (err)\ngoto out_free_oe;\nerr = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);\nif (err)\ngoto out_put_upperpath;\nerr = ovl_mount_dir(ufs->config.workdir, &workpath);\nif (err)\ngoto out_put_lowerpath;\nerr = -EINVAL;\nif (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||\n!S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||\n!S_ISDIR(workpath.dentry->d_inode->i_mode)) {\npr_err(\"overlayfs: upperdir or lowerdir or workdir not a directory\\n\");\ngoto out_put_workpath;\n}\nif (upperpath.mnt != workpath.mnt) {\npr_err(\"overlayfs: workdir and upperdir must reside under the same mount\\n\");\ngoto out_put_workpath;\n}\nif (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {\npr_err(\"overlayfs: workdir and upperdir must be separate subtrees\\n\");\ngoto out_put_workpath;\n}\nif (!ovl_is_allowed_fs_type(upperpath.dentry)) {\npr_err(\"overlayfs: filesystem of upperdir is not supported\\n\");\ngoto out_put_workpath;\n}\nif (!ovl_is_allowed_fs_type(lowerpath.dentry)) {\npr_err(\"overlayfs: filesystem of lowerdir is not supported\\n\");\ngoto out_put_workpath;\n}\nerr = vfs_statfs(&lowerpath, &statfs);\nif (err) {\npr_err(\"overlayfs: statfs failed on lowerpath\\n\");\ngoto out_put_workpath;\n}\nufs->lower_namelen = statfs.f_namelen;\nsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\nlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\nerr = -EINVAL;\nif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\npr_err(\"overlayfs: maximum fs stacking depth exceeded\\n\");\ngoto out_put_workpath;\n}\nufs->upper_mnt = clone_private_mount(&upperpath);\nerr = PTR_ERR(ufs->upper_mnt);\nif (IS_ERR(ufs->upper_mnt)) {\npr_err(\"overlayfs: failed to clone upperpath\\n\");\ngoto out_put_workpath;\n}\nufs->lower_mnt = clone_private_mount(&lowerpath);\nerr = PTR_ERR(ufs->lower_mnt);\nif (IS_ERR(ufs->lower_mnt)) {\npr_err(\"overlayfs: failed to clone lowerpath\\n\");\ngoto out_put_upper_mnt;\n}\nufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);\nerr = PTR_ERR(ufs->workdir);\nif (IS_ERR(ufs->workdir)) {\npr_err(\"overlayfs: failed to create directory %s/%s\\n\",\nufs->config.workdir, OVL_WORKDIR_NAME);\ngoto out_put_lower_mnt;\n}\nufs->lower_mnt->mnt_flags |= MNT_READONLY;\nif (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)\nsb->s_flags |= MS_RDONLY;\nsb->s_d_op = &ovl_dentry_operations;\nerr = -ENOMEM;\nroot_inode = ovl_new_inode(sb, S_IFDIR, oe);\nif (!root_inode)\ngoto out_put_workdir;\nroot_dentry = d_make_root(root_inode);\nif (!root_dentry)\ngoto out_put_workdir;\nmntput(upperpath.mnt);\nmntput(lowerpath.mnt);\npath_put(&workpath);\noe->__upperdentry = upperpath.dentry;\noe->lowerdentry = lowerpath.dentry;\nroot_dentry->d_fsdata = oe;\nsb->s_magic = OVERLAYFS_SUPER_MAGIC;\nsb->s_op = &ovl_super_operations;\nsb->s_root = root_dentry;\nsb->s_fs_info = ufs;\nreturn 0;\nout_put_workdir:\ndput(ufs->workdir);\nout_put_lower_mnt:\nmntput(ufs->lower_mnt);\nout_put_upper_mnt:\nmntput(ufs->upper_mnt);\nout_put_workpath:\npath_put(&workpath);\nout_put_lowerpath:\npath_put(&lowerpath);\nout_put_upperpath:\npath_put(&upperpath);\nout_free_oe:\nkfree(oe);\nout_free_config:\nkfree(ufs->config.lowerdir);\nkfree(ufs->config.upperdir);\nkfree(ufs->config.workdir);\nkfree(ufs);\nout:\nreturn err;\n}", "label": 0}
{"index": 177939, "code": "void edge_sparse_csr_reader_double( const char*           i_csr_file_in,\nunsigned int**        o_row_idx,\nunsigned int**        o_column_idx,\ndouble**              o_values,\nunsigned int*         o_row_count,\nunsigned int*         o_column_count,\nunsigned int*         o_element_count ) {\nFILE *l_csr_file_handle;\nconst unsigned int l_line_length = 512;\nchar l_line[512 +1];\nunsigned int l_header_read = 0;\nunsigned int* l_row_idx_id = NULL;\nunsigned int l_i = 0;\nl_csr_file_handle = fopen( i_csr_file_in, \"r\" );\nif ( l_csr_file_handle == NULL ) {\nfprintf( stderr, \"cannot open CSR file!\\n\" );\nreturn;\n}\nwhile (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\nif ( strlen(l_line) == l_line_length ) {\nfprintf( stderr, \"could not read file length!\\n\" );\nreturn;\n}\nif ( l_line[0] == '%' ) {\ncontinue;\n} else {\nif ( l_header_read == 0 ) {\nif ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n*o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n*o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n*o_values = (double*) malloc(sizeof(double) * (*o_element_count));\nl_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\nif ( ( *o_row_idx == NULL )      ||\n( *o_column_idx == NULL )   ||\n( *o_values == NULL )       ||\n( l_row_idx_id == NULL ) ) {\nfprintf( stderr, \"could not allocate sp data!\\n\" );\nreturn;\n}\nmemset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\nmemset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\nmemset(*o_values, 0, sizeof(double)*(*o_element_count));\nmemset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\nfor ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n(*o_row_idx)[l_i] = (*o_element_count);\n(*o_row_idx)[0] = 0;\nl_i = 0;\nl_header_read = 1;\n} else {\nfprintf( stderr, \"could not csr description!\\n\" );\nreturn;\n}\n} else {\nunsigned int l_row, l_column;\ndouble l_value;\nif ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\nfprintf( stderr, \"could not read element!\\n\" );\nreturn;\n}\nl_row--;\nl_column--;\n(*o_column_idx)[l_i] = l_column;\n(*o_values)[l_i] = l_value;\nl_i++;\nl_row_idx_id[l_row] = 1;\n(*o_row_idx)[l_row+1] = l_i;\n}\n}\n}\nfclose( l_csr_file_handle );\nif ( l_i != (*o_element_count) ) {\nfprintf( stderr, \"we were not able to read all elements!\\n\" );\nreturn;\n}\nfor ( l_i = 0; l_i < (*o_row_count); l_i++) {\nif ( l_row_idx_id[l_i] == 0 ) {\n(*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n}\n}\nif ( l_row_idx_id != NULL ) {\nfree( l_row_idx_id );\n}\n}", "contrast": "void edge_sparse_csr_reader_double( const char*           i_csr_file_in,\nunsigned int**        o_row_idx,\nunsigned int**        o_column_idx,\ndouble**              o_values,\nunsigned int*         o_row_count,\nunsigned int*         o_column_count,\nunsigned int*         o_element_count ) {\nFILE *l_csr_file_handle;\nconst unsigned int l_line_length = 512;\nchar l_line[512 +1];\nunsigned int l_header_read = 0;\nunsigned int* l_row_idx_id = NULL;\nunsigned int l_i = 0;\nl_csr_file_handle = fopen( i_csr_file_in, \"r\" );\nif ( l_csr_file_handle == NULL ) {\nfprintf( stderr, \"cannot open CSR file!\\n\" );\nreturn;\n}\nwhile (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\nif ( strlen(l_line) == l_line_length ) {\nfprintf( stderr, \"could not read file length!\\n\" );\nreturn;\n}\nif ( l_line[0] == '%' ) {\ncontinue;\n} else {\nif ( l_header_read == 0 ) {\nif (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n{\n*o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n*o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n*o_values = (double*) malloc(sizeof(double) * (*o_element_count));\nl_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\nif ( ( *o_row_idx == NULL )      ||\n( *o_column_idx == NULL )   ||\n( *o_values == NULL )       ||\n( l_row_idx_id == NULL ) ) {\nfprintf( stderr, \"could not allocate sp data!\\n\" );\nreturn;\n}\nmemset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\nmemset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\nmemset(*o_values, 0, sizeof(double)*(*o_element_count));\nmemset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\nfor ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n(*o_row_idx)[l_i] = (*o_element_count);\n(*o_row_idx)[0] = 0;\nl_i = 0;\nl_header_read = 1;\n} else {\nfprintf( stderr, \"could not csr description!\\n\" );\nreturn;\n}\n} else {\nunsigned int l_row, l_column;\ndouble l_value;\nif ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\nfprintf( stderr, \"could not read element!\\n\" );\nreturn;\n}\nl_row--;\nl_column--;\n(*o_column_idx)[l_i] = l_column;\n(*o_values)[l_i] = l_value;\nl_i++;\nl_row_idx_id[l_row] = 1;\n(*o_row_idx)[l_row+1] = l_i;\n}\n}\n}\nfclose( l_csr_file_handle );\nif ( l_i != (*o_element_count) ) {\nfprintf( stderr, \"we were not able to read all elements!\\n\" );\nreturn;\n}\nfor ( l_i = 0; l_i < (*o_row_count); l_i++) {\nif ( l_row_idx_id[l_i] == 0 ) {\n(*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n}\n}\nif ( l_row_idx_id != NULL ) {\nfree( l_row_idx_id );\n}\n}", "label": 0}
{"index": 177943, "code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\nstruct ipddp_route __user *rt = ifr->ifr_data;\nstruct ipddp_route rcp, rcp2, *rp;\nif(!capable(CAP_NET_ADMIN))\nreturn -EPERM;\nif(copy_from_user(&rcp, rt, sizeof(rcp)))\nreturn -EFAULT;\nswitch(cmd)\n{\ncase SIOCADDIPDDPRT:\nreturn ipddp_create(&rcp);\ncase SIOCFINDIPDDPRT:\nspin_lock_bh(&ipddp_route_lock);\nrp = __ipddp_find_route(&rcp);\nif (rp)\nmemcpy(&rcp2, rp, sizeof(rcp2));\nspin_unlock_bh(&ipddp_route_lock);\nif (rp) {\nif (copy_to_user(rt, &rcp2,\nsizeof(struct ipddp_route)))\nreturn -EFAULT;\nreturn 0;\n} else\nreturn -ENOENT;\ncase SIOCDELIPDDPRT:\nreturn ipddp_delete(&rcp);\ndefault:\nreturn -EINVAL;\n}\n}", "contrast": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\nstruct ipddp_route __user *rt = ifr->ifr_data;\nstruct ipddp_route rcp, rcp2, *rp;\nif(!capable(CAP_NET_ADMIN))\nreturn -EPERM;\nif(copy_from_user(&rcp, rt, sizeof(rcp)))\nreturn -EFAULT;\nswitch(cmd)\n{\ncase SIOCADDIPDDPRT:\nreturn ipddp_create(&rcp);\ncase SIOCFINDIPDDPRT:\nspin_lock_bh(&ipddp_route_lock);\nrp = __ipddp_find_route(&rcp);\nif (rp) {\nmemset(&rcp2, 0, sizeof(rcp2));\nrcp2.ip    = rp->ip;\nrcp2.at    = rp->at;\nrcp2.flags = rp->flags;\n}\nspin_unlock_bh(&ipddp_route_lock);\nif (rp) {\nif (copy_to_user(rt, &rcp2,\nsizeof(struct ipddp_route)))\nreturn -EFAULT;\nreturn 0;\n} else\nreturn -ENOENT;\ncase SIOCDELIPDDPRT:\nreturn ipddp_delete(&rcp);\ndefault:\nreturn -EINVAL;\n}\n}", "label": 0}
{"index": 177947, "code": "kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\nkrb5_kdc_req *request,\nkrb5_const_principal client_princ,\nkrb5_const_principal header_srv_princ,\nkrb5_boolean issuing_referral,\nconst krb5_db_entry *server,\nkrb5_keyblock *tgs_subkey,\nkrb5_keyblock *tgs_session,\nkrb5_timestamp kdc_time,\nkrb5_pa_s4u_x509_user **s4u_x509_user,\nkrb5_db_entry **princ_ptr,\nconst char **status)\n{\nkrb5_error_code             code;\nkrb5_boolean                is_local_tgt;\nkrb5_pa_data                *pa_data;\nint                         flags;\nkrb5_db_entry               *princ;\n*princ_ptr = NULL;\npa_data = krb5int_find_pa_data(kdc_context,\nrequest->padata, KRB5_PADATA_S4U_X509_USER);\nif (pa_data != NULL) {\ncode = kdc_process_s4u_x509_user(kdc_context,\nrequest,\npa_data,\ntgs_subkey,\ntgs_session,\ns4u_x509_user,\nstatus);\nif (code != 0)\nreturn code;\n} else {\npa_data = krb5int_find_pa_data(kdc_context,\nrequest->padata, KRB5_PADATA_FOR_USER);\nif (pa_data != NULL) {\ncode = kdc_process_for_user(kdc_active_realm,\npa_data,\ntgs_session,\ns4u_x509_user,\nstatus);\nif (code != 0)\nreturn code;\n} else\nreturn 0;\n}\nflags = 0;\nswitch (krb5_princ_type(kdc_context, request->server)) {\ncase KRB5_NT_SRV_HST:\nif (krb5_princ_size(kdc_context, request->server) == 2)\nflags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\nbreak;\ncase KRB5_NT_ENTERPRISE_PRINCIPAL:\nflags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\nbreak;\ndefault:\nbreak;\n}\nif (!krb5_principal_compare_flags(kdc_context,\nrequest->server,\nclient_princ,\nflags)) {\n*status = \"INVALID_S4U2SELF_REQUEST\";\nreturn KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n}\nif (request->kdc_options & AS_INVALID_OPTIONS) {\n*status = \"INVALID AS OPTIONS\";\nreturn KRB5KDC_ERR_BADOPTION;\n}\nis_local_tgt = !is_cross_tgs_principal(header_srv_princ);\nif (is_local_tgt && issuing_referral) {\n*status = \"LOOKING_UP_SERVER\";\nreturn KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n}\nif (is_local_principal(kdc_active_realm,\n(*s4u_x509_user)->user_id.user)) {\nkrb5_db_entry no_server;\nkrb5_pa_data **e_data = NULL;\nif (!is_local_tgt && !issuing_referral) {\n*status = \"NOT_CROSS_REALM_REQUEST\";\nreturn KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n}\ncode = krb5_db_get_principal(kdc_context,\n(*s4u_x509_user)->user_id.user,\nKRB5_KDB_FLAG_INCLUDE_PAC, &princ);\nif (code == KRB5_KDB_NOENTRY) {\n*status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\nreturn KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n} else if (code) {\n*status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\nreturn code;\n}\nmemset(&no_server, 0, sizeof(no_server));\ncode = validate_as_request(kdc_active_realm, request, *princ,\nno_server, kdc_time, status, &e_data);\nif (code) {\nkrb5_db_free_principal(kdc_context, princ);\nkrb5_free_pa_data(kdc_context, e_data);\nreturn code;\n}\n*princ_ptr = princ;\n} else if (is_local_tgt) {\n*status = \"S4U2SELF_CLIENT_NOT_OURS\";\nreturn KRB5KDC_ERR_POLICY;\n}\nreturn 0;\n}", "contrast": "kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\nkrb5_kdc_req *request,\nkrb5_const_principal client_princ,\nkrb5_const_principal header_srv_princ,\nkrb5_boolean issuing_referral,\nconst krb5_db_entry *server,\nkrb5_keyblock *tgs_subkey,\nkrb5_keyblock *tgs_session,\nkrb5_timestamp kdc_time,\nkrb5_pa_s4u_x509_user **s4u_x509_user,\nkrb5_db_entry **princ_ptr,\nconst char **status)\n{\nkrb5_error_code             code;\nkrb5_boolean                is_local_tgt;\nkrb5_pa_data                *pa_data;\nint                         flags;\nkrb5_db_entry               *princ;\n*princ_ptr = NULL;\npa_data = krb5int_find_pa_data(kdc_context,\nrequest->padata, KRB5_PADATA_S4U_X509_USER);\nif (pa_data != NULL) {\ncode = kdc_process_s4u_x509_user(kdc_context,\nrequest,\npa_data,\ntgs_subkey,\ntgs_session,\ns4u_x509_user,\nstatus);\nif (code != 0)\nreturn code;\n} else {\npa_data = krb5int_find_pa_data(kdc_context,\nrequest->padata, KRB5_PADATA_FOR_USER);\nif (pa_data != NULL) {\ncode = kdc_process_for_user(kdc_active_realm,\npa_data,\ntgs_session,\ns4u_x509_user,\nstatus);\nif (code != 0)\nreturn code;\n} else\nreturn 0;\n}\nflags = 0;\nswitch (krb5_princ_type(kdc_context, request->server)) {\ncase KRB5_NT_SRV_HST:\nif (krb5_princ_size(kdc_context, request->server) == 2)\nflags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\nbreak;\ncase KRB5_NT_ENTERPRISE_PRINCIPAL:\nflags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\nbreak;\ndefault:\nbreak;\n}\nif (!krb5_principal_compare_flags(kdc_context,\nrequest->server,\nclient_princ,\nflags)) {\n*status = \"INVALID_S4U2SELF_REQUEST\";\nreturn KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n}\nif (request->kdc_options & AS_INVALID_OPTIONS) {\n*status = \"INVALID AS OPTIONS\";\nreturn KRB5KDC_ERR_BADOPTION;\n}\nis_local_tgt = !is_cross_tgs_principal(header_srv_princ);\nif (is_local_tgt && issuing_referral) {\n*status = \"LOOKING_UP_SERVER\";\nreturn KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n}\nif (is_local_principal(kdc_active_realm,\n(*s4u_x509_user)->user_id.user)) {\nkrb5_db_entry no_server;\nkrb5_pa_data **e_data = NULL;\nif (!is_local_tgt && !issuing_referral) {\n*status = \"NOT_CROSS_REALM_REQUEST\";\nreturn KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n}\ncode = krb5_db_get_principal(kdc_context,\n(*s4u_x509_user)->user_id.user,\nKRB5_KDB_FLAG_INCLUDE_PAC, &princ);\nif (code == KRB5_KDB_NOENTRY) {\n*status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\nreturn KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n} else if (code) {\n*status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\nreturn code;\n}\nmemset(&no_server, 0, sizeof(no_server));\nprinc->pw_expiration = 0;\nclear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);\ncode = validate_as_request(kdc_active_realm, request, *princ,\nno_server, kdc_time, status, &e_data);\nif (code) {\nkrb5_db_free_principal(kdc_context, princ);\nkrb5_free_pa_data(kdc_context, e_data);\nreturn code;\n}\n*princ_ptr = princ;\n} else if (is_local_tgt) {\n*status = \"S4U2SELF_CLIENT_NOT_OURS\";\nreturn KRB5KDC_ERR_POLICY;\n}\nreturn 0;\n}", "label": 0}
{"index": 177952, "code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\nstruct crypto_report_acomp racomp;\nstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\nif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\nsizeof(struct crypto_report_acomp), &racomp))\ngoto nla_put_failure;\nreturn 0;\nnla_put_failure:\nreturn -EMSGSIZE;\n}", "contrast": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\nstruct crypto_report_acomp racomp;\nstrncpy(racomp.type, \"acomp\", sizeof(racomp.type));\nif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\nsizeof(struct crypto_report_acomp), &racomp))\ngoto nla_put_failure;\nreturn 0;\nnla_put_failure:\nreturn -EMSGSIZE;\n}", "label": 0}
{"index": 177969, "code": "keepalived_main(int argc, char **argv)\n{\nbool report_stopped = true;\nstruct utsname uname_buf;\nchar *end;\nset_time_now();\nsave_cmd_line_options(argc, argv);\ndebug = 0;\n#ifndef _DEBUG_\nprog_type = PROG_TYPE_PARENT;\n#endif\n#ifdef _WITH_VRRP_\n__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\nopenlog(PACKAGE_NAME, LOG_PID, log_facility);\n#ifdef _MEM_CHECK_\nmem_log_init(PACKAGE_NAME, \"Parent process\");\n#endif\nif (uname(&uname_buf))\nlog_message(LOG_INFO, \"Unable to get uname() information - error %d\", errno);\nelse {\nos_major = (unsigned)strtoul(uname_buf.release, &end, 10);\nif (*end != '.')\nos_major = 0;\nelse {\nos_minor = (unsigned)strtoul(end + 1, &end, 10);\nif (*end != '.')\nos_major = 0;\nelse {\nif (!isdigit(end[1]))\nos_major = 0;\nelse\nos_release = (unsigned)strtoul(end + 1, &end, 10);\n}\n}\nif (!os_major)\nlog_message(LOG_INFO, \"Unable to parse kernel version %s\", uname_buf.release);\nif (!config_id) {\nend = strchrnul(uname_buf.nodename, '.');\nconfig_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);\nstrncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));\nconfig_id[end - uname_buf.nodename] = '\\0';\n}\n}\nif (parse_cmdline(argc, argv)) {\ncloselog();\nif (!__test_bit(NO_SYSLOG_BIT, &debug))\nopenlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);\n}\nif (__test_bit(LOG_CONSOLE_BIT, &debug))\nenable_console_log();\n#ifdef GIT_COMMIT\nlog_message(LOG_INFO, \"Starting %s, git commit %s\", version_string, GIT_COMMIT);\n#else\nlog_message(LOG_INFO, \"Starting %s\", version_string);\n#endif\ncore_dump_init();\nif (os_major) {\nif (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {\nlog_message(LOG_INFO, \"WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s\",\n(LINUX_VERSION_CODE >> 16) & 0xff,\n(LINUX_VERSION_CODE >>  8) & 0xff,\n(LINUX_VERSION_CODE      ) & 0xff,\nuname_buf.sysname, uname_buf.release, uname_buf.version);\n} else {\nlog_message(LOG_INFO, \"Running on %s %s %s (built for Linux %d.%d.%d)\",\nuname_buf.sysname, uname_buf.release, uname_buf.version,\n(LINUX_VERSION_CODE >> 16) & 0xff,\n(LINUX_VERSION_CODE >>  8) & 0xff,\n(LINUX_VERSION_CODE      ) & 0xff);\n}\n}\n#ifndef _DEBUG_\nlog_command_line(0);\n#endif\nif (!check_conf_file(conf_file)) {\nif (__test_bit(CONFIG_TEST_BIT, &debug))\nconfig_test_exit();\ngoto end;\n}\nglobal_data = alloc_global_data();\nread_config_file();\ninit_global_data(global_data, NULL);\n#if HAVE_DECL_CLONE_NEWNET\nif (override_namespace) {\nif (global_data->network_namespace) {\nlog_message(LOG_INFO, \"Overriding config net_namespace '%s' with command line namespace '%s'\", global_data->network_namespace, override_namespace);\nFREE(global_data->network_namespace);\n}\nglobal_data->network_namespace = override_namespace;\noverride_namespace = NULL;\n}\n#endif\nif (!__test_bit(CONFIG_TEST_BIT, &debug) &&\n(global_data->instance_name\n#if HAVE_DECL_CLONE_NEWNET\n|| global_data->network_namespace\n#endif\n)) {\nif ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {\nlog_message(LOG_INFO, \"Changing syslog ident to %s\", syslog_ident);\ncloselog();\nopenlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);\n}\nelse\nlog_message(LOG_INFO, \"Unable to change syslog ident\");\nuse_pid_dir = true;\nopen_log_file(log_file_name,\nNULL,\n#if HAVE_DECL_CLONE_NEWNET\nglobal_data->network_namespace,\n#else\nNULL,\n#endif\nglobal_data->instance_name);\n}\nset_child_finder_name(find_keepalived_child_name);\nif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\nif (use_pid_dir) {\ncreate_pid_dir();\n}\n}\n#if HAVE_DECL_CLONE_NEWNET\nif (global_data->network_namespace) {\nif (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {\nlog_message(LOG_ERR, \"Unable to set network namespace %s - exiting\", global_data->network_namespace);\ngoto end;\n}\n}\n#endif\nif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\nif (global_data->instance_name) {\nif (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_main_pidfile = true;\n#ifdef _WITH_LVS_\nif (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_checkers_pidfile = true;\n#endif\n#ifdef _WITH_VRRP_\nif (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_vrrp_pidfile = true;\n#endif\n#ifdef _WITH_BFD_\nif (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_bfd_pidfile = true;\n#endif\n}\nif (use_pid_dir) {\nif (!main_pidfile)\nmain_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\nif (!checkers_pidfile)\ncheckers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\nif (!vrrp_pidfile)\nvrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\nif (!bfd_pidfile)\nbfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n}\nelse\n{\nif (!main_pidfile)\nmain_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\nif (!checkers_pidfile)\ncheckers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\nif (!vrrp_pidfile)\nvrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\nif (!bfd_pidfile)\nbfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n}\nif (keepalived_running(daemon_mode)) {\nlog_message(LOG_INFO, \"daemon is already running\");\nreport_stopped = false;\ngoto end;\n}\n}\nif (!__test_bit(DONT_FORK_BIT, &debug) &&\nxdaemon(false, false, true) > 0) {\ncloselog();\nFREE_PTR(config_id);\nFREE_PTR(orig_core_dump_pattern);\nclose_std_fd();\nexit(0);\n}\numask(0);\n#ifdef _MEM_CHECK_\nenable_mem_log_termination();\n#endif\nif (__test_bit(CONFIG_TEST_BIT, &debug)) {\nvalidate_config();\nconfig_test_exit();\n}\nif (!pidfile_write(main_pidfile, getpid()))\ngoto end;\nmaster = thread_make_master();\nsignal_init();\nif (!start_keepalived())\nlog_message(LOG_INFO, \"Warning - keepalived has no configuration to run\");\ninitialise_debug_options();\n#ifdef THREAD_DUMP\nregister_parent_thread_addresses();\n#endif\nlaunch_thread_scheduler(master);\nstop_keepalived();\n#ifdef THREAD_DUMP\nderegister_thread_addresses();\n#endif\nend:\nif (report_stopped) {\n#ifdef GIT_COMMIT\nlog_message(LOG_INFO, \"Stopped %s, git commit %s\", version_string, GIT_COMMIT);\n#else\nlog_message(LOG_INFO, \"Stopped %s\", version_string);\n#endif\n}\n#if HAVE_DECL_CLONE_NEWNET\nif (global_data && global_data->network_namespace)\nclear_namespaces();\n#endif\nif (use_pid_dir)\nremove_pid_dir();\nif (orig_core_dump_pattern)\nupdate_core_dump_pattern(orig_core_dump_pattern);\nfree_parent_mallocs_startup(false);\nfree_parent_mallocs_exit();\nfree_global_data(global_data);\ncloselog();\n#ifndef _MEM_CHECK_LOG_\nFREE_PTR(syslog_ident);\n#else\nif (syslog_ident)\nfree(syslog_ident);\n#endif\nclose_std_fd();\nexit(KEEPALIVED_EXIT_OK);\n}", "contrast": "keepalived_main(int argc, char **argv)\n{\nbool report_stopped = true;\nstruct utsname uname_buf;\nchar *end;\nset_time_now();\nsave_cmd_line_options(argc, argv);\ndebug = 0;\n#ifndef _DEBUG_\nprog_type = PROG_TYPE_PARENT;\n#endif\n#ifdef _WITH_VRRP_\n__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\numask(022);\nopenlog(PACKAGE_NAME, LOG_PID, log_facility);\n#ifdef _MEM_CHECK_\nmem_log_init(PACKAGE_NAME, \"Parent process\");\n#endif\nif (uname(&uname_buf))\nlog_message(LOG_INFO, \"Unable to get uname() information - error %d\", errno);\nelse {\nos_major = (unsigned)strtoul(uname_buf.release, &end, 10);\nif (*end != '.')\nos_major = 0;\nelse {\nos_minor = (unsigned)strtoul(end + 1, &end, 10);\nif (*end != '.')\nos_major = 0;\nelse {\nif (!isdigit(end[1]))\nos_major = 0;\nelse\nos_release = (unsigned)strtoul(end + 1, &end, 10);\n}\n}\nif (!os_major)\nlog_message(LOG_INFO, \"Unable to parse kernel version %s\", uname_buf.release);\nif (!config_id) {\nend = strchrnul(uname_buf.nodename, '.');\nconfig_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);\nstrncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));\nconfig_id[end - uname_buf.nodename] = '\\0';\n}\n}\nif (parse_cmdline(argc, argv)) {\ncloselog();\nif (!__test_bit(NO_SYSLOG_BIT, &debug))\nopenlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);\n}\nif (__test_bit(LOG_CONSOLE_BIT, &debug))\nenable_console_log();\n#ifdef GIT_COMMIT\nlog_message(LOG_INFO, \"Starting %s, git commit %s\", version_string, GIT_COMMIT);\n#else\nlog_message(LOG_INFO, \"Starting %s\", version_string);\n#endif\ncore_dump_init();\nif (os_major) {\nif (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {\nlog_message(LOG_INFO, \"WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s\",\n(LINUX_VERSION_CODE >> 16) & 0xff,\n(LINUX_VERSION_CODE >>  8) & 0xff,\n(LINUX_VERSION_CODE      ) & 0xff,\nuname_buf.sysname, uname_buf.release, uname_buf.version);\n} else {\nlog_message(LOG_INFO, \"Running on %s %s %s (built for Linux %d.%d.%d)\",\nuname_buf.sysname, uname_buf.release, uname_buf.version,\n(LINUX_VERSION_CODE >> 16) & 0xff,\n(LINUX_VERSION_CODE >>  8) & 0xff,\n(LINUX_VERSION_CODE      ) & 0xff);\n}\n}\n#ifndef _DEBUG_\nlog_command_line(0);\n#endif\nif (!check_conf_file(conf_file)) {\nif (__test_bit(CONFIG_TEST_BIT, &debug))\nconfig_test_exit();\ngoto end;\n}\nglobal_data = alloc_global_data();\nglobal_data->umask = umask_val;\nread_config_file();\ninit_global_data(global_data, NULL);\n#if HAVE_DECL_CLONE_NEWNET\nif (override_namespace) {\nif (global_data->network_namespace) {\nlog_message(LOG_INFO, \"Overriding config net_namespace '%s' with command line namespace '%s'\", global_data->network_namespace, override_namespace);\nFREE(global_data->network_namespace);\n}\nglobal_data->network_namespace = override_namespace;\noverride_namespace = NULL;\n}\n#endif\nif (!__test_bit(CONFIG_TEST_BIT, &debug) &&\n(global_data->instance_name\n#if HAVE_DECL_CLONE_NEWNET\n|| global_data->network_namespace\n#endif\n)) {\nif ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {\nlog_message(LOG_INFO, \"Changing syslog ident to %s\", syslog_ident);\ncloselog();\nopenlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);\n}\nelse\nlog_message(LOG_INFO, \"Unable to change syslog ident\");\nuse_pid_dir = true;\nopen_log_file(log_file_name,\nNULL,\n#if HAVE_DECL_CLONE_NEWNET\nglobal_data->network_namespace,\n#else\nNULL,\n#endif\nglobal_data->instance_name);\n}\nset_child_finder_name(find_keepalived_child_name);\nif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\nif (use_pid_dir) {\ncreate_pid_dir();\n}\n}\n#if HAVE_DECL_CLONE_NEWNET\nif (global_data->network_namespace) {\nif (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {\nlog_message(LOG_ERR, \"Unable to set network namespace %s - exiting\", global_data->network_namespace);\ngoto end;\n}\n}\n#endif\nif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\nif (global_data->instance_name) {\nif (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_main_pidfile = true;\n#ifdef _WITH_LVS_\nif (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_checkers_pidfile = true;\n#endif\n#ifdef _WITH_VRRP_\nif (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_vrrp_pidfile = true;\n#endif\n#ifdef _WITH_BFD_\nif (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\nfree_bfd_pidfile = true;\n#endif\n}\nif (use_pid_dir) {\nif (!main_pidfile)\nmain_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\nif (!checkers_pidfile)\ncheckers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\nif (!vrrp_pidfile)\nvrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\nif (!bfd_pidfile)\nbfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n}\nelse\n{\nif (!main_pidfile)\nmain_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\nif (!checkers_pidfile)\ncheckers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\nif (!vrrp_pidfile)\nvrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\nif (!bfd_pidfile)\nbfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n}\nif (keepalived_running(daemon_mode)) {\nlog_message(LOG_INFO, \"daemon is already running\");\nreport_stopped = false;\ngoto end;\n}\n}\nif (!__test_bit(DONT_FORK_BIT, &debug) &&\nxdaemon(false, false, true) > 0) {\ncloselog();\nFREE_PTR(config_id);\nFREE_PTR(orig_core_dump_pattern);\nclose_std_fd();\nexit(0);\n}\n#ifdef _MEM_CHECK_\nenable_mem_log_termination();\n#endif\nif (__test_bit(CONFIG_TEST_BIT, &debug)) {\nvalidate_config();\nconfig_test_exit();\n}\nif (!pidfile_write(main_pidfile, getpid()))\ngoto end;\nmaster = thread_make_master();\nsignal_init();\nif (!start_keepalived())\nlog_message(LOG_INFO, \"Warning - keepalived has no configuration to run\");\ninitialise_debug_options();\n#ifdef THREAD_DUMP\nregister_parent_thread_addresses();\n#endif\nlaunch_thread_scheduler(master);\nstop_keepalived();\n#ifdef THREAD_DUMP\nderegister_thread_addresses();\n#endif\nend:\nif (report_stopped) {\n#ifdef GIT_COMMIT\nlog_message(LOG_INFO, \"Stopped %s, git commit %s\", version_string, GIT_COMMIT);\n#else\nlog_message(LOG_INFO, \"Stopped %s\", version_string);\n#endif\n}\n#if HAVE_DECL_CLONE_NEWNET\nif (global_data && global_data->network_namespace)\nclear_namespaces();\n#endif\nif (use_pid_dir)\nremove_pid_dir();\nif (orig_core_dump_pattern)\nupdate_core_dump_pattern(orig_core_dump_pattern);\nfree_parent_mallocs_startup(false);\nfree_parent_mallocs_exit();\nfree_global_data(global_data);\ncloselog();\n#ifndef _MEM_CHECK_LOG_\nFREE_PTR(syslog_ident);\n#else\nif (syslog_ident)\nfree(syslog_ident);\n#endif\nclose_std_fd();\nexit(KEEPALIVED_EXIT_OK);\n}", "label": 0}
{"index": 177982, "code": "fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\nint ret;\nint sav_errno;\nif (fifo->name) {\nsav_errno = 0;\nif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\nfifo->created_fifo = true;\nelse {\nsav_errno = errno;\nif (sav_errno != EEXIST)\nlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n}\nif (!sav_errno || sav_errno == EEXIST) {\nif (fifo->script)\nnotify_fifo_exec(master, script_exit, fifo, fifo->script);\nif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\nlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\nif (fifo->created_fifo) {\nunlink(fifo->name);\nfifo->created_fifo = false;\n}\n}\n}\nif (fifo->fd == -1) {\nFREE(fifo->name);\nfifo->name = NULL;\n}\n}\n}", "contrast": "fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\nint ret;\nint sav_errno;\nif (fifo->name) {\nsav_errno = 0;\nif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\nfifo->created_fifo = true;\nelse {\nsav_errno = errno;\nif (sav_errno != EEXIST)\nlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n}\nif (!sav_errno || sav_errno == EEXIST) {\nif (fifo->script)\nnotify_fifo_exec(master, script_exit, fifo, fifo->script);\nif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\nlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\nif (fifo->created_fifo) {\nunlink(fifo->name);\nfifo->created_fifo = false;\n}\n}\n}\nif (fifo->fd == -1) {\nFREE(fifo->name);\nfifo->name = NULL;\n}\n}\n}", "label": 0}
{"index": 177987, "code": "int main(int argc, char *argv[]) {\nstruct mschm_decompressor *chmd;\nstruct mschmd_header *chm;\nstruct mschmd_file *file, **f;\nunsigned int numf, i;\nsetbuf(stdout, NULL);\nsetbuf(stderr, NULL);\nuser_umask = umask(0); umask(user_umask);\nMSPACK_SYS_SELFTEST(i);\nif (i) return 0;\nif ((chmd = mspack_create_chm_decompressor(NULL))) {\nfor (argv++; *argv; argv++) {\nprintf(\"%s\\n\", *argv);\nif ((chm = chmd->open(chmd, *argv))) {\nfor (numf=0, file=chm->files; file; file = file->next) numf++;\nif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\nfor (i=0, file=chm->files; file; file = file->next) f[i++] = file;\nqsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\nfor (i = 0; i < numf; i++) {\nchar *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\nprintf(\"Extracting %s\\n\", outname);\nensure_filepath(outname);\nif (chmd->extract(chmd, f[i], outname)) {\nprintf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n*argv, f[i]->filename, ERROR(chmd));\n}\nfree(outname);\n}\nfree(f);\n}\nchmd->close(chmd, chm);\n}\nelse {\nprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n}\n}\nmspack_destroy_chm_decompressor(chmd);\n}\nreturn 0;\n}", "contrast": "int main(int argc, char *argv[]) {\nstruct mschm_decompressor *chmd;\nstruct mschmd_header *chm;\nstruct mschmd_file *file, **f;\nunsigned int numf, i;\nsetbuf(stdout, NULL);\nsetbuf(stderr, NULL);\nuser_umask = umask(0); umask(user_umask);\nMSPACK_SYS_SELFTEST(i);\nif (i) return 0;\nif ((chmd = mspack_create_chm_decompressor(NULL))) {\nfor (argv++; *argv; argv++) {\nprintf(\"%s\\n\", *argv);\nif ((chm = chmd->open(chmd, *argv))) {\nfor (numf=0, file=chm->files; file; file = file->next) numf++;\nif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\nfor (i=0, file=chm->files; file; file = file->next) f[i++] = file;\nqsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\nfor (i = 0; i < numf; i++) {\nchar *outname = create_output_name(f[i]->filename);\nprintf(\"Extracting %s\\n\", outname);\nensure_filepath(outname);\nif (chmd->extract(chmd, f[i], outname)) {\nprintf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n*argv, f[i]->filename, ERROR(chmd));\n}\nfree(outname);\n}\nfree(f);\n}\nchmd->close(chmd, chm);\n}\nelse {\nprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n}\n}\nmspack_destroy_chm_decompressor(chmd);\n}\nreturn 0;\n}", "label": 0}
{"index": 177996, "code": "void nw_cache_free(nw_cache *cache, void *obj)\n{\nif (cache->free < cache->free_total) {\ncache->free_arr[cache->free++] = obj;\n} else {\nuint32_t new_free_total = cache->free_total * 2;\nvoid *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));\nif (new_arr) {\ncache->free_total = new_free_total;\ncache->free_arr = new_arr;\ncache->free_arr[cache->free++] = obj;\n} else {\nfree(obj);\n}\n}\n}", "contrast": "void nw_cache_free(nw_cache *cache, void *obj)\n{\nif (cache->free < cache->free_total) {\ncache->free_arr[cache->free++] = obj;\n} else if (cache->free_total < NW_CACHE_MAX_SIZE) {\nuint32_t new_free_total = cache->free_total * 2;\nvoid *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));\nif (new_arr) {\ncache->free_total = new_free_total;\ncache->free_arr = new_arr;\ncache->free_arr[cache->free++] = obj;\n} else {\nfree(obj);\n}\n} else {\nfree(obj);\n}\n}", "label": 0}
{"index": 178007, "code": "void vmacache_flush_all(struct mm_struct *mm)\n{\nstruct task_struct *g, *p;\ncount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\nif (atomic_read(&mm->mm_users) == 1)\nreturn;\nrcu_read_lock();\nfor_each_process_thread(g, p) {\nif (mm == p->mm)\nvmacache_flush(p);\n}\nrcu_read_unlock();\n}", "contrast": "void vmacache_flush_all(struct mm_struct *mm)", "label": 0}
{"index": 178012, "code": "_bson_iter_next_internal (bson_iter_t *iter,\nuint32_t next_keylen,\nconst char **key,\nuint32_t *bson_type,\nbool *unsupported)\n{\nconst uint8_t *data;\nuint32_t o;\nunsigned int len;\nBSON_ASSERT (iter);\n*unsupported = false;\nif (!iter->raw) {\n*key = NULL;\n*bson_type = BSON_TYPE_EOD;\nreturn false;\n}\ndata = iter->raw;\nlen = iter->len;\niter->off = iter->next_off;\niter->type = iter->off;\niter->key = iter->off + 1;\niter->d1 = 0;\niter->d2 = 0;\niter->d3 = 0;\niter->d4 = 0;\nif (next_keylen == 0) {\nfor (o = iter->key; o < len; o++) {\nif (!data[o]) {\niter->d1 = ++o;\ngoto fill_data_fields;\n}\n}\n} else {\no = iter->key + next_keylen + 1;\niter->d1 = o;\ngoto fill_data_fields;\n}\ngoto mark_invalid;\nfill_data_fields:\n*key = bson_iter_key_unsafe (iter);\n*bson_type = ITER_TYPE (iter);\nswitch (*bson_type) {\ncase BSON_TYPE_DATE_TIME:\ncase BSON_TYPE_DOUBLE:\ncase BSON_TYPE_INT64:\ncase BSON_TYPE_TIMESTAMP:\niter->next_off = o + 8;\nbreak;\ncase BSON_TYPE_CODE:\ncase BSON_TYPE_SYMBOL:\ncase BSON_TYPE_UTF8: {\nuint32_t l;\nif ((o + 4) >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l > (len - (o + 4))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + 4 + l;\nif (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\niter->err_off = o;\ngoto mark_invalid;\n}\nif (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\niter->err_off = o + 4 + l - 1;\ngoto mark_invalid;\n}\n} break;\ncase BSON_TYPE_BINARY: {\nbson_subtype_t subtype;\nuint32_t l;\nif (o >= (len - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\niter->d3 = o + 5;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l >= (len - o)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nsubtype = *(iter->raw + iter->d2);\nif (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\nint32_t binary_len;\nif (l < 4) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\nbinary_len = BSON_UINT32_FROM_LE (binary_len);\nif (binary_len + 4 != l) {\niter->err_off = iter->d3;\ngoto mark_invalid;\n}\n}\niter->next_off = o + 5 + l;\n} break;\ncase BSON_TYPE_ARRAY:\ncase BSON_TYPE_DOCUMENT: {\nuint32_t l;\nif (o >= (len - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif ((l > len) || (l > (len - o))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + l;\n} break;\ncase BSON_TYPE_OID:\niter->next_off = o + 12;\nbreak;\ncase BSON_TYPE_BOOL: {\nchar val;\nif (iter->d1 >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&val, iter->raw + iter->d1, 1);\nif (val != 0x00 && val != 0x01) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + 1;\n} break;\ncase BSON_TYPE_REGEX: {\nbool eor = false;\nbool eoo = false;\nfor (; o < len; o++) {\nif (!data[o]) {\niter->d2 = ++o;\neor = true;\nbreak;\n}\n}\nif (!eor) {\niter->err_off = iter->next_off;\ngoto mark_invalid;\n}\nfor (; o < len; o++) {\nif (!data[o]) {\neoo = true;\nbreak;\n}\n}\nif (!eoo) {\niter->err_off = iter->next_off;\ngoto mark_invalid;\n}\niter->next_off = o + 1;\n} break;\ncase BSON_TYPE_DBPOINTER: {\nuint32_t l;\nif (o >= (len - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l == 0 || l > (len - o - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nif (*(iter->raw + o + l + 3)) {\niter->err_off = o + l + 3;\ngoto mark_invalid;\n}\niter->d3 = o + 4 + l;\niter->next_off = o + 4 + l + 12;\n} break;\ncase BSON_TYPE_CODEWSCOPE: {\nuint32_t l;\nuint32_t doclen;\nif ((len < 19) || (o >= (len - 14))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\niter->d3 = o + 8;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif ((l < 14) || (l >= (len - o))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + l;\nif (iter->next_off >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&l, iter->raw + iter->d2, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l == 0 || l >= (len - o - 4 - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nif ((o + 4 + 4 + l + 4) >= iter->next_off) {\niter->err_off = o + 4;\ngoto mark_invalid;\n}\niter->d4 = o + 4 + 4 + l;\nmemcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\ndoclen = BSON_UINT32_FROM_LE (doclen);\nif ((o + 4 + 4 + l + doclen) != iter->next_off) {\niter->err_off = o + 4 + 4 + l;\ngoto mark_invalid;\n}\n} break;\ncase BSON_TYPE_INT32:\niter->next_off = o + 4;\nbreak;\ncase BSON_TYPE_DECIMAL128:\niter->next_off = o + 16;\nbreak;\ncase BSON_TYPE_MAXKEY:\ncase BSON_TYPE_MINKEY:\ncase BSON_TYPE_NULL:\ncase BSON_TYPE_UNDEFINED:\niter->next_off = o;\nbreak;\ndefault:\n*unsupported = true;\ncase BSON_TYPE_EOD:\niter->err_off = o;\ngoto mark_invalid;\n}\nif (iter->next_off >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->err_off = 0;\nreturn true;\nmark_invalid:\niter->raw = NULL;\niter->len = 0;\niter->next_off = 0;\nreturn false;\n}", "contrast": "_bson_iter_next_internal (bson_iter_t *iter,\nuint32_t next_keylen,\nconst char **key,\nuint32_t *bson_type,\nbool *unsupported)\n{\nconst uint8_t *data;\nuint32_t o;\nunsigned int len;\nBSON_ASSERT (iter);\n*unsupported = false;\nif (!iter->raw) {\n*key = NULL;\n*bson_type = BSON_TYPE_EOD;\nreturn false;\n}\ndata = iter->raw;\nlen = iter->len;\niter->off = iter->next_off;\niter->type = iter->off;\niter->key = iter->off + 1;\niter->d1 = 0;\niter->d2 = 0;\niter->d3 = 0;\niter->d4 = 0;\nif (next_keylen == 0) {\nfor (o = iter->key; o < len; o++) {\nif (!data[o]) {\niter->d1 = ++o;\ngoto fill_data_fields;\n}\n}\n} else {\no = iter->key + next_keylen + 1;\niter->d1 = o;\ngoto fill_data_fields;\n}\ngoto mark_invalid;\nfill_data_fields:\n*key = bson_iter_key_unsafe (iter);\n*bson_type = ITER_TYPE (iter);\nswitch (*bson_type) {\ncase BSON_TYPE_DATE_TIME:\ncase BSON_TYPE_DOUBLE:\ncase BSON_TYPE_INT64:\ncase BSON_TYPE_TIMESTAMP:\niter->next_off = o + 8;\nbreak;\ncase BSON_TYPE_CODE:\ncase BSON_TYPE_SYMBOL:\ncase BSON_TYPE_UTF8: {\nuint32_t l;\nif ((o + 4) >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l > (len - (o + 4))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + 4 + l;\nif (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\niter->err_off = o;\ngoto mark_invalid;\n}\nif (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\niter->err_off = o + 4 + l - 1;\ngoto mark_invalid;\n}\n} break;\ncase BSON_TYPE_BINARY: {\nbson_subtype_t subtype;\nuint32_t l;\nif (o >= (len - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\niter->d3 = o + 5;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l >= (len - o - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nsubtype = *(iter->raw + iter->d2);\nif (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\nint32_t binary_len;\nif (l < 4) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\nbinary_len = BSON_UINT32_FROM_LE (binary_len);\nif (binary_len + 4 != l) {\niter->err_off = iter->d3;\ngoto mark_invalid;\n}\n}\niter->next_off = o + 5 + l;\n} break;\ncase BSON_TYPE_ARRAY:\ncase BSON_TYPE_DOCUMENT: {\nuint32_t l;\nif (o >= (len - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif ((l > len) || (l > (len - o))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + l;\n} break;\ncase BSON_TYPE_OID:\niter->next_off = o + 12;\nbreak;\ncase BSON_TYPE_BOOL: {\nchar val;\nif (iter->d1 >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&val, iter->raw + iter->d1, 1);\nif (val != 0x00 && val != 0x01) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + 1;\n} break;\ncase BSON_TYPE_REGEX: {\nbool eor = false;\nbool eoo = false;\nfor (; o < len; o++) {\nif (!data[o]) {\niter->d2 = ++o;\neor = true;\nbreak;\n}\n}\nif (!eor) {\niter->err_off = iter->next_off;\ngoto mark_invalid;\n}\nfor (; o < len; o++) {\nif (!data[o]) {\neoo = true;\nbreak;\n}\n}\nif (!eoo) {\niter->err_off = iter->next_off;\ngoto mark_invalid;\n}\niter->next_off = o + 1;\n} break;\ncase BSON_TYPE_DBPOINTER: {\nuint32_t l;\nif (o >= (len - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l == 0 || l > (len - o - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nif (*(iter->raw + o + l + 3)) {\niter->err_off = o + l + 3;\ngoto mark_invalid;\n}\niter->d3 = o + 4 + l;\niter->next_off = o + 4 + l + 12;\n} break;\ncase BSON_TYPE_CODEWSCOPE: {\nuint32_t l;\nuint32_t doclen;\nif ((len < 19) || (o >= (len - 14))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->d2 = o + 4;\niter->d3 = o + 8;\nmemcpy (&l, iter->raw + iter->d1, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif ((l < 14) || (l >= (len - o))) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->next_off = o + l;\nif (iter->next_off >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\nmemcpy (&l, iter->raw + iter->d2, sizeof (l));\nl = BSON_UINT32_FROM_LE (l);\nif (l == 0 || l >= (len - o - 4 - 4)) {\niter->err_off = o;\ngoto mark_invalid;\n}\nif ((o + 4 + 4 + l + 4) >= iter->next_off) {\niter->err_off = o + 4;\ngoto mark_invalid;\n}\niter->d4 = o + 4 + 4 + l;\nmemcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\ndoclen = BSON_UINT32_FROM_LE (doclen);\nif ((o + 4 + 4 + l + doclen) != iter->next_off) {\niter->err_off = o + 4 + 4 + l;\ngoto mark_invalid;\n}\n} break;\ncase BSON_TYPE_INT32:\niter->next_off = o + 4;\nbreak;\ncase BSON_TYPE_DECIMAL128:\niter->next_off = o + 16;\nbreak;\ncase BSON_TYPE_MAXKEY:\ncase BSON_TYPE_MINKEY:\ncase BSON_TYPE_NULL:\ncase BSON_TYPE_UNDEFINED:\niter->next_off = o;\nbreak;\ndefault:\n*unsupported = true;\ncase BSON_TYPE_EOD:\niter->err_off = o;\ngoto mark_invalid;\n}\nif (iter->next_off >= len) {\niter->err_off = o;\ngoto mark_invalid;\n}\niter->err_off = 0;\nreturn true;\nmark_invalid:\niter->raw = NULL;\niter->len = 0;\niter->next_off = 0;\nreturn false;\n}", "label": 0}
{"index": 178018, "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\nif (info.scale != (Quantum *) NULL) \\\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\nif (data != (unsigned char *) NULL) \\\ndata=(unsigned char *) RelinquishMagickMemory(data); \\\nif (graymap != (int *) NULL) \\\ngraymap=(int *) RelinquishMagickMemory(graymap); \\\nif (bluemap != (int *) NULL) \\\nbluemap=(int *) RelinquishMagickMemory(bluemap); \\\nif (greenmap != (int *) NULL) \\\ngreenmap=(int *) RelinquishMagickMemory(greenmap); \\\nif (redmap != (int *) NULL) \\\nredmap=(int *) RelinquishMagickMemory(redmap); \\\nif (stream_info->offsets != (ssize_t *) NULL) \\\nstream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\nstream_info->offsets); \\\nif (stream_info != (DCMStreamInfo *) NULL) \\\nstream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\nThrowReaderException((exception),(message)); \\\n}\nchar\nexplicit_vr[MagickPathExtent],\nimplicit_vr[MagickPathExtent],\nmagick[MagickPathExtent],\nphotometric[MagickPathExtent];\nDCMInfo\ninfo;\nDCMStreamInfo\n*stream_info;\nImage\n*image;\nint\n*bluemap,\ndatum,\n*greenmap,\n*graymap,\n*redmap;\nMagickBooleanType\nexplicit_file,\nexplicit_retry,\nuse_explicit;\nMagickOffsetType\noffset;\nregister unsigned char\n*p;\nregister ssize_t\ni;\nsize_t\ncolors,\nheight,\nlength,\nnumber_scenes,\nquantum,\nstatus,\nwidth;\nssize_t\ncount,\nscene;\nunsigned char\n*data;\nunsigned short\ngroup,\nelement;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage->depth=8UL;\nimage->endian=LSBEndian;\n(void) memset(&info,0,sizeof(info));\ndata=(unsigned char *) NULL;\ngraymap=(int *) NULL;\nredmap=(int *) NULL;\ngreenmap=(int *) NULL;\nbluemap=(int *) NULL;\nstream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\nif (stream_info == (DCMStreamInfo *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(stream_info,0,sizeof(*stream_info));\ncount=ReadBlob(image,128,(unsigned char *) magick);\nif (count != 128)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\ncount=ReadBlob(image,4,(unsigned char *) magick);\nif ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n{\noffset=SeekBlob(image,0L,SEEK_SET);\nif (offset < 0)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n}\n(void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\ninfo.bits_allocated=8;\ninfo.bytes_per_pixel=1;\ninfo.depth=8;\ninfo.mask=0xffff;\ninfo.max_value=255UL;\ninfo.samples_per_pixel=1;\ninfo.signed_data=(~0UL);\ninfo.rescale_slope=1.0;\ndata=(unsigned char *) NULL;\nelement=0;\nexplicit_vr[2]='\\0';\nexplicit_file=MagickFalse;\ncolors=0;\nredmap=(int *) NULL;\ngreenmap=(int *) NULL;\nbluemap=(int *) NULL;\ngraymap=(int *) NULL;\nheight=0;\nnumber_scenes=1;\nuse_explicit=MagickFalse;\nexplicit_retry = MagickFalse;\nwidth=0;\nwhile (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n{\nfor (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n{\nimage->offset=(ssize_t) TellBlob(image);\ngroup=ReadBlobLSBShort(image);\nelement=ReadBlobLSBShort(image);\nif ((group == 0xfffc) && (element == 0xfffc))\nbreak;\nif ((group != 0x0002) && (image->endian == MSBEndian))\n{\ngroup=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\nelement=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n}\nquantum=0;\nfor (i=0; dicom_info[i].group < 0xffff; i++)\nif ((group == dicom_info[i].group) &&\n(element == dicom_info[i].element))\nbreak;\n(void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\ncount=ReadBlob(image,2,(unsigned char *) explicit_vr);\nif (count != 2)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nif ((explicit_file == MagickFalse) && (group != 0x0002))\nexplicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n(isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\nMagickTrue : MagickFalse;\nuse_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n(explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\nif ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n(void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\nif ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n{\noffset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\nif (offset < 0)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nquantum=4;\n}\nelse\n{\nquantum=2;\nif ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n(strncmp(explicit_vr,\"UN\",2) == 0) ||\n(strncmp(explicit_vr,\"OW\",2) == 0) ||\n(strncmp(explicit_vr,\"SQ\",2) == 0))\n{\n(void) ReadBlobLSBShort(image);\nquantum=4;\n}\n}\ndatum=0;\nif (quantum == 4)\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedLong(image);\nelse\ndatum=ReadBlobSignedLong(image);\n}\nelse\nif (quantum == 2)\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedShort(image);\nelse\ndatum=ReadBlobSignedShort(image);\n}\nquantum=0;\nlength=1;\nif (datum != 0)\n{\nif ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n(strncmp(implicit_vr,\"SS\",2) == 0) ||\n(strncmp(implicit_vr,\"US\",2) == 0))\nquantum=2;\nelse\nif ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n(strncmp(implicit_vr,\"OF\",2) == 0) ||\n(strncmp(implicit_vr,\"SL\",2) == 0) ||\n(strncmp(implicit_vr,\"UL\",2) == 0))\nquantum=4;\nelse\nif (strncmp(implicit_vr,\"FD\",2) == 0)\nquantum=8;\nelse\nquantum=1;\nif (datum != ~0)\nlength=(size_t) datum/quantum;\nelse\n{\nquantum=0;\nlength=0;\n}\n}\nif (image_info->verbose != MagickFalse)\n{\nif (use_explicit == MagickFalse)\nexplicit_vr[0]='\\0';\nfor (i=0; dicom_info[i].description != (char *) NULL; i++)\nif ((group == dicom_info[i].group) &&\n(element == dicom_info[i].element))\nbreak;\n(void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n(unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n(unsigned long) group,(unsigned long) element);\nif (dicom_info[i].description != (char *) NULL)\n(void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n(void) FormatLocaleFile(stdout,\": \");\n}\nif ((group == 0x7FE0) && (element == 0x0010))\n{\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\"\\n\");\nbreak;\n}\ndata=(unsigned char *) NULL;\nif ((length == 1) && (quantum == 1))\ndatum=ReadBlobByte(image);\nelse\nif ((length == 1) && (quantum == 2))\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedShort(image);\nelse\ndatum=ReadBlobSignedShort(image);\n}\nelse\nif ((length == 1) && (quantum == 4))\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedLong(image);\nelse\ndatum=ReadBlobSignedLong(image);\n}\nelse\nif ((quantum != 0) && (length != 0))\n{\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\n\"InsufficientImageDataInFile\");\nif (~length >= 1)\ndata=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\nsizeof(*data));\nif (data == (unsigned char *) NULL)\nThrowDCMException(ResourceLimitError,\n\"MemoryAllocationFailed\");\ncount=ReadBlob(image,(size_t) quantum*length,data);\nif (count != (ssize_t) (quantum*length))\n{\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n\"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\nlength,(int) group);\nThrowDCMException(CorruptImageError,\n\"InsufficientImageDataInFile\");\n}\ndata[length*quantum]='\\0';\n}\nif ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n{\nif (data != (unsigned char *) NULL)\ndata=(unsigned char *) RelinquishMagickMemory(data);\ncontinue;\n}\nswitch (group)\n{\ncase 0x0002:\n{\nswitch (element)\n{\ncase 0x0010:\n{\nchar\ntransfer_syntax[MagickPathExtent];\nif ((datum == 0) && (explicit_retry == MagickFalse))\n{\nexplicit_retry=MagickTrue;\n(void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\ngroup=0;\nelement=0;\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\n\"Corrupted image - trying explicit format\\n\");\nbreak;\n}\n*transfer_syntax='\\0';\nif (data != (unsigned char *) NULL)\n(void) CopyMagickString(transfer_syntax,(char *) data,\nMagickPathExtent);\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n(const char *) transfer_syntax);\nif (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n{\nint\nsubtype,\ntype;\ntype=1;\nsubtype=0;\nif (strlen(transfer_syntax) > 17)\n{\ncount=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n&subtype);\nif (count < 1)\nThrowDCMException(CorruptImageError,\n\"ImproperImageHeader\");\n}\nswitch (type)\n{\ncase 1:\n{\nimage->endian=LSBEndian;\nbreak;\n}\ncase 2:\n{\nimage->endian=MSBEndian;\nbreak;\n}\ncase 4:\n{\nif ((subtype >= 80) && (subtype <= 81))\nimage->compression=JPEGCompression;\nelse\nif ((subtype >= 90) && (subtype <= 93))\nimage->compression=JPEG2000Compression;\nelse\nimage->compression=JPEGCompression;\nbreak;\n}\ncase 5:\n{\nimage->compression=RLECompression;\nbreak;\n}\n}\n}\nbreak;\n}\ndefault:\nbreak;\n}\nbreak;\n}\ncase 0x0028:\n{\nswitch (element)\n{\ncase 0x0002:\n{\ninfo.samples_per_pixel=(size_t) datum;\nif ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase 0x0004:\n{\nif (data == (unsigned char *) NULL)\nbreak;\nfor (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\nphotometric[i]=(char) data[i];\nphotometric[i]='\\0';\ninfo.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\nMagickTrue : MagickFalse;\nbreak;\n}\ncase 0x0006:\n{\nif (datum == 1)\nimage->interlace=PlaneInterlace;\nbreak;\n}\ncase 0x0008:\n{\nif (data == (unsigned char *) NULL)\nbreak;\nnumber_scenes=StringToUnsignedLong((char *) data);\nbreak;\n}\ncase 0x0010:\n{\nheight=(size_t) datum;\nbreak;\n}\ncase 0x0011:\n{\nwidth=(size_t) datum;\nbreak;\n}\ncase 0x0100:\n{\ninfo.bits_allocated=(size_t) datum;\ninfo.bytes_per_pixel=1;\nif (datum > 8)\ninfo.bytes_per_pixel=2;\ninfo.depth=info.bits_allocated;\nif ((info.depth == 0) || (info.depth > 32))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\ninfo.max_value=(1UL << info.bits_allocated)-1;\nimage->depth=info.depth;\nbreak;\n}\ncase 0x0101:\n{\ninfo.significant_bits=(size_t) datum;\ninfo.bytes_per_pixel=1;\nif (info.significant_bits > 8)\ninfo.bytes_per_pixel=2;\ninfo.depth=info.significant_bits;\nif ((info.depth == 0) || (info.depth > 16))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\ninfo.max_value=(1UL << info.significant_bits)-1;\ninfo.mask=(size_t) GetQuantumRange(info.significant_bits);\nimage->depth=info.depth;\nbreak;\n}\ncase 0x0102:\n{\nbreak;\n}\ncase 0x0103:\n{\ninfo.signed_data=(size_t) datum;\nbreak;\n}\ncase 0x1050:\n{\nif (data != (unsigned char *) NULL)\ninfo.window_center=StringToDouble((char *) data,(char **) NULL);\nbreak;\n}\ncase 0x1051:\n{\nif (data != (unsigned char *) NULL)\ninfo.window_width=StringToDouble((char *) data,(char **) NULL);\nbreak;\n}\ncase 0x1052:\n{\nif (data != (unsigned char *) NULL)\ninfo.rescale_intercept=StringToDouble((char *) data,\n(char **) NULL);\nbreak;\n}\ncase 0x1053:\n{\nif (data != (unsigned char *) NULL)\ninfo.rescale_slope=StringToDouble((char *) data,(char **) NULL);\nbreak;\n}\ncase 0x1200:\ncase 0x3006:\n{\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/info.bytes_per_pixel);\ndatum=(int) colors;\nif (graymap != (int *) NULL)\ngraymap=(int *) RelinquishMagickMemory(graymap);\ngraymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*graymap));\nif (graymap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(graymap,0,MagickMax(colors,65536)*\nsizeof(*graymap));\nfor (i=0; i < (ssize_t) colors; i++)\nif (info.bytes_per_pixel == 1)\ngraymap[i]=(int) data[i];\nelse\ngraymap[i]=(int) ((short *) data)[i];\nbreak;\n}\ncase 0x1201:\n{\nunsigned short\nindex;\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/2);\ndatum=(int) colors;\nif (redmap != (int *) NULL)\nredmap=(int *) RelinquishMagickMemory(redmap);\nredmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*redmap));\nif (redmap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(redmap,0,MagickMax(colors,65536)*\nsizeof(*redmap));\np=data;\nfor (i=0; i < (ssize_t) colors; i++)\n{\nif (image->endian == MSBEndian)\nindex=(unsigned short) ((*p << 8) | *(p+1));\nelse\nindex=(unsigned short) (*p | (*(p+1) << 8));\nredmap[i]=(int) index;\np+=2;\n}\nbreak;\n}\ncase 0x1202:\n{\nunsigned short\nindex;\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/2);\ndatum=(int) colors;\nif (greenmap != (int *) NULL)\ngreenmap=(int *) RelinquishMagickMemory(greenmap);\ngreenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*greenmap));\nif (greenmap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(greenmap,0,MagickMax(colors,65536)*\nsizeof(*greenmap));\np=data;\nfor (i=0; i < (ssize_t) colors; i++)\n{\nif (image->endian == MSBEndian)\nindex=(unsigned short) ((*p << 8) | *(p+1));\nelse\nindex=(unsigned short) (*p | (*(p+1) << 8));\ngreenmap[i]=(int) index;\np+=2;\n}\nbreak;\n}\ncase 0x1203:\n{\nunsigned short\nindex;\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/2);\ndatum=(int) colors;\nif (bluemap != (int *) NULL)\nbluemap=(int *) RelinquishMagickMemory(bluemap);\nbluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*bluemap));\nif (bluemap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(bluemap,0,MagickMax(colors,65536)*\nsizeof(*bluemap));\np=data;\nfor (i=0; i < (ssize_t) colors; i++)\n{\nif (image->endian == MSBEndian)\nindex=(unsigned short) ((*p << 8) | *(p+1));\nelse\nindex=(unsigned short) (*p | (*(p+1) << 8));\nbluemap[i]=(int) index;\np+=2;\n}\nbreak;\n}\ndefault:\nbreak;\n}\nbreak;\n}\ncase 0x2050:\n{\nswitch (element)\n{\ncase 0x0020:\n{\nif ((data != (unsigned char *) NULL) &&\n(strncmp((char *) data,\"INVERSE\",7) == 0))\ninfo.polarity=MagickTrue;\nbreak;\n}\ndefault:\nbreak;\n}\nbreak;\n}\ndefault:\nbreak;\n}\nif (data != (unsigned char *) NULL)\n{\nchar\n*attribute;\nfor (i=0; dicom_info[i].description != (char *) NULL; i++)\nif ((group == dicom_info[i].group) &&\n(element == dicom_info[i].element))\nbreak;\nif (dicom_info[i].description != (char *) NULL)\n{\nattribute=AcquireString(\"dcm:\");\n(void) ConcatenateString(&attribute,dicom_info[i].description);\nfor (i=0; i < (ssize_t) MagickMax(length,4); i++)\nif (isprint((int) data[i]) == MagickFalse)\nbreak;\nif ((i == (ssize_t) length) || (length > 4))\n{\n(void) SubstituteString(&attribute,\" \",\"\");\n(void) SetImageProperty(image,attribute,(char *) data,\nexception);\n}\nattribute=DestroyString(attribute);\n}\n}\nif (image_info->verbose != MagickFalse)\n{\nif (data == (unsigned char *) NULL)\n(void) FormatLocaleFile(stdout,\"%d\\n\",datum);\nelse\n{\nfor (i=0; i < (ssize_t) MagickMax(length,4); i++)\nif (isprint((int) data[i]) == MagickFalse)\nbreak;\nif ((i != (ssize_t) length) && (length <= 4))\n{\nssize_t\nj;\ndatum=0;\nfor (j=(ssize_t) length-1; j >= 0; j--)\ndatum=(256*datum+data[j]);\n(void) FormatLocaleFile(stdout,\"%d\",datum);\n}\nelse\nfor (i=0; i < (ssize_t) length; i++)\nif (isprint((int) data[i]) != MagickFalse)\n(void) FormatLocaleFile(stdout,\"%c\",data[i]);\nelse\n(void) FormatLocaleFile(stdout,\"%c\",'.');\n(void) FormatLocaleFile(stdout,\"\\n\");\n}\n}\nif (data != (unsigned char *) NULL)\ndata=(unsigned char *) RelinquishMagickMemory(data);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\n}\nif ((group == 0xfffc) && (element == 0xfffc))\n{\nImage\n*last;\nlast=RemoveLastImageFromList(&image);\nif (last != (Image *) NULL)\nlast=DestroyImage(last);\nbreak;\n}\nif ((width == 0) || (height == 0))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nimage->columns=(size_t) width;\nimage->rows=(size_t) height;\nif (info.signed_data == 0xffff)\ninfo.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\nif ((image->compression == JPEGCompression) ||\n(image->compression == JPEG2000Compression))\n{\nImage\n*images;\nImageInfo\n*read_info;\nint\nc;\nfor (i=0; i < (ssize_t) stream_info->remaining; i++)\nif (ReadBlobByte(image) == EOF)\nbreak;\n(void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image));\nlength=(size_t) ReadBlobLSBLong(image);\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\nstream_info->offset_count=length >> 2;\nif (stream_info->offset_count != 0)\n{\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *) RelinquishMagickMemory(\nstream_info->offsets);\nstream_info->offsets=(ssize_t *) AcquireQuantumMemory(\nstream_info->offset_count,sizeof(*stream_info->offsets));\nif (stream_info->offsets == (ssize_t *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\nstream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\noffset=TellBlob(image);\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\nstream_info->offsets[i]+=offset;\n}\nread_info=CloneImageInfo(image_info);\nSetImageInfoBlob(read_info,(void *) NULL,0);\nimages=NewImageList();\nfor (scene=0; scene < (ssize_t) number_scenes; scene++)\n{\nchar\nfilename[MagickPathExtent];\nconst char\n*property;\nFILE\n*file;\nImage\n*jpeg_image;\nint\nunique_file;\nunsigned int\ntag;\ntag=((unsigned int) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image);\nlength=(size_t) ReadBlobLSBLong(image);\nif (tag == 0xFFFEE0DD)\nbreak;\nif (tag != 0xFFFEE000)\n{\nread_info=DestroyImageInfo(read_info);\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n}\nfile=(FILE *) NULL;\nunique_file=AcquireUniqueFileResource(filename);\nif (unique_file != -1)\nfile=fdopen(unique_file,\"wb\");\nif (file == (FILE *) NULL)\n{\n(void) RelinquishUniqueFileResource(filename);\nThrowFileException(exception,FileOpenError,\n\"UnableToCreateTemporaryFile\",filename);\nbreak;\n}\nfor (c=EOF; length != 0; length--)\n{\nc=ReadBlobByte(image);\nif (c == EOF)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\n(void) fputc(c,file);\n}\n(void) fclose(file);\nif (c == EOF)\nbreak;\n(void) FormatLocaleString(read_info->filename,MagickPathExtent,\n\"jpeg:%s\",filename);\nif (image->compression == JPEG2000Compression)\n(void) FormatLocaleString(read_info->filename,MagickPathExtent,\n\"j2k:%s\",filename);\njpeg_image=ReadImage(read_info,exception);\nif (jpeg_image != (Image *) NULL)\n{\nResetImagePropertyIterator(image);\nproperty=GetNextImageProperty(image);\nwhile (property != (const char *) NULL)\n{\n(void) SetImageProperty(jpeg_image,property,\nGetImageProperty(image,property,exception),exception);\nproperty=GetNextImageProperty(image);\n}\nAppendImageToList(&images,jpeg_image);\n}\n(void) RelinquishUniqueFileResource(filename);\n}\nread_info=DestroyImageInfo(read_info);\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *)\nRelinquishMagickMemory(stream_info->offsets);\nstream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\nif (info.scale != (Quantum *) NULL)\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale);\nif (graymap != (int *) NULL)\ngraymap=(int *) RelinquishMagickMemory(graymap);\nif (bluemap != (int *) NULL)\nbluemap=(int *) RelinquishMagickMemory(bluemap);\nif (greenmap != (int *) NULL)\ngreenmap=(int *) RelinquishMagickMemory(greenmap);\nif (redmap != (int *) NULL)\nredmap=(int *) RelinquishMagickMemory(redmap);\nimage=DestroyImageList(image);\nreturn(GetFirstImageInList(images));\n}\nif (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n{\nQuantumAny\nrange;\nlength=(size_t) (GetQuantumRange(info.depth)+1);\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\nif (info.scale != (Quantum *) NULL)\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale);\ninfo.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\nsizeof(*info.scale));\nif (info.scale == (Quantum *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(info.scale,0,MagickMax(length,256)*\nsizeof(*info.scale));\nrange=GetQuantumRange(info.depth);\nfor (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\ninfo.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n}\nif (image->compression == RLECompression)\n{\nunsigned int\ntag;\nfor (i=0; i < (ssize_t) stream_info->remaining; i++)\n{\nint\nc;\nc=ReadBlobByte(image);\nif (c == EOF)\nbreak;\n}\ntag=((unsigned int) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image);\n(void) tag;\nlength=(size_t) ReadBlobLSBLong(image);\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\nstream_info->offset_count=length >> 2;\nif (stream_info->offset_count != 0)\n{\nstream_info->offsets=(ssize_t *) AcquireQuantumMemory(\nstream_info->offset_count,sizeof(*stream_info->offsets));\nif (stream_info->offsets == (ssize_t *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\n{\nstream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\nif (EOFBlob(image) != MagickFalse)\nbreak;\n}\noffset=TellBlob(image)+8;\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\nstream_info->offsets[i]+=offset;\n}\n}\nfor (scene=0; scene < (ssize_t) number_scenes; scene++)\n{\nif (image_info->ping != MagickFalse)\nbreak;\nimage->columns=(size_t) width;\nimage->rows=(size_t) height;\nimage->depth=info.depth;\nstatus=SetImageExtent(image,image->columns,image->rows,exception);\nif (status == MagickFalse)\nbreak;\nimage->colorspace=RGBColorspace;\n(void) SetImageBackgroundColor(image,exception);\nif ((image->colormap == (PixelInfo *) NULL) &&\n(info.samples_per_pixel == 1))\n{\nint\nindex;\nsize_t\none;\none=1;\nif (colors == 0)\ncolors=one << info.depth;\nif (AcquireImageColormap(image,colors,exception) == MagickFalse)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\nif (redmap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=redmap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].red=(MagickRealType) index;\n}\nif (greenmap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=greenmap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].green=(MagickRealType) index;\n}\nif (bluemap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=bluemap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].blue=(MagickRealType) index;\n}\nif (graymap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=graymap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].red=(MagickRealType) index;\nimage->colormap[i].green=(MagickRealType) index;\nimage->colormap[i].blue=(MagickRealType) index;\n}\n}\nif (image->compression == RLECompression)\n{\nunsigned int\ntag;\nfor (i=0; i < (ssize_t) stream_info->remaining; i++)\n{\nint\nc;\nc=ReadBlobByte(image);\nif (c == EOF)\nbreak;\n}\ntag=((unsigned int) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image);\nstream_info->remaining=(size_t) ReadBlobLSBLong(image);\nif ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n(EOFBlob(image) != MagickFalse))\n{\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *)\nRelinquishMagickMemory(stream_info->offsets);\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n}\nstream_info->count=0;\nstream_info->segment_count=ReadBlobLSBLong(image);\nfor (i=0; i < 15; i++)\nstream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\nstream_info->remaining-=64;\nif (stream_info->segment_count > 1)\n{\ninfo.bytes_per_pixel=1;\ninfo.depth=8;\nif (stream_info->offset_count > 0)\n(void) SeekBlob(image,(MagickOffsetType)\nstream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n}\n}\nif ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n{\nregister ssize_t\nx;\nregister Quantum\n*q;\nssize_t\ny;\nfor (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=GetAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nswitch ((int) i)\n{\ncase 0:\n{\nSetPixelRed(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ncase 1:\n{\nSetPixelGreen(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ncase 2:\n{\nSetPixelBlue(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ncase 3:\n{\nSetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ndefault:\nbreak;\n}\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\n}\nelse\n{\nconst char\n*option;\noption=GetImageOption(image_info,\"dcm:display-range\");\nif (option != (const char *) NULL)\n{\nif (LocaleCompare(option,\"reset\") == 0)\ninfo.window_width=0;\n}\noption=GetImageOption(image_info,\"dcm:window\");\nif (option != (char *) NULL)\n{\nGeometryInfo\ngeometry_info;\nMagickStatusType\nflags;\nflags=ParseGeometry(option,&geometry_info);\nif (flags & RhoValue)\ninfo.window_center=geometry_info.rho;\nif (flags & SigmaValue)\ninfo.window_width=geometry_info.sigma;\ninfo.rescale=MagickTrue;\n}\noption=GetImageOption(image_info,\"dcm:rescale\");\nif (option != (char *) NULL)\ninfo.rescale=IsStringTrue(option);\nif ((info.window_center != 0) && (info.window_width == 0))\ninfo.window_width=info.window_center;\nstatus=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\nif ((status != MagickFalse) && (stream_info->segment_count > 1))\n{\nif (stream_info->offset_count > 0)\n(void) SeekBlob(image,(MagickOffsetType)\nstream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n(void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\nexception);\n}\n}\nif (SetImageGray(image,exception) != MagickFalse)\n(void) SetImageColorspace(image,GRAYColorspace,exception);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nif (scene < (ssize_t) (number_scenes-1))\n{\nAcquireNextImage(image_info,image,exception);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nstatus=MagickFalse;\nbreak;\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n}\nif (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n{\nAcquireNextImage(image_info,image,exception);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nstatus=MagickFalse;\nbreak;\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n}\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *)\nRelinquishMagickMemory(stream_info->offsets);\nstream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\nif (info.scale != (Quantum *) NULL)\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale);\nif (graymap != (int *) NULL)\ngraymap=(int *) RelinquishMagickMemory(graymap);\nif (bluemap != (int *) NULL)\nbluemap=(int *) RelinquishMagickMemory(bluemap);\nif (greenmap != (int *) NULL)\ngreenmap=(int *) RelinquishMagickMemory(greenmap);\nif (redmap != (int *) NULL)\nredmap=(int *) RelinquishMagickMemory(redmap);\n(void) CloseBlob(image);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\nif (info.scale != (Quantum *) NULL) \\\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\nif (data != (unsigned char *) NULL) \\\ndata=(unsigned char *) RelinquishMagickMemory(data); \\\nif (graymap != (int *) NULL) \\\ngraymap=(int *) RelinquishMagickMemory(graymap); \\\nif (bluemap != (int *) NULL) \\\nbluemap=(int *) RelinquishMagickMemory(bluemap); \\\nif (greenmap != (int *) NULL) \\\ngreenmap=(int *) RelinquishMagickMemory(greenmap); \\\nif (redmap != (int *) NULL) \\\nredmap=(int *) RelinquishMagickMemory(redmap); \\\nif (stream_info->offsets != (ssize_t *) NULL) \\\nstream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\nstream_info->offsets); \\\nif (stream_info != (DCMStreamInfo *) NULL) \\\nstream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\nThrowReaderException((exception),(message)); \\\n}\nchar\nexplicit_vr[MagickPathExtent],\nimplicit_vr[MagickPathExtent],\nmagick[MagickPathExtent],\nphotometric[MagickPathExtent];\nDCMInfo\ninfo;\nDCMStreamInfo\n*stream_info;\nImage\n*image;\nint\n*bluemap,\ndatum,\n*greenmap,\n*graymap,\n*redmap;\nMagickBooleanType\nexplicit_file,\nexplicit_retry,\nuse_explicit;\nMagickOffsetType\noffset;\nregister unsigned char\n*p;\nregister ssize_t\ni;\nsize_t\ncolors,\nheight,\nlength,\nnumber_scenes,\nquantum,\nstatus,\nwidth;\nssize_t\ncount,\nscene;\nunsigned char\n*data;\nunsigned short\ngroup,\nelement;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nimage->depth=8UL;\nimage->endian=LSBEndian;\n(void) memset(&info,0,sizeof(info));\ndata=(unsigned char *) NULL;\ngraymap=(int *) NULL;\nredmap=(int *) NULL;\ngreenmap=(int *) NULL;\nbluemap=(int *) NULL;\nstream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\nif (stream_info == (DCMStreamInfo *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(stream_info,0,sizeof(*stream_info));\ncount=ReadBlob(image,128,(unsigned char *) magick);\nif (count != 128)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\ncount=ReadBlob(image,4,(unsigned char *) magick);\nif ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n{\noffset=SeekBlob(image,0L,SEEK_SET);\nif (offset < 0)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n}\n(void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\ninfo.bits_allocated=8;\ninfo.bytes_per_pixel=1;\ninfo.depth=8;\ninfo.mask=0xffff;\ninfo.max_value=255UL;\ninfo.samples_per_pixel=1;\ninfo.signed_data=(~0UL);\ninfo.rescale_slope=1.0;\ndata=(unsigned char *) NULL;\nelement=0;\nexplicit_vr[2]='\\0';\nexplicit_file=MagickFalse;\ncolors=0;\nredmap=(int *) NULL;\ngreenmap=(int *) NULL;\nbluemap=(int *) NULL;\ngraymap=(int *) NULL;\nheight=0;\nnumber_scenes=1;\nuse_explicit=MagickFalse;\nexplicit_retry = MagickFalse;\nwidth=0;\nwhile (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n{\nfor (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n{\nimage->offset=(ssize_t) TellBlob(image);\ngroup=ReadBlobLSBShort(image);\nelement=ReadBlobLSBShort(image);\nif ((group == 0xfffc) && (element == 0xfffc))\nbreak;\nif ((group != 0x0002) && (image->endian == MSBEndian))\n{\ngroup=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\nelement=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n}\nquantum=0;\nfor (i=0; dicom_info[i].group < 0xffff; i++)\nif ((group == dicom_info[i].group) &&\n(element == dicom_info[i].element))\nbreak;\n(void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\ncount=ReadBlob(image,2,(unsigned char *) explicit_vr);\nif (count != 2)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nif ((explicit_file == MagickFalse) && (group != 0x0002))\nexplicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n(isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\nMagickTrue : MagickFalse;\nuse_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n(explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\nif ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n(void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\nif ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n{\noffset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\nif (offset < 0)\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nquantum=4;\n}\nelse\n{\nquantum=2;\nif ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n(strncmp(explicit_vr,\"UN\",2) == 0) ||\n(strncmp(explicit_vr,\"OW\",2) == 0) ||\n(strncmp(explicit_vr,\"SQ\",2) == 0))\n{\n(void) ReadBlobLSBShort(image);\nquantum=4;\n}\n}\ndatum=0;\nif (quantum == 4)\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedLong(image);\nelse\ndatum=ReadBlobSignedLong(image);\n}\nelse\nif (quantum == 2)\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedShort(image);\nelse\ndatum=ReadBlobSignedShort(image);\n}\nquantum=0;\nlength=1;\nif (datum != 0)\n{\nif ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n(strncmp(implicit_vr,\"SS\",2) == 0) ||\n(strncmp(implicit_vr,\"US\",2) == 0))\nquantum=2;\nelse\nif ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n(strncmp(implicit_vr,\"OF\",2) == 0) ||\n(strncmp(implicit_vr,\"SL\",2) == 0) ||\n(strncmp(implicit_vr,\"UL\",2) == 0))\nquantum=4;\nelse\nif (strncmp(implicit_vr,\"FD\",2) == 0)\nquantum=8;\nelse\nquantum=1;\nif (datum != ~0)\nlength=(size_t) datum/quantum;\nelse\n{\nquantum=0;\nlength=0;\n}\n}\nif (image_info->verbose != MagickFalse)\n{\nif (use_explicit == MagickFalse)\nexplicit_vr[0]='\\0';\nfor (i=0; dicom_info[i].description != (char *) NULL; i++)\nif ((group == dicom_info[i].group) &&\n(element == dicom_info[i].element))\nbreak;\n(void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n(unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n(unsigned long) group,(unsigned long) element);\nif (dicom_info[i].description != (char *) NULL)\n(void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n(void) FormatLocaleFile(stdout,\": \");\n}\nif ((group == 0x7FE0) && (element == 0x0010))\n{\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\"\\n\");\nbreak;\n}\ndata=(unsigned char *) NULL;\nif ((length == 1) && (quantum == 1))\ndatum=ReadBlobByte(image);\nelse\nif ((length == 1) && (quantum == 2))\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedShort(image);\nelse\ndatum=ReadBlobSignedShort(image);\n}\nelse\nif ((length == 1) && (quantum == 4))\n{\nif (group == 0x0002)\ndatum=ReadBlobLSBSignedLong(image);\nelse\ndatum=ReadBlobSignedLong(image);\n}\nelse\nif ((quantum != 0) && (length != 0))\n{\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\n\"InsufficientImageDataInFile\");\nif (~length >= 1)\ndata=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\nsizeof(*data));\nif (data == (unsigned char *) NULL)\nThrowDCMException(ResourceLimitError,\n\"MemoryAllocationFailed\");\ncount=ReadBlob(image,(size_t) quantum*length,data);\nif (count != (ssize_t) (quantum*length))\n{\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n\"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\nlength,(int) group);\nThrowDCMException(CorruptImageError,\n\"InsufficientImageDataInFile\");\n}\ndata[length*quantum]='\\0';\n}\nif ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n{\nif (data != (unsigned char *) NULL)\ndata=(unsigned char *) RelinquishMagickMemory(data);\ncontinue;\n}\nswitch (group)\n{\ncase 0x0002:\n{\nswitch (element)\n{\ncase 0x0010:\n{\nchar\ntransfer_syntax[MagickPathExtent];\nif ((datum == 0) && (explicit_retry == MagickFalse))\n{\nexplicit_retry=MagickTrue;\n(void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\ngroup=0;\nelement=0;\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\n\"Corrupted image - trying explicit format\\n\");\nbreak;\n}\n*transfer_syntax='\\0';\nif (data != (unsigned char *) NULL)\n(void) CopyMagickString(transfer_syntax,(char *) data,\nMagickPathExtent);\nif (image_info->verbose != MagickFalse)\n(void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n(const char *) transfer_syntax);\nif (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n{\nint\nsubtype,\ntype;\ntype=1;\nsubtype=0;\nif (strlen(transfer_syntax) > 17)\n{\ncount=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n&subtype);\nif (count < 1)\nThrowDCMException(CorruptImageError,\n\"ImproperImageHeader\");\n}\nswitch (type)\n{\ncase 1:\n{\nimage->endian=LSBEndian;\nbreak;\n}\ncase 2:\n{\nimage->endian=MSBEndian;\nbreak;\n}\ncase 4:\n{\nif ((subtype >= 80) && (subtype <= 81))\nimage->compression=JPEGCompression;\nelse\nif ((subtype >= 90) && (subtype <= 93))\nimage->compression=JPEG2000Compression;\nelse\nimage->compression=JPEGCompression;\nbreak;\n}\ncase 5:\n{\nimage->compression=RLECompression;\nbreak;\n}\n}\n}\nbreak;\n}\ndefault:\nbreak;\n}\nbreak;\n}\ncase 0x0028:\n{\nswitch (element)\n{\ncase 0x0002:\n{\ninfo.samples_per_pixel=(size_t) datum;\nif ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase 0x0004:\n{\nif (data == (unsigned char *) NULL)\nbreak;\nfor (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\nphotometric[i]=(char) data[i];\nphotometric[i]='\\0';\ninfo.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\nMagickTrue : MagickFalse;\nbreak;\n}\ncase 0x0006:\n{\nif (datum == 1)\nimage->interlace=PlaneInterlace;\nbreak;\n}\ncase 0x0008:\n{\nif (data == (unsigned char *) NULL)\nbreak;\nnumber_scenes=StringToUnsignedLong((char *) data);\nbreak;\n}\ncase 0x0010:\n{\nheight=(size_t) datum;\nbreak;\n}\ncase 0x0011:\n{\nwidth=(size_t) datum;\nbreak;\n}\ncase 0x0100:\n{\ninfo.bits_allocated=(size_t) datum;\ninfo.bytes_per_pixel=1;\nif (datum > 8)\ninfo.bytes_per_pixel=2;\ninfo.depth=info.bits_allocated;\nif ((info.depth == 0) || (info.depth > 32))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\ninfo.max_value=(1UL << info.bits_allocated)-1;\nimage->depth=info.depth;\nbreak;\n}\ncase 0x0101:\n{\ninfo.significant_bits=(size_t) datum;\ninfo.bytes_per_pixel=1;\nif (info.significant_bits > 8)\ninfo.bytes_per_pixel=2;\ninfo.depth=info.significant_bits;\nif ((info.depth == 0) || (info.depth > 16))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\ninfo.max_value=(1UL << info.significant_bits)-1;\ninfo.mask=(size_t) GetQuantumRange(info.significant_bits);\nimage->depth=info.depth;\nbreak;\n}\ncase 0x0102:\n{\nbreak;\n}\ncase 0x0103:\n{\ninfo.signed_data=(size_t) datum;\nbreak;\n}\ncase 0x1050:\n{\nif (data != (unsigned char *) NULL)\ninfo.window_center=StringToDouble((char *) data,(char **) NULL);\nbreak;\n}\ncase 0x1051:\n{\nif (data != (unsigned char *) NULL)\ninfo.window_width=StringToDouble((char *) data,(char **) NULL);\nbreak;\n}\ncase 0x1052:\n{\nif (data != (unsigned char *) NULL)\ninfo.rescale_intercept=StringToDouble((char *) data,\n(char **) NULL);\nbreak;\n}\ncase 0x1053:\n{\nif (data != (unsigned char *) NULL)\ninfo.rescale_slope=StringToDouble((char *) data,(char **) NULL);\nbreak;\n}\ncase 0x1200:\ncase 0x3006:\n{\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/info.bytes_per_pixel);\ndatum=(int) colors;\nif (graymap != (int *) NULL)\ngraymap=(int *) RelinquishMagickMemory(graymap);\ngraymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*graymap));\nif (graymap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(graymap,0,MagickMax(colors,65536)*\nsizeof(*graymap));\nfor (i=0; i < (ssize_t) colors; i++)\nif (info.bytes_per_pixel == 1)\ngraymap[i]=(int) data[i];\nelse\ngraymap[i]=(int) ((short *) data)[i];\nbreak;\n}\ncase 0x1201:\n{\nunsigned short\nindex;\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/2);\ndatum=(int) colors;\nif (redmap != (int *) NULL)\nredmap=(int *) RelinquishMagickMemory(redmap);\nredmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*redmap));\nif (redmap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(redmap,0,MagickMax(colors,65536)*\nsizeof(*redmap));\np=data;\nfor (i=0; i < (ssize_t) colors; i++)\n{\nif (image->endian == MSBEndian)\nindex=(unsigned short) ((*p << 8) | *(p+1));\nelse\nindex=(unsigned short) (*p | (*(p+1) << 8));\nredmap[i]=(int) index;\np+=2;\n}\nbreak;\n}\ncase 0x1202:\n{\nunsigned short\nindex;\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/2);\ndatum=(int) colors;\nif (greenmap != (int *) NULL)\ngreenmap=(int *) RelinquishMagickMemory(greenmap);\ngreenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*greenmap));\nif (greenmap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(greenmap,0,MagickMax(colors,65536)*\nsizeof(*greenmap));\np=data;\nfor (i=0; i < (ssize_t) colors; i++)\n{\nif (image->endian == MSBEndian)\nindex=(unsigned short) ((*p << 8) | *(p+1));\nelse\nindex=(unsigned short) (*p | (*(p+1) << 8));\ngreenmap[i]=(int) index;\np+=2;\n}\nbreak;\n}\ncase 0x1203:\n{\nunsigned short\nindex;\nif (data == (unsigned char *) NULL)\nbreak;\ncolors=(size_t) (length/2);\ndatum=(int) colors;\nif (bluemap != (int *) NULL)\nbluemap=(int *) RelinquishMagickMemory(bluemap);\nbluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\nsizeof(*bluemap));\nif (bluemap == (int *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(bluemap,0,MagickMax(colors,65536)*\nsizeof(*bluemap));\np=data;\nfor (i=0; i < (ssize_t) colors; i++)\n{\nif (image->endian == MSBEndian)\nindex=(unsigned short) ((*p << 8) | *(p+1));\nelse\nindex=(unsigned short) (*p | (*(p+1) << 8));\nbluemap[i]=(int) index;\np+=2;\n}\nbreak;\n}\ndefault:\nbreak;\n}\nbreak;\n}\ncase 0x2050:\n{\nswitch (element)\n{\ncase 0x0020:\n{\nif ((data != (unsigned char *) NULL) &&\n(strncmp((char *) data,\"INVERSE\",7) == 0))\ninfo.polarity=MagickTrue;\nbreak;\n}\ndefault:\nbreak;\n}\nbreak;\n}\ndefault:\nbreak;\n}\nif (data != (unsigned char *) NULL)\n{\nchar\n*attribute;\nfor (i=0; dicom_info[i].description != (char *) NULL; i++)\nif ((group == dicom_info[i].group) &&\n(element == dicom_info[i].element))\nbreak;\nif (dicom_info[i].description != (char *) NULL)\n{\nattribute=AcquireString(\"dcm:\");\n(void) ConcatenateString(&attribute,dicom_info[i].description);\nfor (i=0; i < (ssize_t) MagickMax(length,4); i++)\nif (isprint((int) data[i]) == MagickFalse)\nbreak;\nif ((i == (ssize_t) length) || (length > 4))\n{\n(void) SubstituteString(&attribute,\" \",\"\");\n(void) SetImageProperty(image,attribute,(char *) data,\nexception);\n}\nattribute=DestroyString(attribute);\n}\n}\nif (image_info->verbose != MagickFalse)\n{\nif (data == (unsigned char *) NULL)\n(void) FormatLocaleFile(stdout,\"%d\\n\",datum);\nelse\n{\nfor (i=0; i < (ssize_t) MagickMax(length,4); i++)\nif (isprint((int) data[i]) == MagickFalse)\nbreak;\nif ((i != (ssize_t) length) && (length <= 4))\n{\nssize_t\nj;\ndatum=0;\nfor (j=(ssize_t) length-1; j >= 0; j--)\ndatum=(256*datum+data[j]);\n(void) FormatLocaleFile(stdout,\"%d\",datum);\n}\nelse\nfor (i=0; i < (ssize_t) length; i++)\nif (isprint((int) data[i]) != MagickFalse)\n(void) FormatLocaleFile(stdout,\"%c\",data[i]);\nelse\n(void) FormatLocaleFile(stdout,\"%c\",'.');\n(void) FormatLocaleFile(stdout,\"\\n\");\n}\n}\nif (data != (unsigned char *) NULL)\ndata=(unsigned char *) RelinquishMagickMemory(data);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\n}\nif ((group == 0xfffc) && (element == 0xfffc))\n{\nImage\n*last;\nlast=RemoveLastImageFromList(&image);\nif (last != (Image *) NULL)\nlast=DestroyImage(last);\nbreak;\n}\nif ((width == 0) || (height == 0))\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\nimage->columns=(size_t) width;\nimage->rows=(size_t) height;\nif (info.signed_data == 0xffff)\ninfo.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\nif ((image->compression == JPEGCompression) ||\n(image->compression == JPEG2000Compression))\n{\nImage\n*images;\nImageInfo\n*read_info;\nint\nc;\nfor (i=0; i < (ssize_t) stream_info->remaining; i++)\nif (ReadBlobByte(image) == EOF)\nbreak;\n(void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image));\nlength=(size_t) ReadBlobLSBLong(image);\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\nstream_info->offset_count=length >> 2;\nif (stream_info->offset_count != 0)\n{\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *) RelinquishMagickMemory(\nstream_info->offsets);\nstream_info->offsets=(ssize_t *) AcquireQuantumMemory(\nstream_info->offset_count,sizeof(*stream_info->offsets));\nif (stream_info->offsets == (ssize_t *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\nstream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\noffset=TellBlob(image);\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\nstream_info->offsets[i]+=offset;\n}\nread_info=CloneImageInfo(image_info);\nSetImageInfoBlob(read_info,(void *) NULL,0);\nimages=NewImageList();\nfor (scene=0; scene < (ssize_t) number_scenes; scene++)\n{\nchar\nfilename[MagickPathExtent];\nconst char\n*property;\nFILE\n*file;\nImage\n*jpeg_image;\nint\nunique_file;\nunsigned int\ntag;\ntag=((unsigned int) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image);\nlength=(size_t) ReadBlobLSBLong(image);\nif (tag == 0xFFFEE0DD)\nbreak;\nif (tag != 0xFFFEE000)\n{\nread_info=DestroyImageInfo(read_info);\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n}\nfile=(FILE *) NULL;\nunique_file=AcquireUniqueFileResource(filename);\nif (unique_file != -1)\nfile=fdopen(unique_file,\"wb\");\nif (file == (FILE *) NULL)\n{\n(void) RelinquishUniqueFileResource(filename);\nThrowFileException(exception,FileOpenError,\n\"UnableToCreateTemporaryFile\",filename);\nbreak;\n}\nfor (c=EOF; length != 0; length--)\n{\nc=ReadBlobByte(image);\nif (c == EOF)\n{\nThrowFileException(exception,CorruptImageError,\n\"UnexpectedEndOfFile\",image->filename);\nbreak;\n}\nif (fputc(c,file) != c)\nbreak;\n}\n(void) fclose(file);\nif (c == EOF)\nbreak;\n(void) FormatLocaleString(read_info->filename,MagickPathExtent,\n\"jpeg:%s\",filename);\nif (image->compression == JPEG2000Compression)\n(void) FormatLocaleString(read_info->filename,MagickPathExtent,\n\"j2k:%s\",filename);\njpeg_image=ReadImage(read_info,exception);\nif (jpeg_image != (Image *) NULL)\n{\nResetImagePropertyIterator(image);\nproperty=GetNextImageProperty(image);\nwhile (property != (const char *) NULL)\n{\n(void) SetImageProperty(jpeg_image,property,\nGetImageProperty(image,property,exception),exception);\nproperty=GetNextImageProperty(image);\n}\nAppendImageToList(&images,jpeg_image);\n}\n(void) RelinquishUniqueFileResource(filename);\n}\nread_info=DestroyImageInfo(read_info);\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *)\nRelinquishMagickMemory(stream_info->offsets);\nstream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\nif (info.scale != (Quantum *) NULL)\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale);\nif (graymap != (int *) NULL)\ngraymap=(int *) RelinquishMagickMemory(graymap);\nif (bluemap != (int *) NULL)\nbluemap=(int *) RelinquishMagickMemory(bluemap);\nif (greenmap != (int *) NULL)\ngreenmap=(int *) RelinquishMagickMemory(greenmap);\nif (redmap != (int *) NULL)\nredmap=(int *) RelinquishMagickMemory(redmap);\nimage=DestroyImageList(image);\nreturn(GetFirstImageInList(images));\n}\nif (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n{\nQuantumAny\nrange;\nlength=(size_t) (GetQuantumRange(info.depth)+1);\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\nif (info.scale != (Quantum *) NULL)\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale);\ninfo.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\nsizeof(*info.scale));\nif (info.scale == (Quantum *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n(void) memset(info.scale,0,MagickMax(length,256)*\nsizeof(*info.scale));\nrange=GetQuantumRange(info.depth);\nfor (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\ninfo.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n}\nif (image->compression == RLECompression)\n{\nunsigned int\ntag;\nfor (i=0; i < (ssize_t) stream_info->remaining; i++)\n{\nint\nc;\nc=ReadBlobByte(image);\nif (c == EOF)\nbreak;\n}\ntag=((unsigned int) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image);\n(void) tag;\nlength=(size_t) ReadBlobLSBLong(image);\nif (length > (size_t) GetBlobSize(image))\nThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\nstream_info->offset_count=length >> 2;\nif (stream_info->offset_count != 0)\n{\nstream_info->offsets=(ssize_t *) AcquireQuantumMemory(\nstream_info->offset_count,sizeof(*stream_info->offsets));\nif (stream_info->offsets == (ssize_t *) NULL)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\n{\nstream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\nif (EOFBlob(image) != MagickFalse)\nbreak;\n}\noffset=TellBlob(image)+8;\nfor (i=0; i < (ssize_t) stream_info->offset_count; i++)\nstream_info->offsets[i]+=offset;\n}\n}\nfor (scene=0; scene < (ssize_t) number_scenes; scene++)\n{\nif (image_info->ping != MagickFalse)\nbreak;\nimage->columns=(size_t) width;\nimage->rows=(size_t) height;\nimage->depth=info.depth;\nstatus=SetImageExtent(image,image->columns,image->rows,exception);\nif (status == MagickFalse)\nbreak;\nimage->colorspace=RGBColorspace;\n(void) SetImageBackgroundColor(image,exception);\nif ((image->colormap == (PixelInfo *) NULL) &&\n(info.samples_per_pixel == 1))\n{\nint\nindex;\nsize_t\none;\none=1;\nif (colors == 0)\ncolors=one << info.depth;\nif (AcquireImageColormap(image,colors,exception) == MagickFalse)\nThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\nif (redmap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=redmap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].red=(MagickRealType) index;\n}\nif (greenmap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=greenmap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].green=(MagickRealType) index;\n}\nif (bluemap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=bluemap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].blue=(MagickRealType) index;\n}\nif (graymap != (int *) NULL)\nfor (i=0; i < (ssize_t) colors; i++)\n{\nindex=graymap[i];\nif ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n(index <= (int) info.max_value))\nindex=(int) info.scale[index];\nimage->colormap[i].red=(MagickRealType) index;\nimage->colormap[i].green=(MagickRealType) index;\nimage->colormap[i].blue=(MagickRealType) index;\n}\n}\nif (image->compression == RLECompression)\n{\nunsigned int\ntag;\nfor (i=0; i < (ssize_t) stream_info->remaining; i++)\n{\nint\nc;\nc=ReadBlobByte(image);\nif (c == EOF)\nbreak;\n}\ntag=((unsigned int) ReadBlobLSBShort(image) << 16) |\nReadBlobLSBShort(image);\nstream_info->remaining=(size_t) ReadBlobLSBLong(image);\nif ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n(EOFBlob(image) != MagickFalse))\n{\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *)\nRelinquishMagickMemory(stream_info->offsets);\nThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n}\nstream_info->count=0;\nstream_info->segment_count=ReadBlobLSBLong(image);\nfor (i=0; i < 15; i++)\nstream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\nstream_info->remaining-=64;\nif (stream_info->segment_count > 1)\n{\ninfo.bytes_per_pixel=1;\ninfo.depth=8;\nif (stream_info->offset_count > 0)\n(void) SeekBlob(image,(MagickOffsetType)\nstream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n}\n}\nif ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n{\nregister ssize_t\nx;\nregister Quantum\n*q;\nssize_t\ny;\nfor (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n{\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=GetAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nswitch ((int) i)\n{\ncase 0:\n{\nSetPixelRed(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ncase 1:\n{\nSetPixelGreen(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ncase 2:\n{\nSetPixelBlue(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ncase 3:\n{\nSetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\nReadDCMByte(stream_info,image)),q);\nbreak;\n}\ndefault:\nbreak;\n}\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nif (image->previous == (Image *) NULL)\n{\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\ny,image->rows);\nif (status == MagickFalse)\nbreak;\n}\n}\n}\n}\nelse\n{\nconst char\n*option;\noption=GetImageOption(image_info,\"dcm:display-range\");\nif (option != (const char *) NULL)\n{\nif (LocaleCompare(option,\"reset\") == 0)\ninfo.window_width=0;\n}\noption=GetImageOption(image_info,\"dcm:window\");\nif (option != (char *) NULL)\n{\nGeometryInfo\ngeometry_info;\nMagickStatusType\nflags;\nflags=ParseGeometry(option,&geometry_info);\nif (flags & RhoValue)\ninfo.window_center=geometry_info.rho;\nif (flags & SigmaValue)\ninfo.window_width=geometry_info.sigma;\ninfo.rescale=MagickTrue;\n}\noption=GetImageOption(image_info,\"dcm:rescale\");\nif (option != (char *) NULL)\ninfo.rescale=IsStringTrue(option);\nif ((info.window_center != 0) && (info.window_width == 0))\ninfo.window_width=info.window_center;\nstatus=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\nif ((status != MagickFalse) && (stream_info->segment_count > 1))\n{\nif (stream_info->offset_count > 0)\n(void) SeekBlob(image,(MagickOffsetType)\nstream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n(void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\nexception);\n}\n}\nif (SetImageGray(image,exception) != MagickFalse)\n(void) SetImageColorspace(image,GRAYColorspace,exception);\nif (EOFBlob(image) != MagickFalse)\n{\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\nbreak;\n}\nif (image_info->number_scenes != 0)\nif (image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nif (scene < (ssize_t) (number_scenes-1))\n{\nAcquireNextImage(image_info,image,exception);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nstatus=MagickFalse;\nbreak;\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n}\nif (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n{\nAcquireNextImage(image_info,image,exception);\nif (GetNextImageInList(image) == (Image *) NULL)\n{\nstatus=MagickFalse;\nbreak;\n}\nimage=SyncNextImageInList(image);\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(image),\nGetBlobSize(image));\nif (status == MagickFalse)\nbreak;\n}\n}\nif (stream_info->offsets != (ssize_t *) NULL)\nstream_info->offsets=(ssize_t *)\nRelinquishMagickMemory(stream_info->offsets);\nstream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\nif (info.scale != (Quantum *) NULL)\ninfo.scale=(Quantum *) RelinquishMagickMemory(info.scale);\nif (graymap != (int *) NULL)\ngraymap=(int *) RelinquishMagickMemory(graymap);\nif (bluemap != (int *) NULL)\nbluemap=(int *) RelinquishMagickMemory(bluemap);\nif (greenmap != (int *) NULL)\ngreenmap=(int *) RelinquishMagickMemory(greenmap);\nif (redmap != (int *) NULL)\nredmap=(int *) RelinquishMagickMemory(redmap);\n(void) CloseBlob(image);\nif (status == MagickFalse)\nreturn(DestroyImageList(image));\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 178020, "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nchar\nfilename[MagickPathExtent];\nFILE\n*file;\nImage\n*image,\n*next_image,\n*pwp_image;\nImageInfo\n*read_info;\nint\nc,\nunique_file;\nMagickBooleanType\nstatus;\nregister Image\n*p;\nregister ssize_t\ni;\nsize_t\nfilesize,\nlength;\nssize_t\ncount;\nunsigned char\nmagick[MagickPathExtent];\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImage(image);\nreturn((Image *) NULL);\n}\npwp_image=image;\nmemset(magick,0,sizeof(magick));\ncount=ReadBlob(pwp_image,5,magick);\nif ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nread_info=CloneImageInfo(image_info);\n(void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n(void *) NULL);\nSetImageInfoBlob(read_info,(void *) NULL,0);\nunique_file=AcquireUniqueFileResource(filename);\n(void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",\nfilename);\nfor ( ; ; )\n{\n(void) memset(magick,0,sizeof(magick));\nfor (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n{\nfor (i=0; i < 17; i++)\nmagick[i]=magick[i+1];\nmagick[17]=(unsigned char) c;\nif (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\nbreak;\n}\nif (c == EOF)\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\nif (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nfile=(FILE *) NULL;\nif (unique_file != -1)\nfile=fdopen(unique_file,\"wb\");\nif ((unique_file == -1) || (file == (FILE *) NULL))\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\nimage->filename);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=fwrite(\"SFW94A\",1,6,file);\n(void) length;\nfilesize=65535UL*magick[2]+256L*magick[1]+magick[0];\nfor (i=0; i < (ssize_t) filesize; i++)\n{\nc=ReadBlobByte(pwp_image);\nif (c == EOF)\nbreak;\n(void) fputc(c,file);\n}\n(void) fclose(file);\nif (c == EOF)\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\nnext_image=ReadImage(read_info,exception);\nif (next_image == (Image *) NULL)\nbreak;\n(void) FormatLocaleString(next_image->filename,MagickPathExtent,\n\"slide_%02ld.sfw\",(long) next_image->scene);\nif (image == (Image *) NULL)\nimage=next_image;\nelse\n{\nfor (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\nnext_image->previous=p;\nnext_image->scene=p->scene+1;\np->next=next_image;\n}\nif (image_info->number_scenes != 0)\nif (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\nGetBlobSize(pwp_image));\nif (status == MagickFalse)\nbreak;\n}\nif (unique_file != -1)\n(void) close(unique_file);\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nif (image != (Image *) NULL)\n{\nif (EOFBlob(image) != MagickFalse)\n{\nchar\n*message;\nmessage=GetExceptionMessage(errno);\n(void) ThrowMagickException(exception,GetMagickModule(),\nCorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\nmessage);\nmessage=DestroyString(message);\n}\n(void) CloseBlob(image);\n}\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\nchar\nfilename[MagickPathExtent];\nFILE\n*file;\nImage\n*image,\n*next_image,\n*pwp_image;\nImageInfo\n*read_info;\nint\nc,\nunique_file;\nMagickBooleanType\nstatus;\nregister Image\n*p;\nregister ssize_t\ni;\nsize_t\nfilesize,\nlength;\nssize_t\ncount;\nunsigned char\nmagick[MagickPathExtent];\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImage(image);\nreturn((Image *) NULL);\n}\npwp_image=image;\nmemset(magick,0,sizeof(magick));\ncount=ReadBlob(pwp_image,5,magick);\nif ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nread_info=CloneImageInfo(image_info);\n(void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n(void *) NULL);\nSetImageInfoBlob(read_info,(void *) NULL,0);\nunique_file=AcquireUniqueFileResource(filename);\n(void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",\nfilename);\nfor ( ; ; )\n{\n(void) memset(magick,0,sizeof(magick));\nfor (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n{\nfor (i=0; i < 17; i++)\nmagick[i]=magick[i+1];\nmagick[17]=(unsigned char) c;\nif (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\nbreak;\n}\nif (c == EOF)\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\nif (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nfile=(FILE *) NULL;\nif (unique_file != -1)\nfile=fdopen(unique_file,\"wb\");\nif ((unique_file == -1) || (file == (FILE *) NULL))\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\nimage->filename);\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\nlength=fwrite(\"SFW94A\",1,6,file);\n(void) length;\nfilesize=65535UL*magick[2]+256L*magick[1]+magick[0];\nfor (i=0; i < (ssize_t) filesize; i++)\n{\nc=ReadBlobByte(pwp_image);\nif (c == EOF)\nbreak;\nif (fputc(c,file) != c)\nbreak;\n}\n(void) fclose(file);\nif (c == EOF)\n{\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\nnext_image=ReadImage(read_info,exception);\nif (next_image == (Image *) NULL)\nbreak;\n(void) FormatLocaleString(next_image->filename,MagickPathExtent,\n\"slide_%02ld.sfw\",(long) next_image->scene);\nif (image == (Image *) NULL)\nimage=next_image;\nelse\n{\nfor (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\nnext_image->previous=p;\nnext_image->scene=p->scene+1;\np->next=next_image;\n}\nif (image_info->number_scenes != 0)\nif (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\nbreak;\nstatus=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\nGetBlobSize(pwp_image));\nif (status == MagickFalse)\nbreak;\n}\nif (unique_file != -1)\n(void) close(unique_file);\n(void) RelinquishUniqueFileResource(filename);\nread_info=DestroyImageInfo(read_info);\nif (image != (Image *) NULL)\n{\nif (EOFBlob(image) != MagickFalse)\n{\nchar\n*message;\nmessage=GetExceptionMessage(errno);\n(void) ThrowMagickException(exception,GetMagickModule(),\nCorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\nmessage);\nmessage=DestroyString(message);\n}\n(void) CloseBlob(image);\n}\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 178031, "code": "static int entersafe_gen_key(sc_card_t *card, sc_entersafe_gen_key_data *data)\n{\nint\tr;\nsize_t len = data->key_length >> 3;\nsc_apdu_t apdu;\nu8 rbuf[300];\nu8 sbuf[4],*p;\nSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\nsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x01, 0xB8);\napdu.lc=0x04;\nsbuf[0]=0x83;\nsbuf[1]=0x02;\nsbuf[2]=data->key_id;\nsbuf[3]=0x2A;\napdu.data = sbuf;\napdu.datalen=4;\napdu.lc=4;\napdu.le=0;\nr=entersafe_transmit_apdu(card, &apdu, 0,0,0,0);\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe set MSE failed\");\nsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46,  0x00, 0x00);\napdu.le      = 0;\nsbuf[0] = (u8)(data->key_length >> 8);\nsbuf[1] = (u8)(data->key_length);\napdu.data    = sbuf;\napdu.lc      = 2;\napdu.datalen = 2;\nr = entersafe_transmit_apdu(card, &apdu,0,0,0,0);\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe generate keypair failed\");\nsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xE6,  0x2A, data->key_id);\napdu.cla     = 0x80;\napdu.resp    = rbuf;\napdu.resplen = sizeof(rbuf);\napdu.le      = 256;\nr = entersafe_transmit_apdu(card, &apdu,0,0,0,0);\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe get pukey failed\");\ndata->modulus = malloc(len);\nif (!data->modulus)\nSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_OUT_OF_MEMORY);\np=rbuf;\nassert(*p=='E');\np+=2+p[1];\nassert(*p=='N');\n++p;\nif(*p++>0x80)\n{\nu8 len_bytes=(*(p-1))&0x0f;\nsize_t module_len=0;\nwhile(len_bytes!=0)\n{\nmodule_len=module_len<<8;\nmodule_len+=*p++;\n--len_bytes;\n}\n}\nentersafe_reverse_buffer(p,len);\nmemcpy(data->modulus,p,len);\nSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);\n}", "contrast": "static int entersafe_gen_key(sc_card_t *card, sc_entersafe_gen_key_data *data)\n{\nint\tr;\nsize_t len = data->key_length >> 3;\nsc_apdu_t apdu;\nu8 rbuf[300];\nu8 sbuf[4],*p;\nSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\nsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x01, 0xB8);\napdu.lc=0x04;\nsbuf[0]=0x83;\nsbuf[1]=0x02;\nsbuf[2]=data->key_id;\nsbuf[3]=0x2A;\napdu.data = sbuf;\napdu.datalen=4;\napdu.lc=4;\napdu.le=0;\nr=entersafe_transmit_apdu(card, &apdu, 0,0,0,0);\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe set MSE failed\");\nsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46,  0x00, 0x00);\napdu.le      = 0;\nsbuf[0] = (u8)(data->key_length >> 8);\nsbuf[1] = (u8)(data->key_length);\napdu.data    = sbuf;\napdu.lc      = 2;\napdu.datalen = 2;\nr = entersafe_transmit_apdu(card, &apdu,0,0,0,0);\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe generate keypair failed\");\nsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xE6,  0x2A, data->key_id);\napdu.cla     = 0x80;\napdu.resp    = rbuf;\napdu.resplen = sizeof(rbuf);\napdu.le      = 256;\nr = entersafe_transmit_apdu(card, &apdu,0,0,0,0);\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\nSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe get pukey failed\");\ndata->modulus = malloc(len);\nif (!data->modulus)\nSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_OUT_OF_MEMORY);\np=rbuf;\nif (*p!='E')\nSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);\np+=2+p[1];\nif (*p!='N')\nSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);\n++p;\nif(*p++>0x80)\n{\nu8 len_bytes=(*(p-1))&0x0f;\nsize_t module_len=0;\nwhile(len_bytes!=0)\n{\nmodule_len=module_len<<8;\nmodule_len+=*p++;\n--len_bytes;\n}\n}\nentersafe_reverse_buffer(p,len);\nmemcpy(data->modulus,p,len);\nSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);\n}", "label": 0}
{"index": 178035, "code": "gpk_parse_fileinfo(sc_card_t *card,\nconst u8 *buf, size_t buflen,\nsc_file_t *file)\n{\nconst u8\t*sp, *end, *next;\nint\t\ti, rc;\nmemset(file, 0, sizeof(*file));\nfor (i = 0; i < SC_MAX_AC_OPS; i++)\nsc_file_add_acl_entry(file, i, SC_AC_UNKNOWN, SC_AC_KEY_REF_NONE);\nend = buf + buflen;\nfor (sp = buf; sp + 2 < end; sp = next) {\nnext = sp + 2 + sp[1];\nif (next > end)\nbreak;\nif (sp[0] == 0x84) {\nif (sp[1] > sizeof(file->name))\ncontinue;\nmemset(file->name, 0, sizeof(file->name));\nmemcpy(file->name, sp+2, sp[1]);\n} else\nif (sp[0] == 0x85) {\nunsigned int\tac[3], n;\nfile->id = (sp[4] << 8) | sp[5];\nfile->size = (sp[8] << 8) | sp[9];\nfile->record_length = sp[7];\nfor (n = 0; n < 3; n++)\nac[n] = (sp[10+2*n] << 8) | sp[11+2*n];\nswitch (sp[6] & 7) {\ncase 0x01: case 0x02: case 0x03: case 0x04:\ncase 0x05: case 0x06: case 0x07:\nfile->type = SC_FILE_TYPE_WORKING_EF;\nfile->ef_structure = sp[6] & 7;\nac_to_acl(ac[0], file, SC_AC_OP_UPDATE);\nac_to_acl(ac[1], file, SC_AC_OP_WRITE);\nac_to_acl(ac[2], file, SC_AC_OP_READ);\nbreak;\ncase 0x00:\nfile->type = SC_FILE_TYPE_DF;\nac_to_acl(ac[0], file, SC_AC_OP_LOCK);\nac_to_acl(ac[1], file, SC_AC_OP_CREATE);\nsc_file_add_acl_entry(file, SC_AC_OP_SELECT,\nSC_AC_NONE, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_DELETE,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_LIST_FILES,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nbreak;\n}\n} else\nif (sp[0] == 0x6f) {\nfile->type = SC_FILE_TYPE_DF;\nrc = gpk_parse_fci(card, sp + 2, sp[1], file);\nif (rc < 0)\nreturn rc;\n}\n}\nif (file->record_length)\nfile->record_count = file->size / file->record_length;\nfile->magic = SC_FILE_MAGIC;\nreturn 0;\n}", "contrast": "gpk_parse_fileinfo(sc_card_t *card,\nconst u8 *buf, size_t buflen,\nsc_file_t *file)\n{\nconst u8\t*sp, *end, *next;\nint\t\ti, rc;\nmemset(file, 0, sizeof(*file));\nfor (i = 0; i < SC_MAX_AC_OPS; i++)\nsc_file_add_acl_entry(file, i, SC_AC_UNKNOWN, SC_AC_KEY_REF_NONE);\nend = buf + buflen;\nfor (sp = buf; sp + 2 < end; sp = next) {\nnext = sp + 2 + sp[1];\nif (next > end)\nbreak;\nif (sp[0] == 0x84) {\nif (sp[1] > sizeof(file->name))\ncontinue;\nmemset(file->name, 0, sizeof(file->name));\nmemcpy(file->name, sp+2, sp[1]);\n} else\nif (sp[0] == 0x85) {\nunsigned int\tac[3], n;\nif (sp + 11 + 2*3 >= end)\nbreak;\nfile->id = (sp[4] << 8) | sp[5];\nfile->size = (sp[8] << 8) | sp[9];\nfile->record_length = sp[7];\nfor (n = 0; n < 3; n++)\nac[n] = (sp[10+2*n] << 8) | sp[11+2*n];\nswitch (sp[6] & 7) {\ncase 0x01: case 0x02: case 0x03: case 0x04:\ncase 0x05: case 0x06: case 0x07:\nfile->type = SC_FILE_TYPE_WORKING_EF;\nfile->ef_structure = sp[6] & 7;\nac_to_acl(ac[0], file, SC_AC_OP_UPDATE);\nac_to_acl(ac[1], file, SC_AC_OP_WRITE);\nac_to_acl(ac[2], file, SC_AC_OP_READ);\nbreak;\ncase 0x00:\nfile->type = SC_FILE_TYPE_DF;\nac_to_acl(ac[0], file, SC_AC_OP_LOCK);\nac_to_acl(ac[1], file, SC_AC_OP_CREATE);\nsc_file_add_acl_entry(file, SC_AC_OP_SELECT,\nSC_AC_NONE, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_DELETE,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nsc_file_add_acl_entry(file, SC_AC_OP_LIST_FILES,\nSC_AC_NEVER, SC_AC_KEY_REF_NONE);\nbreak;\n}\n} else\nif (sp[0] == 0x6f) {\nfile->type = SC_FILE_TYPE_DF;\nrc = gpk_parse_fci(card, sp + 2, sp[1], file);\nif (rc < 0)\nreturn rc;\n}\n}\nif (file->record_length)\nfile->record_count = file->size / file->record_length;\nfile->magic = SC_FILE_MAGIC;\nreturn 0;\n}", "label": 0}
{"index": 178050, "code": "epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\nint r;\nsize_t len = 0;\nepass2003_exdata *exdata = NULL;\nif (!card->drv_data)\nreturn SC_ERROR_INVALID_ARGUMENTS;\nexdata = (epass2003_exdata *)card->drv_data;\nLOG_FUNC_CALLED(card->ctx);\nr = sc_check_sw(card, sm->sw1, sm->sw2);\nif (r == SC_SUCCESS) {\nif (exdata->sm) {\nif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\nreturn SC_ERROR_CARD_CMD_FAILED;\n}\nelse {\nmemcpy(plain->resp, sm->resp, sm->resplen);\nlen = sm->resplen;\n}\n}\nplain->resplen = len;\nplain->sw1 = sm->sw1;\nplain->sw2 = sm->sw2;\nsc_log(card->ctx,\n\"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\nplain->resplen, plain->sw1, plain->sw2);\nLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}", "contrast": "epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\nint r;\nsize_t len = 0;\nepass2003_exdata *exdata = NULL;\nif (!card->drv_data)\nreturn SC_ERROR_INVALID_ARGUMENTS;\nexdata = (epass2003_exdata *)card->drv_data;\nLOG_FUNC_CALLED(card->ctx);\nr = sc_check_sw(card, sm->sw1, sm->sw2);\nif (r == SC_SUCCESS) {\nif (exdata->sm) {\nlen = plain->resplen;\nif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\nreturn SC_ERROR_CARD_CMD_FAILED;\n}\nelse {\nmemcpy(plain->resp, sm->resp, sm->resplen);\nlen = sm->resplen;\n}\n}\nplain->resplen = len;\nplain->sw1 = sm->sw1;\nplain->sw2 = sm->sw2;\nsc_log(card->ctx,\n\"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\nplain->resplen, plain->sw1, plain->sw2);\nLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}", "label": 0}
{"index": 178051, "code": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\nmuscle_private_t* priv = MUSCLE_DATA(card);\nmscfs_t *fs = priv->fs;\nint x;\nint count = 0;\nmscfs_check_cache(priv->fs);\nfor(x = 0; x < fs->cache.size; x++) {\nu8* oid= fs->cache.array[x].objectId.id;\nsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\"FILE: %02X%02X%02X%02X\\n\",\noid[0],oid[1],oid[2],oid[3]);\nif(0 == memcmp(fs->currentPath, oid, 2)) {\nbuf[0] = oid[2];\nbuf[1] = oid[3];\nif(buf[0] == 0x00 && buf[1] == 0x00) continue;\nbuf += 2;\ncount+=2;\n}\n}\nreturn count;\n}", "contrast": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\nmuscle_private_t* priv = MUSCLE_DATA(card);\nmscfs_t *fs = priv->fs;\nint x;\nint count = 0;\nmscfs_check_cache(priv->fs);\nfor(x = 0; x < fs->cache.size; x++) {\nu8* oid = fs->cache.array[x].objectId.id;\nif (bufLen < 2)\nbreak;\nsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\"FILE: %02X%02X%02X%02X\\n\",\noid[0],oid[1],oid[2],oid[3]);\nif(0 == memcmp(fs->currentPath, oid, 2)) {\nbuf[0] = oid[2];\nbuf[1] = oid[3];\nif(buf[0] == 0x00 && buf[1] == 0x00) continue;\nbuf += 2;\ncount += 2;\nbufLen -= 2;\n}\n}\nreturn count;\n}", "label": 0}
{"index": 178059, "code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\nstruct sc_path path;\nstruct sc_file *file;\nunsigned char *p;\nint ok = 0;\nint r;\nsize_t len;\nsc_format_path(str_path, &path);\nif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\ngoto err;\n}\nlen = file ? file->size : 4096;\np = realloc(*data, len);\nif (!p) {\ngoto err;\n}\n*data = p;\n*data_len = len;\nr = sc_read_binary(card, 0, p, len, 0);\nif (r < 0)\ngoto err;\n*data_len = r;\nok = 1;\nerr:\nsc_file_free(file);\nreturn ok;\n}", "contrast": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\nstruct sc_path path;\nstruct sc_file *file;\nunsigned char *p;\nint ok = 0;\nint r;\nsize_t len;\nsc_format_path(str_path, &path);\nif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\ngoto err;\n}\nlen = file && file->size > 0 ? file->size : 4096;\np = realloc(*data, len);\nif (!p) {\ngoto err;\n}\n*data = p;\n*data_len = len;\nr = sc_read_binary(card, 0, p, len, 0);\nif (r < 0)\ngoto err;\n*data_len = r;\nok = 1;\nerr:\nsc_file_free(file);\nreturn ok;\n}", "label": 0}
{"index": 178078, "code": "userauth_gssapi(struct ssh *ssh)\n{\nAuthctxt *authctxt = ssh->authctxt;\ngss_OID_desc goid = {0, NULL};\nGssctxt *ctxt = NULL;\nint r, present;\nu_int mechs;\nOM_uint32 ms;\nsize_t len;\nu_char *doid = NULL;\nif (!authctxt->valid || authctxt->user == NULL)\nreturn (0);\nif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\nfatal(\"%s: %s\", __func__, ssh_err(r));\nif (mechs == 0) {\ndebug(\"Mechanism negotiation is not supported\");\nreturn (0);\n}\ndo {\nmechs--;\nfree(doid);\npresent = 0;\nif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\nfatal(\"%s: %s\", __func__, ssh_err(r));\nif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\ndoid[1] == len - 2) {\ngoid.elements = doid + 2;\ngoid.length   = len - 2;\nssh_gssapi_test_oid_supported(&ms, &goid, &present);\n} else {\nlogit(\"Badly formed OID received\");\n}\n} while (mechs > 0 && !present);\nif (!present) {\nfree(doid);\nauthctxt->server_caused_failure = 1;\nreturn (0);\n}\nif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\nif (ctxt != NULL)\nssh_gssapi_delete_ctx(&ctxt);\nfree(doid);\nauthctxt->server_caused_failure = 1;\nreturn (0);\n}\nauthctxt->methoddata = (void *)ctxt;\nif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n(r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n(r = sshpkt_send(ssh)) != 0)\nfatal(\"%s: %s\", __func__, ssh_err(r));\nfree(doid);\nssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\nssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\nauthctxt->postponed = 1;\nreturn (0);\n}", "contrast": "userauth_gssapi(struct ssh *ssh)\n{\nAuthctxt *authctxt = ssh->authctxt;\ngss_OID_desc goid = {0, NULL};\nGssctxt *ctxt = NULL;\nint r, present;\nu_int mechs;\nOM_uint32 ms;\nsize_t len;\nu_char *doid = NULL;\nif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\nfatal(\"%s: %s\", __func__, ssh_err(r));\nif (mechs == 0) {\ndebug(\"Mechanism negotiation is not supported\");\nreturn (0);\n}\ndo {\nmechs--;\nfree(doid);\npresent = 0;\nif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\nfatal(\"%s: %s\", __func__, ssh_err(r));\nif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\ndoid[1] == len - 2) {\ngoid.elements = doid + 2;\ngoid.length   = len - 2;\nssh_gssapi_test_oid_supported(&ms, &goid, &present);\n} else {\nlogit(\"Badly formed OID received\");\n}\n} while (mechs > 0 && !present);\nif (!present) {\nfree(doid);\nauthctxt->server_caused_failure = 1;\nreturn (0);\n}\nif (!authctxt->valid || authctxt->user == NULL) {\ndebug2(\"%s: disabled because of invalid user\", __func__);\nfree(doid);\nreturn (0);\n}\nif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\nif (ctxt != NULL)\nssh_gssapi_delete_ctx(&ctxt);\nfree(doid);\nauthctxt->server_caused_failure = 1;\nreturn (0);\n}\nauthctxt->methoddata = (void *)ctxt;\nif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n(r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n(r = sshpkt_send(ssh)) != 0)\nfatal(\"%s: %s\", __func__, ssh_err(r));\nfree(doid);\nssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\nssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\nauthctxt->postponed = 1;\nreturn (0);\n}", "label": 0}
{"index": 178082, "code": "_pango_emoji_iter_next (PangoEmojiIter *iter)\n{\nPangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID;\nif (iter->end == iter->text_end)\nreturn FALSE;\niter->start = iter->end;\nfor (; iter->end < iter->text_end; iter->end = g_utf8_next_char (iter->end))\n{\ngunichar ch = g_utf8_get_char (iter->end);\nif ((!(ch == kZeroWidthJoinerCharacter && !iter->is_emoji) &&\nch != kVariationSelector15Character &&\nch != kVariationSelector16Character &&\nch != kCombiningEnclosingCircleBackslashCharacter &&\n!_pango_Is_Regional_Indicator(ch) &&\n!((ch == kLeftSpeechBubbleCharacter ||\nch == kRainbowCharacter ||\nch == kMaleSignCharacter ||\nch == kFemaleSignCharacter ||\nch == kStaffOfAesculapiusCharacter) &&\n!iter->is_emoji)) ||\ncurrent_emoji_type == PANGO_EMOJI_TYPE_INVALID) {\ncurrent_emoji_type = _pango_get_emoji_type (ch);\n}\nif (g_utf8_next_char (iter->end) < iter->text_end)\n{\ngunichar peek_char = g_utf8_get_char (g_utf8_next_char (iter->end));\nif (current_emoji_type ==\nPANGO_EMOJI_TYPE_EMOJI_EMOJI &&\npeek_char == kVariationSelector15Character) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT;\n}\nif ((current_emoji_type ==\nPANGO_EMOJI_TYPE_EMOJI_TEXT ||\n_pango_Is_Emoji_Keycap_Base(ch)) &&\npeek_char == kVariationSelector16Character) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n}\nif (_pango_Is_Emoji_Keycap_Base(ch) &&\npeek_char == kCombiningEnclosingKeycapCharacter) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n};\nif (_pango_Is_Regional_Indicator(ch) &&\n_pango_Is_Regional_Indicator(peek_char)) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n}\nif ((ch == kEyeCharacter ||\nch == kWavingWhiteFlagCharacter) &&\npeek_char == kZeroWidthJoinerCharacter) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n}\n}\nif (iter->is_emoji == (gboolean) 2)\niter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);\nif (iter->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type))\n{\niter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);\nreturn TRUE;\n}\n}\niter->is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);\nreturn TRUE;\n}", "contrast": "_pango_emoji_iter_next (PangoEmojiIter *iter)\n{\nPangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID;\nif (iter->end == iter->text_end)\nreturn FALSE;\niter->start = iter->end;\nfor (; iter->end < iter->text_end; iter->end = g_utf8_next_char (iter->end))\n{\ngunichar ch = g_utf8_get_char (iter->end);\nif ((!(ch == kZeroWidthJoinerCharacter && !iter->is_emoji) &&\nch != kVariationSelector15Character &&\nch != kVariationSelector16Character &&\nch != kCombiningEnclosingCircleBackslashCharacter &&\n!_pango_Is_Regional_Indicator(ch) &&\n!((ch == kLeftSpeechBubbleCharacter ||\nch == kRainbowCharacter ||\nch == kMaleSignCharacter ||\nch == kFemaleSignCharacter ||\nch == kStaffOfAesculapiusCharacter) &&\n!iter->is_emoji)) ||\ncurrent_emoji_type == PANGO_EMOJI_TYPE_INVALID) {\ncurrent_emoji_type = _pango_get_emoji_type (ch);\n}\nif (g_utf8_next_char (iter->end) < iter->text_end)\n{\ngunichar peek_char = g_utf8_get_char (g_utf8_next_char (iter->end));\nif (current_emoji_type ==\nPANGO_EMOJI_TYPE_EMOJI_EMOJI &&\npeek_char == kVariationSelector15Character) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT;\n}\nif ((current_emoji_type ==\nPANGO_EMOJI_TYPE_EMOJI_TEXT ||\n_pango_Is_Emoji_Keycap_Base(ch)) &&\npeek_char == kVariationSelector16Character) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n}\nif (_pango_Is_Emoji_Keycap_Base(ch) &&\npeek_char == kCombiningEnclosingKeycapCharacter) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n};\nif (_pango_Is_Regional_Indicator(ch) &&\n_pango_Is_Regional_Indicator(peek_char)) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n}\nif ((ch == kEyeCharacter ||\nch == kWavingWhiteFlagCharacter) &&\npeek_char == kZeroWidthJoinerCharacter) {\ncurrent_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;\n}\n}\nif (iter->is_emoji == (gboolean) 2)\niter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);\nif (iter->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type))\n{\niter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);\nif (iter->start == iter->end)\niter->end = g_utf8_next_char (iter->end);\nreturn TRUE;\n}\n}\niter->is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);\nreturn TRUE;\n}", "label": 0}
{"index": 178090, "code": "static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\nanum_t last, int restore)\n{\nstruct NntpData *nntp_data = ctx->data;\nstruct FetchCtx fc;\nstruct Header *hdr = NULL;\nchar buf[HUGE_STRING];\nint rc = 0;\nint oldmsgcount = ctx->msgcount;\nanum_t current;\nanum_t first_over = first;\n#ifdef USE_HCACHE\nvoid *hdata = NULL;\n#endif\nif (!last || first > last)\nreturn 0;\nfc.ctx = ctx;\nfc.first = first;\nfc.last = last;\nfc.restore = restore;\nfc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n#ifdef USE_HCACHE\nfc.hc = hc;\n#endif\nif (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n{\nif (!ctx->quiet)\nmutt_message(_(\"Fetching list of articles...\"));\nif (nntp_data->nserv->hasLISTGROUPrange)\nsnprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\nelse\nsnprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\nrc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\nif (rc > 0)\n{\nmutt_error(\"LISTGROUP: %s\", buf);\n}\nif (rc == 0)\n{\nfor (current = first; current <= last && rc == 0; current++)\n{\nif (fc.messages[current - first])\ncontinue;\nsnprintf(buf, sizeof(buf), \"%u\", current);\nif (nntp_data->bcache)\n{\nmutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\nmutt_bcache_del(nntp_data->bcache, buf);\n}\n#ifdef USE_HCACHE\nif (fc.hc)\n{\nmutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\nmutt_hcache_delete(fc.hc, buf, strlen(buf));\n}\n#endif\n}\n}\n}\nelse\n{\nfor (current = first; current <= last; current++)\nfc.messages[current - first] = 1;\n}\nif (!ctx->quiet)\n{\nmutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\nMUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n}\nfor (current = first; current <= last && rc == 0; current++)\n{\nif (!ctx->quiet)\nmutt_progress_update(&fc.progress, current - first + 1, -1);\n#ifdef USE_HCACHE\nsnprintf(buf, sizeof(buf), \"%u\", current);\n#endif\nif (!fc.messages[current - first])\ncontinue;\nif (ctx->msgcount >= ctx->hdrmax)\nmx_alloc_memory(ctx);\n#ifdef USE_HCACHE\nhdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\nif (hdata)\n{\nmutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\nctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\nmutt_hcache_free(fc.hc, &hdata);\nhdr->data = 0;\nif (hdr->deleted && !restore)\n{\nmutt_header_free(&hdr);\nif (nntp_data->bcache)\n{\nmutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\nmutt_bcache_del(nntp_data->bcache, buf);\n}\ncontinue;\n}\nhdr->read = false;\nhdr->old = false;\n}\nelse\n#endif\nif (nntp_data->deleted)\ncontinue;\nelse if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n{\nif (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\nbreak;\nelse\ncontinue;\n}\nelse\n{\nFILE *fp = mutt_file_mkstemp();\nif (!fp)\n{\nmutt_perror(\"mutt_file_mkstemp() failed!\");\nrc = -1;\nbreak;\n}\nsnprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\nrc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\nif (rc)\n{\nmutt_file_fclose(&fp);\nif (rc < 0)\nbreak;\nif (mutt_str_strncmp(\"423\", buf, 3) != 0)\n{\nmutt_error(\"HEAD: %s\", buf);\nbreak;\n}\nif (nntp_data->bcache)\n{\nsnprintf(buf, sizeof(buf), \"%u\", current);\nmutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\nmutt_bcache_del(nntp_data->bcache, buf);\n}\nrc = 0;\ncontinue;\n}\nhdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\nhdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\nhdr->received = hdr->date_sent;\nmutt_file_fclose(&fp);\n}\nhdr->index = ctx->msgcount++;\nhdr->read = false;\nhdr->old = false;\nhdr->deleted = false;\nhdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\nNHDR(hdr)->article_num = current;\nif (restore)\nhdr->changed = true;\nelse\n{\nnntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\nif (!hdr->read)\nnntp_parse_xref(ctx, hdr);\n}\nif (current > nntp_data->last_loaded)\nnntp_data->last_loaded = current;\nfirst_over = current + 1;\n}\nif (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\ncurrent = first_over;\nif (current <= last && rc == 0 && !nntp_data->deleted)\n{\nchar *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\nsnprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\nrc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\nif (rc > 0)\n{\nmutt_error(\"%s: %s\", cmd, buf);\n}\n}\nif (ctx->msgcount > oldmsgcount)\nmx_update_context(ctx, ctx->msgcount - oldmsgcount);\nFREE(&fc.messages);\nif (rc != 0)\nreturn -1;\nmutt_clear_error();\nreturn 0;\n}", "contrast": "static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\nanum_t last, int restore)\n{\nstruct NntpData *nntp_data = ctx->data;\nstruct FetchCtx fc;\nstruct Header *hdr = NULL;\nchar buf[HUGE_STRING];\nint rc = 0;\nint oldmsgcount = ctx->msgcount;\nanum_t current;\nanum_t first_over = first;\n#ifdef USE_HCACHE\nvoid *hdata = NULL;\n#endif\nif (!last || first > last)\nreturn 0;\nfc.ctx = ctx;\nfc.first = first;\nfc.last = last;\nfc.restore = restore;\nfc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\nif (fc.messages == NULL)\nreturn -1;\n#ifdef USE_HCACHE\nfc.hc = hc;\n#endif\nif (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n{\nif (!ctx->quiet)\nmutt_message(_(\"Fetching list of articles...\"));\nif (nntp_data->nserv->hasLISTGROUPrange)\nsnprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\nelse\nsnprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\nrc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\nif (rc > 0)\n{\nmutt_error(\"LISTGROUP: %s\", buf);\n}\nif (rc == 0)\n{\nfor (current = first; current <= last && rc == 0; current++)\n{\nif (fc.messages[current - first])\ncontinue;\nsnprintf(buf, sizeof(buf), \"%u\", current);\nif (nntp_data->bcache)\n{\nmutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\nmutt_bcache_del(nntp_data->bcache, buf);\n}\n#ifdef USE_HCACHE\nif (fc.hc)\n{\nmutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\nmutt_hcache_delete(fc.hc, buf, strlen(buf));\n}\n#endif\n}\n}\n}\nelse\n{\nfor (current = first; current <= last; current++)\nfc.messages[current - first] = 1;\n}\nif (!ctx->quiet)\n{\nmutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\nMUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n}\nfor (current = first; current <= last && rc == 0; current++)\n{\nif (!ctx->quiet)\nmutt_progress_update(&fc.progress, current - first + 1, -1);\n#ifdef USE_HCACHE\nsnprintf(buf, sizeof(buf), \"%u\", current);\n#endif\nif (!fc.messages[current - first])\ncontinue;\nif (ctx->msgcount >= ctx->hdrmax)\nmx_alloc_memory(ctx);\n#ifdef USE_HCACHE\nhdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\nif (hdata)\n{\nmutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\nctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\nmutt_hcache_free(fc.hc, &hdata);\nhdr->data = 0;\nif (hdr->deleted && !restore)\n{\nmutt_header_free(&hdr);\nif (nntp_data->bcache)\n{\nmutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\nmutt_bcache_del(nntp_data->bcache, buf);\n}\ncontinue;\n}\nhdr->read = false;\nhdr->old = false;\n}\nelse\n#endif\nif (nntp_data->deleted)\ncontinue;\nelse if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n{\nif (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\nbreak;\nelse\ncontinue;\n}\nelse\n{\nFILE *fp = mutt_file_mkstemp();\nif (!fp)\n{\nmutt_perror(\"mutt_file_mkstemp() failed!\");\nrc = -1;\nbreak;\n}\nsnprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\nrc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\nif (rc)\n{\nmutt_file_fclose(&fp);\nif (rc < 0)\nbreak;\nif (mutt_str_strncmp(\"423\", buf, 3) != 0)\n{\nmutt_error(\"HEAD: %s\", buf);\nbreak;\n}\nif (nntp_data->bcache)\n{\nsnprintf(buf, sizeof(buf), \"%u\", current);\nmutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\nmutt_bcache_del(nntp_data->bcache, buf);\n}\nrc = 0;\ncontinue;\n}\nhdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\nhdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\nhdr->received = hdr->date_sent;\nmutt_file_fclose(&fp);\n}\nhdr->index = ctx->msgcount++;\nhdr->read = false;\nhdr->old = false;\nhdr->deleted = false;\nhdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\nNHDR(hdr)->article_num = current;\nif (restore)\nhdr->changed = true;\nelse\n{\nnntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\nif (!hdr->read)\nnntp_parse_xref(ctx, hdr);\n}\nif (current > nntp_data->last_loaded)\nnntp_data->last_loaded = current;\nfirst_over = current + 1;\n}\nif (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\ncurrent = first_over;\nif (current <= last && rc == 0 && !nntp_data->deleted)\n{\nchar *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\nsnprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\nrc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\nif (rc > 0)\n{\nmutt_error(\"%s: %s\", cmd, buf);\n}\n}\nif (ctx->msgcount > oldmsgcount)\nmx_update_context(ctx, ctx->msgcount - oldmsgcount);\nFREE(&fc.messages);\nif (rc != 0)\nreturn -1;\nmutt_clear_error();\nreturn 0;\n}", "label": 0}
{"index": 178098, "code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\nchar tmp[SHORT_STRING];\nchar *ptmp = NULL;\nif (!s)\nreturn -1;\nwhile (*s)\n{\nSKIPWS(s);\nif (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n{\ns = msg_parse_flags(h, s);\nif (!s)\nreturn -1;\n}\nelse if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n{\ns += 3;\nSKIPWS(s);\nif (mutt_str_atoui(s, &h->data->uid) < 0)\nreturn -1;\ns = imap_next_word(s);\n}\nelse if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n{\ns += 12;\nSKIPWS(s);\nif (*s != '\\\"')\n{\nmutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\nreturn -1;\n}\ns++;\nptmp = tmp;\nwhile (*s && *s != '\\\"')\n*ptmp++ = *s++;\nif (*s != '\\\"')\nreturn -1;\ns++;\n*ptmp = '\\0';\nh->received = mutt_date_parse_imap(tmp);\n}\nelse if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n{\ns += 11;\nSKIPWS(s);\nptmp = tmp;\nwhile (isdigit((unsigned char) *s))\n*ptmp++ = *s++;\n*ptmp = '\\0';\nif (mutt_str_atol(tmp, &h->content_length) < 0)\nreturn -1;\n}\nelse if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n(mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n{\nreturn -2;\n}\nelse if (*s == ')')\ns++;\nelse if (*s)\n{\nimap_error(\"msg_parse_fetch\", s);\nreturn -1;\n}\n}\nreturn 0;\n}", "contrast": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\nchar tmp[SHORT_STRING];\nchar *ptmp = NULL;\nif (!s)\nreturn -1;\nwhile (*s)\n{\nSKIPWS(s);\nif (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n{\ns = msg_parse_flags(h, s);\nif (!s)\nreturn -1;\n}\nelse if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n{\ns += 3;\nSKIPWS(s);\nif (mutt_str_atoui(s, &h->data->uid) < 0)\nreturn -1;\ns = imap_next_word(s);\n}\nelse if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n{\ns += 12;\nSKIPWS(s);\nif (*s != '\\\"')\n{\nmutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\nreturn -1;\n}\ns++;\nptmp = tmp;\nwhile (*s && (*s != '\\\"') && (ptmp != (tmp + sizeof(tmp) - 1)))\n*ptmp++ = *s++;\nif (*s != '\\\"')\nreturn -1;\ns++;\n*ptmp = '\\0';\nh->received = mutt_date_parse_imap(tmp);\n}\nelse if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n{\ns += 11;\nSKIPWS(s);\nptmp = tmp;\nwhile (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1)))\n*ptmp++ = *s++;\n*ptmp = '\\0';\nif (mutt_str_atol(tmp, &h->content_length) < 0)\nreturn -1;\n}\nelse if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n(mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n{\nreturn -2;\n}\nelse if (*s == ')')\ns++;\nelse if (*s)\n{\nimap_error(\"msg_parse_fetch\", s);\nreturn -1;\n}\n}\nreturn 0;\n}", "label": 0}
{"index": 178112, "code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\nMpegEncContext *s = &ctx->m;\nunsigned startcode, v;\nint ret;\nint vol = 0;\nalign_get_bits(gb);\nif (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\ns->avctx->bits_per_raw_sample = 0;\nif (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\nskip_bits(gb, 24);\nif (get_bits(gb, 8) == 0xF0)\ngoto end;\n}\nstartcode = 0xff;\nfor (;;) {\nif (get_bits_count(gb) >= gb->size_in_bits) {\nif (gb->size_in_bits == 8 &&\n(ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\nav_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\nreturn FRAME_SKIPPED;\n} else\nreturn AVERROR_INVALIDDATA;\n}\nv = get_bits(gb, 8);\nstartcode = ((startcode << 8) | v) & 0xffffffff;\nif ((startcode & 0xFFFFFF00) != 0x100)\ncontinue;\nif (s->avctx->debug & FF_DEBUG_STARTCODE) {\nav_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\nif (startcode <= 0x11F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\nelse if (startcode <= 0x12F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\nelse if (startcode <= 0x13F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode <= 0x15F)\nav_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\nelse if (startcode <= 0x1AF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode == 0x1B0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\nelse if (startcode == 0x1B1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\nelse if (startcode == 0x1B2)\nav_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\nelse if (startcode == 0x1B3)\nav_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\nelse if (startcode == 0x1B4)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\nelse if (startcode == 0x1B5)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\nelse if (startcode == 0x1B6)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\nelse if (startcode == 0x1B7)\nav_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\nelse if (startcode == 0x1B8)\nav_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\nelse if (startcode == 0x1B9)\nav_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\nelse if (startcode == 0x1BA)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\nelse if (startcode == 0x1BB)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\nelse if (startcode == 0x1BC)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\nelse if (startcode == 0x1BD)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\nelse if (startcode == 0x1BE)\nav_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\nelse if (startcode == 0x1BF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\nelse if (startcode == 0x1C0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\nelse if (startcode == 0x1C1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\nelse if (startcode == 0x1C2)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\nelse if (startcode == 0x1C3)\nav_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\nelse if (startcode <= 0x1C5)\nav_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\nelse if (startcode <= 0x1FF)\nav_log(s->avctx, AV_LOG_DEBUG, \"System start\");\nav_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n}\nif (startcode >= 0x120 && startcode <= 0x12F) {\nif (vol) {\nav_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\ncontinue;\n}\nvol++;\nif ((ret = decode_vol_header(ctx, gb)) < 0)\nreturn ret;\n} else if (startcode == USER_DATA_STARTCODE) {\ndecode_user_data(ctx, gb);\n} else if (startcode == GOP_STARTCODE) {\nmpeg4_decode_gop_header(s, gb);\n} else if (startcode == VOS_STARTCODE) {\nint profile, level;\nmpeg4_decode_profile_level(s, gb, &profile, &level);\nif (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n(level > 0 && level < 9)) {\ns->studio_profile = 1;\nnext_start_code_studio(gb);\nextension_and_user_data(s, gb, 0);\n} else if (s->studio_profile) {\navpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\nreturn AVERROR_PATCHWELCOME;\n}\ns->avctx->profile = profile;\ns->avctx->level   = level;\n} else if (startcode == VISUAL_OBJ_STARTCODE) {\nif (s->studio_profile) {\nif ((ret = decode_studiovisualobject(ctx, gb)) < 0)\nreturn ret;\n} else\nmpeg4_decode_visual_object(s, gb);\n} else if (startcode == VOP_STARTCODE) {\nbreak;\n}\nalign_get_bits(gb);\nstartcode = 0xff;\n}\nend:\nif (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\ns->low_delay = 1;\ns->avctx->has_b_frames = !s->low_delay;\nif (s->studio_profile) {\nav_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\nif (!s->avctx->bits_per_raw_sample) {\nav_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nreturn decode_studio_vop_header(ctx, gb);\n} else\nreturn decode_vop_header(ctx, gb);\n}", "contrast": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\nMpegEncContext *s = &ctx->m;\nunsigned startcode, v;\nint ret;\nint vol = 0;\nalign_get_bits(gb);\nif (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\ns->avctx->bits_per_raw_sample = 0;\nif (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\nskip_bits(gb, 24);\nif (get_bits(gb, 8) == 0xF0)\ngoto end;\n}\nstartcode = 0xff;\nfor (;;) {\nif (get_bits_count(gb) >= gb->size_in_bits) {\nif (gb->size_in_bits == 8 &&\n(ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\nav_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\nreturn FRAME_SKIPPED;\n} else\nreturn AVERROR_INVALIDDATA;\n}\nv = get_bits(gb, 8);\nstartcode = ((startcode << 8) | v) & 0xffffffff;\nif ((startcode & 0xFFFFFF00) != 0x100)\ncontinue;\nif (s->avctx->debug & FF_DEBUG_STARTCODE) {\nav_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\nif (startcode <= 0x11F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\nelse if (startcode <= 0x12F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\nelse if (startcode <= 0x13F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode <= 0x15F)\nav_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\nelse if (startcode <= 0x1AF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode == 0x1B0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\nelse if (startcode == 0x1B1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\nelse if (startcode == 0x1B2)\nav_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\nelse if (startcode == 0x1B3)\nav_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\nelse if (startcode == 0x1B4)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\nelse if (startcode == 0x1B5)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\nelse if (startcode == 0x1B6)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\nelse if (startcode == 0x1B7)\nav_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\nelse if (startcode == 0x1B8)\nav_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\nelse if (startcode == 0x1B9)\nav_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\nelse if (startcode == 0x1BA)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\nelse if (startcode == 0x1BB)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\nelse if (startcode == 0x1BC)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\nelse if (startcode == 0x1BD)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\nelse if (startcode == 0x1BE)\nav_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\nelse if (startcode == 0x1BF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\nelse if (startcode == 0x1C0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\nelse if (startcode == 0x1C1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\nelse if (startcode == 0x1C2)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\nelse if (startcode == 0x1C3)\nav_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\nelse if (startcode <= 0x1C5)\nav_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\nelse if (startcode <= 0x1FF)\nav_log(s->avctx, AV_LOG_DEBUG, \"System start\");\nav_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n}\nif (startcode >= 0x120 && startcode <= 0x12F) {\nif (vol) {\nav_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\ncontinue;\n}\nvol++;\nif ((ret = decode_vol_header(ctx, gb)) < 0)\nreturn ret;\n} else if (startcode == USER_DATA_STARTCODE) {\ndecode_user_data(ctx, gb);\n} else if (startcode == GOP_STARTCODE) {\nmpeg4_decode_gop_header(s, gb);\n} else if (startcode == VOS_STARTCODE) {\nint profile, level;\nmpeg4_decode_profile_level(s, gb, &profile, &level);\nif (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n(level > 0 && level < 9)) {\ns->studio_profile = 1;\nnext_start_code_studio(gb);\nextension_and_user_data(s, gb, 0);\n} else if (s->studio_profile) {\navpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\nreturn AVERROR_PATCHWELCOME;\n}\ns->avctx->profile = profile;\ns->avctx->level   = level;\n} else if (startcode == VISUAL_OBJ_STARTCODE) {\nif (s->studio_profile) {\nif ((ret = decode_studiovisualobject(ctx, gb)) < 0)\nreturn ret;\n} else\nmpeg4_decode_visual_object(s, gb);\n} else if (startcode == VOP_STARTCODE) {\nbreak;\n}\nalign_get_bits(gb);\nstartcode = 0xff;\n}\nend:\nif (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\ns->low_delay = 1;\ns->avctx->has_b_frames = !s->low_delay;\nif (s->studio_profile) {\nif (!s->avctx->bits_per_raw_sample) {\nav_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nreturn decode_studio_vop_header(ctx, gb);\n} else\nreturn decode_vop_header(ctx, gb);\n}", "label": 0}
{"index": 178115, "code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\nMpegEncContext *s = &ctx->m;\nunsigned startcode, v;\nint ret;\nint vol = 0;\nalign_get_bits(gb);\nif (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\ns->avctx->bits_per_raw_sample = 0;\nif (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\nskip_bits(gb, 24);\nif (get_bits(gb, 8) == 0xF0)\ngoto end;\n}\nstartcode = 0xff;\nfor (;;) {\nif (get_bits_count(gb) >= gb->size_in_bits) {\nif (gb->size_in_bits == 8 &&\n(ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\nav_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\nreturn FRAME_SKIPPED;\n} else\nreturn AVERROR_INVALIDDATA;\n}\nv = get_bits(gb, 8);\nstartcode = ((startcode << 8) | v) & 0xffffffff;\nif ((startcode & 0xFFFFFF00) != 0x100)\ncontinue;\nif (s->avctx->debug & FF_DEBUG_STARTCODE) {\nav_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\nif (startcode <= 0x11F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\nelse if (startcode <= 0x12F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\nelse if (startcode <= 0x13F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode <= 0x15F)\nav_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\nelse if (startcode <= 0x1AF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode == 0x1B0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\nelse if (startcode == 0x1B1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\nelse if (startcode == 0x1B2)\nav_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\nelse if (startcode == 0x1B3)\nav_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\nelse if (startcode == 0x1B4)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\nelse if (startcode == 0x1B5)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\nelse if (startcode == 0x1B6)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\nelse if (startcode == 0x1B7)\nav_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\nelse if (startcode == 0x1B8)\nav_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\nelse if (startcode == 0x1B9)\nav_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\nelse if (startcode == 0x1BA)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\nelse if (startcode == 0x1BB)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\nelse if (startcode == 0x1BC)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\nelse if (startcode == 0x1BD)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\nelse if (startcode == 0x1BE)\nav_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\nelse if (startcode == 0x1BF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\nelse if (startcode == 0x1C0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\nelse if (startcode == 0x1C1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\nelse if (startcode == 0x1C2)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\nelse if (startcode == 0x1C3)\nav_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\nelse if (startcode <= 0x1C5)\nav_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\nelse if (startcode <= 0x1FF)\nav_log(s->avctx, AV_LOG_DEBUG, \"System start\");\nav_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n}\nif (startcode >= 0x120 && startcode <= 0x12F) {\nif (vol) {\nav_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\ncontinue;\n}\nvol++;\nif ((ret = decode_vol_header(ctx, gb)) < 0)\nreturn ret;\n} else if (startcode == USER_DATA_STARTCODE) {\ndecode_user_data(ctx, gb);\n} else if (startcode == GOP_STARTCODE) {\nmpeg4_decode_gop_header(s, gb);\n} else if (startcode == VOS_STARTCODE) {\nmpeg4_decode_profile_level(s, gb);\nif (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n(s->avctx->level > 0 && s->avctx->level < 9)) {\ns->studio_profile = 1;\nnext_start_code_studio(gb);\nextension_and_user_data(s, gb, 0);\n}\n} else if (startcode == VISUAL_OBJ_STARTCODE) {\nif (s->studio_profile) {\nif ((ret = decode_studiovisualobject(ctx, gb)) < 0)\nreturn ret;\n} else\nmpeg4_decode_visual_object(s, gb);\n} else if (startcode == VOP_STARTCODE) {\nbreak;\n}\nalign_get_bits(gb);\nstartcode = 0xff;\n}\nend:\nif (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\ns->low_delay = 1;\ns->avctx->has_b_frames = !s->low_delay;\nif (s->studio_profile) {\nif (!s->avctx->bits_per_raw_sample) {\nav_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nreturn decode_studio_vop_header(ctx, gb);\n} else\nreturn decode_vop_header(ctx, gb);\n}", "contrast": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\nMpegEncContext *s = &ctx->m;\nunsigned startcode, v;\nint ret;\nint vol = 0;\nalign_get_bits(gb);\nif (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\ns->avctx->bits_per_raw_sample = 0;\nif (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\nskip_bits(gb, 24);\nif (get_bits(gb, 8) == 0xF0)\ngoto end;\n}\nstartcode = 0xff;\nfor (;;) {\nif (get_bits_count(gb) >= gb->size_in_bits) {\nif (gb->size_in_bits == 8 &&\n(ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\nav_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\nreturn FRAME_SKIPPED;\n} else\nreturn AVERROR_INVALIDDATA;\n}\nv = get_bits(gb, 8);\nstartcode = ((startcode << 8) | v) & 0xffffffff;\nif ((startcode & 0xFFFFFF00) != 0x100)\ncontinue;\nif (s->avctx->debug & FF_DEBUG_STARTCODE) {\nav_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\nif (startcode <= 0x11F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\nelse if (startcode <= 0x12F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\nelse if (startcode <= 0x13F)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode <= 0x15F)\nav_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\nelse if (startcode <= 0x1AF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\nelse if (startcode == 0x1B0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\nelse if (startcode == 0x1B1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\nelse if (startcode == 0x1B2)\nav_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\nelse if (startcode == 0x1B3)\nav_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\nelse if (startcode == 0x1B4)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\nelse if (startcode == 0x1B5)\nav_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\nelse if (startcode == 0x1B6)\nav_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\nelse if (startcode == 0x1B7)\nav_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\nelse if (startcode == 0x1B8)\nav_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\nelse if (startcode == 0x1B9)\nav_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\nelse if (startcode == 0x1BA)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\nelse if (startcode == 0x1BB)\nav_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\nelse if (startcode == 0x1BC)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\nelse if (startcode == 0x1BD)\nav_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\nelse if (startcode == 0x1BE)\nav_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\nelse if (startcode == 0x1BF)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\nelse if (startcode == 0x1C0)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\nelse if (startcode == 0x1C1)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\nelse if (startcode == 0x1C2)\nav_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\nelse if (startcode == 0x1C3)\nav_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\nelse if (startcode <= 0x1C5)\nav_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\nelse if (startcode <= 0x1FF)\nav_log(s->avctx, AV_LOG_DEBUG, \"System start\");\nav_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n}\nif (startcode >= 0x120 && startcode <= 0x12F) {\nif (vol) {\nav_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\ncontinue;\n}\nvol++;\nif ((ret = decode_vol_header(ctx, gb)) < 0)\nreturn ret;\n} else if (startcode == USER_DATA_STARTCODE) {\ndecode_user_data(ctx, gb);\n} else if (startcode == GOP_STARTCODE) {\nmpeg4_decode_gop_header(s, gb);\n} else if (startcode == VOS_STARTCODE) {\nint profile, level;\nmpeg4_decode_profile_level(s, gb, &profile, &level);\nif (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n(level > 0 && level < 9)) {\ns->studio_profile = 1;\nnext_start_code_studio(gb);\nextension_and_user_data(s, gb, 0);\n} else if (s->studio_profile) {\navpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\nreturn AVERROR_PATCHWELCOME;\n}\ns->avctx->profile = profile;\ns->avctx->level   = level;\n} else if (startcode == VISUAL_OBJ_STARTCODE) {\nif (s->studio_profile) {\nif ((ret = decode_studiovisualobject(ctx, gb)) < 0)\nreturn ret;\n} else\nmpeg4_decode_visual_object(s, gb);\n} else if (startcode == VOP_STARTCODE) {\nbreak;\n}\nalign_get_bits(gb);\nstartcode = 0xff;\n}\nend:\nif (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\ns->low_delay = 1;\ns->avctx->has_b_frames = !s->low_delay;\nif (s->studio_profile) {\nav_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\nif (!s->avctx->bits_per_raw_sample) {\nav_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nreturn decode_studio_vop_header(ctx, gb);\n} else\nreturn decode_vop_header(ctx, gb);\n}", "label": 0}
{"index": 178138, "code": "static int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\nchar addrbuf[64];\nconst int buffsize = sizeof (addrbuf) - 1;\nmemset (op, '\\0', sizeof (RAnalOp));\nop->size = snes_op_get_size (1, 1, &snes_op[data[0]]);\nop->addr = addr;\nop->type = R_ANAL_OP_TYPE_UNK;\nop->id = data[0];\nr_strbuf_init (&op->esil);\nswitch (data[0]) {\ncase 0x02:\ncase 0x03:\ncase 0x04:\ncase 0x07:\ncase 0x0b:\ncase 0x0c:\ncase 0x0f:\ncase 0x12:\ncase 0x13:\ncase 0x14:\ncase 0x17:\ncase 0x1a:\ncase 0x1b:\ncase 0x1c:\ncase 0x1f:\ncase 0x22:\ncase 0x23:\ncase 0x27:\ncase 0x2b:\ncase 0x2f:\ncase 0x32:\ncase 0x33:\ncase 0x34:\ncase 0x37:\ncase 0x3a:\ncase 0x3b:\ncase 0x3c:\ncase 0x3f:\ncase 0x42:\ncase 0x43:\ncase 0x44:\ncase 0x47:\ncase 0x4b:\ncase 0x4f:\ncase 0x52:\ncase 0x53:\ncase 0x54:\ncase 0x57:\ncase 0x5a:\ncase 0x5b:\ncase 0x5c:\ncase 0x5f:\ncase 0x62:\ncase 0x63:\ncase 0x64:\ncase 0x67:\ncase 0x6b:\ncase 0x6f:\ncase 0x72:\ncase 0x73:\ncase 0x74:\ncase 0x77:\ncase 0x7a:\ncase 0x7b:\ncase 0x7c:\ncase 0x7f:\ncase 0x80:\ncase 0x82:\ncase 0x83:\ncase 0x87:\ncase 0x89:\ncase 0x8b:\ncase 0x8f:\ncase 0x92:\ncase 0x93:\ncase 0x97:\ncase 0x9b:\ncase 0x9c:\ncase 0x9e:\ncase 0x9f:\ncase 0xa3:\ncase 0xa7:\ncase 0xab:\ncase 0xaf:\ncase 0xb2:\ncase 0xb3:\ncase 0xb7:\ncase 0xbb:\ncase 0xbf:\ncase 0xc2:\ncase 0xc3:\ncase 0xc7:\ncase 0xcb:\ncase 0xcf:\ncase 0xd2:\ncase 0xd3:\ncase 0xd4:\ncase 0xd7:\ncase 0xda:\ncase 0xdb:\ncase 0xdc:\ncase 0xdf:\ncase 0xe2:\ncase 0xe3:\ncase 0xe7:\ncase 0xeb:\ncase 0xef:\ncase 0xf2:\ncase 0xf3:\ncase 0xf4:\ncase 0xf7:\ncase 0xfa:\ncase 0xfb:\ncase 0xfc:\ncase 0xff:\nop->size = 1;\nop->type = R_ANAL_OP_TYPE_ILL;\nbreak;\ncase 0x00:\nop->cycles = 7;\nop->type = R_ANAL_OP_TYPE_SWI;\nop->size = 1;\nr_strbuf_set (&op->esil, \",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=\");\nbreak;\ncase 0x78:\ncase 0x58:\ncase 0x38:\ncase 0x18:\ncase 0xf8:\ncase 0xd8:\ncase 0xb8:\nop->cycles = 2;\nop->type = R_ANAL_OP_TYPE_NOP;\n_6502_anal_esil_flags (op, data[0]);\nbreak;\ncase 0x24:\ncase 0x2c:\nop->type = R_ANAL_OP_TYPE_MOV;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\nr_strbuf_setf (&op->esil, \"a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,=\",addrbuf, addrbuf, addrbuf);\nbreak;\ncase 0x69:\ncase 0x65:\ncase 0x75:\ncase 0x6d:\ncase 0x7d:\ncase 0x79:\ncase 0x61:\ncase 0x71:\nop->type = R_ANAL_OP_TYPE_ADD;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x69)\nr_strbuf_setf (&op->esil, \"%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=\");\nbreak;\ncase 0xe9:\ncase 0xe5:\ncase 0xf5:\ncase 0xed:\ncase 0xfd:\ncase 0xf9:\ncase 0xe1:\ncase 0xf1:\nop->type = R_ANAL_OP_TYPE_SUB;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0xe9)\nr_strbuf_setf (&op->esil, \"C,!,%s,+,a,-=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"C,!,%s,[1],+,a,-=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=,C,!=\");\nbreak;\ncase 0x09:\ncase 0x05:\ncase 0x15:\ncase 0x0d:\ncase 0x1d:\ncase 0x19:\ncase 0x01:\ncase 0x11:\nop->type = R_ANAL_OP_TYPE_OR;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x09)\nr_strbuf_setf (&op->esil, \"%s,a,|=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,|=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x29:\ncase 0x25:\ncase 0x35:\ncase 0x2d:\ncase 0x3d:\ncase 0x39:\ncase 0x21:\ncase 0x31:\nop->type = R_ANAL_OP_TYPE_AND;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x29)\nr_strbuf_setf (&op->esil, \"%s,a,&=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,&=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x49:\ncase 0x45:\ncase 0x55:\ncase 0x4d:\ncase 0x5d:\ncase 0x59:\ncase 0x41:\ncase 0x51:\nop->type = R_ANAL_OP_TYPE_XOR;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x49)\nr_strbuf_setf (&op->esil, \"%s,a,^=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,^=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x0a:\ncase 0x06:\ncase 0x16:\ncase 0x0e:\ncase 0x1e:\nop->type = R_ANAL_OP_TYPE_SHL;\nif (data[0] == 0x0a) {\nr_strbuf_set (&op->esil, \"1,a,<<=,$c7,C,=,a,a,=\");\n} else  {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"1,%s,[1],<<,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x4a:\ncase 0x46:\ncase 0x56:\ncase 0x4e:\ncase 0x5e:\nop->type = R_ANAL_OP_TYPE_SHR;\nif (data[0] == 0x4a) {\nr_strbuf_set (&op->esil, \"1,a,&,C,=,1,a,>>=\");\n} else {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x2a:\ncase 0x26:\ncase 0x36:\ncase 0x2e:\ncase 0x3e:\nop->type = R_ANAL_OP_TYPE_ROL;\nif (data[0] == 0x2a) {\nr_strbuf_set (&op->esil, \"1,a,<<,C,|,a,=,$c7,C,=,a,a,=\");\n} else {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"1,%s,[1],<<,C,|,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x6a:\ncase 0x66:\ncase 0x76:\ncase 0x6e:\ncase 0x7e:\nop->type = R_ANAL_OP_TYPE_ROR;\nif (data[0] == 0x6a) {\nr_strbuf_set (&op->esil, \"C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=\");\n} else {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xe6:\ncase 0xf6:\ncase 0xee:\ncase 0xfe:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"%s,++=[1]\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xc6:\ncase 0xd6:\ncase 0xce:\ncase 0xde:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"%s,--=[1]\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xe8:\ncase 0xc8:\nop->cycles = 2;\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_inc_reg (op, data[0], \"+\");\nbreak;\ncase 0xca:\ncase 0x88:\nop->cycles = 2;\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_inc_reg (op, data[0], \"-\");\nbreak;\ncase 0xc9:\ncase 0xc5:\ncase 0xd5:\ncase 0xcd:\ncase 0xdd:\ncase 0xd9:\ncase 0xc1:\ncase 0xd1:\nop->type = R_ANAL_OP_TYPE_CMP;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0xc9)\nr_strbuf_setf (&op->esil, \"%s,a,==\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,==\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",C,!,C,=\");\nbreak;\ncase 0xe0:\ncase 0xe4:\ncase 0xec:\nop->type = R_ANAL_OP_TYPE_CMP;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\nif (data[0] == 0xe0)\nr_strbuf_setf (&op->esil, \"%s,x,==\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],x,==\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",C,!,C,=\");\nbreak;\ncase 0xc0:\ncase 0xc4:\ncase 0xcc:\nop->type = R_ANAL_OP_TYPE_CMP;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\nif (data[0] == 0xc0)\nr_strbuf_setf (&op->esil, \"%s,y,==\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],y,==\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",C,!,C,=\");\nbreak;\ncase 0x10:\ncase 0x30:\ncase 0x50:\ncase 0x70:\ncase 0x90:\ncase 0xb0:\ncase 0xd0:\ncase 0xf0:\nop->cycles = 2;\nop->failcycles = 3;\nop->type = R_ANAL_OP_TYPE_CJMP;\nif (data[1] <= 127)\nop->jump = addr + data[1] + op->size;\nelse\top->jump = addr - (256 - data[1]) + op->size;\nop->fail = addr + op->size;\n_6502_anal_esil_ccall (op, data[0]);\nbreak;\ncase 0x20:\nop->cycles = 6;\nop->type = R_ANAL_OP_TYPE_CALL;\nop->jump = data[1] | data[2] << 8;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = 2;\nr_strbuf_setf (&op->esil, \"1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-=\", op->jump);\nbreak;\ncase 0x4c:\nop->cycles = 3;\nop->type = R_ANAL_OP_TYPE_JMP;\nop->jump = data[1] | data[2] << 8;\nr_strbuf_setf (&op->esil, \"0x%04x,pc,=\", op->jump);\nbreak;\ncase 0x6c:\nop->cycles = 5;\nop->type = R_ANAL_OP_TYPE_UJMP;\nr_strbuf_setf (&op->esil, \"0x%04x,[2],pc,=\", data[1] | data[2] << 8);\nbreak;\ncase 0x60:\nop->eob = true;\nop->type = R_ANAL_OP_TYPE_RET;\nop->cycles = 6;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = -2;\nr_strbuf_set (&op->esil, \"0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=\");\nbreak;\ncase 0x40:\nop->eob = true;\nop->type = R_ANAL_OP_TYPE_RET;\nop->cycles = 6;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = -3;\nr_strbuf_set (&op->esil, \"0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=\");\nbreak;\ncase 0xea:\nop->type = R_ANAL_OP_TYPE_NOP;\nop->cycles = 2;\nbreak;\ncase 0xa9:\ncase 0xa5:\ncase 0xb5:\ncase 0xad:\ncase 0xbd:\ncase 0xb9:\ncase 0xa1:\ncase 0xb1:\nop->type = R_ANAL_OP_TYPE_LOAD;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0xa9)\nr_strbuf_setf (&op->esil, \"%s,a,=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xa2:\ncase 0xa6:\ncase 0xb6:\ncase 0xae:\ncase 0xbe:\nop->type = R_ANAL_OP_TYPE_LOAD;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\nif (data[0] == 0xa2)\nr_strbuf_setf (&op->esil, \"%s,x,=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],x,=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xa0:\ncase 0xa4:\ncase 0xb4:\ncase 0xac:\ncase 0xbc:\nop->type = R_ANAL_OP_TYPE_LOAD;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\nif (data[0] == 0xa0)\nr_strbuf_setf (&op->esil, \"%s,y,=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],y,=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x85:\ncase 0x95:\ncase 0x8d:\ncase 0x9d:\ncase 0x99:\ncase 0x81:\ncase 0x91:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nr_strbuf_setf (&op->esil, \"a,%s,=[1]\", addrbuf);\nbreak;\ncase 0x86:\ncase 0x96:\ncase 0x8e:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\nr_strbuf_setf (&op->esil, \"x,%s,=[1]\", addrbuf);\nbreak;\ncase 0x84:\ncase 0x94:\ncase 0x8c:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"y,%s,=[1]\", addrbuf);\nbreak;\ncase 0x08:\ncase 0x48:\nop->type = R_ANAL_OP_TYPE_PUSH;\nop->cycles = 3;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = 1;\n_6502_anal_esil_push (op, data[0]);\nbreak;\ncase 0x28:\ncase 0x68:\nop->type = R_ANAL_OP_TYPE_POP;\nop->cycles = 4;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = -1;\n_6502_anal_esil_pop (op, data[0]);\nbreak;\ncase 0xaa:\ncase 0x8a:\ncase 0xa8:\ncase 0x98:\nop->type = R_ANAL_OP_TYPE_MOV;\nop->cycles = 2;\n_6502_anal_esil_mov (op, data[0]);\nbreak;\ncase 0x9a:\nop->type = R_ANAL_OP_TYPE_MOV;\nop->cycles = 2;\nop->stackop = R_ANAL_STACK_SET;\n_6502_anal_esil_mov (op, data[0]);\nbreak;\ncase 0xba:\nop->type = R_ANAL_OP_TYPE_MOV;\nop->cycles = 2;\nop->stackop = R_ANAL_STACK_GET;\n_6502_anal_esil_mov (op, data[0]);\nbreak;\n}\nreturn op->size;\n}", "contrast": "static int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\nchar addrbuf[64];\nconst int buffsize = sizeof (addrbuf) - 1;\nmemset (op, '\\0', sizeof (RAnalOp));\nop->size = snes_op_get_size (1, 1, &snes_op[data[0]]);\nop->addr = addr;\nop->type = R_ANAL_OP_TYPE_UNK;\nop->id = data[0];\nr_strbuf_init (&op->esil);\nswitch (data[0]) {\ncase 0x02:\ncase 0x03:\ncase 0x04:\ncase 0x07:\ncase 0x0b:\ncase 0x0c:\ncase 0x0f:\ncase 0x12:\ncase 0x13:\ncase 0x14:\ncase 0x17:\ncase 0x1a:\ncase 0x1b:\ncase 0x1c:\ncase 0x1f:\ncase 0x22:\ncase 0x23:\ncase 0x27:\ncase 0x2b:\ncase 0x2f:\ncase 0x32:\ncase 0x33:\ncase 0x34:\ncase 0x37:\ncase 0x3a:\ncase 0x3b:\ncase 0x3c:\ncase 0x3f:\ncase 0x42:\ncase 0x43:\ncase 0x44:\ncase 0x47:\ncase 0x4b:\ncase 0x4f:\ncase 0x52:\ncase 0x53:\ncase 0x54:\ncase 0x57:\ncase 0x5a:\ncase 0x5b:\ncase 0x5c:\ncase 0x5f:\ncase 0x62:\ncase 0x63:\ncase 0x64:\ncase 0x67:\ncase 0x6b:\ncase 0x6f:\ncase 0x72:\ncase 0x73:\ncase 0x74:\ncase 0x77:\ncase 0x7a:\ncase 0x7b:\ncase 0x7c:\ncase 0x7f:\ncase 0x80:\ncase 0x82:\ncase 0x83:\ncase 0x87:\ncase 0x89:\ncase 0x8b:\ncase 0x8f:\ncase 0x92:\ncase 0x93:\ncase 0x97:\ncase 0x9b:\ncase 0x9c:\ncase 0x9e:\ncase 0x9f:\ncase 0xa3:\ncase 0xa7:\ncase 0xab:\ncase 0xaf:\ncase 0xb2:\ncase 0xb3:\ncase 0xb7:\ncase 0xbb:\ncase 0xbf:\ncase 0xc2:\ncase 0xc3:\ncase 0xc7:\ncase 0xcb:\ncase 0xcf:\ncase 0xd2:\ncase 0xd3:\ncase 0xd4:\ncase 0xd7:\ncase 0xda:\ncase 0xdb:\ncase 0xdc:\ncase 0xdf:\ncase 0xe2:\ncase 0xe3:\ncase 0xe7:\ncase 0xeb:\ncase 0xef:\ncase 0xf2:\ncase 0xf3:\ncase 0xf4:\ncase 0xf7:\ncase 0xfa:\ncase 0xfb:\ncase 0xfc:\ncase 0xff:\nop->size = 1;\nop->type = R_ANAL_OP_TYPE_ILL;\nbreak;\ncase 0x00:\nop->cycles = 7;\nop->type = R_ANAL_OP_TYPE_SWI;\nop->size = 1;\nr_strbuf_set (&op->esil, \",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=\");\nbreak;\ncase 0x78:\ncase 0x58:\ncase 0x38:\ncase 0x18:\ncase 0xf8:\ncase 0xd8:\ncase 0xb8:\nop->cycles = 2;\nop->type = R_ANAL_OP_TYPE_NOP;\n_6502_anal_esil_flags (op, data[0]);\nbreak;\ncase 0x24:\ncase 0x2c:\nop->type = R_ANAL_OP_TYPE_MOV;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\nr_strbuf_setf (&op->esil, \"a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,=\",addrbuf, addrbuf, addrbuf);\nbreak;\ncase 0x69:\ncase 0x65:\ncase 0x75:\ncase 0x6d:\ncase 0x7d:\ncase 0x79:\ncase 0x61:\ncase 0x71:\nop->type = R_ANAL_OP_TYPE_ADD;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x69)\nr_strbuf_setf (&op->esil, \"%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=\");\nbreak;\ncase 0xe9:\ncase 0xe5:\ncase 0xf5:\ncase 0xed:\ncase 0xfd:\ncase 0xf9:\ncase 0xe1:\ncase 0xf1:\nop->type = R_ANAL_OP_TYPE_SUB;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0xe9)\nr_strbuf_setf (&op->esil, \"C,!,%s,+,a,-=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"C,!,%s,[1],+,a,-=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=,C,!=\");\nbreak;\ncase 0x09:\ncase 0x05:\ncase 0x15:\ncase 0x0d:\ncase 0x1d:\ncase 0x19:\ncase 0x01:\ncase 0x11:\nop->type = R_ANAL_OP_TYPE_OR;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x09)\nr_strbuf_setf (&op->esil, \"%s,a,|=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,|=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x29:\ncase 0x25:\ncase 0x35:\ncase 0x2d:\ncase 0x3d:\ncase 0x39:\ncase 0x21:\ncase 0x31:\nop->type = R_ANAL_OP_TYPE_AND;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x29)\nr_strbuf_setf (&op->esil, \"%s,a,&=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,&=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x49:\ncase 0x45:\ncase 0x55:\ncase 0x4d:\ncase 0x5d:\ncase 0x59:\ncase 0x41:\ncase 0x51:\nop->type = R_ANAL_OP_TYPE_XOR;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0x49)\nr_strbuf_setf (&op->esil, \"%s,a,^=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,^=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x0a:\ncase 0x06:\ncase 0x16:\ncase 0x0e:\ncase 0x1e:\nop->type = R_ANAL_OP_TYPE_SHL;\nif (data[0] == 0x0a) {\nr_strbuf_set (&op->esil, \"1,a,<<=,$c7,C,=,a,a,=\");\n} else  {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"1,%s,[1],<<,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x4a:\ncase 0x46:\ncase 0x56:\ncase 0x4e:\ncase 0x5e:\nop->type = R_ANAL_OP_TYPE_SHR;\nif (data[0] == 0x4a) {\nr_strbuf_set (&op->esil, \"1,a,&,C,=,1,a,>>=\");\n} else {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x2a:\ncase 0x26:\ncase 0x36:\ncase 0x2e:\ncase 0x3e:\nop->type = R_ANAL_OP_TYPE_ROL;\nif (data[0] == 0x2a) {\nr_strbuf_set (&op->esil, \"1,a,<<,C,|,a,=,$c7,C,=,a,a,=\");\n} else {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"1,%s,[1],<<,C,|,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x6a:\ncase 0x66:\ncase 0x76:\ncase 0x6e:\ncase 0x7e:\nop->type = R_ANAL_OP_TYPE_ROR;\nif (data[0] == 0x6a) {\nr_strbuf_set (&op->esil, \"C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=\");\n} else {\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n}\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xe6:\ncase 0xf6:\ncase 0xee:\ncase 0xfe:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"%s,++=[1]\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xc6:\ncase 0xd6:\ncase 0xce:\ncase 0xde:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"%s,--=[1]\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xe8:\ncase 0xc8:\nop->cycles = 2;\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_inc_reg (op, data[0], \"+\");\nbreak;\ncase 0xca:\ncase 0x88:\nop->cycles = 2;\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_inc_reg (op, data[0], \"-\");\nbreak;\ncase 0xc9:\ncase 0xc5:\ncase 0xd5:\ncase 0xcd:\ncase 0xdd:\ncase 0xd9:\ncase 0xc1:\ncase 0xd1:\nop->type = R_ANAL_OP_TYPE_CMP;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0xc9)\nr_strbuf_setf (&op->esil, \"%s,a,==\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,==\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",C,!,C,=\");\nbreak;\ncase 0xe0:\ncase 0xe4:\ncase 0xec:\nop->type = R_ANAL_OP_TYPE_CMP;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\nif (data[0] == 0xe0)\nr_strbuf_setf (&op->esil, \"%s,x,==\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],x,==\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",C,!,C,=\");\nbreak;\ncase 0xc0:\ncase 0xc4:\ncase 0xcc:\nop->type = R_ANAL_OP_TYPE_CMP;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\nif (data[0] == 0xc0)\nr_strbuf_setf (&op->esil, \"%s,y,==\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],y,==\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\nr_strbuf_append (&op->esil, \",C,!,C,=\");\nbreak;\ncase 0x10:\ncase 0x30:\ncase 0x50:\ncase 0x70:\ncase 0x90:\ncase 0xb0:\ncase 0xd0:\ncase 0xf0:\nop->cycles = 2;\nop->failcycles = 3;\nop->type = R_ANAL_OP_TYPE_CJMP;\nif (len > 1) {\nif (data[1] <= 127) {\nop->jump = addr + data[1] + op->size;\n} else {\nop->jump = addr - (256 - data[1]) + op->size;\n}\n} else {\nop->jump = addr;\n}\nop->fail = addr + op->size;\n_6502_anal_esil_ccall (op, data[0]);\nbreak;\ncase 0x20:\nop->cycles = 6;\nop->type = R_ANAL_OP_TYPE_CALL;\nop->jump = data[1] | data[2] << 8;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = 2;\nr_strbuf_setf (&op->esil, \"1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-=\", op->jump);\nbreak;\ncase 0x4c:\nop->cycles = 3;\nop->type = R_ANAL_OP_TYPE_JMP;\nop->jump = data[1] | data[2] << 8;\nr_strbuf_setf (&op->esil, \"0x%04x,pc,=\", op->jump);\nbreak;\ncase 0x6c:\nop->cycles = 5;\nop->type = R_ANAL_OP_TYPE_UJMP;\nr_strbuf_setf (&op->esil, \"0x%04x,[2],pc,=\", data[1] | data[2] << 8);\nbreak;\ncase 0x60:\nop->eob = true;\nop->type = R_ANAL_OP_TYPE_RET;\nop->cycles = 6;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = -2;\nr_strbuf_set (&op->esil, \"0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=\");\nbreak;\ncase 0x40:\nop->eob = true;\nop->type = R_ANAL_OP_TYPE_RET;\nop->cycles = 6;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = -3;\nr_strbuf_set (&op->esil, \"0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=\");\nbreak;\ncase 0xea:\nop->type = R_ANAL_OP_TYPE_NOP;\nop->cycles = 2;\nbreak;\ncase 0xa9:\ncase 0xa5:\ncase 0xb5:\ncase 0xad:\ncase 0xbd:\ncase 0xb9:\ncase 0xa1:\ncase 0xb1:\nop->type = R_ANAL_OP_TYPE_LOAD;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nif (data[0] == 0xa9)\nr_strbuf_setf (&op->esil, \"%s,a,=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],a,=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xa2:\ncase 0xa6:\ncase 0xb6:\ncase 0xae:\ncase 0xbe:\nop->type = R_ANAL_OP_TYPE_LOAD;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\nif (data[0] == 0xa2)\nr_strbuf_setf (&op->esil, \"%s,x,=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],x,=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0xa0:\ncase 0xa4:\ncase 0xb4:\ncase 0xac:\ncase 0xbc:\nop->type = R_ANAL_OP_TYPE_LOAD;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\nif (data[0] == 0xa0)\nr_strbuf_setf (&op->esil, \"%s,y,=\", addrbuf);\nelse\tr_strbuf_setf (&op->esil, \"%s,[1],y,=\", addrbuf);\n_6502_anal_update_flags (op, _6502_FLAGS_NZ);\nbreak;\ncase 0x85:\ncase 0x95:\ncase 0x8d:\ncase 0x9d:\ncase 0x99:\ncase 0x81:\ncase 0x91:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\nr_strbuf_setf (&op->esil, \"a,%s,=[1]\", addrbuf);\nbreak;\ncase 0x86:\ncase 0x96:\ncase 0x8e:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\nr_strbuf_setf (&op->esil, \"x,%s,=[1]\", addrbuf);\nbreak;\ncase 0x84:\ncase 0x94:\ncase 0x8c:\nop->type = R_ANAL_OP_TYPE_STORE;\n_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\nr_strbuf_setf (&op->esil, \"y,%s,=[1]\", addrbuf);\nbreak;\ncase 0x08:\ncase 0x48:\nop->type = R_ANAL_OP_TYPE_PUSH;\nop->cycles = 3;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = 1;\n_6502_anal_esil_push (op, data[0]);\nbreak;\ncase 0x28:\ncase 0x68:\nop->type = R_ANAL_OP_TYPE_POP;\nop->cycles = 4;\nop->stackop = R_ANAL_STACK_INC;\nop->stackptr = -1;\n_6502_anal_esil_pop (op, data[0]);\nbreak;\ncase 0xaa:\ncase 0x8a:\ncase 0xa8:\ncase 0x98:\nop->type = R_ANAL_OP_TYPE_MOV;\nop->cycles = 2;\n_6502_anal_esil_mov (op, data[0]);\nbreak;\ncase 0x9a:\nop->type = R_ANAL_OP_TYPE_MOV;\nop->cycles = 2;\nop->stackop = R_ANAL_STACK_SET;\n_6502_anal_esil_mov (op, data[0]);\nbreak;\ncase 0xba:\nop->type = R_ANAL_OP_TYPE_MOV;\nop->cycles = 2;\nop->stackop = R_ANAL_STACK_GET;\n_6502_anal_esil_mov (op, data[0]);\nbreak;\n}\nreturn op->size;\n}", "label": 0}
{"index": 178145, "code": "init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\nswitch (mrb_type(obj)) {\ncase MRB_TT_CLASS:\ncase MRB_TT_MODULE:\ncopy_class(mrb, dest, obj);\nmrb_iv_copy(mrb, dest, obj);\nmrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\nbreak;\ncase MRB_TT_OBJECT:\ncase MRB_TT_SCLASS:\ncase MRB_TT_HASH:\ncase MRB_TT_DATA:\ncase MRB_TT_EXCEPTION:\nmrb_iv_copy(mrb, dest, obj);\nbreak;\ncase MRB_TT_ISTRUCT:\nmrb_istruct_copy(dest, obj);\nbreak;\ndefault:\nbreak;\n}\nmrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "contrast": "init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\nswitch (mrb_type(obj)) {\ncase MRB_TT_ICLASS:\ncopy_class(mrb, dest, obj);\nreturn;\ncase MRB_TT_CLASS:\ncase MRB_TT_MODULE:\ncopy_class(mrb, dest, obj);\nmrb_iv_copy(mrb, dest, obj);\nmrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\nbreak;\ncase MRB_TT_OBJECT:\ncase MRB_TT_SCLASS:\ncase MRB_TT_HASH:\ncase MRB_TT_DATA:\ncase MRB_TT_EXCEPTION:\nmrb_iv_copy(mrb, dest, obj);\nbreak;\ncase MRB_TT_ISTRUCT:\nmrb_istruct_copy(dest, obj);\nbreak;\ndefault:\nbreak;\n}\nmrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "label": 0}
{"index": 178159, "code": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\nut8 op_MSB,op_LSB;\nint ret;\nif (!data)\nreturn 0;\nmemset (op, '\\0', sizeof (RAnalOp));\nop->addr = addr;\nop->type = R_ANAL_OP_TYPE_UNK;\nop->jump = op->fail = -1;\nop->ptr = op->val = -1;\nop->size = 2;\nop_MSB = anal->big_endian? data[0]: data[1];\nop_LSB = anal->big_endian? data[1]: data[0];\nret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\nreturn ret;\n}", "contrast": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\nut8 op_MSB,op_LSB;\nint ret;\nif (!data || len < 2) {\nreturn 0;\n}\nmemset (op, '\\0', sizeof (RAnalOp));\nop->addr = addr;\nop->type = R_ANAL_OP_TYPE_UNK;\nop->jump = op->fail = -1;\nop->ptr = op->val = -1;\nop->size = 2;\nop_MSB = anal->big_endian? data[0]: data[1];\nop_LSB = anal->big_endian? data[1]: data[0];\nret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\nreturn ret;\n}", "label": 0}
{"index": 178169, "code": "static void *etm_setup_aux(int event_cpu, void **pages,\nint nr_pages, bool overwrite)\n{\nint cpu;\ncpumask_t *mask;\nstruct coresight_device *sink;\nstruct etm_event_data *event_data = NULL;\nevent_data = alloc_event_data(event_cpu);\nif (!event_data)\nreturn NULL;\nsink = coresight_get_enabled_sink(true);\nif (!sink)\ngoto err;\nINIT_WORK(&event_data->work, free_event_data);\nmask = &event_data->mask;\nfor_each_cpu(cpu, mask) {\nstruct coresight_device *csdev;\ncsdev = per_cpu(csdev_src, cpu);\nif (!csdev)\ngoto err;\nevent_data->path[cpu] = coresight_build_path(csdev, sink);\nif (IS_ERR(event_data->path[cpu]))\ngoto err;\n}\nif (!sink_ops(sink)->alloc_buffer)\ngoto err;\nevent_data->snk_config =\nsink_ops(sink)->alloc_buffer(sink, cpu, pages,\nnr_pages, overwrite);\nif (!event_data->snk_config)\ngoto err;\nout:\nreturn event_data;\nerr:\netm_free_aux(event_data);\nevent_data = NULL;\ngoto out;\n}", "contrast": "static void *etm_setup_aux(int event_cpu, void **pages,\nint nr_pages, bool overwrite)\n{\nint cpu;\ncpumask_t *mask;\nstruct coresight_device *sink;\nstruct etm_event_data *event_data = NULL;\nevent_data = alloc_event_data(event_cpu);\nif (!event_data)\nreturn NULL;\nsink = coresight_get_enabled_sink(true);\nif (!sink)\ngoto err;\nINIT_WORK(&event_data->work, free_event_data);\nmask = &event_data->mask;\nfor_each_cpu(cpu, mask) {\nstruct coresight_device *csdev;\ncsdev = per_cpu(csdev_src, cpu);\nif (!csdev)\ngoto err;\nevent_data->path[cpu] = coresight_build_path(csdev, sink);\nif (IS_ERR(event_data->path[cpu]))\ngoto err;\n}\nif (!sink_ops(sink)->alloc_buffer)\ngoto err;\ncpu = cpumask_first(mask);\nevent_data->snk_config =\nsink_ops(sink)->alloc_buffer(sink, cpu, pages,\nnr_pages, overwrite);\nif (!event_data->snk_config)\ngoto err;\nout:\nreturn event_data;\nerr:\netm_free_aux(event_data);\nevent_data = NULL;\ngoto out;\n}", "label": 0}
{"index": 178175, "code": "static int DecodeGifImg(struct ngiflib_img * i) {\nstruct ngiflib_decode_context context;\nlong npix;\nu8 * stackp;\nu8 * stack_top;\nu16 clr;\nu16 eof;\nu16 free;\nu16 act_code = 0;\nu16 old_code = 0;\nu16 read_byt;\nu16 ab_prfx[4096];\nu8 ab_suffx[4096];\nu8 ab_stack[4096];\nu8 flags;\nu8 casspecial = 0;\nif(!i) return -1;\ni->posX = GetWord(i->parent);\ni->posY = GetWord(i->parent);\ni->width = GetWord(i->parent);\ni->height = GetWord(i->parent);\nif((i->width > i->parent->width) || (i->height > i->parent->height)) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");\n#endif\nreturn -1;\n}\nif((i->posX + i->width) > i->parent->width) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");\n#endif\ni->posX = i->parent->width - i->width;\n}\nif((i->posY + i->height) > i->parent->height) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");\n#endif\ni->posY = i->parent->height - i->height;\n}\ncontext.Xtogo = i->width;\ncontext.curY = i->posY;\n#ifdef NGIFLIB_INDEXED_ONLY\n#ifdef NGIFLIB_ENABLE_CALLBACKS\ncontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\ncontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n#else\ncontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n#endif\n#else\nif(i->parent->mode & NGIFLIB_MODE_INDEXED) {\n#ifdef NGIFLIB_ENABLE_CALLBACKS\ncontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\ncontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n#else\ncontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n#endif\n} else {\n#ifdef NGIFLIB_ENABLE_CALLBACKS\ncontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;\ncontext.frbuff_p.p32 = context.line_p.p32 + i->posX;\n#else\ncontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;\n#endif\n}\n#endif\nnpix = (long)i->width * i->height;\nflags = GetByte(i->parent);\ni->interlaced = (flags & 64) >> 6;\ncontext.pass = i->interlaced ? 1 : 0;\ni->sort_flag = (flags & 32) >> 5;\ni->localpalbits = (flags & 7) + 1;\nif(flags&128) {\nint k;\nint localpalsize = 1 << i->localpalbits;\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");\n#endif\ni->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);\nfor(k=0; k<localpalsize; k++) {\ni->palette[k].r = GetByte(i->parent);\ni->palette[k].g = GetByte(i->parent);\ni->palette[k].b = GetByte(i->parent);\n}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\nif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);\n#endif\n} else {\ni->palette = i->parent->palette;\ni->localpalbits = i->parent->imgbits;\n}\ni->ncolors = 1 << i->localpalbits;\ni->imgbits = GetByte(i->parent);\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) {\nif(i->interlaced) fprintf(i->parent->log, \"interlaced \");\nfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",\ni->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);\n}\n#endif\nif(i->imgbits==1) {\ni->imgbits = 2;\n}\nclr = 1 << i->imgbits;\neof = clr + 1;\nfree = clr + 2;\ncontext.nbbit = i->imgbits + 1;\ncontext.max = clr + clr - 1;\nstackp = stack_top = ab_stack + 4096;\ncontext.restbits = 0;\ncontext.restbyte = 0;\ncontext.lbyte = 0;\nfor(;;) {\nact_code = GetGifWord(i, &context);\nif(act_code==eof) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code\\n\");\n#endif\nreturn 0;\n}\nif(npix==0) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");\n#endif\nreturn 1;\n}\nif(act_code==clr) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif\nfree = clr + 2;\ncontext.nbbit = i->imgbits + 1;\ncontext.max = clr + clr - 1;\nact_code = GetGifWord(i, &context);\ncasspecial = (u8)act_code;\nold_code = act_code;\nWritePixel(i, &context, casspecial); npix--;\n} else {\nread_byt = act_code;\nif(act_code >= free) {\n*(--stackp) = casspecial;\nact_code = old_code;\n}\nwhile(act_code > clr) {\n*(--stackp) = ab_suffx[act_code];\nact_code = ab_prfx[act_code];\n}\ncasspecial = (u8)act_code;\n*(--stackp) = casspecial;\nWritePixels(i, &context, stackp, stack_top - stackp);\nnpix -= (stack_top - stackp);\nstackp = stack_top;\nif(free < 4096) {\nab_prfx[free] = old_code;\nab_suffx[free] = (u8)act_code;\nfree++;\nif((free > context.max) && (context.nbbit < 12)) {\ncontext.nbbit++;\ncontext.max += context.max + 1;\n}\n}\nold_code = read_byt;\n}\n}\nreturn 0;\n}", "contrast": "static int DecodeGifImg(struct ngiflib_img * i) {\nstruct ngiflib_decode_context context;\nlong npix;\nu8 * stackp;\nu8 * stack_top;\nu16 clr;\nu16 eof;\nu16 free;\nu16 act_code = 0;\nu16 old_code = 0;\nu16 read_byt;\nu16 ab_prfx[4096];\nu8 ab_suffx[4096];\nu8 ab_stack[4096];\nu8 flags;\nu8 casspecial = 0;\nif(!i) return -1;\ni->posX = GetWord(i->parent);\ni->posY = GetWord(i->parent);\ni->width = GetWord(i->parent);\ni->height = GetWord(i->parent);\nif((i->width > i->parent->width) || (i->height > i->parent->height)) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");\n#endif\nreturn -1;\n}\nif((i->posX + i->width) > i->parent->width) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");\n#endif\ni->posX = i->parent->width - i->width;\n}\nif((i->posY + i->height) > i->parent->height) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");\n#endif\ni->posY = i->parent->height - i->height;\n}\ncontext.Xtogo = i->width;\ncontext.curY = i->posY;\n#ifdef NGIFLIB_INDEXED_ONLY\n#ifdef NGIFLIB_ENABLE_CALLBACKS\ncontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\ncontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n#else\ncontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n#endif\n#else\nif(i->parent->mode & NGIFLIB_MODE_INDEXED) {\n#ifdef NGIFLIB_ENABLE_CALLBACKS\ncontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\ncontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n#else\ncontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n#endif\n} else {\n#ifdef NGIFLIB_ENABLE_CALLBACKS\ncontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;\ncontext.frbuff_p.p32 = context.line_p.p32 + i->posX;\n#else\ncontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;\n#endif\n}\n#endif\nnpix = (long)i->width * i->height;\nflags = GetByte(i->parent);\ni->interlaced = (flags & 64) >> 6;\ncontext.pass = i->interlaced ? 1 : 0;\ni->sort_flag = (flags & 32) >> 5;\ni->localpalbits = (flags & 7) + 1;\nif(flags&128) {\nint k;\nint localpalsize = 1 << i->localpalbits;\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");\n#endif\ni->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);\nfor(k=0; k<localpalsize; k++) {\ni->palette[k].r = GetByte(i->parent);\ni->palette[k].g = GetByte(i->parent);\ni->palette[k].b = GetByte(i->parent);\n}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\nif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);\n#endif\n} else {\ni->palette = i->parent->palette;\ni->localpalbits = i->parent->imgbits;\n}\ni->ncolors = 1 << i->localpalbits;\ni->imgbits = GetByte(i->parent);\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) {\nif(i->interlaced) fprintf(i->parent->log, \"interlaced \");\nfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",\ni->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);\n}\n#endif\nif(i->imgbits==1) {\ni->imgbits = 2;\n}\nclr = 1 << i->imgbits;\neof = clr + 1;\nfree = clr + 2;\ncontext.nbbit = i->imgbits + 1;\ncontext.max = clr + clr - 1;\nstackp = stack_top = ab_stack + 4096;\ncontext.restbits = 0;\ncontext.restbyte = 0;\ncontext.lbyte = 0;\nfor(;;) {\nact_code = GetGifWord(i, &context);\nif(act_code==eof) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code\\n\");\n#endif\nreturn 0;\n}\nif(npix==0) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");\n#endif\nreturn 1;\n}\nif(act_code==clr) {\n#if !defined(NGIFLIB_NO_FILE)\nif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif\nfree = clr + 2;\ncontext.nbbit = i->imgbits + 1;\ncontext.max = clr + clr - 1;\nact_code = GetGifWord(i, &context);\ncasspecial = (u8)act_code;\nold_code = act_code;\nif(npix > 0) WritePixel(i, &context, casspecial);\nnpix--;\n} else {\nread_byt = act_code;\nif(act_code >= free) {\n*(--stackp) = casspecial;\nact_code = old_code;\n}\nwhile(act_code > clr) {\n*(--stackp) = ab_suffx[act_code];\nact_code = ab_prfx[act_code];\n}\ncasspecial = (u8)act_code;\n*(--stackp) = casspecial;\nif(npix >= (stack_top - stackp)) {\nWritePixels(i, &context, stackp, stack_top - stackp);\n} else if(npix > 0) {\nWritePixels(i, &context, stackp, npix);\n}\nnpix -= (stack_top - stackp);\nstackp = stack_top;\nif(free < 4096) {\nab_prfx[free] = old_code;\nab_suffx[free] = (u8)act_code;\nfree++;\nif((free > context.max) && (context.nbbit < 12)) {\ncontext.nbbit++;\ncontext.max += context.max + 1;\n}\n}\nold_code = read_byt;\n}\n}\nreturn 0;\n}", "label": 0}
{"index": 178179, "code": "int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\nint is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0;\nint64_t total_samples = 0, infilesize;\nRiffChunkHeader riff_chunk_header;\nChunkHeader chunk_header;\nWaveHeader WaveHeader;\nDS64Chunk ds64_chunk;\nuint32_t bcount;\nCLEAR (WaveHeader);\nCLEAR (ds64_chunk);\ninfilesize = DoGetFileSize (infile);\nif (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\nerror_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nmemcpy (&riff_chunk_header, fourcc, 4);\nif ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\nbcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nwhile (1) {\nif (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\nbcount != sizeof (ChunkHeader)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\nif (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\nif (chunk_header.ckSize < sizeof (DS64Chunk) ||\n!DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\nbcount != sizeof (DS64Chunk)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\ngot_ds64 = 1;\nWavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\nif (debug_logging_mode)\nerror_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n(long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n(long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\nif (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nwhile (ds64_chunk.tableLength--) {\nCS64Chunk cs64_chunk;\nif (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\nbcount != sizeof (CS64Chunk) ||\n(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\n}\n}\nelse if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {\nint supported = TRUE, format;\nif (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n!DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\nbcount != chunk_header.ckSize) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\nif (debug_logging_mode) {\nerror_line (\"format tag size = %d\", chunk_header.ckSize);\nerror_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\nWaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\nerror_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\nWaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\nif (chunk_header.ckSize > 16)\nerror_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\nWaveHeader.ValidBitsPerSample);\nif (chunk_header.ckSize > 20)\nerror_line (\"ChannelMask = %x, SubFormat = %d\",\nWaveHeader.ChannelMask, WaveHeader.SubFormat);\n}\nif (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\nconfig->qmode |= QMODE_ADOBE_MODE;\nformat = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\nWaveHeader.SubFormat : WaveHeader.FormatTag;\nconfig->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\nWaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\nif (format != 1 && format != 3)\nsupported = FALSE;\nif (format == 3 && config->bits_per_sample != 32)\nsupported = FALSE;\nif (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\nWaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\nWaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\nWaveHeader.BlockAlign % WaveHeader.NumChannels)\nsupported = FALSE;\nif (config->bits_per_sample < 1 || config->bits_per_sample > 32)\nsupported = FALSE;\nif (!supported) {\nerror_line (\"%s is an unsupported .WAV format!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (chunk_header.ckSize < 40) {\nif (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\nif (WaveHeader.NumChannels <= 2)\nconfig->channel_mask = 0x5 - WaveHeader.NumChannels;\nelse if (WaveHeader.NumChannels <= 18)\nconfig->channel_mask = (1 << WaveHeader.NumChannels) - 1;\nelse\nconfig->channel_mask = 0x3ffff;\n}\n}\nelse if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\nerror_line (\"this WAV file already has channel order information!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (WaveHeader.ChannelMask)\nconfig->channel_mask = WaveHeader.ChannelMask;\nif (format == 3)\nconfig->float_norm_exp = 127;\nelse if ((config->qmode & QMODE_ADOBE_MODE) &&\nWaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\nif (WaveHeader.BitsPerSample == 24)\nconfig->float_norm_exp = 127 + 23;\nelse if (WaveHeader.BitsPerSample == 32)\nconfig->float_norm_exp = 127 + 15;\n}\nif (debug_logging_mode) {\nif (config->float_norm_exp == 127)\nerror_line (\"data format: normalized 32-bit floating point\");\nelse if (config->float_norm_exp)\nerror_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\nconfig->float_norm_exp - 126, 150 - config->float_norm_exp);\nelse\nerror_line (\"data format: %d-bit integers stored in %d byte(s)\",\nconfig->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n}\n}\nelse if (!strncmp (chunk_header.ckID, \"data\", 4)) {\nint64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\nds64_chunk.dataSize64 : chunk_header.ckSize;\nif (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\nerror_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nif (config->qmode & QMODE_IGNORE_LENGTH) {\nif (infilesize && DoGetFilePosition (infile) != -1)\ntotal_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\nelse\ntotal_samples = -1;\n}\nelse {\ntotal_samples = data_chunk_size / WaveHeader.BlockAlign;\nif (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (!total_samples) {\nerror_line (\"this .WAV file has no audio samples, probably is corrupt!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nif (total_samples > MAX_WAVPACK_SAMPLES) {\nerror_line (\"%s has too many samples for WavPack!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\n}\nconfig->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\nconfig->num_channels = WaveHeader.NumChannels;\nconfig->sample_rate = WaveHeader.SampleRate;\nbreak;\n}\nelse {\nint bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\nchar *buff = malloc (bytes_to_copy);\nif (debug_logging_mode)\nerror_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\nchunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\nchunk_header.ckID [3], chunk_header.ckSize);\nif (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\nbcount != bytes_to_copy ||\n(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nfree (buff);\nreturn WAVPACK_SOFT_ERROR;\n}\nfree (buff);\n}\n}\nif (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\nerror_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nreturn WAVPACK_NO_ERROR;\n}", "contrast": "int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\nint is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0;\nint64_t total_samples = 0, infilesize;\nRiffChunkHeader riff_chunk_header;\nChunkHeader chunk_header;\nWaveHeader WaveHeader;\nDS64Chunk ds64_chunk;\nuint32_t bcount;\nCLEAR (WaveHeader);\nCLEAR (ds64_chunk);\ninfilesize = DoGetFileSize (infile);\nif (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\nerror_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nmemcpy (&riff_chunk_header, fourcc, 4);\nif ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\nbcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nwhile (1) {\nif (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\nbcount != sizeof (ChunkHeader)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\nif (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\nif (chunk_header.ckSize < sizeof (DS64Chunk) ||\n!DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\nbcount != sizeof (DS64Chunk)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\ngot_ds64 = 1;\nWavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\nif (debug_logging_mode)\nerror_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n(long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n(long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\nif (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nwhile (ds64_chunk.tableLength--) {\nCS64Chunk cs64_chunk;\nif (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\nbcount != sizeof (CS64Chunk) ||\n(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\n}\n}\nelse if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {\nint supported = TRUE, format;\nif (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n!DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\nbcount != chunk_header.ckSize) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\nif (debug_logging_mode) {\nerror_line (\"format tag size = %d\", chunk_header.ckSize);\nerror_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\nWaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\nerror_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\nWaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\nif (chunk_header.ckSize > 16)\nerror_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\nWaveHeader.ValidBitsPerSample);\nif (chunk_header.ckSize > 20)\nerror_line (\"ChannelMask = %x, SubFormat = %d\",\nWaveHeader.ChannelMask, WaveHeader.SubFormat);\n}\nif (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\nconfig->qmode |= QMODE_ADOBE_MODE;\nformat = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\nWaveHeader.SubFormat : WaveHeader.FormatTag;\nconfig->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\nWaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\nif (format != 1 && format != 3)\nsupported = FALSE;\nif (format == 3 && config->bits_per_sample != 32)\nsupported = FALSE;\nif (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\nWaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\nWaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\nWaveHeader.BlockAlign % WaveHeader.NumChannels)\nsupported = FALSE;\nif (config->bits_per_sample < 1 || config->bits_per_sample > 32)\nsupported = FALSE;\nif (!supported) {\nerror_line (\"%s is an unsupported .WAV format!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (chunk_header.ckSize < 40) {\nif (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\nif (WaveHeader.NumChannels <= 2)\nconfig->channel_mask = 0x5 - WaveHeader.NumChannels;\nelse if (WaveHeader.NumChannels <= 18)\nconfig->channel_mask = (1 << WaveHeader.NumChannels) - 1;\nelse\nconfig->channel_mask = 0x3ffff;\n}\n}\nelse if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\nerror_line (\"this WAV file already has channel order information!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (WaveHeader.ChannelMask)\nconfig->channel_mask = WaveHeader.ChannelMask;\nif (format == 3)\nconfig->float_norm_exp = 127;\nelse if ((config->qmode & QMODE_ADOBE_MODE) &&\nWaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\nif (WaveHeader.BitsPerSample == 24)\nconfig->float_norm_exp = 127 + 23;\nelse if (WaveHeader.BitsPerSample == 32)\nconfig->float_norm_exp = 127 + 15;\n}\nif (debug_logging_mode) {\nif (config->float_norm_exp == 127)\nerror_line (\"data format: normalized 32-bit floating point\");\nelse if (config->float_norm_exp)\nerror_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\nconfig->float_norm_exp - 126, 150 - config->float_norm_exp);\nelse\nerror_line (\"data format: %d-bit integers stored in %d byte(s)\",\nconfig->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n}\n}\nelse if (!strncmp (chunk_header.ckID, \"data\", 4)) {\nint64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\nds64_chunk.dataSize64 : chunk_header.ckSize;\nif (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\nerror_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nif (config->qmode & QMODE_IGNORE_LENGTH) {\nif (infilesize && DoGetFilePosition (infile) != -1)\ntotal_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\nelse\ntotal_samples = -1;\n}\nelse {\ntotal_samples = data_chunk_size / WaveHeader.BlockAlign;\nif (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (!total_samples) {\nerror_line (\"this .WAV file has no audio samples, probably is corrupt!\");\nreturn WAVPACK_SOFT_ERROR;\n}\nif (total_samples > MAX_WAVPACK_SAMPLES) {\nerror_line (\"%s has too many samples for WavPack!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\n}\nconfig->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\nconfig->num_channels = WaveHeader.NumChannels;\nconfig->sample_rate = WaveHeader.SampleRate;\nbreak;\n}\nelse {\nint bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\nchar *buff;\nif (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\nerror_line (\"%s is not a valid .WAV file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nbuff = malloc (bytes_to_copy);\nif (debug_logging_mode)\nerror_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\nchunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\nchunk_header.ckID [3], chunk_header.ckSize);\nif (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\nbcount != bytes_to_copy ||\n(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nfree (buff);\nreturn WAVPACK_SOFT_ERROR;\n}\nfree (buff);\n}\n}\nif (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\nerror_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nreturn WAVPACK_NO_ERROR;\n}", "label": 0}
{"index": 178189, "code": "static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\nstruct sas_task *task = TO_SAS_TASK(cmd);\nsas_end_task(cmd, task);\nscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}", "contrast": "static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\nstruct domain_device *dev = cmd_to_domain_dev(cmd);\nstruct sas_task *task = TO_SAS_TASK(cmd);\nsas_end_task(cmd, task);\nif (dev_is_sata(dev)) {\nlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\nreturn;\n}\nscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}", "label": 0}
{"index": 178195, "code": "int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\nconst char *name, size_t namelen)\n{\nchar *copy;\nif (name && memchr(name, '\\0', namelen))\nreturn 0;\nif (mode == SET_HOST && id->hosts) {\nstring_stack_free(id->hosts);\nid->hosts = NULL;\n}\nif (name == NULL || namelen == 0)\nreturn 1;\ncopy = strndup(name, namelen);\nif (copy == NULL)\nreturn 0;\nif (id->hosts == NULL &&\n(id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\nfree(copy);\nreturn 0;\n}\nif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\nfree(copy);\nif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\nsk_OPENSSL_STRING_free(id->hosts);\nid->hosts = NULL;\n}\nreturn 0;\n}\nreturn 1;\n}", "contrast": "int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\nconst char *name, size_t namelen)\n{\nchar *copy;\nif (name != NULL && namelen == 0)\nnamelen = strlen(name);\nif (name && memchr(name, '\\0', namelen))\nreturn 0;\nif (mode == SET_HOST && id->hosts) {\nstring_stack_free(id->hosts);\nid->hosts = NULL;\n}\nif (name == NULL || namelen == 0)\nreturn 1;\ncopy = strndup(name, namelen);\nif (copy == NULL)\nreturn 0;\nif (id->hosts == NULL &&\n(id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\nfree(copy);\nreturn 0;\n}\nif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\nfree(copy);\nif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\nsk_OPENSSL_STRING_free(id->hosts);\nid->hosts = NULL;\n}\nreturn 0;\n}\nreturn 1;\n}", "label": 0}
{"index": 178240, "code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\nchar *chr;\nint len = 0;\nif ( !in )\n{\nreturn in;\n}\nwhile ( in[ len ] != 0 )\n{\nlen ++;\n}\nchr = malloc( len + 1 );\nlen = 0;\nwhile ( in[ len ] != 0 )\n{\nchr[ len ] = 0xFF & in[ len ];\nlen ++;\n}\nchr[ len ++ ] = '\\0';\nreturn chr;\n}", "contrast": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\nchar *chr;\nint len = 0;\nif ( !in )\n{\nreturn NULL;\n}\nwhile ( in[ len ] != 0 )\n{\nlen ++;\n}\nchr = malloc( len + 1 );\nlen = 0;\nwhile ( in[ len ] != 0 )\n{\nchr[ len ] = 0xFF & in[ len ];\nlen ++;\n}\nchr[ len ++ ] = '\\0';\nreturn chr;\n}", "label": 0}
{"index": 178242, "code": "BOOL SQLWriteFileDSN(\t\t\tLPCSTR\tpszFileName,\nLPCSTR\tpszAppName,\nLPCSTR\tpszKeyName,\nLPCSTR\tpszString )\n{\nHINI\thIni;\nchar\tszFileName[ODBC_FILENAME_MAX+1];\nif ( pszFileName[0] == '/' )\n{\nstrncpy( szFileName, sizeof(szFileName) - 5, pszFileName );\n}\nelse\n{\nchar szPath[ODBC_FILENAME_MAX+1];\n*szPath = '\\0';\n_odbcinst_FileINI( szPath );\nsnprintf( szFileName, sizeof(szFileName) - 5, \"%s/%s\", szPath, pszFileName );\n}\nif ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, \".dsn\" ))\n{\nstrcat( szFileName, \".dsn\" );\n}\n#ifdef __OS2__\nif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE, 0L ) != INI_SUCCESS )\n#else\nif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE ) != INI_SUCCESS )\n#endif\n{\ninst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, \"\" );\nreturn FALSE;\n}\nif ( pszString == NULL && pszKeyName == NULL )\n{\nif ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS )\n{\niniObjectDelete( hIni );\n}\n}\nelse if\t( pszString == NULL )\n{\nif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )\n{\niniPropertyDelete( hIni );\n}\n}\nelse\n{\nif ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS )\n{\niniObjectInsert( hIni, (char *)pszAppName );\n}\nif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )\n{\niniObjectSeek( hIni, (char *)pszAppName );\niniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString );\n}\nelse\n{\niniObjectSeek( hIni, (char *)pszAppName );\niniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString );\n}\n}\nif ( iniCommit( hIni ) != INI_SUCCESS )\n{\niniClose( hIni );\ninst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, \"\" );\nreturn FALSE;\n}\niniClose( hIni );\nreturn TRUE;\n}", "contrast": "BOOL SQLWriteFileDSN(\t\t\tLPCSTR\tpszFileName,\nLPCSTR\tpszAppName,\nLPCSTR\tpszKeyName,\nLPCSTR\tpszString )\n{\nHINI\thIni;\nchar\tszFileName[ODBC_FILENAME_MAX+1];\nif ( pszFileName[0] == '/' )\n{\nstrncpy( szFileName, pszFileName, sizeof(szFileName) - 5 );\n}\nelse\n{\nchar szPath[ODBC_FILENAME_MAX+1];\n*szPath = '\\0';\n_odbcinst_FileINI( szPath );\nsnprintf( szFileName, sizeof(szFileName) - 5, \"%s/%s\", szPath, pszFileName );\n}\nif ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, \".dsn\" ))\n{\nstrcat( szFileName, \".dsn\" );\n}\n#ifdef __OS2__\nif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE, 0L ) != INI_SUCCESS )\n#else\nif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE ) != INI_SUCCESS )\n#endif\n{\ninst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, \"\" );\nreturn FALSE;\n}\nif ( pszString == NULL && pszKeyName == NULL )\n{\nif ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS )\n{\niniObjectDelete( hIni );\n}\n}\nelse if\t( pszString == NULL )\n{\nif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )\n{\niniPropertyDelete( hIni );\n}\n}\nelse\n{\nif ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS )\n{\niniObjectInsert( hIni, (char *)pszAppName );\n}\nif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )\n{\niniObjectSeek( hIni, (char *)pszAppName );\niniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString );\n}\nelse\n{\niniObjectSeek( hIni, (char *)pszAppName );\niniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString );\n}\n}\nif ( iniCommit( hIni ) != INI_SUCCESS )\n{\niniClose( hIni );\ninst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, \"\" );\nreturn FALSE;\n}\niniClose( hIni );\nreturn TRUE;\n}", "label": 0}
{"index": 178246, "code": "pixHtmlViewer(const char  *dirin,\nconst char  *dirout,\nconst char  *rootname,\nl_int32      thumbwidth,\nl_int32      viewwidth)\n{\nchar      *fname, *fullname, *outname;\nchar      *mainname, *linkname, *linknameshort;\nchar      *viewfile, *thumbfile;\nchar      *shtml, *slink;\nchar       charbuf[512];\nchar       htmlstring[] = \"<html>\";\nchar       framestring[] = \"</frameset></html>\";\nl_int32    i, nfiles, index, w, d, nimages, ret;\nl_float32  factor;\nPIX       *pix, *pixthumb, *pixview;\nSARRAY    *safiles, *sathumbs, *saviews, *sahtml, *salink;\nPROCNAME(\"pixHtmlViewer\");\nif (!dirin)\nreturn ERROR_INT(\"dirin not defined\", procName, 1);\nif (!dirout)\nreturn ERROR_INT(\"dirout not defined\", procName, 1);\nif (!rootname)\nreturn ERROR_INT(\"rootname not defined\", procName, 1);\nif (thumbwidth == 0)\nthumbwidth = DEFAULT_THUMB_WIDTH;\nif (thumbwidth < MIN_THUMB_WIDTH) {\nL_WARNING(\"thumbwidth too small; using min value\\n\", procName);\nthumbwidth = MIN_THUMB_WIDTH;\n}\nif (viewwidth == 0)\nviewwidth = DEFAULT_VIEW_WIDTH;\nif (viewwidth < MIN_VIEW_WIDTH) {\nL_WARNING(\"viewwidth too small; using min value\\n\", procName);\nviewwidth = MIN_VIEW_WIDTH;\n}\n#ifndef _WIN32\nsnprintf(charbuf, sizeof(charbuf), \"mkdir -p %s\", dirout);\nret = system(charbuf);\n#else\nret = CreateDirectory(dirout, NULL) ? 0 : 1;\n#endif\nif (ret) {\nL_ERROR(\"output directory %s not made\\n\", procName, dirout);\nreturn 1;\n}\nif ((safiles = getFilenamesInDirectory(dirin)) == NULL)\nreturn ERROR_INT(\"safiles not made\", procName, 1);\nsprintf(charbuf, \"%s/%s.html\", dirout, rootname);\nmainname = stringNew(charbuf);\nsprintf(charbuf, \"%s/%s-links.html\", dirout, rootname);\nlinkname = stringNew(charbuf);\nlinknameshort = stringJoin(rootname, \"-links.html\");\nsathumbs = sarrayCreate(0);\nsaviews = sarrayCreate(0);\nnfiles = sarrayGetCount(safiles);\nindex = 0;\nfor (i = 0; i < nfiles; i++) {\nfname = sarrayGetString(safiles, i, L_NOCOPY);\nfullname = genPathname(dirin, fname);\nfprintf(stderr, \"name: %s\\n\", fullname);\nif ((pix = pixRead(fullname)) == NULL) {\nfprintf(stderr, \"file %s not a readable image\\n\", fullname);\nlept_free(fullname);\ncontinue;\n}\nlept_free(fullname);\npixGetDimensions(pix, &w, NULL, &d);\nfactor = (l_float32)thumbwidth / (l_float32)w;\npixthumb = pixScale(pix, factor, factor);\nsprintf(charbuf, \"%s_thumb_%03d\", rootname, index);\nsarrayAddString(sathumbs, charbuf, L_COPY);\noutname = genPathname(dirout, charbuf);\nWriteFormattedPix(outname, pixthumb);\nlept_free(outname);\npixDestroy(&pixthumb);\nfactor = (l_float32)viewwidth / (l_float32)w;\nif (factor >= 1.0)\npixview = pixClone(pix);\nelse\npixview = pixScale(pix, factor, factor);\nsnprintf(charbuf, sizeof(charbuf), \"%s_view_%03d\", rootname, index);\nsarrayAddString(saviews, charbuf, L_COPY);\noutname = genPathname(dirout, charbuf);\nWriteFormattedPix(outname, pixview);\nlept_free(outname);\npixDestroy(&pixview);\npixDestroy(&pix);\nindex++;\n}\nsahtml = sarrayCreate(0);\nsarrayAddString(sahtml, htmlstring, L_COPY);\nsprintf(charbuf, \"<frameset cols=\\\"%d, *\\\">\", thumbwidth + 30);\nsarrayAddString(sahtml, charbuf, L_COPY);\nsprintf(charbuf, \"<frame name=\\\"thumbs\\\" src=\\\"%s\\\">\", linknameshort);\nsarrayAddString(sahtml, charbuf, L_COPY);\nsprintf(charbuf, \"<frame name=\\\"views\\\" src=\\\"%s\\\">\",\nsarrayGetString(saviews, 0, L_NOCOPY));\nsarrayAddString(sahtml, charbuf, L_COPY);\nsarrayAddString(sahtml, framestring, L_COPY);\nshtml = sarrayToString(sahtml, 1);\nl_binaryWrite(mainname, \"w\", shtml, strlen(shtml));\nfprintf(stderr, \"******************************************\\n\"\n\"Writing html file: %s\\n\"\n\"******************************************\\n\", mainname);\nlept_free(shtml);\nlept_free(mainname);\nnimages = sarrayGetCount(saviews);\nfprintf(stderr, \"num. images = %d\\n\", nimages);\nsalink = sarrayCreate(0);\nfor (i = 0; i < nimages; i++) {\nviewfile = sarrayGetString(saviews, i, L_NOCOPY);\nthumbfile = sarrayGetString(sathumbs, i, L_NOCOPY);\nsprintf(charbuf, \"<a href=\\\"%s\\\" TARGET=views><img src=\\\"%s\\\"></a>\",\nviewfile, thumbfile);\nsarrayAddString(salink, charbuf, L_COPY);\n}\nslink = sarrayToString(salink, 1);\nl_binaryWrite(linkname, \"w\", slink, strlen(slink));\nlept_free(slink);\nlept_free(linkname);\nlept_free(linknameshort);\nsarrayDestroy(&safiles);\nsarrayDestroy(&sathumbs);\nsarrayDestroy(&saviews);\nsarrayDestroy(&sahtml);\nsarrayDestroy(&salink);\nreturn 0;\n}", "contrast": "pixHtmlViewer(const char  *dirin,\nconst char  *dirout,\nconst char  *rootname,\nl_int32      thumbwidth,\nl_int32      viewwidth)\n{\nchar      *fname, *fullname, *outname;\nchar      *mainname, *linkname, *linknameshort;\nchar      *viewfile, *thumbfile;\nchar      *shtml, *slink;\nchar       charbuf[512];\nchar       htmlstring[] = \"<html>\";\nchar       framestring[] = \"</frameset></html>\";\nl_int32    i, nfiles, index, w, d, nimages, ret;\nl_float32  factor;\nPIX       *pix, *pixthumb, *pixview;\nSARRAY    *safiles, *sathumbs, *saviews, *sahtml, *salink;\nPROCNAME(\"pixHtmlViewer\");\nif (!dirin)\nreturn ERROR_INT(\"dirin not defined\", procName, 1);\nif (!dirout)\nreturn ERROR_INT(\"dirout not defined\", procName, 1);\nif (!rootname)\nreturn ERROR_INT(\"rootname not defined\", procName, 1);\nif (thumbwidth == 0)\nthumbwidth = DEFAULT_THUMB_WIDTH;\nif (thumbwidth < MIN_THUMB_WIDTH) {\nL_WARNING(\"thumbwidth too small; using min value\\n\", procName);\nthumbwidth = MIN_THUMB_WIDTH;\n}\nif (viewwidth == 0)\nviewwidth = DEFAULT_VIEW_WIDTH;\nif (viewwidth < MIN_VIEW_WIDTH) {\nL_WARNING(\"viewwidth too small; using min value\\n\", procName);\nviewwidth = MIN_VIEW_WIDTH;\n}\n#ifndef _WIN32\nsnprintf(charbuf, sizeof(charbuf), \"mkdir -p %s\", dirout);\nret = system(charbuf);\n#else\nret = CreateDirectory(dirout, NULL) ? 0 : 1;\n#endif\nif (ret) {\nL_ERROR(\"output directory %s not made\\n\", procName, dirout);\nreturn 1;\n}\nif ((safiles = getFilenamesInDirectory(dirin)) == NULL)\nreturn ERROR_INT(\"safiles not made\", procName, 1);\nsnprintf(charbuf, sizeof(charbuf), \"%s/%s.html\", dirout, rootname);\nmainname = stringNew(charbuf);\nsnprintf(charbuf, sizeof(charbuf), \"%s/%s-links.html\", dirout, rootname);\nlinkname = stringNew(charbuf);\nlinknameshort = stringJoin(rootname, \"-links.html\");\nsathumbs = sarrayCreate(0);\nsaviews = sarrayCreate(0);\nnfiles = sarrayGetCount(safiles);\nindex = 0;\nfor (i = 0; i < nfiles; i++) {\nfname = sarrayGetString(safiles, i, L_NOCOPY);\nfullname = genPathname(dirin, fname);\nfprintf(stderr, \"name: %s\\n\", fullname);\nif ((pix = pixRead(fullname)) == NULL) {\nfprintf(stderr, \"file %s not a readable image\\n\", fullname);\nlept_free(fullname);\ncontinue;\n}\nlept_free(fullname);\npixGetDimensions(pix, &w, NULL, &d);\nfactor = (l_float32)thumbwidth / (l_float32)w;\npixthumb = pixScale(pix, factor, factor);\nsnprintf(charbuf, sizeof(charbuf), \"%s_thumb_%03d\", rootname, index);\nsarrayAddString(sathumbs, charbuf, L_COPY);\noutname = genPathname(dirout, charbuf);\nWriteFormattedPix(outname, pixthumb);\nlept_free(outname);\npixDestroy(&pixthumb);\nfactor = (l_float32)viewwidth / (l_float32)w;\nif (factor >= 1.0)\npixview = pixClone(pix);\nelse\npixview = pixScale(pix, factor, factor);\nsnprintf(charbuf, sizeof(charbuf), \"%s_view_%03d\", rootname, index);\nsarrayAddString(saviews, charbuf, L_COPY);\noutname = genPathname(dirout, charbuf);\nWriteFormattedPix(outname, pixview);\nlept_free(outname);\npixDestroy(&pixview);\npixDestroy(&pix);\nindex++;\n}\nsahtml = sarrayCreate(0);\nsarrayAddString(sahtml, htmlstring, L_COPY);\nsprintf(charbuf, \"<frameset cols=\\\"%d, *\\\">\", thumbwidth + 30);\nsarrayAddString(sahtml, charbuf, L_COPY);\nsprintf(charbuf, \"<frame name=\\\"thumbs\\\" src=\\\"%s\\\">\", linknameshort);\nsarrayAddString(sahtml, charbuf, L_COPY);\nsprintf(charbuf, \"<frame name=\\\"views\\\" src=\\\"%s\\\">\",\nsarrayGetString(saviews, 0, L_NOCOPY));\nsarrayAddString(sahtml, charbuf, L_COPY);\nsarrayAddString(sahtml, framestring, L_COPY);\nshtml = sarrayToString(sahtml, 1);\nl_binaryWrite(mainname, \"w\", shtml, strlen(shtml));\nfprintf(stderr, \"******************************************\\n\"\n\"Writing html file: %s\\n\"\n\"******************************************\\n\", mainname);\nlept_free(shtml);\nlept_free(mainname);\nnimages = sarrayGetCount(saviews);\nfprintf(stderr, \"num. images = %d\\n\", nimages);\nsalink = sarrayCreate(0);\nfor (i = 0; i < nimages; i++) {\nviewfile = sarrayGetString(saviews, i, L_NOCOPY);\nthumbfile = sarrayGetString(sathumbs, i, L_NOCOPY);\nsprintf(charbuf, \"<a href=\\\"%s\\\" TARGET=views><img src=\\\"%s\\\"></a>\",\nviewfile, thumbfile);\nsarrayAddString(salink, charbuf, L_COPY);\n}\nslink = sarrayToString(salink, 1);\nl_binaryWrite(linkname, \"w\", slink, strlen(slink));\nlept_free(slink);\nlept_free(linkname);\nlept_free(linknameshort);\nsarrayDestroy(&safiles);\nsarrayDestroy(&sathumbs);\nsarrayDestroy(&saviews);\nsarrayDestroy(&sahtml);\nsarrayDestroy(&salink);\nreturn 0;\n}", "label": 0}
{"index": 178251, "code": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\nPROCNAME(\"gplotMakeOutput\");\nif (!gplot)\nreturn ERROR_INT(\"gplot not defined\", procName, 1);\ngplotGenCommandFile(gplot);\ngplotGenDataFiles(gplot);\ncmdname = genPathname(gplot->cmdname, NULL);\n#ifndef _WIN32\nsnprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\nsnprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif\n#ifndef OS_IOS\nignore = system(buf);\n#endif\nLEPT_FREE(cmdname);\nreturn 0;\n}", "contrast": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUFSIZE];\nchar    *cmdname;\nl_int32  ignore;\nPROCNAME(\"gplotMakeOutput\");\nif (!gplot)\nreturn ERROR_INT(\"gplot not defined\", procName, 1);\ngplotGenCommandFile(gplot);\ngplotGenDataFiles(gplot);\ncmdname = genPathname(gplot->cmdname, NULL);\n#ifndef _WIN32\nsnprintf(buf, L_BUFSIZE, \"gnuplot %s\", cmdname);\n#else\nsnprintf(buf, L_BUFSIZE, \"wgnuplot %s\", cmdname);\n#endif\n#ifndef OS_IOS\nignore = system(buf);\n#endif\nLEPT_FREE(cmdname);\nreturn 0;\n}", "label": 0}
{"index": 178258, "code": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\nPacketQueue *pq)\n{\nSCEnter();\nDEBUG_ASSERT_FLOW_LOCKED(p->flow);\nSCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\nif (unlikely(p->flow->thread_id == 0)) {\np->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n} else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\nSCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n}\nTcpSession *ssn = (TcpSession *)p->flow->protoctx;\nif (ssn != NULL) {\nssn->tcp_packet_flags |= p->tcph->th_flags;\nif (PKT_IS_TOSERVER(p))\nssn->client.tcp_flags |= p->tcph->th_flags;\nelse if (PKT_IS_TOCLIENT(p))\nssn->server.tcp_flags |= p->tcph->th_flags;\nif (ssn->flags & STREAMTCP_FLAG_ASYNC &&\nssn->client.tcp_flags != 0 &&\nssn->server.tcp_flags != 0)\n{\nSCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\nssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n}\n}\nif ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\nStatsIncr(tv, stt->counter_tcp_synack);\n} else if (p->tcph->th_flags & (TH_SYN)) {\nStatsIncr(tv, stt->counter_tcp_syn);\n}\nif (p->tcph->th_flags & (TH_RST)) {\nStatsIncr(tv, stt->counter_tcp_rst);\n}\nif (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\nStreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n}\nif (StreamTcpCheckFlowDrops(p) == 1) {\nSCLogDebug(\"This flow/stream triggered a drop rule\");\nFlowSetNoPacketInspectionFlag(p->flow);\nDecodeSetNoPacketInspectionFlag(p);\nStreamTcpDisableAppLayer(p->flow);\nPACKET_DROP(p);\nStreamTcpSessionPktFree(p);\nSCReturnInt(0);\n}\nif (ssn == NULL || ssn->state == TCP_NONE) {\nif (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\ngoto error;\n}\nif (ssn != NULL)\nSCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n} else {\nif (p->flags & PKT_PSEUDO_STREAM_END) {\nif (PKT_IS_TOCLIENT(p)) {\nssn->client.last_ack = TCP_GET_ACK(p);\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->server, p, pq);\n} else {\nssn->server.last_ack = TCP_GET_ACK(p);\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->client, p, pq);\n}\ngoto skip;\n}\nif (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\nStreamTcpPacketSwitchDir(ssn, p);\nif (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\ngoto skip;\n}\nif (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\nStreamTcpClearKeepAliveFlag(ssn, p);\ngoto skip;\n}\nStreamTcpClearKeepAliveFlag(ssn, p);\nif (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\nif (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\nif (StreamTcpPacketIsBadWindowUpdate(ssn,p))\ngoto skip;\nswitch (ssn->state) {\ncase TCP_SYN_SENT:\nif(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_SYN_RECV:\nif(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_ESTABLISHED:\nif(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_FIN_WAIT1:\nif(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_FIN_WAIT2:\nif(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_CLOSING:\nif(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_CLOSE_WAIT:\nif(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_LAST_ACK:\nif(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_TIME_WAIT:\nif(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_CLOSED:\nSCLogDebug(\"packet received on closed state\");\nbreak;\ndefault:\nSCLogDebug(\"packet received on default state\");\nbreak;\n}\nskip:\nif (ssn->state >= TCP_ESTABLISHED) {\np->flags |= PKT_STREAM_EST;\n}\n}\nif (ssn != NULL) {\nwhile (stt->pseudo_queue.len > 0) {\nSCLogDebug(\"processing pseudo packet / stream end\");\nPacket *np = PacketDequeue(&stt->pseudo_queue);\nif (np != NULL) {\nif (PKT_IS_TOSERVER(np)) {\nSCLogDebug(\"pseudo packet is to server\");\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->client, np, NULL);\n} else {\nSCLogDebug(\"pseudo packet is to client\");\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->server, np, NULL);\n}\nPacketEnqueue(pq, np);\n}\nSCLogDebug(\"processing pseudo packet / stream end done\");\n}\nif (p->flags & PKT_STREAM_MODIFIED) {\nReCalculateChecksum(p);\n}\nif ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n(ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n{\nif (StreamTcpBypassEnabled()) {\nPacketBypassCallback(p);\n}\n}\nif ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n(ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n{\np->flags |= PKT_STREAM_NOPCAPLOG;\n}\nif ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n(PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n{\np->flags |= PKT_STREAM_NOPCAPLOG;\n}\nif (ssn->flags & STREAMTCP_FLAG_BYPASS) {\nif (StreamTcpBypassEnabled()) {\nPacketBypassCallback(p);\n}\n} else if (g_detect_disabled &&\n(ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n(ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\nStreamTcpBypassEnabled())\n{\nSCLogDebug(\"bypass as stream is dead and we have no rules\");\nPacketBypassCallback(p);\n}\n}\nSCReturnInt(0);\nerror:\nwhile (stt->pseudo_queue.len > 0) {\nPacket *np = PacketDequeue(&stt->pseudo_queue);\nif (np != NULL) {\nPacketEnqueue(pq, np);\n}\n}\nif (p->flags & PKT_STREAM_MODIFIED) {\nReCalculateChecksum(p);\n}\nif (StreamTcpInlineDropInvalid()) {\nPACKET_DROP(p);\n}\nSCReturnInt(-1);\n}", "contrast": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\nPacketQueue *pq)\n{\nSCEnter();\nDEBUG_ASSERT_FLOW_LOCKED(p->flow);\nSCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\nif (unlikely(p->flow->thread_id == 0)) {\np->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n} else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\nSCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n}\nTcpSession *ssn = (TcpSession *)p->flow->protoctx;\nif (ssn != NULL) {\nssn->tcp_packet_flags |= p->tcph->th_flags;\nif (PKT_IS_TOSERVER(p))\nssn->client.tcp_flags |= p->tcph->th_flags;\nelse if (PKT_IS_TOCLIENT(p))\nssn->server.tcp_flags |= p->tcph->th_flags;\nif (ssn->flags & STREAMTCP_FLAG_ASYNC &&\nssn->client.tcp_flags != 0 &&\nssn->server.tcp_flags != 0)\n{\nSCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\nssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n}\n}\nif ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\nStatsIncr(tv, stt->counter_tcp_synack);\n} else if (p->tcph->th_flags & (TH_SYN)) {\nStatsIncr(tv, stt->counter_tcp_syn);\n}\nif (p->tcph->th_flags & (TH_RST)) {\nStatsIncr(tv, stt->counter_tcp_rst);\n}\nif (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\nStreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n}\nif (StreamTcpCheckFlowDrops(p) == 1) {\nSCLogDebug(\"This flow/stream triggered a drop rule\");\nFlowSetNoPacketInspectionFlag(p->flow);\nDecodeSetNoPacketInspectionFlag(p);\nStreamTcpDisableAppLayer(p->flow);\nPACKET_DROP(p);\nStreamTcpSessionPktFree(p);\nSCReturnInt(0);\n}\nif (ssn == NULL || ssn->state == TCP_NONE) {\nif (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\ngoto error;\n}\nif (ssn != NULL)\nSCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n} else {\nif (p->flags & PKT_PSEUDO_STREAM_END) {\nif (PKT_IS_TOCLIENT(p)) {\nssn->client.last_ack = TCP_GET_ACK(p);\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->server, p, pq);\n} else {\nssn->server.last_ack = TCP_GET_ACK(p);\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->client, p, pq);\n}\ngoto skip;\n}\nif (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\nStreamTcpPacketSwitchDir(ssn, p);\nif (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\ngoto skip;\n}\nif (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\nStreamTcpClearKeepAliveFlag(ssn, p);\ngoto skip;\n}\nStreamTcpClearKeepAliveFlag(ssn, p);\nif (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\nif (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\nif (StreamTcpPacketIsBadWindowUpdate(ssn,p))\ngoto skip;\nswitch (ssn->state) {\ncase TCP_SYN_SENT:\nif(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_SYN_RECV:\nif(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_ESTABLISHED:\nif(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_FIN_WAIT1:\nif(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_FIN_WAIT2:\nif(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_CLOSING:\nif(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_CLOSE_WAIT:\nif(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_LAST_ACK:\nif(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_TIME_WAIT:\nif(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\ngoto error;\n}\nbreak;\ncase TCP_CLOSED:\nSCLogDebug(\"packet received on closed state\");\nbreak;\ndefault:\nSCLogDebug(\"packet received on default state\");\nbreak;\n}\nskip:\nif (ssn->state >= TCP_ESTABLISHED) {\np->flags |= PKT_STREAM_EST;\n}\n}\nif (ssn != NULL) {\nwhile (stt->pseudo_queue.len > 0) {\nSCLogDebug(\"processing pseudo packet / stream end\");\nPacket *np = PacketDequeue(&stt->pseudo_queue);\nif (np != NULL) {\nif (PKT_IS_TOSERVER(np)) {\nSCLogDebug(\"pseudo packet is to server\");\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->client, np, NULL);\n} else {\nSCLogDebug(\"pseudo packet is to client\");\nStreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n&ssn->server, np, NULL);\n}\nPacketEnqueue(pq, np);\n}\nSCLogDebug(\"processing pseudo packet / stream end done\");\n}\nif (p->flags & PKT_STREAM_MODIFIED) {\nReCalculateChecksum(p);\n}\nif ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n(ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n{\nif (StreamTcpBypassEnabled()) {\nPacketBypassCallback(p);\n}\n}\nif ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n(ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n{\np->flags |= PKT_STREAM_NOPCAPLOG;\n}\nif ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n(PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n{\np->flags |= PKT_STREAM_NOPCAPLOG;\n}\nif (ssn->flags & STREAMTCP_FLAG_BYPASS) {\nif (StreamTcpBypassEnabled()) {\nPacketBypassCallback(p);\n}\n} else if (g_detect_disabled &&\n(ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n(ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\nStreamTcpBypassEnabled())\n{\nSCLogDebug(\"bypass as stream is dead and we have no rules\");\nPacketBypassCallback(p);\n}\n}\nSCReturnInt(0);\nerror:\nwhile (stt->pseudo_queue.len > 0) {\nPacket *np = PacketDequeue(&stt->pseudo_queue);\nif (np != NULL) {\nPacketEnqueue(pq, np);\n}\n}\nif (p->flags & PKT_STREAM_MODIFIED) {\nReCalculateChecksum(p);\n}\nif (StreamTcpInlineDropInvalid()) {\nDecodeSetNoPayloadInspectionFlag(p);\nPACKET_DROP(p);\n}\nSCReturnInt(-1);\n}", "label": 0}
{"index": 178267, "code": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\ninit_side (client, &client->client_side);\ninit_side (client, &client->bus_side);\nclient->auth_end_offset = AUTH_END_INIT_OFFSET;\nclient->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\nclient->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\nclient->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "contrast": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\ninit_side (client, &client->client_side);\ninit_side (client, &client->bus_side);\nclient->auth_buffer = g_byte_array_new ();\nclient->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\nclient->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\nclient->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "label": 0}
{"index": 178285, "code": "ipt_do_table(struct sk_buff *skb,\nconst struct nf_hook_state *state,\nstruct xt_table *table)\n{\nunsigned int hook = state->hook;\nstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\nconst struct iphdr *ip;\nunsigned int verdict = NF_DROP;\nconst char *indev, *outdev;\nconst void *table_base;\nstruct ipt_entry *e, **jumpstack;\nunsigned int stackidx, cpu;\nconst struct xt_table_info *private;\nstruct xt_action_param acpar;\nunsigned int addend;\nstackidx = 0;\nip = ip_hdr(skb);\nindev = state->in ? state->in->name : nulldevname;\noutdev = state->out ? state->out->name : nulldevname;\nacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\nacpar.thoff   = ip_hdrlen(skb);\nacpar.hotdrop = false;\nacpar.state   = state;\nWARN_ON(!(table->valid_hooks & (1 << hook)));\nlocal_bh_disable();\naddend = xt_write_recseq_begin();\nprivate = READ_ONCE(table->private);\ncpu        = smp_processor_id();\ntable_base = private->entries;\njumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\nif (static_key_false(&xt_tee_enabled))\njumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\ne = get_entry(table_base, private->hook_entry[hook]);\ndo {\nconst struct xt_entry_target *t;\nconst struct xt_entry_match *ematch;\nstruct xt_counters *counter;\nWARN_ON(!e);\nif (!ip_packet_match(ip, indev, outdev,\n&e->ip, acpar.fragoff)) {\nno_match:\ne = ipt_next_entry(e);\ncontinue;\n}\nxt_ematch_foreach(ematch, e) {\nacpar.match     = ematch->u.kernel.match;\nacpar.matchinfo = ematch->data;\nif (!acpar.match->match(skb, &acpar))\ngoto no_match;\n}\ncounter = xt_get_this_cpu_counter(&e->counters);\nADD_COUNTER(*counter, skb->len, 1);\nt = ipt_get_target(e);\nWARN_ON(!t->u.kernel.target);\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\nif (unlikely(skb->nf_trace))\ntrace_packet(state->net, skb, hook, state->in,\nstate->out, table->name, private, e);\n#endif\nif (!t->u.kernel.target->target) {\nint v;\nv = ((struct xt_standard_target *)t)->verdict;\nif (v < 0) {\nif (v != XT_RETURN) {\nverdict = (unsigned int)(-v) - 1;\nbreak;\n}\nif (stackidx == 0) {\ne = get_entry(table_base,\nprivate->underflow[hook]);\n} else {\ne = jumpstack[--stackidx];\ne = ipt_next_entry(e);\n}\ncontinue;\n}\nif (table_base + v != ipt_next_entry(e) &&\n!(e->ip.flags & IPT_F_GOTO))\njumpstack[stackidx++] = e;\ne = get_entry(table_base, v);\ncontinue;\n}\nacpar.target   = t->u.kernel.target;\nacpar.targinfo = t->data;\nverdict = t->u.kernel.target->target(skb, &acpar);\nif (verdict == XT_CONTINUE) {\nip = ip_hdr(skb);\ne = ipt_next_entry(e);\n} else {\nbreak;\n}\n} while (!acpar.hotdrop);\nxt_write_recseq_end(addend);\nlocal_bh_enable();\nif (acpar.hotdrop)\nreturn NF_DROP;\nelse return verdict;\n}", "contrast": "ipt_do_table(struct sk_buff *skb,\nconst struct nf_hook_state *state,\nstruct xt_table *table)\n{\nunsigned int hook = state->hook;\nstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\nconst struct iphdr *ip;\nunsigned int verdict = NF_DROP;\nconst char *indev, *outdev;\nconst void *table_base;\nstruct ipt_entry *e, **jumpstack;\nunsigned int stackidx, cpu;\nconst struct xt_table_info *private;\nstruct xt_action_param acpar;\nunsigned int addend;\nstackidx = 0;\nip = ip_hdr(skb);\nindev = state->in ? state->in->name : nulldevname;\noutdev = state->out ? state->out->name : nulldevname;\nacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\nacpar.thoff   = ip_hdrlen(skb);\nacpar.hotdrop = false;\nacpar.state   = state;\nWARN_ON(!(table->valid_hooks & (1 << hook)));\nlocal_bh_disable();\naddend = xt_write_recseq_begin();\nprivate = READ_ONCE(table->private);\ncpu        = smp_processor_id();\ntable_base = private->entries;\njumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\nif (static_key_false(&xt_tee_enabled))\njumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\ne = get_entry(table_base, private->hook_entry[hook]);\ndo {\nconst struct xt_entry_target *t;\nconst struct xt_entry_match *ematch;\nstruct xt_counters *counter;\nWARN_ON(!e);\nif (!ip_packet_match(ip, indev, outdev,\n&e->ip, acpar.fragoff)) {\nno_match:\ne = ipt_next_entry(e);\ncontinue;\n}\nxt_ematch_foreach(ematch, e) {\nacpar.match     = ematch->u.kernel.match;\nacpar.matchinfo = ematch->data;\nif (!acpar.match->match(skb, &acpar))\ngoto no_match;\n}\ncounter = xt_get_this_cpu_counter(&e->counters);\nADD_COUNTER(*counter, skb->len, 1);\nt = ipt_get_target(e);\nWARN_ON(!t->u.kernel.target);\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\nif (unlikely(skb->nf_trace))\ntrace_packet(state->net, skb, hook, state->in,\nstate->out, table->name, private, e);\n#endif\nif (!t->u.kernel.target->target) {\nint v;\nv = ((struct xt_standard_target *)t)->verdict;\nif (v < 0) {\nif (v != XT_RETURN) {\nverdict = (unsigned int)(-v) - 1;\nbreak;\n}\nif (stackidx == 0) {\ne = get_entry(table_base,\nprivate->underflow[hook]);\n} else {\ne = jumpstack[--stackidx];\ne = ipt_next_entry(e);\n}\ncontinue;\n}\nif (table_base + v != ipt_next_entry(e) &&\n!(e->ip.flags & IPT_F_GOTO)) {\nif (unlikely(stackidx >= private->stacksize)) {\nverdict = NF_DROP;\nbreak;\n}\njumpstack[stackidx++] = e;\n}\ne = get_entry(table_base, v);\ncontinue;\n}\nacpar.target   = t->u.kernel.target;\nacpar.targinfo = t->data;\nverdict = t->u.kernel.target->target(skb, &acpar);\nif (verdict == XT_CONTINUE) {\nip = ip_hdr(skb);\ne = ipt_next_entry(e);\n} else {\nbreak;\n}\n} while (!acpar.hotdrop);\nxt_write_recseq_end(addend);\nlocal_bh_enable();\nif (acpar.hotdrop)\nreturn NF_DROP;\nelse return verdict;\n}", "label": 0}
{"index": 178289, "code": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\ndecoder_info->width = get_flc(16, stream);\ndecoder_info->height = get_flc(16, stream);\ndecoder_info->log2_sb_size = get_flc(3, stream);\ndecoder_info->pb_split = get_flc(1, stream);\ndecoder_info->tb_split_enable = get_flc(1, stream);\ndecoder_info->max_num_ref = get_flc(2, stream) + 1;\ndecoder_info->interp_ref = get_flc(2, stream);\ndecoder_info->max_delta_qp = get_flc(1, stream);\ndecoder_info->deblocking = get_flc(1, stream);\ndecoder_info->clpf = get_flc(1, stream);\ndecoder_info->use_block_contexts = get_flc(1, stream);\ndecoder_info->bipred = get_flc(2, stream);\ndecoder_info->qmtx = get_flc(1, stream);\nif (decoder_info->qmtx) {\ndecoder_info->qmtx_offset = get_flc(6, stream) - 32;\n}\ndecoder_info->subsample = get_flc(2, stream);\ndecoder_info->subsample =\n(decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n((decoder_info->subsample & 3) == 3) * 2 + 400;\ndecoder_info->num_reorder_pics = get_flc(4, stream);\nif (decoder_info->subsample != 400) {\ndecoder_info->cfl_intra = get_flc(1, stream);\ndecoder_info->cfl_inter = get_flc(1, stream);\n}\ndecoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\nif (decoder_info->bitdepth == 10)\ndecoder_info->bitdepth += 2 * get_flc(1, stream);\ndecoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\nif (decoder_info->input_bitdepth == 10)\ndecoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}", "contrast": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\ndecoder_info->width = get_flc(16, stream);\ndecoder_info->height = get_flc(16, stream);\ndecoder_info->log2_sb_size = get_flc(3, stream);\ndecoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\ndecoder_info->pb_split = get_flc(1, stream);\ndecoder_info->tb_split_enable = get_flc(1, stream);\ndecoder_info->max_num_ref = get_flc(2, stream) + 1;\ndecoder_info->interp_ref = get_flc(2, stream);\ndecoder_info->max_delta_qp = get_flc(1, stream);\ndecoder_info->deblocking = get_flc(1, stream);\ndecoder_info->clpf = get_flc(1, stream);\ndecoder_info->use_block_contexts = get_flc(1, stream);\ndecoder_info->bipred = get_flc(2, stream);\ndecoder_info->qmtx = get_flc(1, stream);\nif (decoder_info->qmtx) {\ndecoder_info->qmtx_offset = get_flc(6, stream) - 32;\n}\ndecoder_info->subsample = get_flc(2, stream);\ndecoder_info->subsample =\n(decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n((decoder_info->subsample & 3) == 3) * 2 + 400;\ndecoder_info->num_reorder_pics = get_flc(4, stream);\nif (decoder_info->subsample != 400) {\ndecoder_info->cfl_intra = get_flc(1, stream);\ndecoder_info->cfl_inter = get_flc(1, stream);\n}\ndecoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\nif (decoder_info->bitdepth == 10)\ndecoder_info->bitdepth += 2 * get_flc(1, stream);\ndecoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\nif (decoder_info->input_bitdepth == 10)\ndecoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}", "label": 0}
{"index": 178296, "code": "struct key *key_alloc(struct key_type *type, const char *desc,\nkuid_t uid, kgid_t gid, const struct cred *cred,\nkey_perm_t perm, unsigned long flags,\nstruct key_restriction *restrict_link)\n{\nstruct key_user *user = NULL;\nstruct key *key;\nsize_t desclen, quotalen;\nint ret;\nkey = ERR_PTR(-EINVAL);\nif (!desc || !*desc)\ngoto error;\nif (type->vet_description) {\nret = type->vet_description(desc);\nif (ret < 0) {\nkey = ERR_PTR(ret);\ngoto error;\n}\n}\ndesclen = strlen(desc);\nquotalen = desclen + 1 + type->def_datalen;\nuser = key_user_lookup(uid);\nif (!user)\ngoto no_memory_1;\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\nunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\nkey_quota_root_maxkeys : key_quota_maxkeys;\nunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\nkey_quota_root_maxbytes : key_quota_maxbytes;\nspin_lock(&user->lock);\nif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\nif (user->qnkeys + 1 >= maxkeys ||\nuser->qnbytes + quotalen >= maxbytes ||\nuser->qnbytes + quotalen < user->qnbytes)\ngoto no_quota;\n}\nuser->qnkeys++;\nuser->qnbytes += quotalen;\nspin_unlock(&user->lock);\n}\nkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\nif (!key)\ngoto no_memory_2;\nkey->index_key.desc_len = desclen;\nkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\nif (!key->index_key.description)\ngoto no_memory_3;\nrefcount_set(&key->usage, 1);\ninit_rwsem(&key->sem);\nlockdep_set_class(&key->sem, &type->lock_class);\nkey->index_key.type = type;\nkey->user = user;\nkey->quotalen = quotalen;\nkey->datalen = type->def_datalen;\nkey->uid = uid;\nkey->gid = gid;\nkey->perm = perm;\nkey->restrict_link = restrict_link;\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\nkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\nif (flags & KEY_ALLOC_BUILT_IN)\nkey->flags |= 1 << KEY_FLAG_BUILTIN;\n#ifdef KEY_DEBUGGING\nkey->magic = KEY_DEBUG_MAGIC;\n#endif\nret = security_key_alloc(key, cred, flags);\nif (ret < 0)\ngoto security_error;\natomic_inc(&user->nkeys);\nkey_alloc_serial(key);\nerror:\nreturn key;\nsecurity_error:\nkfree(key->description);\nkmem_cache_free(key_jar, key);\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\nspin_lock(&user->lock);\nuser->qnkeys--;\nuser->qnbytes -= quotalen;\nspin_unlock(&user->lock);\n}\nkey_user_put(user);\nkey = ERR_PTR(ret);\ngoto error;\nno_memory_3:\nkmem_cache_free(key_jar, key);\nno_memory_2:\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\nspin_lock(&user->lock);\nuser->qnkeys--;\nuser->qnbytes -= quotalen;\nspin_unlock(&user->lock);\n}\nkey_user_put(user);\nno_memory_1:\nkey = ERR_PTR(-ENOMEM);\ngoto error;\nno_quota:\nspin_unlock(&user->lock);\nkey_user_put(user);\nkey = ERR_PTR(-EDQUOT);\ngoto error;\n}", "contrast": "struct key *key_alloc(struct key_type *type, const char *desc,\nkuid_t uid, kgid_t gid, const struct cred *cred,\nkey_perm_t perm, unsigned long flags,\nstruct key_restriction *restrict_link)\n{\nstruct key_user *user = NULL;\nstruct key *key;\nsize_t desclen, quotalen;\nint ret;\nkey = ERR_PTR(-EINVAL);\nif (!desc || !*desc)\ngoto error;\nif (type->vet_description) {\nret = type->vet_description(desc);\nif (ret < 0) {\nkey = ERR_PTR(ret);\ngoto error;\n}\n}\ndesclen = strlen(desc);\nquotalen = desclen + 1 + type->def_datalen;\nuser = key_user_lookup(uid);\nif (!user)\ngoto no_memory_1;\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\nunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\nkey_quota_root_maxkeys : key_quota_maxkeys;\nunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\nkey_quota_root_maxbytes : key_quota_maxbytes;\nspin_lock(&user->lock);\nif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\nif (user->qnkeys + 1 >= maxkeys ||\nuser->qnbytes + quotalen >= maxbytes ||\nuser->qnbytes + quotalen < user->qnbytes)\ngoto no_quota;\n}\nuser->qnkeys++;\nuser->qnbytes += quotalen;\nspin_unlock(&user->lock);\n}\nkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\nif (!key)\ngoto no_memory_2;\nkey->index_key.desc_len = desclen;\nkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\nif (!key->index_key.description)\ngoto no_memory_3;\nrefcount_set(&key->usage, 1);\ninit_rwsem(&key->sem);\nlockdep_set_class(&key->sem, &type->lock_class);\nkey->index_key.type = type;\nkey->user = user;\nkey->quotalen = quotalen;\nkey->datalen = type->def_datalen;\nkey->uid = uid;\nkey->gid = gid;\nkey->perm = perm;\nkey->restrict_link = restrict_link;\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\nkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\nif (flags & KEY_ALLOC_BUILT_IN)\nkey->flags |= 1 << KEY_FLAG_BUILTIN;\nif (flags & KEY_ALLOC_UID_KEYRING)\nkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n#ifdef KEY_DEBUGGING\nkey->magic = KEY_DEBUG_MAGIC;\n#endif\nret = security_key_alloc(key, cred, flags);\nif (ret < 0)\ngoto security_error;\natomic_inc(&user->nkeys);\nkey_alloc_serial(key);\nerror:\nreturn key;\nsecurity_error:\nkfree(key->description);\nkmem_cache_free(key_jar, key);\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\nspin_lock(&user->lock);\nuser->qnkeys--;\nuser->qnbytes -= quotalen;\nspin_unlock(&user->lock);\n}\nkey_user_put(user);\nkey = ERR_PTR(ret);\ngoto error;\nno_memory_3:\nkmem_cache_free(key_jar, key);\nno_memory_2:\nif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\nspin_lock(&user->lock);\nuser->qnkeys--;\nuser->qnbytes -= quotalen;\nspin_unlock(&user->lock);\n}\nkey_user_put(user);\nno_memory_1:\nkey = ERR_PTR(-ENOMEM);\ngoto error;\nno_quota:\nspin_unlock(&user->lock);\nkey_user_put(user);\nkey = ERR_PTR(-EDQUOT);\ngoto error;\n}", "label": 0}
{"index": 178302, "code": "int build_segment_manager(struct f2fs_sb_info *sbi)\n{\nstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\nstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\nstruct f2fs_sm_info *sm_info;\nint err;\nsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\nif (!sm_info)\nreturn -ENOMEM;\nsbi->sm_info = sm_info;\nsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\nsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\nsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\nsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\nsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\nsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\nsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\nsm_info->rec_prefree_segments = sm_info->main_segments *\nDEF_RECLAIM_PREFREE_SEGMENTS / 100;\nif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)\nsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;\nif (!test_opt(sbi, LFS))\nsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\nsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\nsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\nsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;\nsm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;\nINIT_LIST_HEAD(&sm_info->sit_entry_set);\nif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\nerr = create_flush_cmd_control(sbi);\nif (err)\nreturn err;\n}\nerr = create_discard_cmd_control(sbi);\nif (err)\nreturn err;\nerr = build_sit_info(sbi);\nif (err)\nreturn err;\nerr = build_free_segmap(sbi);\nif (err)\nreturn err;\nerr = build_curseg(sbi);\nif (err)\nreturn err;\nbuild_sit_entries(sbi);\ninit_free_segmap(sbi);\nerr = build_dirty_segmap(sbi);\nif (err)\nreturn err;\ninit_min_max_mtime(sbi);\nreturn 0;\n}", "contrast": "int build_segment_manager(struct f2fs_sb_info *sbi)\n{\nstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\nstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\nstruct f2fs_sm_info *sm_info;\nint err;\nsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\nif (!sm_info)\nreturn -ENOMEM;\nsbi->sm_info = sm_info;\nsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\nsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\nsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\nsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\nsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\nsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\nsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\nsm_info->rec_prefree_segments = sm_info->main_segments *\nDEF_RECLAIM_PREFREE_SEGMENTS / 100;\nif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)\nsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;\nif (!test_opt(sbi, LFS))\nsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\nsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\nsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\nsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;\nsm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;\nINIT_LIST_HEAD(&sm_info->sit_entry_set);\nif (!f2fs_readonly(sbi->sb)) {\nerr = create_flush_cmd_control(sbi);\nif (err)\nreturn err;\n}\nerr = create_discard_cmd_control(sbi);\nif (err)\nreturn err;\nerr = build_sit_info(sbi);\nif (err)\nreturn err;\nerr = build_free_segmap(sbi);\nif (err)\nreturn err;\nerr = build_curseg(sbi);\nif (err)\nreturn err;\nbuild_sit_entries(sbi);\ninit_free_segmap(sbi);\nerr = build_dirty_segmap(sbi);\nif (err)\nreturn err;\ninit_min_max_mtime(sbi);\nreturn 0;\n}", "label": 0}
{"index": 178303, "code": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\ndev_t dev = sbi->sb->s_bdev->bd_dev;\nstruct flush_cmd_control *fcc;\nint err = 0;\nif (SM_I(sbi)->fcc_info) {\nfcc = SM_I(sbi)->fcc_info;\ngoto init_thread;\n}\nfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\nif (!fcc)\nreturn -ENOMEM;\natomic_set(&fcc->issued_flush, 0);\natomic_set(&fcc->issing_flush, 0);\ninit_waitqueue_head(&fcc->flush_wait_queue);\ninit_llist_head(&fcc->issue_list);\nSM_I(sbi)->fcc_info = fcc;\ninit_thread:\nfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\nif (IS_ERR(fcc->f2fs_issue_flush)) {\nerr = PTR_ERR(fcc->f2fs_issue_flush);\nkfree(fcc);\nSM_I(sbi)->fcc_info = NULL;\nreturn err;\n}\nreturn err;\n}", "contrast": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\ndev_t dev = sbi->sb->s_bdev->bd_dev;\nstruct flush_cmd_control *fcc;\nint err = 0;\nif (SM_I(sbi)->fcc_info) {\nfcc = SM_I(sbi)->fcc_info;\ngoto init_thread;\n}\nfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\nif (!fcc)\nreturn -ENOMEM;\natomic_set(&fcc->issued_flush, 0);\natomic_set(&fcc->issing_flush, 0);\ninit_waitqueue_head(&fcc->flush_wait_queue);\ninit_llist_head(&fcc->issue_list);\nSM_I(sbi)->fcc_info = fcc;\nif (!test_opt(sbi, FLUSH_MERGE))\nreturn err;\ninit_thread:\nfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\nif (IS_ERR(fcc->f2fs_issue_flush)) {\nerr = PTR_ERR(fcc->f2fs_issue_flush);\nkfree(fcc);\nSM_I(sbi)->fcc_info = NULL;\nreturn err;\n}\nreturn err;\n}", "label": 0}
{"index": 178331, "code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\nstruct mmu_gather tlb;\nstruct vm_area_struct *vma;\nbool ret = true;\nmutex_lock(&oom_lock);\nif (!down_read_trylock(&mm->mmap_sem)) {\nret = false;\ntrace_skip_task_reaping(tsk->pid);\ngoto unlock_oom;\n}\nif (mm_has_notifiers(mm)) {\nup_read(&mm->mmap_sem);\nschedule_timeout_idle(HZ);\ngoto unlock_oom;\n}\nif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\nup_read(&mm->mmap_sem);\ntrace_skip_task_reaping(tsk->pid);\ngoto unlock_oom;\n}\ntrace_start_task_reaping(tsk->pid);\nset_bit(MMF_UNSTABLE, &mm->flags);\ntlb_gather_mmu(&tlb, mm, 0, -1);\nfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\nif (!can_madv_dontneed_vma(vma))\ncontinue;\nif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\nunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\nNULL);\n}\ntlb_finish_mmu(&tlb, 0, -1);\npr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\ntask_pid_nr(tsk), tsk->comm,\nK(get_mm_counter(mm, MM_ANONPAGES)),\nK(get_mm_counter(mm, MM_FILEPAGES)),\nK(get_mm_counter(mm, MM_SHMEMPAGES)));\nup_read(&mm->mmap_sem);\ntrace_finish_task_reaping(tsk->pid);\nunlock_oom:\nmutex_unlock(&oom_lock);\nreturn ret;\n}", "contrast": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\nstruct mmu_gather tlb;\nstruct vm_area_struct *vma;\nbool ret = true;\nmutex_lock(&oom_lock);\nif (!down_read_trylock(&mm->mmap_sem)) {\nret = false;\ntrace_skip_task_reaping(tsk->pid);\ngoto unlock_oom;\n}\nif (mm_has_notifiers(mm)) {\nup_read(&mm->mmap_sem);\nschedule_timeout_idle(HZ);\ngoto unlock_oom;\n}\nif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\nup_read(&mm->mmap_sem);\ntrace_skip_task_reaping(tsk->pid);\ngoto unlock_oom;\n}\ntrace_start_task_reaping(tsk->pid);\nset_bit(MMF_UNSTABLE, &mm->flags);\nfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\nif (!can_madv_dontneed_vma(vma))\ncontinue;\nif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\ntlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);\nunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\nNULL);\ntlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);\n}\n}\npr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\ntask_pid_nr(tsk), tsk->comm,\nK(get_mm_counter(mm, MM_ANONPAGES)),\nK(get_mm_counter(mm, MM_FILEPAGES)),\nK(get_mm_counter(mm, MM_SHMEMPAGES)));\nup_read(&mm->mmap_sem);\ntrace_finish_task_reaping(tsk->pid);\nunlock_oom:\nmutex_unlock(&oom_lock);\nreturn ret;\n}", "label": 0}
{"index": 178343, "code": "static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\nu32 type, u32 mask)\n{\nstruct pcrypt_instance_ctx *ctx;\nstruct crypto_attr_type *algt;\nstruct aead_instance *inst;\nstruct aead_alg *alg;\nconst char *name;\nint err;\nalgt = crypto_get_attr_type(tb);\nif (IS_ERR(algt))\nreturn PTR_ERR(algt);\nname = crypto_attr_alg_name(tb[1]);\nif (IS_ERR(name))\nreturn PTR_ERR(name);\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\nif (!inst)\nreturn -ENOMEM;\nctx = aead_instance_ctx(inst);\ncrypto_set_aead_spawn(&ctx->spawn, aead_crypto_instance(inst));\nerr = crypto_grab_aead(&ctx->spawn, name, 0, 0);\nif (err)\ngoto out_free_inst;\nalg = crypto_spawn_aead_alg(&ctx->spawn);\nerr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\nif (err)\ngoto out_drop_aead;\ninst->alg.base.cra_flags = CRYPTO_ALG_ASYNC;\ninst->alg.ivsize = crypto_aead_alg_ivsize(alg);\ninst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\ninst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\ninst->alg.init = pcrypt_aead_init_tfm;\ninst->alg.exit = pcrypt_aead_exit_tfm;\ninst->alg.setkey = pcrypt_aead_setkey;\ninst->alg.setauthsize = pcrypt_aead_setauthsize;\ninst->alg.encrypt = pcrypt_aead_encrypt;\ninst->alg.decrypt = pcrypt_aead_decrypt;\nerr = aead_register_instance(tmpl, inst);\nif (err)\ngoto out_drop_aead;\nout:\nreturn err;\nout_drop_aead:\ncrypto_drop_aead(&ctx->spawn);\nout_free_inst:\nkfree(inst);\ngoto out;\n}", "contrast": "static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\nu32 type, u32 mask)\n{\nstruct pcrypt_instance_ctx *ctx;\nstruct crypto_attr_type *algt;\nstruct aead_instance *inst;\nstruct aead_alg *alg;\nconst char *name;\nint err;\nalgt = crypto_get_attr_type(tb);\nif (IS_ERR(algt))\nreturn PTR_ERR(algt);\nname = crypto_attr_alg_name(tb[1]);\nif (IS_ERR(name))\nreturn PTR_ERR(name);\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\nif (!inst)\nreturn -ENOMEM;\nctx = aead_instance_ctx(inst);\ncrypto_set_aead_spawn(&ctx->spawn, aead_crypto_instance(inst));\nerr = crypto_grab_aead(&ctx->spawn, name, 0, 0);\nif (err)\ngoto out_free_inst;\nalg = crypto_spawn_aead_alg(&ctx->spawn);\nerr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\nif (err)\ngoto out_drop_aead;\ninst->alg.base.cra_flags = CRYPTO_ALG_ASYNC;\ninst->alg.ivsize = crypto_aead_alg_ivsize(alg);\ninst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\ninst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\ninst->alg.init = pcrypt_aead_init_tfm;\ninst->alg.exit = pcrypt_aead_exit_tfm;\ninst->alg.setkey = pcrypt_aead_setkey;\ninst->alg.setauthsize = pcrypt_aead_setauthsize;\ninst->alg.encrypt = pcrypt_aead_encrypt;\ninst->alg.decrypt = pcrypt_aead_decrypt;\ninst->free = pcrypt_free;\nerr = aead_register_instance(tmpl, inst);\nif (err)\ngoto out_drop_aead;\nout:\nreturn err;\nout_drop_aead:\ncrypto_drop_aead(&ctx->spawn);\nout_free_inst:\nkfree(inst);\ngoto out;\n}", "label": 0}
{"index": 178352, "code": "rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n{\nrpm_mode_t fmode = rpmfilesFMode(fi, ix);\nrpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);\nrpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);\nconst char * fn = rpmfilesFN(fi, ix);\nstruct stat sb;\nrpmVerifyAttrs vfy = RPMVERIFY_NONE;\nswitch (rpmfilesFState(fi, ix)) {\ncase RPMFILE_STATE_NETSHARED:\ncase RPMFILE_STATE_NOTINSTALLED:\ngoto exit;\nbreak;\ncase RPMFILE_STATE_REPLACED:\nflags = RPMVERIFY_LSTATFAIL;\nbreak;\ncase RPMFILE_STATE_WRONGCOLOR:\nflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\nRPMVERIFY_MTIME | RPMVERIFY_RDEV);\nbreak;\ncase RPMFILE_STATE_NORMAL:\ncase RPMFILE_STATE_MISSING:\nbreak;\n}\nif (fn == NULL || lstat(fn, &sb) != 0) {\nvfy |= RPMVERIFY_LSTATFAIL;\ngoto exit;\n}\nif (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {\nvfy |= RPMVERIFY_LSTATFAIL;\ngoto exit;\n}\nif (S_ISLNK(sb.st_mode))\nflags &= ~(RPMVERIFY_MODE);\nelse\nflags &= ~(RPMVERIFY_LINKTO);\nif (!S_ISREG(sb.st_mode))\nflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\nRPMVERIFY_MTIME | RPMVERIFY_CAPS);\nif (fileAttrs & RPMFILE_GHOST)\nflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\nRPMVERIFY_MTIME | RPMVERIFY_LINKTO);\nflags &= ~(omitMask | RPMVERIFY_FAILURES);\nif (flags & RPMVERIFY_FILEDIGEST) {\nconst unsigned char *digest;\nint algo;\nsize_t diglen;\nif ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {\nunsigned char fdigest[diglen];\nrpm_loff_t fsize;\nif (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {\nvfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);\n} else {\nsb.st_size = fsize;\nif (memcmp(fdigest, digest, diglen))\nvfy |= RPMVERIFY_FILEDIGEST;\n}\n} else {\nvfy |= RPMVERIFY_FILEDIGEST;\n}\n}\nif (flags & RPMVERIFY_LINKTO) {\nchar linkto[1024+1];\nint size = 0;\nif ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)\nvfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);\nelse {\nconst char * flink = rpmfilesFLink(fi, ix);\nlinkto[size] = '\\0';\nif (flink == NULL || !rstreq(linkto, flink))\nvfy |= RPMVERIFY_LINKTO;\n}\n}\nif (flags & RPMVERIFY_FILESIZE) {\nif (sb.st_size != rpmfilesFSize(fi, ix))\nvfy |= RPMVERIFY_FILESIZE;\n}\nif (flags & RPMVERIFY_MODE) {\nrpm_mode_t metamode = fmode;\nrpm_mode_t filemode;\nfilemode = (rpm_mode_t)sb.st_mode;\nif (fileAttrs & RPMFILE_GHOST) {\nmetamode &= ~0xf000;\nfilemode &= ~0xf000;\n}\nif (metamode != filemode)\nvfy |= RPMVERIFY_MODE;\n#if WITH_ACL\nacl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);\nif (facl) {\nif (acl_equiv_mode(facl, NULL) == 1) {\nvfy |= RPMVERIFY_MODE;\n}\nacl_free(facl);\n}\n#endif\n}\nif (flags & RPMVERIFY_RDEV) {\nif (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)\n|| S_ISBLK(fmode) != S_ISBLK(sb.st_mode))\n{\nvfy |= RPMVERIFY_RDEV;\n} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {\nrpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);\nrpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);\nif (st_rdev != frdev)\nvfy |= RPMVERIFY_RDEV;\n}\n}\n#if WITH_CAP\nif (flags & RPMVERIFY_CAPS) {\ncap_t cap, fcap;\ncap = cap_from_text(rpmfilesFCaps(fi, ix));\nif (!cap) {\ncap = cap_from_text(\"=\");\n}\nfcap = cap_get_file(fn);\nif (!fcap) {\nfcap = cap_from_text(\"=\");\n}\nif (cap_compare(cap, fcap) != 0)\nvfy |= RPMVERIFY_CAPS;\ncap_free(fcap);\ncap_free(cap);\n}\n#endif\nif ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {\nvfy |= RPMVERIFY_MTIME;\n}\nif (flags & RPMVERIFY_USER) {\nconst char * name = rpmugUname(sb.st_uid);\nconst char * fuser = rpmfilesFUser(fi, ix);\nuid_t uid;\nint namematch = 0;\nint idmatch = 0;\nif (name && fuser)\nnamematch =  rstreq(name, fuser);\nif (fuser && rpmugUid(fuser, &uid) == 0)\nidmatch = (uid == sb.st_uid);\nif (namematch != idmatch) {\nrpmlog(RPMLOG_WARNING,\n_(\"Duplicate username or UID for user %s\\n\"), fuser);\n}\nif (!(namematch || idmatch))\nvfy |= RPMVERIFY_USER;\n}\nif (flags & RPMVERIFY_GROUP) {\nconst char * name = rpmugGname(sb.st_gid);\nconst char * fgroup = rpmfilesFGroup(fi, ix);\ngid_t gid;\nint namematch = 0;\nint idmatch = 0;\nif (name && fgroup)\nnamematch = rstreq(name, fgroup);\nif (fgroup && rpmugGid(fgroup, &gid) == 0)\nidmatch = (gid == sb.st_gid);\nif (namematch != idmatch) {\nrpmlog(RPMLOG_WARNING,\n_(\"Duplicate groupname or GID for group %s\\n\"), fgroup);\n}\nif (!(namematch || idmatch))\nvfy |= RPMVERIFY_GROUP;\n}\nexit:\nreturn vfy;\n}", "contrast": "rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n{\nrpm_mode_t fmode = rpmfilesFMode(fi, ix);\nrpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);\nrpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);\nconst char * fn = rpmfilesFN(fi, ix);\nstruct stat sb;\nrpmVerifyAttrs vfy = RPMVERIFY_NONE;\nswitch (rpmfilesFState(fi, ix)) {\ncase RPMFILE_STATE_NETSHARED:\ncase RPMFILE_STATE_NOTINSTALLED:\ngoto exit;\nbreak;\ncase RPMFILE_STATE_REPLACED:\nflags = RPMVERIFY_LSTATFAIL;\nbreak;\ncase RPMFILE_STATE_WRONGCOLOR:\nflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\nRPMVERIFY_MTIME | RPMVERIFY_RDEV);\nbreak;\ncase RPMFILE_STATE_NORMAL:\ncase RPMFILE_STATE_MISSING:\nbreak;\n}\nif (fn == NULL || lstat(fn, &sb) != 0) {\nvfy |= RPMVERIFY_LSTATFAIL;\ngoto exit;\n}\nif (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {\nstruct stat dsb;\nif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {\nuid_t fuid;\nif (sb.st_uid == 0 ||\n(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&\nsb.st_uid == fuid)) {\nsb = dsb;\n}\n}\n}\nif (S_ISLNK(sb.st_mode))\nflags &= ~(RPMVERIFY_MODE);\nelse\nflags &= ~(RPMVERIFY_LINKTO);\nif (!S_ISREG(sb.st_mode))\nflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\nRPMVERIFY_MTIME | RPMVERIFY_CAPS);\nif (fileAttrs & RPMFILE_GHOST)\nflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\nRPMVERIFY_MTIME | RPMVERIFY_LINKTO);\nflags &= ~(omitMask | RPMVERIFY_FAILURES);\nif (flags & RPMVERIFY_FILEDIGEST) {\nconst unsigned char *digest;\nint algo;\nsize_t diglen;\nif ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {\nunsigned char fdigest[diglen];\nrpm_loff_t fsize;\nif (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {\nvfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);\n} else {\nsb.st_size = fsize;\nif (memcmp(fdigest, digest, diglen))\nvfy |= RPMVERIFY_FILEDIGEST;\n}\n} else {\nvfy |= RPMVERIFY_FILEDIGEST;\n}\n}\nif (flags & RPMVERIFY_LINKTO) {\nchar linkto[1024+1];\nint size = 0;\nif ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)\nvfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);\nelse {\nconst char * flink = rpmfilesFLink(fi, ix);\nlinkto[size] = '\\0';\nif (flink == NULL || !rstreq(linkto, flink))\nvfy |= RPMVERIFY_LINKTO;\n}\n}\nif (flags & RPMVERIFY_FILESIZE) {\nif (sb.st_size != rpmfilesFSize(fi, ix))\nvfy |= RPMVERIFY_FILESIZE;\n}\nif (flags & RPMVERIFY_MODE) {\nrpm_mode_t metamode = fmode;\nrpm_mode_t filemode;\nfilemode = (rpm_mode_t)sb.st_mode;\nif (fileAttrs & RPMFILE_GHOST) {\nmetamode &= ~0xf000;\nfilemode &= ~0xf000;\n}\nif (metamode != filemode)\nvfy |= RPMVERIFY_MODE;\n#if WITH_ACL\nacl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);\nif (facl) {\nif (acl_equiv_mode(facl, NULL) == 1) {\nvfy |= RPMVERIFY_MODE;\n}\nacl_free(facl);\n}\n#endif\n}\nif (flags & RPMVERIFY_RDEV) {\nif (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)\n|| S_ISBLK(fmode) != S_ISBLK(sb.st_mode))\n{\nvfy |= RPMVERIFY_RDEV;\n} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {\nrpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);\nrpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);\nif (st_rdev != frdev)\nvfy |= RPMVERIFY_RDEV;\n}\n}\n#if WITH_CAP\nif (flags & RPMVERIFY_CAPS) {\ncap_t cap, fcap;\ncap = cap_from_text(rpmfilesFCaps(fi, ix));\nif (!cap) {\ncap = cap_from_text(\"=\");\n}\nfcap = cap_get_file(fn);\nif (!fcap) {\nfcap = cap_from_text(\"=\");\n}\nif (cap_compare(cap, fcap) != 0)\nvfy |= RPMVERIFY_CAPS;\ncap_free(fcap);\ncap_free(cap);\n}\n#endif\nif ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {\nvfy |= RPMVERIFY_MTIME;\n}\nif (flags & RPMVERIFY_USER) {\nconst char * name = rpmugUname(sb.st_uid);\nconst char * fuser = rpmfilesFUser(fi, ix);\nuid_t uid;\nint namematch = 0;\nint idmatch = 0;\nif (name && fuser)\nnamematch =  rstreq(name, fuser);\nif (fuser && rpmugUid(fuser, &uid) == 0)\nidmatch = (uid == sb.st_uid);\nif (namematch != idmatch) {\nrpmlog(RPMLOG_WARNING,\n_(\"Duplicate username or UID for user %s\\n\"), fuser);\n}\nif (!(namematch || idmatch))\nvfy |= RPMVERIFY_USER;\n}\nif (flags & RPMVERIFY_GROUP) {\nconst char * name = rpmugGname(sb.st_gid);\nconst char * fgroup = rpmfilesFGroup(fi, ix);\ngid_t gid;\nint namematch = 0;\nint idmatch = 0;\nif (name && fgroup)\nnamematch = rstreq(name, fgroup);\nif (fgroup && rpmugGid(fgroup, &gid) == 0)\nidmatch = (gid == sb.st_gid);\nif (namematch != idmatch) {\nrpmlog(RPMLOG_WARNING,\n_(\"Duplicate groupname or GID for group %s\\n\"), fgroup);\n}\nif (!(namematch || idmatch))\nvfy |= RPMVERIFY_GROUP;\n}\nexit:\nreturn vfy;\n}", "label": 0}
{"index": 178364, "code": "PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\nstatic const char module[] = \"PixarLogDecode\";\nTIFFDirectory *td = &tif->tif_dir;\nPixarLogState* sp = DecoderState(tif);\ntmsize_t i;\ntmsize_t nsamples;\nint llen;\nuint16 *up;\nswitch (sp->user_datafmt) {\ncase PIXARLOGDATAFMT_FLOAT:\nnsamples = occ / sizeof(float);\nbreak;\ncase PIXARLOGDATAFMT_16BIT:\ncase PIXARLOGDATAFMT_12BITPICIO:\ncase PIXARLOGDATAFMT_11BITLOG:\nnsamples = occ / sizeof(uint16);\nbreak;\ncase PIXARLOGDATAFMT_8BIT:\ncase PIXARLOGDATAFMT_8BITABGR:\nnsamples = occ;\nbreak;\ndefault:\nTIFFErrorExt(tif->tif_clientdata, module,\n\"%d bit input not supported in PixarLog\",\ntd->td_bitspersample);\nreturn 0;\n}\nllen = sp->stride * td->td_imagewidth;\n(void) s;\nassert(sp != NULL);\nsp->stream.next_out = (unsigned char *) sp->tbuf;\nassert(sizeof(sp->stream.avail_out)==4);\nsp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));\nif (sp->stream.avail_out != nsamples * sizeof(uint16))\n{\nTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\nreturn (0);\n}\ndo {\nint state = inflate(&sp->stream, Z_PARTIAL_FLUSH);\nif (state == Z_STREAM_END) {\nbreak;\n}\nif (state == Z_DATA_ERROR) {\nTIFFErrorExt(tif->tif_clientdata, module,\n\"Decoding error at scanline %lu, %s\",\n(unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : \"(null)\");\nif (inflateSync(&sp->stream) != Z_OK)\nreturn (0);\ncontinue;\n}\nif (state != Z_OK) {\nTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\nsp->stream.msg ? sp->stream.msg : \"(null)\");\nreturn (0);\n}\n} while (sp->stream.avail_out > 0);\nif (sp->stream.avail_out != 0) {\nTIFFErrorExt(tif->tif_clientdata, module,\n\"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\",\n(unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);\nreturn (0);\n}\nup = sp->tbuf;\nif (tif->tif_flags & TIFF_SWAB)\nTIFFSwabArrayOfShort(up, nsamples);\nif (nsamples % llen) {\nTIFFWarningExt(tif->tif_clientdata, module,\n\"stride %lu is not a multiple of sample count, \"\n\"%lu, data truncated.\", (unsigned long) llen, (unsigned long) nsamples);\nnsamples -= nsamples % llen;\n}\nfor (i = 0; i < nsamples; i += llen, up += llen) {\nswitch (sp->user_datafmt)  {\ncase PIXARLOGDATAFMT_FLOAT:\nhorizontalAccumulateF(up, llen, sp->stride,\n(float *)op, sp->ToLinearF);\nop += llen * sizeof(float);\nbreak;\ncase PIXARLOGDATAFMT_16BIT:\nhorizontalAccumulate16(up, llen, sp->stride,\n(uint16 *)op, sp->ToLinear16);\nop += llen * sizeof(uint16);\nbreak;\ncase PIXARLOGDATAFMT_12BITPICIO:\nhorizontalAccumulate12(up, llen, sp->stride,\n(int16 *)op, sp->ToLinearF);\nop += llen * sizeof(int16);\nbreak;\ncase PIXARLOGDATAFMT_11BITLOG:\nhorizontalAccumulate11(up, llen, sp->stride,\n(uint16 *)op);\nop += llen * sizeof(uint16);\nbreak;\ncase PIXARLOGDATAFMT_8BIT:\nhorizontalAccumulate8(up, llen, sp->stride,\n(unsigned char *)op, sp->ToLinear8);\nop += llen * sizeof(unsigned char);\nbreak;\ncase PIXARLOGDATAFMT_8BITABGR:\nhorizontalAccumulate8abgr(up, llen, sp->stride,\n(unsigned char *)op, sp->ToLinear8);\nop += llen * sizeof(unsigned char);\nbreak;\ndefault:\nTIFFErrorExt(tif->tif_clientdata, module,\n\"Unsupported bits/sample: %d\",\ntd->td_bitspersample);\nreturn (0);\n}\n}\nreturn (1);\n}", "contrast": "PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\nstatic const char module[] = \"PixarLogDecode\";\nTIFFDirectory *td = &tif->tif_dir;\nPixarLogState* sp = DecoderState(tif);\ntmsize_t i;\ntmsize_t nsamples;\nint llen;\nuint16 *up;\nswitch (sp->user_datafmt) {\ncase PIXARLOGDATAFMT_FLOAT:\nnsamples = occ / sizeof(float);\nbreak;\ncase PIXARLOGDATAFMT_16BIT:\ncase PIXARLOGDATAFMT_12BITPICIO:\ncase PIXARLOGDATAFMT_11BITLOG:\nnsamples = occ / sizeof(uint16);\nbreak;\ncase PIXARLOGDATAFMT_8BIT:\ncase PIXARLOGDATAFMT_8BITABGR:\nnsamples = occ;\nbreak;\ndefault:\nTIFFErrorExt(tif->tif_clientdata, module,\n\"%d bit input not supported in PixarLog\",\ntd->td_bitspersample);\nreturn 0;\n}\nllen = sp->stride * td->td_imagewidth;\n(void) s;\nassert(sp != NULL);\nsp->stream.next_out = (unsigned char *) sp->tbuf;\nassert(sizeof(sp->stream.avail_out)==4);\nsp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));\nif (sp->stream.avail_out != nsamples * sizeof(uint16))\n{\nTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\nreturn (0);\n}\nif (sp->stream.avail_out > sp->tbuf_size)\n{\nTIFFErrorExt(tif->tif_clientdata, module, \"sp->stream.avail_out > sp->tbuf_size\");\nreturn (0);\n}\ndo {\nint state = inflate(&sp->stream, Z_PARTIAL_FLUSH);\nif (state == Z_STREAM_END) {\nbreak;\n}\nif (state == Z_DATA_ERROR) {\nTIFFErrorExt(tif->tif_clientdata, module,\n\"Decoding error at scanline %lu, %s\",\n(unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : \"(null)\");\nif (inflateSync(&sp->stream) != Z_OK)\nreturn (0);\ncontinue;\n}\nif (state != Z_OK) {\nTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\nsp->stream.msg ? sp->stream.msg : \"(null)\");\nreturn (0);\n}\n} while (sp->stream.avail_out > 0);\nif (sp->stream.avail_out != 0) {\nTIFFErrorExt(tif->tif_clientdata, module,\n\"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\",\n(unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);\nreturn (0);\n}\nup = sp->tbuf;\nif (tif->tif_flags & TIFF_SWAB)\nTIFFSwabArrayOfShort(up, nsamples);\nif (nsamples % llen) {\nTIFFWarningExt(tif->tif_clientdata, module,\n\"stride %lu is not a multiple of sample count, \"\n\"%lu, data truncated.\", (unsigned long) llen, (unsigned long) nsamples);\nnsamples -= nsamples % llen;\n}\nfor (i = 0; i < nsamples; i += llen, up += llen) {\nswitch (sp->user_datafmt)  {\ncase PIXARLOGDATAFMT_FLOAT:\nhorizontalAccumulateF(up, llen, sp->stride,\n(float *)op, sp->ToLinearF);\nop += llen * sizeof(float);\nbreak;\ncase PIXARLOGDATAFMT_16BIT:\nhorizontalAccumulate16(up, llen, sp->stride,\n(uint16 *)op, sp->ToLinear16);\nop += llen * sizeof(uint16);\nbreak;\ncase PIXARLOGDATAFMT_12BITPICIO:\nhorizontalAccumulate12(up, llen, sp->stride,\n(int16 *)op, sp->ToLinearF);\nop += llen * sizeof(int16);\nbreak;\ncase PIXARLOGDATAFMT_11BITLOG:\nhorizontalAccumulate11(up, llen, sp->stride,\n(uint16 *)op);\nop += llen * sizeof(uint16);\nbreak;\ncase PIXARLOGDATAFMT_8BIT:\nhorizontalAccumulate8(up, llen, sp->stride,\n(unsigned char *)op, sp->ToLinear8);\nop += llen * sizeof(unsigned char);\nbreak;\ncase PIXARLOGDATAFMT_8BITABGR:\nhorizontalAccumulate8abgr(up, llen, sp->stride,\n(unsigned char *)op, sp->ToLinear8);\nop += llen * sizeof(unsigned char);\nbreak;\ndefault:\nTIFFErrorExt(tif->tif_clientdata, module,\n\"Unsupported bits/sample: %d\",\ntd->td_bitspersample);\nreturn (0);\n}\n}\nreturn (1);\n}", "label": 0}
{"index": 178369, "code": "static void flush_end_io(struct request *flush_rq, int error)\n{\nstruct request_queue *q = flush_rq->q;\nstruct list_head *running;\nbool queued = false;\nstruct request *rq, *n;\nunsigned long flags = 0;\nstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\nif (q->mq_ops) {\nspin_lock_irqsave(&fq->mq_flush_lock, flags);\nflush_rq->tag = -1;\n}\nrunning = &fq->flush_queue[fq->flush_running_idx];\nBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\nfq->flush_running_idx ^= 1;\nif (!q->mq_ops)\nelv_completed_request(q, flush_rq);\nlist_for_each_entry_safe(rq, n, running, flush.list) {\nunsigned int seq = blk_flush_cur_seq(rq);\nBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\nqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n}\nif (queued || fq->flush_queue_delayed) {\nWARN_ON(q->mq_ops);\nblk_run_queue_async(q);\n}\nfq->flush_queue_delayed = 0;\nif (q->mq_ops)\nspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "contrast": "static void flush_end_io(struct request *flush_rq, int error)\n{\nstruct request_queue *q = flush_rq->q;\nstruct list_head *running;\nbool queued = false;\nstruct request *rq, *n;\nunsigned long flags = 0;\nstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\nif (q->mq_ops) {\nstruct blk_mq_hw_ctx *hctx;\nspin_lock_irqsave(&fq->mq_flush_lock, flags);\nhctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\nblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\nflush_rq->tag = -1;\n}\nrunning = &fq->flush_queue[fq->flush_running_idx];\nBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\nfq->flush_running_idx ^= 1;\nif (!q->mq_ops)\nelv_completed_request(q, flush_rq);\nlist_for_each_entry_safe(rq, n, running, flush.list) {\nunsigned int seq = blk_flush_cur_seq(rq);\nBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\nqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n}\nif (queued || fq->flush_queue_delayed) {\nWARN_ON(q->mq_ops);\nblk_run_queue_async(q);\n}\nfq->flush_queue_delayed = 0;\nif (q->mq_ops)\nspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "label": 0}
{"index": 178386, "code": "static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,\nPacket *p, Flow * const pflow)\n{\nPACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);\nPacketPatternCleanup(det_ctx);\nif (pflow != NULL) {\nif (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {\nStreamReassembleRawUpdateProgress(pflow->protoctx, p,\ndet_ctx->raw_stream_progress);\nDetectEngineCleanHCBDBuffers(det_ctx);\n}\n}\nPACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);\nSCReturn;\n}", "contrast": "static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,\nPacket *p, Flow * const pflow)\n{\nPACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);\nPacketPatternCleanup(det_ctx);\nif (pflow != NULL) {\nif (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&\n(p->flags & PKT_STREAM_EST))\n{\nStreamReassembleRawUpdateProgress(pflow->protoctx, p,\ndet_ctx->raw_stream_progress);\nDetectEngineCleanHCBDBuffers(det_ctx);\n}\n}\nPACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);\nSCReturn;\n}", "label": 0}
{"index": 178410, "code": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\nunsigned char multicast_spec, u8 protocol_version)\n{\nstruct hsr_priv *hsr;\nstruct hsr_port *port;\nint res;\nhsr = netdev_priv(hsr_dev);\nINIT_LIST_HEAD(&hsr->ports);\nINIT_LIST_HEAD(&hsr->node_db);\nINIT_LIST_HEAD(&hsr->self_node_db);\nether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\nres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\nslave[1]->dev_addr);\nif (res < 0)\nreturn res;\nspin_lock_init(&hsr->seqnr_lock);\nhsr->sequence_nr = HSR_SEQNR_START;\nhsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\ntimer_setup(&hsr->announce_timer, hsr_announce, 0);\ntimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\nether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\nhsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\nhsr->protVersion = protocol_version;\nnetif_carrier_off(hsr_dev);\nres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\nif (res)\nreturn res;\nres = register_netdevice(hsr_dev);\nif (res)\ngoto fail;\nres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\nif (res)\ngoto fail;\nres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\nif (res)\ngoto fail;\nmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\nreturn 0;\nfail:\nhsr_for_each_port(hsr, port)\nhsr_del_port(port);\nreturn res;\n}", "contrast": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\nunsigned char multicast_spec, u8 protocol_version)\n{\nstruct hsr_priv *hsr;\nstruct hsr_port *port;\nint res;\nhsr = netdev_priv(hsr_dev);\nINIT_LIST_HEAD(&hsr->ports);\nINIT_LIST_HEAD(&hsr->node_db);\nINIT_LIST_HEAD(&hsr->self_node_db);\nether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\nres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\nslave[1]->dev_addr);\nif (res < 0)\nreturn res;\nspin_lock_init(&hsr->seqnr_lock);\nhsr->sequence_nr = HSR_SEQNR_START;\nhsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\ntimer_setup(&hsr->announce_timer, hsr_announce, 0);\ntimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\nether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\nhsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\nhsr->protVersion = protocol_version;\nnetif_carrier_off(hsr_dev);\nres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\nif (res)\ngoto err_add_port;\nres = register_netdevice(hsr_dev);\nif (res)\ngoto fail;\nres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\nif (res)\ngoto fail;\nres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\nif (res)\ngoto fail;\nmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\nreturn 0;\nfail:\nhsr_for_each_port(hsr, port)\nhsr_del_port(port);\nerr_add_port:\nhsr_del_node(&hsr->self_node_db);\nreturn res;\n}", "label": 0}
{"index": 178435, "code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\nconst char **nextPtr) {\nconst char *next = s;\nint tok = XmlPrologTok(parser->m_encoding, s, end, &next);\nreturn doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n(XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "contrast": "prologProcessor(XML_Parser parser, const char *s, const char *end,\nconst char **nextPtr) {\nconst char *next = s;\nint tok = XmlPrologTok(parser->m_encoding, s, end, &next);\nreturn doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n(XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}", "label": 0}
{"index": 178444, "code": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size)\n{\nif (ms)\n{\nint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\nif (nestsize == 0 && ms->nest_level == 0)\nnestsize = ms->buffer_size_longs;\nif (size + 2 <= nestsize) return GPMF_OK;\n}\nreturn GPMF_ERROR_BAD_STRUCTURE;\n}", "contrast": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size)\n{\nif (ms)\n{\nuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\nif (nestsize == 0 && ms->nest_level == 0)\nnestsize = ms->buffer_size_longs;\nif (size + 2 <= nestsize) return GPMF_OK;\n}\nreturn GPMF_ERROR_BAD_STRUCTURE;\n}", "label": 0}
{"index": 178446, "code": "double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n{\nmp4object *mp4 = (mp4object *)handle;\nif (mp4 == NULL) return 0.0;\nGPMF_stream metadata_stream, *ms = &metadata_stream;\nuint32_t teststart = 0;\nuint32_t testend = mp4->indexcount;\ndouble rate = 0.0;\nif (mp4->indexcount < 1)\nreturn 0.0;\nif (mp4->indexcount > 3)\n{\nteststart++;\ntestend--;\n}\nuint32_t *payload = GetPayload(handle, NULL, teststart);\nuint32_t payloadsize = GetPayloadSize(handle, teststart);\nint32_t ret = GPMF_Init(ms, payload, payloadsize);\nif (ret != GPMF_OK)\ngoto cleanup;\n{\nuint32_t startsamples = 0;\nuint32_t endsamples = 0;\nuint32_t missing_samples = 0;\nwhile (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n{\nmissing_samples = 1;\nteststart++;\npayload = GetPayload(handle, payload, teststart);\npayloadsize = GetPayloadSize(handle, teststart);\nret = GPMF_Init(ms, payload, payloadsize);\n}\nif (missing_samples)\n{\nteststart++;\npayload = GetPayload(handle, payload, teststart);\npayloadsize = GetPayloadSize(handle, teststart);\nret = GPMF_Init(ms, payload, payloadsize);\n}\nif (ret == GPMF_OK)\n{\nuint32_t samples = GPMF_Repeat(ms);\nGPMF_stream find_stream;\nGPMF_CopyState(ms, &find_stream);\nif (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n{\nstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\npayload = GetPayload(handle, payload, testend);\npayloadsize = GetPayloadSize(handle, testend);\nret = GPMF_Init(ms, payload, payloadsize);\nif (ret != GPMF_OK)\ngoto cleanup;\nif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n{\nGPMF_CopyState(ms, &find_stream);\nif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n{\nendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\nrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\ngoto cleanup;\n}\n}\nrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n}\nelse\n{\nuint32_t payloadpos = 0, payloadcount = 0;\ndouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\nuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\nmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\nsamples = 0;\nfor (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)\n{\npayload = GetPayload(handle, payload, payloadpos);\npayloadsize = GetPayloadSize(handle, payloadpos);\nret = GPMF_Init(ms, payload, payloadsize);\nif (ret != GPMF_OK)\ngoto cleanup;\nif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n{\nGPMF_stream find_stream2;\nGPMF_CopyState(ms, &find_stream2);\nif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL))\n{\nif (repeatarray)\n{\nfloat in, out;\ndo\n{\nsamples++;\n} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\nrepeatarray[payloadpos] = samples;\nmeanY += (double)samples;\nGetPayloadTime(handle, payloadpos, &in, &out);\nmeanX += out;\n}\n}\nelse\n{\nuint32_t repeat = GPMF_Repeat(ms);\nsamples += repeat;\nif (repeatarray)\n{\nfloat in, out;\nrepeatarray[payloadpos] = samples;\nmeanY += (double)samples;\nGetPayloadTime(handle, payloadpos, &in, &out);\nmeanX += out;\n}\n}\n}\n}\nif (repeatarray)\n{\nmeanY /= (double)payloadcount;\nmeanX /= (double)payloadcount;\nfor (payloadpos = teststart; payloadpos < testend; payloadpos++)\n{\nfloat in, out;\nGetPayloadTime(handle, payloadpos, &in, &out);\ntop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\nbot += ((double)out - meanX)*((double)out - meanX);\n}\nslope = top / bot;\n#if 0\n{\ndouble intercept;\nintercept = meanY - slope*meanX;\nprintf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);\n}\n#endif\nrate = slope;\n}\nelse\n{\nrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n}\nfree(repeatarray);\ngoto cleanup;\n}\n}\n}\ncleanup:\nif (payload)\n{\nFreePayload(payload);\npayload = NULL;\n}\nreturn rate;\n}", "contrast": "double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\ndouble GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)\n{\nmp4object *mp4 = (mp4object *)handle;\nif (mp4 == NULL) return 0.0;\nGPMF_stream metadata_stream, *ms = &metadata_stream;\nuint32_t teststart = 0;\nuint32_t testend = mp4->indexcount;\ndouble rate = 0.0;\nuint32_t *payload;\nuint32_t payloadsize;\nint32_t ret;\nif (mp4->indexcount < 1)\nreturn 0.0;\npayload = GetPayload(handle, NULL, teststart);\npayloadsize = GetPayloadSize(handle, teststart);\nret = GPMF_Init(ms, payload, payloadsize);\nif (ret != GPMF_OK)\ngoto cleanup;\n{\nuint64_t minimumtimestamp = 0;\nuint64_t starttimestamp = 0;\nuint64_t endtimestamp = 0;\nuint32_t startsamples = 0;\nuint32_t endsamples = 0;\ndouble intercept = 0.0;\nwhile (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n{\nteststart++;\npayload = GetPayload(handle, payload, teststart);\npayloadsize = GetPayloadSize(handle, teststart);\nret = GPMF_Init(ms, payload, payloadsize);\n}\nif (ret == GPMF_OK && payload)\n{\nuint32_t samples = GPMF_PayloadSampleCount(ms);\nGPMF_stream find_stream;\nGPMF_CopyState(ms, &find_stream);\nif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\nstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\nGPMF_CopyState(ms, &find_stream);\nif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\nstarttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\nif (starttimestamp)\n{\nGPMF_stream any_stream;\nGPMF_Init(&any_stream, payload, payloadsize);\nminimumtimestamp = starttimestamp;\nwhile (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))\n{\nuint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));\nif (timestamp < minimumtimestamp)\nminimumtimestamp = timestamp;\n}\n}\ntestend = mp4->indexcount;\ndo\n{\ntestend--;\npayload = GetPayload(handle, payload, testend);\npayloadsize = GetPayloadSize(handle, testend);\nret = GPMF_Init(ms, payload, payloadsize);\n} while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\nGPMF_CopyState(ms, &find_stream);\nif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\nendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\nelse\n{\nuint32_t i;\nfor (i = teststart; i <= testend; i++)\n{\npayload = GetPayload(handle,payload, i);\npayloadsize = GetPayloadSize(handle, i);\nif (GPMF_OK == GPMF_Init(ms, payload, payloadsize))\nif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\nendsamples += GPMF_PayloadSampleCount(ms);\n}\n}\nif (starttimestamp != 0)\n{\nuint32_t last_samples = GPMF_PayloadSampleCount(ms);\nuint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;\ndouble time_stamp_scale = 1000000000.0;\nGPMF_CopyState(ms, &find_stream);\nif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\nendtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\nif (endtimestamp)\n{\ndouble approxrate = 0.0;\nif (endsamples > startsamples)\napproxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\nif (approxrate == 0.0)\napproxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\nwhile (time_stamp_scale >= 1)\n{\nrate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);\nif (rate*0.9 < approxrate && approxrate < rate*1.1)\nbreak;\ntime_stamp_scale *= 0.1;\n}\nif (time_stamp_scale < 1.0) rate = 0.0;\nintercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;\n}\n}\nif (rate == 0.0)\n{\nif (!(flags & GPMF_SAMPLE_RATE_PRECISE))\n{\nif (endsamples > startsamples)\nrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\nif (rate == 0.0)\nrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\ndouble in, out;\nif (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))\nintercept = (double)-in * rate;\n}\nelse\n{\nuint32_t payloadpos = 0, payloadcount = 0;\ndouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\nuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\nmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\nsamples = 0;\nfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n{\npayload = GetPayload(handle, payload, payloadpos);\npayloadsize = GetPayloadSize(handle, payloadpos);\nret = GPMF_Init(ms, payload, payloadsize);\nif (ret != GPMF_OK)\ngoto cleanup;\nif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n{\nGPMF_stream find_stream2;\nGPMF_CopyState(ms, &find_stream2);\npayloadcount++;\nif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL))\n{\nif (repeatarray)\n{\ndouble in, out;\ndo\n{\nsamples++;\n} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\nrepeatarray[payloadpos] = samples;\nmeanY += (double)samples;\nif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\nmeanX += out;\n}\n}\nelse\n{\nuint32_t repeat = GPMF_PayloadSampleCount(ms);\nsamples += repeat;\nif (repeatarray)\n{\ndouble in, out;\nrepeatarray[payloadpos] = samples;\nmeanY += (double)samples;\nif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\nmeanX += out;\n}\n}\n}\nelse\n{\nrepeatarray[payloadpos] = 0;\n}\n}\nif (repeatarray)\n{\nmeanY /= (double)payloadcount;\nmeanX /= (double)payloadcount;\nfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n{\ndouble in, out;\nif (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n{\ntop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\nbot += ((double)out - meanX)*((double)out - meanX);\n}\n}\nslope = top / bot;\nrate = slope;\nintercept = meanY - slope * meanX;\n#if 0\nprintf(\"%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);\nprintf(\"%c%c%c%c first sample at time %.3fms\\n\", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);\n#endif\n}\nelse\n{\nrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n}\nfree(repeatarray);\n}\n}", "label": 0}
{"index": 178450, "code": "size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)\n{\nmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));\nif (mp4 == NULL) return 0;\nmemset(mp4, 0, sizeof(mp4object));\n#ifdef _WINDOWS\nfopen_s(&mp4->mediafp, filename, \"rb\");\n#else\nmp4->mediafp = fopen(filename, \"rb\");\n#endif\nif (mp4->mediafp)\n{\nuint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;\nsize_t len;\nint32_t nest = 0;\nuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\nuint64_t lastsize = 0, qtsize;\ndo\n{\nlen = fread(&qtsize32, 1, 4, mp4->mediafp);\nlen += fread(&qttag, 1, 4, mp4->mediafp);\nif (len == 8)\n{\nif (!VALID_FOURCC(qttag))\n{\nLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\nNESTSIZE(lastsize - 8);\ncontinue;\n}\nqtsize32 = BYTESWAP32(qtsize32);\nif (qtsize32 == 1)\n{\nfread(&qtsize, 1, 8, mp4->mediafp);\nqtsize = BYTESWAP64(qtsize) - 8;\n}\nelse\nqtsize = qtsize32;\nnest++;\nif (qtsize < 8) break;\nif (nest >= MAX_NEST_LEVEL) break;\nnestsize[nest] = qtsize;\nlastsize = qtsize;\n#if PRINT_MP4_STRUCTURE\nfor (int i = 1; i < nest; i++) printf(\"    \");\nprintf(\"%c%c%c%c (%lld)\\n\", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);\nif (qttag == MAKEID('m', 'd', 'a', 't') ||\nqttag == MAKEID('f', 't', 'y', 'p') ||\nqttag == MAKEID('u', 'd', 't', 'a'))\n{\nLONGSEEK(mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\ncontinue;\n}\n#else\nif (qttag != MAKEID('m', 'o', 'o', 'v') &&\nqttag != MAKEID('m', 'v', 'h', 'd') &&\nqttag != MAKEID('t', 'r', 'a', 'k') &&\nqttag != MAKEID('m', 'd', 'i', 'a') &&\nqttag != MAKEID('m', 'd', 'h', 'd') &&\nqttag != MAKEID('m', 'i', 'n', 'f') &&\nqttag != MAKEID('g', 'm', 'i', 'n') &&\nqttag != MAKEID('d', 'i', 'n', 'f') &&\nqttag != MAKEID('a', 'l', 'i', 's') &&\nqttag != MAKEID('s', 't', 's', 'd') &&\nqttag != MAKEID('a', 'l', 'i', 's') &&\nqttag != MAKEID('a', 'l', 'i', 's') &&\nqttag != MAKEID('s', 't', 'b', 'l') &&\nqttag != MAKEID('s', 't', 't', 's') &&\nqttag != MAKEID('s', 't', 's', 'c') &&\nqttag != MAKEID('s', 't', 's', 'z') &&\nqttag != MAKEID('s', 't', 'c', 'o') &&\nqttag != MAKEID('c', 'o', '6', '4') &&\nqttag != MAKEID('h', 'd', 'l', 'r'))\n{\nLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse\n#endif\nif (qttag == MAKEID('m', 'v', 'h', 'd'))\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);\nlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('m', 'd', 'h', 'd'))\n{\nmedia_header md;\nlen = fread(&md, 1, sizeof(md), mp4->mediafp);\nif (len == sizeof(md))\n{\nmd.creation_time = BYTESWAP32(md.creation_time);\nmd.modification_time = BYTESWAP32(md.modification_time);\nmd.time_scale = BYTESWAP32(md.time_scale);\nmd.duration = BYTESWAP32(md.duration);\nmp4->trak_clockdemon = md.time_scale;\nmp4->trak_clockcount = md.duration;\nif (mp4->videolength == 0.0)\n{\nmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);\n}\n}\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('h', 'd', 'l', 'r'))\n{\nuint32_t temp;\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&temp, 1, 4, mp4->mediafp);\nif (temp != MAKEID('a', 'l', 'i', 's'))\ntype = temp;\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 's', 'd'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&subtype, 1, 4, mp4->mediafp);\nif (len == 16)\n{\nif (subtype != traksubtype)\n{\ntype = 0;\n}\n}\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\n}\nelse\nLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 's', 'c'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 12 <= qtsize - 8 - len)\n{\nmp4->metastsc_count = num;\nif (mp4->metastsc) free(mp4->metastsc);\nmp4->metastsc = (SampleToChunk *)malloc(num * 12);\nif (mp4->metastsc)\n{\nuint32_t total_stsc = num;\nlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\ndo\n{\nnum--;\nmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\nmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\nmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n} while (num > 0);\n}\nif (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1)\n{\nif (mp4->metastsc) free(mp4->metastsc);\nmp4->metastsc = NULL;\nmp4->metastsc_count = 0;\n}\n}\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\n}\nelse\nLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 's', 'z'))\n{\nif (type == traktype)\n{\nuint32_t equalsamplesize;\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&equalsamplesize, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 4 <= qtsize - 8 - len)\n{\nmp4->metasize_count = num;\nif (mp4->metasizes) free(mp4->metasizes);\nmp4->metasizes = (uint32_t *)malloc(num * 4);\nif (mp4->metasizes)\n{\nif (equalsamplesize == 0)\n{\nlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\ndo\n{\nnum--;\nmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n} while (num > 0);\n}\nelse\n{\nequalsamplesize = BYTESWAP32(equalsamplesize);\ndo\n{\nnum--;\nmp4->metasizes[num] = equalsamplesize;\n} while (num > 0);\n}\n}\n}\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\n}\nelse\nLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 'c', 'o'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 4 <= qtsize - 8 - len)\n{\nif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n{\nmp4->indexcount = mp4->metasize_count;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\nif (mp4->metaoffsets)\n{\nuint32_t *metaoffsets32 = NULL;\nmetaoffsets32 = (uint32_t *)malloc(num * 4);\nif (metaoffsets32)\n{\nuint64_t fileoffset = 0;\nint stsc_pos = 0;\nint stco_pos = 0;\nint repeat = 1;\nlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\ndo\n{\nnum--;\nmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n} while (num > 0);\nmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\nnum = 1;\nwhile (num < mp4->metasize_count)\n{\nif (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)\n{\nstco_pos++; stsc_pos++;\nfileoffset = (uint64_t)metaoffsets32[stco_pos];\nrepeat = 1;\n}\nelse if (repeat == mp4->metastsc[stsc_pos].samples)\n{\nstco_pos++;\nfileoffset = (uint64_t)metaoffsets32[stco_pos];\nrepeat = 1;\n}\nelse\n{\nfileoffset += (uint64_t)mp4->metasizes[num - 1];\nrepeat++;\n}\nmp4->metaoffsets[num] = fileoffset;\nnum++;\n}\nif (mp4->metastsc) free(mp4->metastsc);\nmp4->metastsc = NULL;\nmp4->metastsc_count = 0;\nfree(metaoffsets32);\n}\n}\n}\nelse\n{\nmp4->indexcount = num;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nmp4->metaoffsets = (uint64_t *)malloc(num * 8);\nif (mp4->metaoffsets)\n{\nuint32_t *metaoffsets32 = NULL;\nmetaoffsets32 = (uint32_t *)malloc(num * 4);\nif (metaoffsets32)\n{\nsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\nlen += readlen;\ndo\n{\nnum--;\nmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n} while (num > 0);\nfree(metaoffsets32);\n}\n}\n}\n}\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\n}\nelse\nLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('c', 'o', '6', '4'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 8 <= qtsize - 8 - len)\n{\nif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n{\nmp4->indexcount = mp4->metasize_count;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\nif (mp4->metaoffsets)\n{\nuint64_t *metaoffsets64 = NULL;\nmetaoffsets64 = (uint64_t *)malloc(num * 8);\nif (metaoffsets64)\n{\nuint64_t fileoffset = 0;\nint stsc_pos = 0;\nint stco_pos = 0;\nlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\ndo\n{\nnum--;\nmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n} while (num > 0);\nfileoffset = metaoffsets64[0];\nmp4->metaoffsets[0] = fileoffset;\nnum = 1;\nwhile (num < mp4->metasize_count)\n{\nif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n{\nstco_pos++;\nfileoffset = (uint64_t)metaoffsets64[stco_pos];\n}\nelse\n{\nfileoffset += (uint64_t)mp4->metasizes[num - 1];\n}\nmp4->metaoffsets[num] = fileoffset;\nnum++;\n}\nif (mp4->metastsc) free(mp4->metastsc);\nmp4->metastsc = NULL;\nmp4->metastsc_count = 0;\nfree(metaoffsets64);\n}\n}\n}\nelse\n{\nmp4->indexcount = num;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nmp4->metaoffsets = (uint64_t *)malloc(num * 8);\nif (mp4->metaoffsets)\n{\nlen += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);\ndo\n{\nnum--;\nmp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);\n} while (num > 0);\n}\n}\n}\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\n}\nelse\nLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 't', 's'))\n{\nif (type == traktype)\n{\nuint32_t totaldur = 0, samples = 0;\nint32_t entries = 0;\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 8 <= qtsize - 8 - len)\n{\nentries = num;\nmp4->meta_clockdemon = mp4->trak_clockdemon;\nmp4->meta_clockcount = mp4->trak_clockcount;\nwhile (entries > 0)\n{\nint32_t samplecount;\nint32_t duration;\nlen += fread(&samplecount, 1, 4, mp4->mediafp);\nsamplecount = BYTESWAP32(samplecount);\nlen += fread(&duration, 1, 4, mp4->mediafp);\nduration = BYTESWAP32(duration);\nsamples += samplecount;\nentries--;\ntotaldur += duration;\nmp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);\n}\nmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;\n}\nLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);\n}\nelse\nLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\nNESTSIZE(qtsize);\n}\nelse\n{\nNESTSIZE(8);\n}\n}\nelse\n{\nbreak;\n}\n} while (len > 0);\n}\nelse\n{\nfree(mp4);\nmp4 = NULL;\n}\nreturn (size_t)mp4;\n}", "contrast": "size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)\n{\nmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));\nif (mp4 == NULL) return 0;\nmemset(mp4, 0, sizeof(mp4object));\nstruct stat64 mp4stat;\nstat64(filename, &mp4stat);\nmp4->filesize = mp4stat.st_size;\nif (mp4->filesize < 64) return 0;\n#ifdef _WINDOWS\nfopen_s(&mp4->mediafp, filename, \"rb\");\n#else\nmp4->mediafp = fopen(filename, \"rb\");\n#endif\nif (mp4->mediafp)\n{\nuint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;\nsize_t len;\nint32_t nest = 0;\nuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\nuint64_t lastsize = 0, qtsize;\ndo\n{\nlen = fread(&qtsize32, 1, 4, mp4->mediafp);\nlen += fread(&qttag, 1, 4, mp4->mediafp);\nmp4->filepos += len;\nif (len == 8 && mp4->filepos < mp4->filesize)\n{\nif (!VALID_FOURCC(qttag))\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\nbreak;\n}\nqtsize32 = BYTESWAP32(qtsize32);\nif (qtsize32 == 1)\n{\nlen = fread(&qtsize, 1, 8, mp4->mediafp);\nmp4->filepos += len;\nqtsize = BYTESWAP64(qtsize) - 8;\n}\nelse\nqtsize = qtsize32;\nnest++;\nif (qtsize < 8) break;\nif (nest >= MAX_NEST_LEVEL) break;\nnestsize[nest] = qtsize;\nlastsize = qtsize;\n#if PRINT_MP4_STRUCTURE\nfor (int i = 1; i < nest; i++) printf(\"    \");\nprintf(\"%c%c%c%c (%lld)\\n\", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);\nif (qttag == MAKEID('m', 'd', 'a', 't') ||\nqttag == MAKEID('f', 't', 'y', 'p') ||\nqttag == MAKEID('u', 'd', 't', 'a') ||\nqttag == MAKEID('f', 'r', 'e', 'e'))\n{\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\ncontinue;\n}\n#else\nif (qttag != MAKEID('m', 'o', 'o', 'v') &&\nqttag != MAKEID('m', 'v', 'h', 'd') &&\nqttag != MAKEID('t', 'r', 'a', 'k') &&\nqttag != MAKEID('m', 'd', 'i', 'a') &&\nqttag != MAKEID('m', 'd', 'h', 'd') &&\nqttag != MAKEID('m', 'i', 'n', 'f') &&\nqttag != MAKEID('g', 'm', 'i', 'n') &&\nqttag != MAKEID('d', 'i', 'n', 'f') &&\nqttag != MAKEID('a', 'l', 'i', 's') &&\nqttag != MAKEID('s', 't', 's', 'd') &&\nqttag != MAKEID('s', 't', 'b', 'l') &&\nqttag != MAKEID('s', 't', 't', 's') &&\nqttag != MAKEID('s', 't', 's', 'c') &&\nqttag != MAKEID('s', 't', 's', 'z') &&\nqttag != MAKEID('s', 't', 'c', 'o') &&\nqttag != MAKEID('c', 'o', '6', '4') &&\nqttag != MAKEID('h', 'd', 'l', 'r'))\n{\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\n}\nelse\n#endif\nif (qttag == MAKEID('m', 'v', 'h', 'd'))\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);\nlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('m', 'd', 'h', 'd'))\n{\nmedia_header md;\nlen = fread(&md, 1, sizeof(md), mp4->mediafp);\nif (len == sizeof(md))\n{\nmd.creation_time = BYTESWAP32(md.creation_time);\nmd.modification_time = BYTESWAP32(md.modification_time);\nmd.time_scale = BYTESWAP32(md.time_scale);\nmd.duration = BYTESWAP32(md.duration);\nmp4->trak_clockdemon = md.time_scale;\nmp4->trak_clockcount = md.duration;\nif (mp4->videolength == 0.0)\n{\nmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);\n}\n}\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('h', 'd', 'l', 'r'))\n{\nuint32_t temp;\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&temp, 1, 4, mp4->mediafp);\nif (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))\ntype = temp;\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 's', 'd'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&subtype, 1, 4, mp4->mediafp);\nif (len == 16)\n{\nif (subtype != traksubtype)\n{\ntype = 0;\n}\n}\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\n}\nelse\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 's', 'c'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 12 <= qtsize - 8 - len)\n{\nmp4->metastsc_count = num;\nif (mp4->metastsc) free(mp4->metastsc);\nif (num > 0)\n{\nmp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));\nif (mp4->metastsc)\n{\nlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\ndo\n{\nnum--;\nmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\nmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\nmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n} while (num > 0);\n}\n}\nelse\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\nbreak;\n}\n}\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\n}\nelse\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 's', 'z'))\n{\nif (type == traktype)\n{\nuint32_t equalsamplesize;\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&equalsamplesize, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 4 <= qtsize - 8 - len)\n{\nmp4->metasize_count = num;\nif (mp4->metasizes) free(mp4->metasizes);\nif(num > 0)\n{\nmp4->metasizes = (uint32_t *)malloc(num * 4);\nif (mp4->metasizes)\n{\nif (equalsamplesize == 0)\n{\nlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\ndo\n{\nnum--;\nmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n} while (num > 0);\n}\nelse\n{\nequalsamplesize = BYTESWAP32(equalsamplesize);\ndo\n{\nnum--;\nmp4->metasizes[num] = equalsamplesize;\n} while (num > 0);\n}\n}\n}\nelse\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\nbreak;\n}\n}\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\n}\nelse\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 'c', 'o'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 4 <= qtsize - 8 - len)\n{\nuint32_t metastco_count = num;\nif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n{\nmp4->indexcount = num;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nif(num > 0)\n{\nmp4->metaoffsets = (uint64_t *)malloc(num * 8);\nif (mp4->metaoffsets)\n{\nuint32_t *metaoffsets32 = NULL;\nmetaoffsets32 = (uint32_t *)malloc(num * 4);\nif (metaoffsets32)\n{\nuint64_t fileoffset = 0;\nint stsc_pos = 0;\nint stco_pos = 0;\nint repeat = 1;\nlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\ndo\n{\nnum--;\nmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n} while (num > 0);\nmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\nnum = 1;\nwhile (num < mp4->indexcount)\n{\nif ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)\n{\nif ((uint32_t)stco_pos + 1 < metastco_count)\n{\nstco_pos++;\nfileoffset = (uint64_t)metaoffsets32[stco_pos];\n}\nelse\n{\nfileoffset += (uint64_t)mp4->metasizes[num - 1];\n}\nif ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)\nif (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)\nstsc_pos++;\nrepeat = 1;\n}\nelse\n{\nfileoffset += (uint64_t)mp4->metasizes[num - 1];\nrepeat++;\n}\nmp4->metaoffsets[num] = fileoffset;\nnum++;\n}\nif (mp4->metastsc) free(mp4->metastsc);\nmp4->metastsc = NULL;\nmp4->metastsc_count = 0;\nfree(metaoffsets32);\n}\n}\n}\nelse\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\nbreak;\n}\n}\nelse\n{\nmp4->indexcount = num;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nif (num > 0)\n{\nmp4->metaoffsets = (uint64_t *)malloc(num * 8);\nif (mp4->metaoffsets)\n{\nuint32_t *metaoffsets32 = NULL;\nmetaoffsets32 = (uint32_t *)malloc(num * 4);\nif (metaoffsets32)\n{\nsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\nlen += readlen;\ndo\n{\nnum--;\nmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n} while (num > 0);\nfree(metaoffsets32);\n}\n}\n}\nelse\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\nbreak;\n}\n}\n}\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\n}\nelse\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('c', 'o', '6', '4'))\n{\nif (type == traktype)\n{\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif(num == 0)\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\nbreak;\n}\nif (num * 8 <= qtsize - 8 - len)\n{\nif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n{\nmp4->indexcount = mp4->metasize_count;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nif (mp4->metasize_count)\n{\nmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\nif (mp4->metaoffsets)\n{\nuint64_t *metaoffsets64 = NULL;\nmetaoffsets64 = (uint64_t *)malloc(num * 8);\nif (metaoffsets64)\n{\nuint64_t fileoffset = 0;\nint stsc_pos = 0;\nint stco_pos = 0;\nlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\ndo\n{\nnum--;\nmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n} while (num > 0);\nfileoffset = metaoffsets64[0];\nmp4->metaoffsets[0] = fileoffset;\nnum = 1;\nwhile (num < mp4->metasize_count)\n{\nif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n{\nstco_pos++;\nfileoffset = (uint64_t)metaoffsets64[stco_pos];\n}\nelse\n{\nfileoffset += (uint64_t)mp4->metasizes[num - 1];\n}\nmp4->metaoffsets[num] = fileoffset;\nnum++;\n}\nif (mp4->metastsc) free(mp4->metastsc);\nmp4->metastsc = NULL;\nmp4->metastsc_count = 0;\nfree(metaoffsets64);\n}\n}\n}\nelse\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\nbreak;\n}\n}\nelse\n{\nmp4->indexcount = num;\nif (mp4->metaoffsets) free(mp4->metaoffsets);\nmp4->metaoffsets = (uint64_t *)malloc(num * 8);\nif (mp4->metaoffsets)\n{\nlen += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);\ndo\n{\nnum--;\nmp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);\n} while (num > 0);\n}\n}\n}\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\n}\nelse\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\n}\nelse if (qttag == MAKEID('s', 't', 't', 's'))\n{\nif (type == traktype)\n{\nuint32_t totaldur = 0, samples = 0;\nint32_t entries = 0;\nlen = fread(&skip, 1, 4, mp4->mediafp);\nlen += fread(&num, 1, 4, mp4->mediafp);\nnum = BYTESWAP32(num);\nif (num * 8 <= qtsize - 8 - len)\n{\nentries = num;\nmp4->meta_clockdemon = mp4->trak_clockdemon;\nmp4->meta_clockcount = mp4->trak_clockcount;\nwhile (entries > 0)\n{\nint32_t samplecount;\nint32_t duration;\nlen += fread(&samplecount, 1, 4, mp4->mediafp);\nsamplecount = BYTESWAP32(samplecount);\nlen += fread(&duration, 1, 4, mp4->mediafp);\nduration = BYTESWAP32(duration);\nsamples += samplecount;\nentries--;\ntotaldur += duration;\nmp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);\n}\nmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;\n}\nmp4->filepos += len;\nLongSeek(mp4, qtsize - 8 - len);\n}\nelse\nLongSeek(mp4, qtsize - 8);\nNESTSIZE(qtsize);\n}\nelse\n{\nNESTSIZE(8);\n}\n}\nelse\n{\nbreak;\n}\n} while (len > 0);\nif (mp4)\n{\nif (mp4->metasizes == NULL || mp4->metaoffsets == NULL)\n{\nCloseSource((size_t)mp4);\nmp4 = NULL;\n}\n}\n}\nelse\n{\nfree(mp4);\nmp4 = NULL;\n}\nreturn (size_t)mp4;\n}", "label": 0}
{"index": 178452, "code": "void SavePayload(size_t handle, uint32_t *payload, uint32_t index)\n{\nmp4object *mp4 = (mp4object *)handle;\nif (mp4 == NULL) return;\nuint32_t *MP4buffer = NULL;\nif (index < mp4->indexcount && mp4->mediafp && payload)\n{\nLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\nfwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);\n}\nreturn;\n}", "contrast": "void SavePayload(size_t handle, uint32_t *payload, uint32_t index)\nvoid LongSeek(mp4object *mp4, int64_t offset)\n{\nif (mp4 && offset)\n{\nif (mp4->filepos + offset < mp4->filesize)\n{\nLONGSEEK(mp4->mediafp, offset, SEEK_CUR);\nmp4->filepos += offset;\n}\nelse\n{\nmp4->filepos = mp4->filesize;\n}\n}\n}", "label": 0}
{"index": 178456, "code": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n(((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\nchar\n*comment;\nImage\n*image;\nint\nx_status;\nMagickBooleanType\nauthentic_colormap;\nMagickStatusType\nstatus;\nQuantum\nindex;\nregister ssize_t\nx;\nregister Quantum\n*q;\nregister ssize_t\ni;\nregister size_t\npixel;\nsize_t\nlength;\nssize_t\ncount,\ny;\nunsigned long\nlsb_first;\nXColor\n*colors;\nXImage\n*ximage;\nXWDFileHeader\nheader;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\ncount=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\nif (count != sz_XWDheader)\nThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\nlsb_first=1;\nif ((int) (*(char *) &lsb_first) != 0)\nMSBOrderLong((unsigned char *) &header,sz_XWDheader);\nif (header.file_version != XWD_FILE_VERSION)\nThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\nif (header.header_size < sz_XWDheader)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nswitch (header.visual_class)\n{\ncase StaticGray:\ncase GrayScale:\n{\nif (header.bits_per_pixel != 1)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase StaticColor:\ncase PseudoColor:\n{\nif ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) ||\n(header.ncolors == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase TrueColor:\ncase DirectColor:\n{\nif ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) &&\n(header.bits_per_pixel != 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.pixmap_format)\n{\ncase XYBitmap:\n{\nif (header.pixmap_depth != 1)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase XYPixmap:\ncase ZPixmap:\n{\nif ((header.pixmap_depth < 1) || (header.pixmap_depth > 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nswitch (header.bitmap_pad)\n{\ncase 8:\ncase 16:\ncase 32:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nbreak;\n}\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.bitmap_unit)\n{\ncase 8:\ncase 16:\ncase 32:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.byte_order)\n{\ncase LSBFirst:\ncase MSBFirst:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.bitmap_bit_order)\n{\ncase LSBFirst:\ncase MSBFirst:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif (header.ncolors > 65535)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nlength=(size_t) (header.header_size-sz_XWDheader);\ncomment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\nif (comment == (char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,length,(unsigned char *) comment);\ncomment[length]='\\0';\n(void) SetImageProperty(image,\"comment\",comment,exception);\ncomment=DestroyString(comment);\nif (count != (ssize_t) length)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\nif (ximage == (XImage *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nximage->depth=(int) header.pixmap_depth;\nximage->format=(int) header.pixmap_format;\nximage->xoffset=(int) header.xoffset;\nximage->data=(char *) NULL;\nximage->width=(int) header.pixmap_width;\nximage->height=(int) header.pixmap_height;\nximage->bitmap_pad=(int) header.bitmap_pad;\nximage->bytes_per_line=(int) header.bytes_per_line;\nximage->byte_order=(int) header.byte_order;\nximage->bitmap_unit=(int) header.bitmap_unit;\nximage->bitmap_bit_order=(int) header.bitmap_bit_order;\nximage->bits_per_pixel=(int) header.bits_per_pixel;\nximage->red_mask=header.red_mask;\nximage->green_mask=header.green_mask;\nximage->blue_mask=header.blue_mask;\nif ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||\n(ximage->format < 0) || (ximage->byte_order < 0) ||\n(ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n(ximage->bytes_per_line < 0))\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif ((ximage->width > 65535) || (ximage->height > 65535))\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nx_status=XInitImage(ximage);\nif (x_status == 0)\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\nauthentic_colormap=MagickFalse;\ncolors=(XColor *) NULL;\nif (header.ncolors != 0)\n{\nXWDColor\ncolor;\ncolors=(XColor *) AcquireQuantumMemory((size_t) header.ncolors,\nsizeof(*colors));\nif (colors == (XColor *) NULL)\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nfor (i=0; i < (ssize_t) header.ncolors; i++)\n{\ncount=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\nif (count != sz_XWDColor)\n{\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\ncolors[i].pixel=color.pixel;\ncolors[i].red=color.red;\ncolors[i].green=color.green;\ncolors[i].blue=color.blue;\ncolors[i].flags=(char) color.flags;\nif (color.flags != 0)\nauthentic_colormap=MagickTrue;\n}\nlsb_first=1;\nif ((int) (*(char *) &lsb_first) != 0)\nfor (i=0; i < (ssize_t) header.ncolors; i++)\n{\nMSBOrderLong((unsigned char *) &colors[i].pixel,\nsizeof(colors[i].pixel));\nMSBOrderShort((unsigned char *) &colors[i].red,3*\nsizeof(colors[i].red));\n}\n}\nlength=(size_t) ximage->bytes_per_line*ximage->height;\nif (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif (ximage->format != ZPixmap)\n{\nsize_t\nextent;\nextent=length;\nlength*=ximage->depth;\nif (CheckOverflowException(length,extent,ximage->depth))\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\n}\nximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\nif (ximage->data == (char *) NULL)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\ncount=ReadBlob(image,length,(unsigned char *) ximage->data);\nif (count != (ssize_t) length)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\nimage->columns=(size_t) ximage->width;\nimage->rows=(size_t) ximage->height;\nimage->depth=8;\nstatus=SetImageExtent(image,image->columns,image->rows,exception);\nif (status == MagickFalse)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nreturn(DestroyImageList(image));\n}\nif ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n(ximage->green_mask != 0) || (ximage->blue_mask != 0))\nimage->storage_class=DirectClass;\nelse\nimage->storage_class=PseudoClass;\nimage->colors=header.ncolors;\nif (image_info->ping == MagickFalse)\nswitch (image->storage_class)\n{\ncase DirectClass:\ndefault:\n{\nregister size_t\ncolor;\nsize_t\nblue_mask,\nblue_shift,\ngreen_mask,\ngreen_shift,\nred_mask,\nred_shift;\nred_mask=ximage->red_mask;\nred_shift=0;\nwhile ((red_mask != 0) && ((red_mask & 0x01) == 0))\n{\nred_mask>>=1;\nred_shift++;\n}\ngreen_mask=ximage->green_mask;\ngreen_shift=0;\nwhile ((green_mask != 0) && ((green_mask & 0x01) == 0))\n{\ngreen_mask>>=1;\ngreen_shift++;\n}\nblue_mask=ximage->blue_mask;\nblue_shift=0;\nwhile ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n{\nblue_mask>>=1;\nblue_shift++;\n}\nif ((image->colors != 0) && (authentic_colormap != MagickFalse))\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\npixel=XGetPixel(ximage,(int) x,(int) y);\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\nred_shift) & red_mask,exception);\nSetPixelRed(image,ScaleShortToQuantum(\ncolors[(ssize_t) index].red),q);\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\ngreen_shift) & green_mask,exception);\nSetPixelGreen(image,ScaleShortToQuantum(\ncolors[(ssize_t) index].green),q);\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\nblue_shift) & blue_mask,exception);\nSetPixelBlue(image,ScaleShortToQuantum(\ncolors[(ssize_t) index].blue),q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nelse\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\npixel=XGetPixel(ximage,(int) x,(int) y);\ncolor=(pixel >> red_shift) & red_mask;\nif (red_mask != 0)\ncolor=(color*65535UL)/red_mask;\nSetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\ncolor=(pixel >> green_shift) & green_mask;\nif (green_mask != 0)\ncolor=(color*65535UL)/green_mask;\nSetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\nq);\ncolor=(pixel >> blue_shift) & blue_mask;\nif (blue_mask != 0)\ncolor=(color*65535UL)/blue_mask;\nSetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\ncase PseudoClass:\n{\nif (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\ncolors[i].red);\nimage->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\ncolors[i].green);\nimage->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\ncolors[i].blue);\n}\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t)\nXGetPixel(ximage,(int) x,(int) y),exception);\nSetPixelIndex(image,index,q);\nSetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\n}\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nif (EOFBlob(image) != MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "contrast": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n(((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\nchar\n*comment;\nImage\n*image;\nint\nx_status;\nMagickBooleanType\nauthentic_colormap;\nMagickStatusType\nstatus;\nQuantum\nindex;\nregister ssize_t\nx;\nregister Quantum\n*q;\nregister ssize_t\ni;\nregister size_t\npixel;\nsize_t\nlength;\nssize_t\ncount,\ny;\nunsigned long\nlsb_first;\nXColor\n*colors;\nXImage\n*ximage;\nXWDFileHeader\nheader;\nassert(image_info != (const ImageInfo *) NULL);\nassert(image_info->signature == MagickCoreSignature);\nif (image_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\nimage_info->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=AcquireImage(image_info,exception);\nstatus=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\nif (status == MagickFalse)\n{\nimage=DestroyImageList(image);\nreturn((Image *) NULL);\n}\ncount=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\nif (count != sz_XWDheader)\nThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\nlsb_first=1;\nif ((int) (*(char *) &lsb_first) != 0)\nMSBOrderLong((unsigned char *) &header,sz_XWDheader);\nif (header.file_version != XWD_FILE_VERSION)\nThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\nif (header.header_size < sz_XWDheader)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nif ((MagickSizeType) header.xoffset >= GetBlobSize(image))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nswitch (header.visual_class)\n{\ncase StaticGray:\ncase GrayScale:\n{\nif (header.bits_per_pixel != 1)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase StaticColor:\ncase PseudoColor:\n{\nif ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) ||\n(header.colormap_entries == 0))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase TrueColor:\ncase DirectColor:\n{\nif ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) &&\n(header.bits_per_pixel != 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.pixmap_format)\n{\ncase XYBitmap:\n{\nif (header.pixmap_depth != 1)\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nbreak;\n}\ncase XYPixmap:\ncase ZPixmap:\n{\nif ((header.pixmap_depth < 1) || (header.pixmap_depth > 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nswitch (header.bitmap_pad)\n{\ncase 8:\ncase 16:\ncase 32:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nbreak;\n}\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.bitmap_unit)\n{\ncase 8:\ncase 16:\ncase 32:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.byte_order)\n{\ncase LSBFirst:\ncase MSBFirst:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nswitch (header.bitmap_bit_order)\n{\ncase LSBFirst:\ncase MSBFirst:\nbreak;\ndefault:\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\nlength=(size_t) (header.header_size-sz_XWDheader);\ncomment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\nif (comment == (char *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\ncount=ReadBlob(image,length,(unsigned char *) comment);\ncomment[length]='\\0';\n(void) SetImageProperty(image,\"comment\",comment,exception);\ncomment=DestroyString(comment);\nif (count != (ssize_t) length)\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\nximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\nif (ximage == (XImage *) NULL)\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\nximage->depth=(int) header.pixmap_depth;\nximage->format=(int) header.pixmap_format;\nximage->xoffset=(int) header.xoffset;\nximage->data=(char *) NULL;\nximage->width=(int) header.pixmap_width;\nximage->height=(int) header.pixmap_height;\nximage->bitmap_pad=(int) header.bitmap_pad;\nximage->bytes_per_line=(int) header.bytes_per_line;\nximage->byte_order=(int) header.byte_order;\nximage->bitmap_unit=(int) header.bitmap_unit;\nximage->bitmap_bit_order=(int) header.bitmap_bit_order;\nximage->bits_per_pixel=(int) header.bits_per_pixel;\nximage->red_mask=header.red_mask;\nximage->green_mask=header.green_mask;\nximage->blue_mask=header.blue_mask;\nif ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||\n(ximage->format < 0) || (ximage->byte_order < 0) ||\n(ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n(ximage->bytes_per_line < 0))\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif ((ximage->width > 65535) || (ximage->height > 65535))\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nx_status=XInitImage(ximage);\nif (x_status == 0)\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\nauthentic_colormap=MagickFalse;\ncolors=(XColor *) NULL;\nif (header.ncolors != 0)\n{\nXWDColor\ncolor;\nlength=(size_t) header.ncolors;\nif (length > ((~0UL)/sizeof(*colors)))\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\ncolors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\nif (colors == (XColor *) NULL)\n{\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nfor (i=0; i < (ssize_t) header.ncolors; i++)\n{\ncount=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\nif (count != sz_XWDColor)\n{\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n}\ncolors[i].pixel=color.pixel;\ncolors[i].red=color.red;\ncolors[i].green=color.green;\ncolors[i].blue=color.blue;\ncolors[i].flags=(char) color.flags;\nif (color.flags != 0)\nauthentic_colormap=MagickTrue;\n}\nlsb_first=1;\nif ((int) (*(char *) &lsb_first) != 0)\nfor (i=0; i < (ssize_t) header.ncolors; i++)\n{\nMSBOrderLong((unsigned char *) &colors[i].pixel,\nsizeof(colors[i].pixel));\nMSBOrderShort((unsigned char *) &colors[i].red,3*\nsizeof(colors[i].red));\n}\n}\nlength=(size_t) ximage->bytes_per_line*ximage->height;\nif (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\nif (ximage->format != ZPixmap)\n{\nsize_t\nextent;\nextent=length;\nlength*=ximage->depth;\nif (CheckOverflowException(length,extent,ximage->depth))\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n}\n}\nximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\nif (ximage->data == (char *) NULL)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\ncount=ReadBlob(image,length,(unsigned char *) ximage->data);\nif (count != (ssize_t) length)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n}\nimage->columns=(size_t) ximage->width;\nimage->rows=(size_t) ximage->height;\nimage->depth=8;\nstatus=SetImageExtent(image,image->columns,image->rows,exception);\nif (status == MagickFalse)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nreturn(DestroyImageList(image));\n}\nif ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n(ximage->green_mask != 0) || (ximage->blue_mask != 0))\nimage->storage_class=DirectClass;\nelse\nimage->storage_class=PseudoClass;\nimage->colors=header.ncolors;\nif (image_info->ping == MagickFalse)\nswitch (image->storage_class)\n{\ncase DirectClass:\ndefault:\n{\nregister size_t\ncolor;\nsize_t\nblue_mask,\nblue_shift,\ngreen_mask,\ngreen_shift,\nred_mask,\nred_shift;\nred_mask=ximage->red_mask;\nred_shift=0;\nwhile ((red_mask != 0) && ((red_mask & 0x01) == 0))\n{\nred_mask>>=1;\nred_shift++;\n}\ngreen_mask=ximage->green_mask;\ngreen_shift=0;\nwhile ((green_mask != 0) && ((green_mask & 0x01) == 0))\n{\ngreen_mask>>=1;\ngreen_shift++;\n}\nblue_mask=ximage->blue_mask;\nblue_shift=0;\nwhile ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n{\nblue_mask>>=1;\nblue_shift++;\n}\nif ((image->colors != 0) && (authentic_colormap != MagickFalse))\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\npixel=XGetPixel(ximage,(int) x,(int) y);\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\nred_shift) & red_mask,exception);\nSetPixelRed(image,ScaleShortToQuantum(\ncolors[(ssize_t) index].red),q);\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\ngreen_shift) & green_mask,exception);\nSetPixelGreen(image,ScaleShortToQuantum(\ncolors[(ssize_t) index].green),q);\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\nblue_shift) & blue_mask,exception);\nSetPixelBlue(image,ScaleShortToQuantum(\ncolors[(ssize_t) index].blue),q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nelse\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\npixel=XGetPixel(ximage,(int) x,(int) y);\ncolor=(pixel >> red_shift) & red_mask;\nif (red_mask != 0)\ncolor=(color*65535UL)/red_mask;\nSetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\ncolor=(pixel >> green_shift) & green_mask;\nif (green_mask != 0)\ncolor=(color*65535UL)/green_mask;\nSetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\nq);\ncolor=(pixel >> blue_shift) & blue_mask;\nif (blue_mask != 0)\ncolor=(color*65535UL)/blue_mask;\nSetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\ncase PseudoClass:\n{\nif (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n{\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n}\nfor (i=0; i < (ssize_t) image->colors; i++)\n{\nimage->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\ncolors[i].red);\nimage->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\ncolors[i].green);\nimage->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\ncolors[i].blue);\n}\nfor (y=0; y < (ssize_t) image->rows; y++)\n{\nq=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\nif (q == (Quantum *) NULL)\nbreak;\nfor (x=0; x < (ssize_t) image->columns; x++)\n{\nindex=(Quantum) ConstrainColormapIndex(image,(ssize_t)\nXGetPixel(ximage,(int) x,(int) y),exception);\nSetPixelIndex(image,index,q);\nSetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\nq+=GetPixelChannels(image);\n}\nif (SyncAuthenticPixels(image,exception) == MagickFalse)\nbreak;\nstatus=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\nimage->rows);\nif (status == MagickFalse)\nbreak;\n}\nbreak;\n}\n}\nif (header.ncolors != 0)\ncolors=(XColor *) RelinquishMagickMemory(colors);\nximage->data=DestroyString(ximage->data);\nximage=(XImage *) RelinquishMagickMemory(ximage);\nif (EOFBlob(image) != MagickFalse)\nThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\nimage->filename);\n(void) CloseBlob(image);\nreturn(GetFirstImageInList(image));\n}", "label": 0}
{"index": 178464, "code": "int main(int argc, char **argv)\n{\nint         i, n_valid, do_write, do_scrub;\nchar       *c, *dname, *name;\nDIR        *dir;\nFILE       *fp;\npdf_t      *pdf;\npdf_flag_t  flags;\nif (argc < 2)\nusage();\ndo_write = do_scrub = flags = 0;\nname = NULL;\nfor (i=1; i<argc; i++)\n{\nif (strncmp(argv[i], \"-w\", 2) == 0)\ndo_write = 1;\nelse if (strncmp(argv[i], \"-i\", 2) == 0)\nflags |= PDF_FLAG_DISP_CREATOR;\nelse if (strncmp(argv[i], \"-q\", 2) == 0)\nflags |= PDF_FLAG_QUIET;\nelse if (strncmp(argv[i], \"-s\", 2) == 0)\ndo_scrub = 1;\nelse if (argv[i][0] != '-')\nname = argv[i];\nelse if (argv[i][0] == '-')\nusage();\n}\nif (!name)\nusage();\nif (!(fp = fopen(name, \"r\")))\n{\nERR(\"Could not open file '%s'\\n\", argv[1]);\nreturn -1;\n}\nelse if (!pdf_is_pdf(fp))\n{\nERR(\"'%s' specified is not a valid PDF\\n\", name);\nfclose(fp);\nreturn -1;\n}\nif (!(pdf = init_pdf(fp, name)))\n{\nfclose(fp);\nreturn -1;\n}\nfor (i=0, n_valid=0; i<pdf->n_xrefs; i++)\nif (pdf->xrefs[i].version)\n++n_valid;\nif (n_valid < 2)\n{\nif (!(flags & (PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR)))\nprintf(\"%s: There is only one version of this PDF\\n\", pdf->name);\nif (do_write)\n{\nfclose(fp);\npdf_delete(pdf);\nreturn 0;\n}\n}\ndname = NULL;\nif (do_write)\n{\nif ((c = strrchr(name, '/')))\nname = c + 1;\nif ((c = strrchr(name, '.')))\n*c = '\\0';\ndname = malloc(strlen(name) + 16);\nsprintf(dname, \"%s-versions\", name);\nif (!(dir = opendir(dname)))\nmkdir(dname, S_IRWXU);\nelse\n{\nERR(\"This directory already exists, PDF version extraction will \"\n\"not occur.\\n\");\nfclose(fp);\nclosedir(dir);\nfree(dname);\npdf_delete(pdf);\nreturn -1;\n}\nfor (i=0; i<pdf->n_xrefs; i++)\nif (pdf->xrefs[i].version)\nwrite_version(fp, name, dname, &pdf->xrefs[i]);\n}\npdf_summarize(fp, pdf, dname, flags);\nif (do_scrub)\nscrub_document(fp, pdf);\nif (flags & PDF_FLAG_DISP_CREATOR)\ndisplay_creator(fp, pdf);\nfclose(fp);\nfree(dname);\npdf_delete(pdf);\nreturn 0;\n}", "contrast": "int main(int argc, char **argv)\n{\nint         i, n_valid, do_write, do_scrub;\nchar       *c, *dname, *name;\nDIR        *dir;\nFILE       *fp;\npdf_t      *pdf;\npdf_flag_t  flags;\nif (argc < 2)\nusage();\ndo_write = do_scrub = flags = 0;\nname = NULL;\nfor (i=1; i<argc; i++)\n{\nif (strncmp(argv[i], \"-w\", 2) == 0)\ndo_write = 1;\nelse if (strncmp(argv[i], \"-i\", 2) == 0)\nflags |= PDF_FLAG_DISP_CREATOR;\nelse if (strncmp(argv[i], \"-q\", 2) == 0)\nflags |= PDF_FLAG_QUIET;\nelse if (strncmp(argv[i], \"-s\", 2) == 0)\ndo_scrub = 1;\nelse if (argv[i][0] != '-')\nname = argv[i];\nelse if (argv[i][0] == '-')\nusage();\n}\nif (!name)\nusage();\nif (!(fp = fopen(name, \"r\")))\n{\nERR(\"Could not open file '%s'\\n\", argv[1]);\nreturn -1;\n}\nelse if (!pdf_is_pdf(fp))\n{\nERR(\"'%s' specified is not a valid PDF\\n\", name);\nfclose(fp);\nreturn -1;\n}\nif (!(pdf = init_pdf(fp, name)))\n{\nfclose(fp);\nreturn -1;\n}\nfor (i=0, n_valid=0; i<pdf->n_xrefs; i++)\nif (pdf->xrefs[i].version)\n++n_valid;\nif (n_valid < 2)\n{\nif (!(flags & (PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR)))\nprintf(\"%s: There is only one version of this PDF\\n\", pdf->name);\nif (do_write)\n{\nfclose(fp);\npdf_delete(pdf);\nreturn 0;\n}\n}\ndname = NULL;\nif (do_write)\n{\nif ((c = strrchr(name, '/')))\nname = c + 1;\nif ((c = strrchr(name, '.')))\n*c = '\\0';\ndname = safe_calloc(strlen(name) + 16);\nsprintf(dname, \"%s-versions\", name);\nif (!(dir = opendir(dname)))\nmkdir(dname, S_IRWXU);\nelse\n{\nERR(\"This directory already exists, PDF version extraction will \"\n\"not occur.\\n\");\nfclose(fp);\nclosedir(dir);\nfree(dname);\npdf_delete(pdf);\nreturn -1;\n}\nfor (i=0; i<pdf->n_xrefs; i++)\nif (pdf->xrefs[i].version)\nwrite_version(fp, name, dname, &pdf->xrefs[i]);\n}\npdf_summarize(fp, pdf, dname, flags);\nif (do_scrub)\nscrub_document(fp, pdf);\nif (flags & PDF_FLAG_DISP_CREATOR)\ndisplay_creator(fp, pdf);\nfclose(fp);\nfree(dname);\npdf_delete(pdf);\nreturn 0;\n}", "label": 0}
{"index": 178487, "code": "MagickExport void RemoveDuplicateLayers(Image **images,\nExceptionInfo *exception)\n{\nregister Image\n*curr,\n*next;\nRectangleInfo\nbounds;\nassert((*images) != (const Image *) NULL);\nassert((*images)->signature == MagickCoreSignature);\nif ((*images)->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\ncurr=GetFirstImageInList(*images);\nfor (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n{\nif ( curr->columns != next->columns || curr->rows != next->rows\n|| curr->page.x != next->page.x || curr->page.y != next->page.y )\ncontinue;\nbounds=CompareImageBounds(curr,next,CompareAnyLayer,exception);\nif ( bounds.x < 0 ) {\nsize_t time;\ntime = curr->delay*1000/curr->ticks_per_second;\ntime += next->delay*1000/next->ticks_per_second;\nnext->ticks_per_second = 100L;\nnext->delay = time*curr->ticks_per_second/1000;\nnext->iterations = curr->iterations;\n*images = curr;\n(void) DeleteImageFromList(images);\n}\n}\n*images = GetFirstImageInList(*images);\n}", "contrast": "MagickExport void RemoveDuplicateLayers(Image **images,\nMagickExport void RemoveDuplicateLayers(Image **images,ExceptionInfo *exception)\n{\nRectangleInfo\nbounds;\nregister Image\n*image,\n*next;\nassert((*images) != (const Image *) NULL);\nassert((*images)->signature == MagickCoreSignature);\nif ((*images)->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n(*images)->filename);\nassert(exception != (ExceptionInfo *) NULL);\nassert(exception->signature == MagickCoreSignature);\nimage=GetFirstImageInList(*images);\nfor ( ; (next=GetNextImageInList(image)) != (Image *) NULL; image=next)\n{\nif ((image->columns != next->columns) || (image->rows != next->rows) ||\n(image->page.x != next->page.x) || (image->page.y != next->page.y))\ncontinue;\nbounds=CompareImageBounds(image,next,CompareAnyLayer,exception);\nif (bounds.x < 0)\n{\nsize_t\ntime;\ntime=1000*image->delay*PerceptibleReciprocal(image->ticks_per_second);\ntime+=1000*next->delay*PerceptibleReciprocal(next->ticks_per_second);\nnext->ticks_per_second=100L;\nnext->delay=time*image->ticks_per_second/1000;\nnext->iterations=image->iterations;\n*images=image;\n(void) DeleteImageFromList(images);\n}\n}\n*images=GetFirstImageInList(*images);\n}", "label": 0}
{"index": 178494, "code": "static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)\n{\nconst Image\n*next;\nMagickPixelPacket\n**pixels;\nregister ssize_t\ni,\nj;\nsize_t\ncolumns,\nnumber_threads;\nnumber_threads=(size_t) GetMagickResourceLimit(ThreadResource);\npixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,\nsizeof(*pixels));\nif (pixels == (MagickPixelPacket **) NULL)\nreturn((MagickPixelPacket **) NULL);\n(void) memset(pixels,0,number_threads*sizeof(*pixels));\ncolumns=images->columns;\nfor (next=images; next != (Image *) NULL; next=next->next)\ncolumns=MagickMax(next->columns,columns);\nfor (i=0; i < (ssize_t) number_threads; i++)\n{\npixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,\nsizeof(**pixels));\nif (pixels[i] == (MagickPixelPacket *) NULL)\nreturn(DestroyPixelThreadSet(pixels));\nfor (j=0; j < (ssize_t) columns; j++)\nGetMagickPixelPacket(images,&pixels[i][j]);\n}\nreturn(pixels);\n}", "contrast": "static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)\n{\nconst Image\n*next;\nMagickPixelPacket\n**pixels;\nregister ssize_t\ni,\nj;\nsize_t\ncolumns,\nrows;\nrows=MagickMax(GetImageListLength(images),\n(size_t) GetMagickResourceLimit(ThreadResource));\npixels=(MagickPixelPacket **) AcquireQuantumMemory(rows,sizeof(*pixels));\nif (pixels == (MagickPixelPacket **) NULL)\nreturn((MagickPixelPacket **) NULL);\ncolumns=images->columns;\nfor (next=images; next != (Image *) NULL; next=next->next)\ncolumns=MagickMax(next->columns,columns);\nfor (i=0; i < (ssize_t) rows; i++)\n{\npixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,\nsizeof(**pixels));\nif (pixels[i] == (MagickPixelPacket *) NULL)\nreturn(DestroyPixelThreadSet(pixels));\nfor (j=0; j < (ssize_t) columns; j++)\nGetMagickPixelPacket(images,&pixels[i][j]);\n}\nreturn(pixels);\n}", "label": 0}
{"index": 178518, "code": "void qrio_prstcfg(u8 bit, u8 mode)\n{\nu32 prstcfg;\nu8 i;\nvoid __iomem *qrio_base = (void *)CONFIG_SYS_QRIO_BASE;\nprstcfg = in_be32(qrio_base + PRSTCFG_OFF);\nfor (i = 0; i < 2; i++) {\nif (mode & (1<<i))\nset_bit(2*bit+i, &prstcfg);\nelse\nclear_bit(2*bit+i, &prstcfg);\n}\nout_be32(qrio_base + PRSTCFG_OFF, prstcfg);\n}", "contrast": "void qrio_prstcfg(u8 bit, u8 mode)\n{\nu32 prstcfg;\nu8 i;\nvoid __iomem *qrio_base = (void *)CONFIG_SYS_QRIO_BASE;\nprstcfg = in_be32(qrio_base + PRSTCFG_OFF);\nfor (i = 0; i < 2; i++) {\nif (mode & (1 << i))\nset_bit(2 * bit + i, &prstcfg);\nelse\nclear_bit(2 * bit + i, &prstcfg);\n}\nout_be32(qrio_base + PRSTCFG_OFF, prstcfg);\n}", "label": 0}
{"index": 178531, "code": "static int do_zfs_load(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\nchar *filename = NULL;\nint dev;\nint part;\nulong addr = 0;\ndisk_partition_t info;\nstruct blk_desc *dev_desc;\nchar buf[12];\nunsigned long count;\nconst char *addr_str;\nstruct zfs_file zfile;\nstruct device_s vdev;\nif (argc < 3)\nreturn CMD_RET_USAGE;\ncount = 0;\naddr = simple_strtoul(argv[3], NULL, 16);\nfilename = env_get(\"bootfile\");\nswitch (argc) {\ncase 3:\naddr_str = env_get(\"loadaddr\");\nif (addr_str != NULL)\naddr = simple_strtoul(addr_str, NULL, 16);\nelse\naddr = CONFIG_SYS_LOAD_ADDR;\nbreak;\ncase 4:\nbreak;\ncase 5:\nfilename = argv[4];\nbreak;\ncase 6:\nfilename = argv[4];\ncount = simple_strtoul(argv[5], NULL, 16);\nbreak;\ndefault:\nreturn cmd_usage(cmdtp);\n}\nif (!filename) {\nputs(\"** No boot file defined **\\n\");\nreturn 1;\n}\npart = blk_get_device_part_str(argv[1], argv[2], &dev_desc, &info, 1);\nif (part < 0)\nreturn 1;\ndev = dev_desc->devnum;\nprintf(\"Loading file \\\"%s\\\" from %s device %d%c%c\\n\",\nfilename, argv[1], dev,\npart ? ':' : ' ', part ? part + '0' : ' ');\nzfs_set_blk_dev(dev_desc, &info);\nvdev.part_length = info.size;\nmemset(&zfile, 0, sizeof(zfile));\nzfile.device = &vdev;\nif (zfs_open(&zfile, filename)) {\nprintf(\"** File not found %s **\\n\", filename);\nreturn 1;\n}\nif ((count < zfile.size) && (count != 0))\nzfile.size = (uint64_t)count;\nif (zfs_read(&zfile, (char *)addr, zfile.size) != zfile.size) {\nprintf(\"** Unable to read \\\"%s\\\" from %s %d:%d **\\n\",\nfilename, argv[1], dev, part);\nzfs_close(&zfile);\nreturn 1;\n}\nzfs_close(&zfile);\nimage_load_addr = addr;\nprintf(\"%llu bytes read\\n\", zfile.size);\nenv_set_hex(\"filesize\", zfile.size);\nreturn 0;\n}", "contrast": "static int do_zfs_load(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\nchar *filename = NULL;\nint dev;\nint part;\nulong addr = 0;\ndisk_partition_t info;\nstruct blk_desc *dev_desc;\nunsigned long count;\nconst char *addr_str;\nstruct zfs_file zfile;\nstruct device_s vdev;\nif (argc < 3)\nreturn CMD_RET_USAGE;\ncount = 0;\naddr = simple_strtoul(argv[3], NULL, 16);\nfilename = env_get(\"bootfile\");\nswitch (argc) {\ncase 3:\naddr_str = env_get(\"loadaddr\");\nif (addr_str != NULL)\naddr = simple_strtoul(addr_str, NULL, 16);\nelse\naddr = CONFIG_SYS_LOAD_ADDR;\nbreak;\ncase 4:\nbreak;\ncase 5:\nfilename = argv[4];\nbreak;\ncase 6:\nfilename = argv[4];\ncount = simple_strtoul(argv[5], NULL, 16);\nbreak;\ndefault:\nreturn cmd_usage(cmdtp);\n}\nif (!filename) {\nputs(\"** No boot file defined **\\n\");\nreturn 1;\n}\npart = blk_get_device_part_str(argv[1], argv[2], &dev_desc, &info, 1);\nif (part < 0)\nreturn 1;\ndev = dev_desc->devnum;\nprintf(\"Loading file \\\"%s\\\" from %s device %d%c%c\\n\",\nfilename, argv[1], dev,\npart ? ':' : ' ', part ? part + '0' : ' ');\nzfs_set_blk_dev(dev_desc, &info);\nvdev.part_length = info.size;\nmemset(&zfile, 0, sizeof(zfile));\nzfile.device = &vdev;\nif (zfs_open(&zfile, filename)) {\nprintf(\"** File not found %s **\\n\", filename);\nreturn 1;\n}\nif ((count < zfile.size) && (count != 0))\nzfile.size = (uint64_t)count;\nif (zfs_read(&zfile, (char *)addr, zfile.size) != zfile.size) {\nprintf(\"** Unable to read \\\"%s\\\" from %s %d:%d **\\n\",\nfilename, argv[1], dev, part);\nzfs_close(&zfile);\nreturn 1;\n}\nzfs_close(&zfile);\nimage_load_addr = addr;\nprintf(\"%llu bytes read\\n\", zfile.size);\nenv_set_hex(\"filesize\", zfile.size);\nreturn 0;\n}", "label": 0}
{"index": 178534, "code": "static lba512_t lba512_muldiv(lba512_t block_count, lba512_t mul_by, int div_by)\n{\nlba512_t bc_quot, bc_rem;\nbc_quot = block_count >> div_by;\nbc_rem  = block_count - (bc_quot << div_by);\nreturn bc_quot * mul_by + ((bc_rem * mul_by) >> div_by);\n}", "contrast": "static lba512_t lba512_muldiv(lba512_t block_count, lba512_t mul_by, int div_by)\nstatic lba512_t lba512_muldiv(lba512_t block_count, lba512_t mul_by,\nint right_shift)\n{\nlba512_t bc_quot, bc_rem;\nbc_quot = block_count >> right_shift;\nbc_rem  = block_count - (bc_quot << right_shift);\nreturn bc_quot * mul_by + ((bc_rem * mul_by) >> right_shift);\n}", "label": 0}
{"index": 178535, "code": "static void destroy_server_connect(SERVER_CONNECT_REC *conn)\n{\nIRC_SERVER_CONNECT_REC *ircconn;\nircconn = IRC_SERVER_CONNECT(conn);\nif (ircconn == NULL)\nreturn;\ng_free_not_null(ircconn->usermode);\ng_free_not_null(ircconn->alternate_nick);\n}", "contrast": "static void destroy_server_connect(SERVER_CONNECT_REC *conn)\n{\nIRC_SERVER_CONNECT_REC *ircconn;\nircconn = IRC_SERVER_CONNECT(conn);\nif (ircconn == NULL)\nreturn;\ng_free_not_null(ircconn->usermode);\ng_free_not_null(ircconn->alternate_nick);\ng_free_not_null(ircconn->sasl_username);\ng_free_not_null(ircconn->sasl_password);\n}", "label": 0}
{"index": 178547, "code": "int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\nstruct nfc_llcp_local *local;\nstruct sk_buff *skb;\nu8 *service_name_tlv = NULL, service_name_tlv_length;\nu8 *miux_tlv = NULL, miux_tlv_length;\nu8 *rw_tlv = NULL, rw_tlv_length, rw;\nint err;\nu16 size = 0;\n__be16 miux;\npr_debug(\"Sending CONNECT\\n\");\nlocal = sock->local;\nif (local == NULL)\nreturn -ENODEV;\nif (sock->service_name != NULL) {\nservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\nsock->service_name,\nsock->service_name_len,\n&service_name_tlv_length);\nsize += service_name_tlv_length;\n}\nmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\nlocal->miux : sock->miux;\nrw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\nmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n&miux_tlv_length);\nsize += miux_tlv_length;\nrw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\nsize += rw_tlv_length;\npr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\nskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\nif (skb == NULL) {\nerr = -ENOMEM;\ngoto error_tlv;\n}\nllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\nllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\nllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\nskb_queue_tail(&local->tx_queue, skb);\nerr = 0;\nerror_tlv:\nif (err)\npr_err(\"error %d\\n\", err);\nkfree(service_name_tlv);\nkfree(miux_tlv);\nkfree(rw_tlv);\nreturn err;\n}", "contrast": "int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\nstruct nfc_llcp_local *local;\nstruct sk_buff *skb;\nu8 *service_name_tlv = NULL, service_name_tlv_length;\nu8 *miux_tlv = NULL, miux_tlv_length;\nu8 *rw_tlv = NULL, rw_tlv_length, rw;\nint err;\nu16 size = 0;\n__be16 miux;\npr_debug(\"Sending CONNECT\\n\");\nlocal = sock->local;\nif (local == NULL)\nreturn -ENODEV;\nif (sock->service_name != NULL) {\nservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\nsock->service_name,\nsock->service_name_len,\n&service_name_tlv_length);\nif (!service_name_tlv) {\nerr = -ENOMEM;\ngoto error_tlv;\n}\nsize += service_name_tlv_length;\n}\nmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\nlocal->miux : sock->miux;\nrw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\nmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n&miux_tlv_length);\nif (!miux_tlv) {\nerr = -ENOMEM;\ngoto error_tlv;\n}\nsize += miux_tlv_length;\nrw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\nif (!rw_tlv) {\nerr = -ENOMEM;\ngoto error_tlv;\n}\nsize += rw_tlv_length;\npr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\nskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\nif (skb == NULL) {\nerr = -ENOMEM;\ngoto error_tlv;\n}\nllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\nllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\nllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\nskb_queue_tail(&local->tx_queue, skb);\nerr = 0;\nerror_tlv:\nif (err)\npr_err(\"error %d\\n\", err);\nkfree(service_name_tlv);\nkfree(miux_tlv);\nkfree(rw_tlv);\nreturn err;\n}", "label": 0}
{"index": 178561, "code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\nstatic const char notifymsg[] =\n\"NOTIFY %s HTTP/1.1\\r\\n\"\n\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\"Content-Type: text/xml\\r\\n\"\n#else\n\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\n#endif\n\"Content-Length: %d\\r\\n\"\n\"NT: upnp:event\\r\\n\"\n\"NTS: upnp:propchange\\r\\n\"\n\"SID: %s\\r\\n\"\n\"SEQ: %u\\r\\n\"\n\"Connection: close\\r\\n\"\n\"Cache-Control: no-cache\\r\\n\"\n\"\\r\\n\"\n\"%.*s\\r\\n\";\nchar * xml;\nint l;\nif(obj->sub == NULL) {\nobj->state = EError;\nreturn;\n}\nswitch(obj->sub->service) {\ncase EWanCFG:\nxml = getVarsWANCfg(&l);\nbreak;\ncase EWanIPC:\nxml = getVarsWANIPCn(&l);\nbreak;\n#ifdef ENABLE_L3F_SERVICE\ncase EL3F:\nxml = getVarsL3F(&l);\nbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\ncase E6FC:\nxml = getVars6FC(&l);\nbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\ncase EDP:\nxml = getVarsDP(&l);\nbreak;\n#endif\ndefault:\nxml = NULL;\nl = 0;\n}\nobj->buffersize = 1024;\nobj->buffer = malloc(obj->buffersize);\nif(!obj->buffer) {\nsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\nif(xml) {\nfree(xml);\n}\nobj->state = EError;\nreturn;\n}\nobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\nobj->path, obj->addrstr, obj->portstr, l+2,\nobj->sub->uuid, obj->sub->seq,\nl, xml);\nif(xml) {\nfree(xml);\nxml = NULL;\n}\nobj->state = ESending;\n}", "contrast": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\nstatic const char notifymsg[] =\n\"NOTIFY %s HTTP/1.1\\r\\n\"\n\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\"Content-Type: text/xml\\r\\n\"\n#else\n\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\n#endif\n\"Content-Length: %d\\r\\n\"\n\"NT: upnp:event\\r\\n\"\n\"NTS: upnp:propchange\\r\\n\"\n\"SID: %s\\r\\n\"\n\"SEQ: %u\\r\\n\"\n\"Connection: close\\r\\n\"\n\"Cache-Control: no-cache\\r\\n\"\n\"\\r\\n\"\n\"%.*s\\r\\n\";\nchar * xml;\nint l;\nif(obj->sub == NULL) {\nobj->state = EError;\nreturn;\n}\nswitch(obj->sub->service) {\ncase EWanCFG:\nxml = getVarsWANCfg(&l);\nbreak;\ncase EWanIPC:\nxml = getVarsWANIPCn(&l);\nbreak;\n#ifdef ENABLE_L3F_SERVICE\ncase EL3F:\nxml = getVarsL3F(&l);\nbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\ncase E6FC:\nxml = getVars6FC(&l);\nbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\ncase EDP:\nxml = getVarsDP(&l);\nbreak;\n#endif\ndefault:\nxml = NULL;\nl = 0;\n}\nobj->buffersize = 1024;\nfor (;;) {\nobj->buffer = malloc(obj->buffersize);\nif(!obj->buffer) {\nsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\nif(xml) {\nfree(xml);\n}\nobj->state = EError;\nreturn;\n}\nobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\nobj->path, obj->addrstr, obj->portstr, l+2,\nobj->sub->uuid, obj->sub->seq,\nl, xml);\nif (obj->tosend < 0) {\nsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\nif(xml) {\nfree(xml);\n}\nobj->state = EError;\nreturn;\n} else if (obj->tosend < obj->buffersize) {\nbreak;\n}\nfree(obj->buffer);\nobj->buffersize = obj->tosend + 1;\n}\nif(xml) {\nfree(xml);\nxml = NULL;\n}\nobj->state = ESending;\n}", "label": 0}
{"index": 178566, "code": "ZSTD_encodeSequences_body(\nvoid* dst, size_t dstCapacity,\nFSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\nFSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\nFSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\nseqDef const* sequences, size_t nbSeq, int longOffsets)\n{\nBIT_CStream_t blockStream;\nFSE_CState_t  stateMatchLength;\nFSE_CState_t  stateOffsetBits;\nFSE_CState_t  stateLitLength;\nCHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall);\nFSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);\nFSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);\nFSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);\nBIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);\nif (MEM_32bits()) BIT_flushBits(&blockStream);\nBIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);\nif (MEM_32bits()) BIT_flushBits(&blockStream);\nif (longOffsets) {\nU32 const ofBits = ofCodeTable[nbSeq-1];\nint const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);\nif (extraBits) {\nBIT_addBits(&blockStream, sequences[nbSeq-1].offset, extraBits);\nBIT_flushBits(&blockStream);\n}\nBIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,\nofBits - extraBits);\n} else {\nBIT_addBits(&blockStream, sequences[nbSeq-1].offset, ofCodeTable[nbSeq-1]);\n}\nBIT_flushBits(&blockStream);\n{   size_t n;\nfor (n=nbSeq-2 ; n<nbSeq ; n--) {\nBYTE const llCode = llCodeTable[n];\nBYTE const ofCode = ofCodeTable[n];\nBYTE const mlCode = mlCodeTable[n];\nU32  const llBits = LL_bits[llCode];\nU32  const ofBits = ofCode;\nU32  const mlBits = ML_bits[mlCode];\nDEBUGLOG(6, \"encoding: litlen:%2u - matchlen:%2u - offCode:%7u\",\nsequences[n].litLength,\nsequences[n].matchLength + MINMATCH,\nsequences[n].offset);\nFSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);\nFSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);\nif (MEM_32bits()) BIT_flushBits(&blockStream);\nFSE_encodeSymbol(&blockStream, &stateLitLength, llCode);\nif (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))\nBIT_flushBits(&blockStream);\nBIT_addBits(&blockStream, sequences[n].litLength, llBits);\nif (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);\nBIT_addBits(&blockStream, sequences[n].matchLength, mlBits);\nif (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);\nif (longOffsets) {\nint const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);\nif (extraBits) {\nBIT_addBits(&blockStream, sequences[n].offset, extraBits);\nBIT_flushBits(&blockStream);\n}\nBIT_addBits(&blockStream, sequences[n].offset >> extraBits,\nofBits - extraBits);\n} else {\nBIT_addBits(&blockStream, sequences[n].offset, ofBits);\n}\nBIT_flushBits(&blockStream);\n}   }\nDEBUGLOG(6, \"ZSTD_encodeSequences: flushing ML state with %u bits\", stateMatchLength.stateLog);\nFSE_flushCState(&blockStream, &stateMatchLength);\nDEBUGLOG(6, \"ZSTD_encodeSequences: flushing Off state with %u bits\", stateOffsetBits.stateLog);\nFSE_flushCState(&blockStream, &stateOffsetBits);\nDEBUGLOG(6, \"ZSTD_encodeSequences: flushing LL state with %u bits\", stateLitLength.stateLog);\nFSE_flushCState(&blockStream, &stateLitLength);\n{   size_t const streamSize = BIT_closeCStream(&blockStream);\nif (streamSize==0) return ERROR(dstSize_tooSmall);\nreturn streamSize;\n}\n}", "contrast": "ZSTD_encodeSequences_body(\nvoid* dst, size_t dstCapacity,\nFSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\nFSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\nFSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\nseqDef const* sequences, size_t nbSeq, int longOffsets)\n{\nBIT_CStream_t blockStream;\nFSE_CState_t  stateMatchLength;\nFSE_CState_t  stateOffsetBits;\nFSE_CState_t  stateLitLength;\nCHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall);\nDEBUGLOG(6, \"available space for bitstream : %i  (dstCapacity=%u)\",\n(int)(blockStream.endPtr - blockStream.startPtr),\n(unsigned)dstCapacity);\nFSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);\nFSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);\nFSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);\nBIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);\nif (MEM_32bits()) BIT_flushBits(&blockStream);\nBIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);\nif (MEM_32bits()) BIT_flushBits(&blockStream);\nif (longOffsets) {\nU32 const ofBits = ofCodeTable[nbSeq-1];\nint const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);\nif (extraBits) {\nBIT_addBits(&blockStream, sequences[nbSeq-1].offset, extraBits);\nBIT_flushBits(&blockStream);\n}\nBIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,\nofBits - extraBits);\n} else {\nBIT_addBits(&blockStream, sequences[nbSeq-1].offset, ofCodeTable[nbSeq-1]);\n}\nBIT_flushBits(&blockStream);\n{   size_t n;\nfor (n=nbSeq-2 ; n<nbSeq ; n--) {\nBYTE const llCode = llCodeTable[n];\nBYTE const ofCode = ofCodeTable[n];\nBYTE const mlCode = mlCodeTable[n];\nU32  const llBits = LL_bits[llCode];\nU32  const ofBits = ofCode;\nU32  const mlBits = ML_bits[mlCode];\nDEBUGLOG(6, \"encoding: litlen:%2u - matchlen:%2u - offCode:%7u\",\nsequences[n].litLength,\nsequences[n].matchLength + MINMATCH,\nsequences[n].offset);\nFSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);\nFSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);\nif (MEM_32bits()) BIT_flushBits(&blockStream);\nFSE_encodeSymbol(&blockStream, &stateLitLength, llCode);\nif (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))\nBIT_flushBits(&blockStream);\nBIT_addBits(&blockStream, sequences[n].litLength, llBits);\nif (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);\nBIT_addBits(&blockStream, sequences[n].matchLength, mlBits);\nif (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);\nif (longOffsets) {\nint const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);\nif (extraBits) {\nBIT_addBits(&blockStream, sequences[n].offset, extraBits);\nBIT_flushBits(&blockStream);\n}\nBIT_addBits(&blockStream, sequences[n].offset >> extraBits,\nofBits - extraBits);\n} else {\nBIT_addBits(&blockStream, sequences[n].offset, ofBits);\n}\nBIT_flushBits(&blockStream);\nDEBUGLOG(7, \"remaining space : %i\", (int)(blockStream.endPtr - blockStream.ptr));\n}   }\nDEBUGLOG(6, \"ZSTD_encodeSequences: flushing ML state with %u bits\", stateMatchLength.stateLog);\nFSE_flushCState(&blockStream, &stateMatchLength);\nDEBUGLOG(6, \"ZSTD_encodeSequences: flushing Off state with %u bits\", stateOffsetBits.stateLog);\nFSE_flushCState(&blockStream, &stateOffsetBits);\nDEBUGLOG(6, \"ZSTD_encodeSequences: flushing LL state with %u bits\", stateLitLength.stateLog);\nFSE_flushCState(&blockStream, &stateLitLength);\n{   size_t const streamSize = BIT_closeCStream(&blockStream);\nif (streamSize==0) return ERROR(dstSize_tooSmall);\nreturn streamSize;\n}\n}", "label": 0}
{"index": 178570, "code": "static void rds_tcp_kill_sock(struct net *net)\n{\nstruct rds_tcp_connection *tc, *_tc;\nLIST_HEAD(tmp_list);\nstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\nstruct socket *lsock = rtn->rds_tcp_listen_sock;\nrtn->rds_tcp_listen_sock = NULL;\nrds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\nspin_lock_irq(&rds_tcp_conn_lock);\nlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\nstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\nif (net != c_net || !tc->t_sock)\ncontinue;\nif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\nlist_move_tail(&tc->t_tcp_node, &tmp_list);\n} else {\nlist_del(&tc->t_tcp_node);\ntc->t_tcp_node_detached = true;\n}\n}\nspin_unlock_irq(&rds_tcp_conn_lock);\nlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\nrds_conn_destroy(tc->t_cpath->cp_conn);\n}", "contrast": "static void rds_tcp_kill_sock(struct net *net)\n{\nstruct rds_tcp_connection *tc, *_tc;\nLIST_HEAD(tmp_list);\nstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\nstruct socket *lsock = rtn->rds_tcp_listen_sock;\nrtn->rds_tcp_listen_sock = NULL;\nrds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\nspin_lock_irq(&rds_tcp_conn_lock);\nlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\nstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\nif (net != c_net)\ncontinue;\nif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\nlist_move_tail(&tc->t_tcp_node, &tmp_list);\n} else {\nlist_del(&tc->t_tcp_node);\ntc->t_tcp_node_detached = true;\n}\n}\nspin_unlock_irq(&rds_tcp_conn_lock);\nlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\nrds_conn_destroy(tc->t_cpath->cp_conn);\n}", "label": 0}
{"index": 178571, "code": "static int try_smi_init(struct smi_info *new_smi)\n{\nint rv = 0;\nint i;\nchar *init_name = NULL;\npr_info(\"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\n\",\nipmi_addr_src_to_str(new_smi->io.addr_source),\nsi_to_str[new_smi->io.si_type],\naddr_space_to_str[new_smi->io.addr_type],\nnew_smi->io.addr_data,\nnew_smi->io.slave_addr, new_smi->io.irq);\nswitch (new_smi->io.si_type) {\ncase SI_KCS:\nnew_smi->handlers = &kcs_smi_handlers;\nbreak;\ncase SI_SMIC:\nnew_smi->handlers = &smic_smi_handlers;\nbreak;\ncase SI_BT:\nnew_smi->handlers = &bt_smi_handlers;\nbreak;\ndefault:\nrv = -EIO;\ngoto out_err;\n}\nnew_smi->si_num = smi_num;\nif (!new_smi->io.dev) {\ninit_name = kasprintf(GFP_KERNEL, \"ipmi_si.%d\",\nnew_smi->si_num);\nnew_smi->pdev = platform_device_alloc(\"ipmi_si\",\nnew_smi->si_num);\nif (!new_smi->pdev) {\npr_err(\"Unable to allocate platform device\\n\");\nrv = -ENOMEM;\ngoto out_err;\n}\nnew_smi->io.dev = &new_smi->pdev->dev;\nnew_smi->io.dev->driver = &ipmi_platform_driver.driver;\nnew_smi->io.dev->init_name = init_name;\n}\nnew_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);\nif (!new_smi->si_sm) {\nrv = -ENOMEM;\ngoto out_err;\n}\nnew_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,\n&new_smi->io);\nrv = new_smi->io.io_setup(&new_smi->io);\nif (rv) {\ndev_err(new_smi->io.dev, \"Could not set up I/O space\\n\");\ngoto out_err;\n}\nif (new_smi->handlers->detect(new_smi->si_sm)) {\nif (new_smi->io.addr_source)\ndev_err(new_smi->io.dev,\n\"Interface detection failed\\n\");\nrv = -ENODEV;\ngoto out_err;\n}\nrv = try_get_dev_id(new_smi);\nif (rv) {\nif (new_smi->io.addr_source)\ndev_err(new_smi->io.dev,\n\"There appears to be no BMC at this location\\n\");\ngoto out_err;\n}\nsetup_oem_data_handler(new_smi);\nsetup_xaction_handlers(new_smi);\ncheck_for_broken_irqs(new_smi);\nnew_smi->waiting_msg = NULL;\nnew_smi->curr_msg = NULL;\natomic_set(&new_smi->req_events, 0);\nnew_smi->run_to_completion = false;\nfor (i = 0; i < SI_NUM_STATS; i++)\natomic_set(&new_smi->stats[i], 0);\nnew_smi->interrupt_disabled = true;\natomic_set(&new_smi->need_watch, 0);\nrv = try_enable_event_buffer(new_smi);\nif (rv == 0)\nnew_smi->has_event_buffer = true;\nstart_clear_flags(new_smi);\nif (new_smi->io.irq) {\nnew_smi->interrupt_disabled = false;\natomic_set(&new_smi->req_events, 1);\n}\nif (new_smi->pdev && !new_smi->pdev_registered) {\nrv = platform_device_add(new_smi->pdev);\nif (rv) {\ndev_err(new_smi->io.dev,\n\"Unable to register system interface device: %d\\n\",\nrv);\ngoto out_err;\n}\nnew_smi->pdev_registered = true;\n}\ndev_set_drvdata(new_smi->io.dev, new_smi);\nrv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);\nif (rv) {\ndev_err(new_smi->io.dev,\n\"Unable to add device attributes: error %d\\n\",\nrv);\ngoto out_err;\n}\nnew_smi->dev_group_added = true;\nrv = ipmi_register_smi(&handlers,\nnew_smi,\nnew_smi->io.dev,\nnew_smi->io.slave_addr);\nif (rv) {\ndev_err(new_smi->io.dev,\n\"Unable to register device: error %d\\n\",\nrv);\ngoto out_err;\n}\nsmi_num++;\ndev_info(new_smi->io.dev, \"IPMI %s interface initialized\\n\",\nsi_to_str[new_smi->io.si_type]);\nWARN_ON(new_smi->io.dev->init_name != NULL);\nout_err:\nkfree(init_name);\nreturn rv;\n}", "contrast": "static int try_smi_init(struct smi_info *new_smi)\n{\nint rv = 0;\nint i;\nchar *init_name = NULL;\npr_info(\"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\n\",\nipmi_addr_src_to_str(new_smi->io.addr_source),\nsi_to_str[new_smi->io.si_type],\naddr_space_to_str[new_smi->io.addr_type],\nnew_smi->io.addr_data,\nnew_smi->io.slave_addr, new_smi->io.irq);\nswitch (new_smi->io.si_type) {\ncase SI_KCS:\nnew_smi->handlers = &kcs_smi_handlers;\nbreak;\ncase SI_SMIC:\nnew_smi->handlers = &smic_smi_handlers;\nbreak;\ncase SI_BT:\nnew_smi->handlers = &bt_smi_handlers;\nbreak;\ndefault:\nrv = -EIO;\ngoto out_err;\n}\nnew_smi->si_num = smi_num;\nif (!new_smi->io.dev) {\ninit_name = kasprintf(GFP_KERNEL, \"ipmi_si.%d\",\nnew_smi->si_num);\nnew_smi->pdev = platform_device_alloc(\"ipmi_si\",\nnew_smi->si_num);\nif (!new_smi->pdev) {\npr_err(\"Unable to allocate platform device\\n\");\nrv = -ENOMEM;\ngoto out_err;\n}\nnew_smi->io.dev = &new_smi->pdev->dev;\nnew_smi->io.dev->driver = &ipmi_platform_driver.driver;\nnew_smi->io.dev->init_name = init_name;\n}\nnew_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);\nif (!new_smi->si_sm) {\nrv = -ENOMEM;\ngoto out_err;\n}\nnew_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,\n&new_smi->io);\nrv = new_smi->io.io_setup(&new_smi->io);\nif (rv) {\ndev_err(new_smi->io.dev, \"Could not set up I/O space\\n\");\ngoto out_err;\n}\nif (new_smi->handlers->detect(new_smi->si_sm)) {\nif (new_smi->io.addr_source)\ndev_err(new_smi->io.dev,\n\"Interface detection failed\\n\");\nrv = -ENODEV;\ngoto out_err;\n}\nrv = try_get_dev_id(new_smi);\nif (rv) {\nif (new_smi->io.addr_source)\ndev_err(new_smi->io.dev,\n\"There appears to be no BMC at this location\\n\");\ngoto out_err;\n}\nsetup_oem_data_handler(new_smi);\nsetup_xaction_handlers(new_smi);\ncheck_for_broken_irqs(new_smi);\nnew_smi->waiting_msg = NULL;\nnew_smi->curr_msg = NULL;\natomic_set(&new_smi->req_events, 0);\nnew_smi->run_to_completion = false;\nfor (i = 0; i < SI_NUM_STATS; i++)\natomic_set(&new_smi->stats[i], 0);\nnew_smi->interrupt_disabled = true;\natomic_set(&new_smi->need_watch, 0);\nrv = try_enable_event_buffer(new_smi);\nif (rv == 0)\nnew_smi->has_event_buffer = true;\nstart_clear_flags(new_smi);\nif (new_smi->io.irq) {\nnew_smi->interrupt_disabled = false;\natomic_set(&new_smi->req_events, 1);\n}\nif (new_smi->pdev && !new_smi->pdev_registered) {\nrv = platform_device_add(new_smi->pdev);\nif (rv) {\ndev_err(new_smi->io.dev,\n\"Unable to register system interface device: %d\\n\",\nrv);\ngoto out_err;\n}\nnew_smi->pdev_registered = true;\n}\ndev_set_drvdata(new_smi->io.dev, new_smi);\nrv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);\nif (rv) {\ndev_err(new_smi->io.dev,\n\"Unable to add device attributes: error %d\\n\",\nrv);\ngoto out_err;\n}\nnew_smi->dev_group_added = true;\nrv = ipmi_register_smi(&handlers,\nnew_smi,\nnew_smi->io.dev,\nnew_smi->io.slave_addr);\nif (rv) {\ndev_err(new_smi->io.dev,\n\"Unable to register device: error %d\\n\",\nrv);\ngoto out_err;\n}\nsmi_num++;\ndev_info(new_smi->io.dev, \"IPMI %s interface initialized\\n\",\nsi_to_str[new_smi->io.si_type]);\nWARN_ON(new_smi->io.dev->init_name != NULL);\nout_err:\nif (rv && new_smi->io.io_cleanup) {\nnew_smi->io.io_cleanup(&new_smi->io);\nnew_smi->io.io_cleanup = NULL;\n}\nkfree(init_name);\nreturn rv;\n}", "label": 0}
{"index": 178574, "code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\nint i;\nint j;\nu16 max_cmd;\nstruct megasas_cmd *cmd;\nmax_cmd = instance->max_mfi_cmds;\ninstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\nif (!instance->cmd_list) {\ndev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\nreturn -ENOMEM;\n}\nmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\nfor (i = 0; i < max_cmd; i++) {\ninstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\nGFP_KERNEL);\nif (!instance->cmd_list[i]) {\nfor (j = 0; j < i; j++)\nkfree(instance->cmd_list[j]);\nkfree(instance->cmd_list);\ninstance->cmd_list = NULL;\nreturn -ENOMEM;\n}\n}\nfor (i = 0; i < max_cmd; i++) {\ncmd = instance->cmd_list[i];\nmemset(cmd, 0, sizeof(struct megasas_cmd));\ncmd->index = i;\ncmd->scmd = NULL;\ncmd->instance = instance;\nlist_add_tail(&cmd->list, &instance->cmd_pool);\n}\nif (megasas_create_frame_pool(instance)) {\ndev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\nmegasas_free_cmds(instance);\n}\nreturn 0;\n}", "contrast": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\nint i;\nint j;\nu16 max_cmd;\nstruct megasas_cmd *cmd;\nmax_cmd = instance->max_mfi_cmds;\ninstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\nif (!instance->cmd_list) {\ndev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\nreturn -ENOMEM;\n}\nmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\nfor (i = 0; i < max_cmd; i++) {\ninstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\nGFP_KERNEL);\nif (!instance->cmd_list[i]) {\nfor (j = 0; j < i; j++)\nkfree(instance->cmd_list[j]);\nkfree(instance->cmd_list);\ninstance->cmd_list = NULL;\nreturn -ENOMEM;\n}\n}\nfor (i = 0; i < max_cmd; i++) {\ncmd = instance->cmd_list[i];\nmemset(cmd, 0, sizeof(struct megasas_cmd));\ncmd->index = i;\ncmd->scmd = NULL;\ncmd->instance = instance;\nlist_add_tail(&cmd->list, &instance->cmd_pool);\n}\nif (megasas_create_frame_pool(instance)) {\ndev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\nmegasas_free_cmds(instance);\nreturn -ENOMEM;\n}\nreturn 0;\n}", "label": 0}
{"index": 178579, "code": "int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\nint64_t infilesize, total_samples;\nDFFFileHeader dff_file_header;\nDFFChunkHeader dff_chunk_header;\nuint32_t bcount;\ninfilesize = DoGetFileSize (infile);\nmemcpy (&dff_file_header, fourcc, 4);\nif ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\nbcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\n#if 1\nWavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\nif (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\ndff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\nerror_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (debug_logging_mode)\nerror_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n#endif\nwhile (1) {\nif (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\nbcount != sizeof (DFFChunkHeader)) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\nif (debug_logging_mode)\nerror_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\nif (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\nuint32_t version;\nif (dff_chunk_header.ckDataSize != sizeof (version) ||\n!DoReadFile (infile, &version, sizeof (version), &bcount) ||\nbcount != sizeof (version)) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &version, sizeof (version))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackBigEndianToNative (&version, \"L\");\nif (debug_logging_mode)\nerror_line (\"dsdiff file version = 0x%08x\", version);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\nchar *prop_chunk;\nif (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (debug_logging_mode)\nerror_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\nprop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\nif (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\nbcount != dff_chunk_header.ckDataSize) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (!strncmp (prop_chunk, \"SND \", 4)) {\nchar *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\nuint16_t numChannels = 0, chansSpecified, chanMask = 0;\nuint32_t sampleRate;\nwhile (eptr - cptr >= sizeof (dff_chunk_header)) {\nmemcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\ncptr += sizeof (dff_chunk_header);\nWavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\nif (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {\nif (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\nmemcpy (&sampleRate, cptr, sizeof (sampleRate));\nWavpackBigEndianToNative (&sampleRate, \"L\");\ncptr += dff_chunk_header.ckDataSize;\nif (debug_logging_mode)\nerror_line (\"got sample rate of %u Hz\", sampleRate);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\nmemcpy (&numChannels, cptr, sizeof (numChannels));\nWavpackBigEndianToNative (&numChannels, \"S\");\ncptr += sizeof (numChannels);\nchansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\nif (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nwhile (chansSpecified--) {\nif (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\nchanMask |= 0x1;\nelse if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\nchanMask |= 0x2;\nelse if (!strncmp (cptr, \"LS  \", 4))\nchanMask |= 0x10;\nelse if (!strncmp (cptr, \"RS  \", 4))\nchanMask |= 0x20;\nelse if (!strncmp (cptr, \"C   \", 4))\nchanMask |= 0x4;\nelse if (!strncmp (cptr, \"LFE \", 4))\nchanMask |= 0x8;\nelse\nif (debug_logging_mode)\nerror_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\ncptr += 4;\n}\nif (debug_logging_mode)\nerror_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\nif (strncmp (cptr, \"DSD \", 4)) {\nerror_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\ncptr [0], cptr [1], cptr [2], cptr [3]);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\ncptr += dff_chunk_header.ckDataSize;\n}\nelse {\nif (debug_logging_mode)\nerror_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\ndff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\ncptr += dff_chunk_header.ckDataSize;\n}\n}\nelse {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\n}\nif (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\nerror_line (\"this DSDIFF file already has channel order information!\");\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (chanMask)\nconfig->channel_mask = chanMask;\nconfig->bits_per_sample = 8;\nconfig->bytes_per_sample = 1;\nconfig->num_channels = numChannels;\nconfig->sample_rate = sampleRate / 8;\nconfig->qmode |= QMODE_DSD_MSB_FIRST;\n}\nelse if (debug_logging_mode)\nerror_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\nprop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\nfree (prop_chunk);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\nif (!config->num_channels) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\ntotal_samples = dff_chunk_header.ckDataSize / config->num_channels;\nbreak;\n}\nelse {\nint bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\nchar *buff;\nif (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nbuff = malloc (bytes_to_copy);\nif (debug_logging_mode)\nerror_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\ndff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\ndff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\nif (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\nbcount != bytes_to_copy ||\n(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nfree (buff);\nreturn WAVPACK_SOFT_ERROR;\n}\nfree (buff);\n}\n}\nif (debug_logging_mode)\nerror_line (\"setting configuration with %lld samples\", total_samples);\nif (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\nerror_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nreturn WAVPACK_NO_ERROR;\n}", "contrast": "int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\nint64_t infilesize, total_samples;\nDFFFileHeader dff_file_header;\nDFFChunkHeader dff_chunk_header;\nuint32_t bcount;\ninfilesize = DoGetFileSize (infile);\nmemcpy (&dff_file_header, fourcc, 4);\nif ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\nbcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\n#if 1\nWavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\nif (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\ndff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\nerror_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (debug_logging_mode)\nerror_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n#endif\nwhile (1) {\nif (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\nbcount != sizeof (DFFChunkHeader)) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\nif (debug_logging_mode)\nerror_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\nif (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\nuint32_t version;\nif (dff_chunk_header.ckDataSize != sizeof (version) ||\n!DoReadFile (infile, &version, sizeof (version), &bcount) ||\nbcount != sizeof (version)) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, &version, sizeof (version))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nWavpackBigEndianToNative (&version, \"L\");\nif (debug_logging_mode)\nerror_line (\"dsdiff file version = 0x%08x\", version);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\nchar *prop_chunk;\nif (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (debug_logging_mode)\nerror_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\nprop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\nif (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\nbcount != dff_chunk_header.ckDataSize) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nif (!strncmp (prop_chunk, \"SND \", 4)) {\nchar *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\nuint16_t numChannels = 0, chansSpecified, chanMask = 0;\nuint32_t sampleRate = 0;\nwhile (eptr - cptr >= sizeof (dff_chunk_header)) {\nmemcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\ncptr += sizeof (dff_chunk_header);\nWavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\nif (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {\nif (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\nmemcpy (&sampleRate, cptr, sizeof (sampleRate));\nWavpackBigEndianToNative (&sampleRate, \"L\");\ncptr += dff_chunk_header.ckDataSize;\nif (debug_logging_mode)\nerror_line (\"got sample rate of %u Hz\", sampleRate);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\nmemcpy (&numChannels, cptr, sizeof (numChannels));\nWavpackBigEndianToNative (&numChannels, \"S\");\ncptr += sizeof (numChannels);\nchansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\nif (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nwhile (chansSpecified--) {\nif (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\nchanMask |= 0x1;\nelse if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\nchanMask |= 0x2;\nelse if (!strncmp (cptr, \"LS  \", 4))\nchanMask |= 0x10;\nelse if (!strncmp (cptr, \"RS  \", 4))\nchanMask |= 0x20;\nelse if (!strncmp (cptr, \"C   \", 4))\nchanMask |= 0x4;\nelse if (!strncmp (cptr, \"LFE \", 4))\nchanMask |= 0x8;\nelse\nif (debug_logging_mode)\nerror_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\ncptr += 4;\n}\nif (debug_logging_mode)\nerror_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\nif (strncmp (cptr, \"DSD \", 4)) {\nerror_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\ncptr [0], cptr [1], cptr [2], cptr [3]);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\ncptr += dff_chunk_header.ckDataSize;\n}\nelse {\nif (debug_logging_mode)\nerror_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\ndff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\ncptr += dff_chunk_header.ckDataSize;\n}\n}\nelse {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\n}\nif (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\nerror_line (\"this DSDIFF file already has channel order information!\");\nfree (prop_chunk);\nreturn WAVPACK_SOFT_ERROR;\n}\nelse if (chanMask)\nconfig->channel_mask = chanMask;\nconfig->bits_per_sample = 8;\nconfig->bytes_per_sample = 1;\nconfig->num_channels = numChannels;\nconfig->sample_rate = sampleRate / 8;\nconfig->qmode |= QMODE_DSD_MSB_FIRST;\n}\nelse if (debug_logging_mode)\nerror_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\nprop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\nfree (prop_chunk);\n}\nelse if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\nif (!config->num_channels || !config->sample_rate) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\ntotal_samples = dff_chunk_header.ckDataSize / config->num_channels;\nbreak;\n}\nelse {\nint bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\nchar *buff;\nif (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\nerror_line (\"%s is not a valid .DFF file!\", infilename);\nreturn WAVPACK_SOFT_ERROR;\n}\nbuff = malloc (bytes_to_copy);\nif (debug_logging_mode)\nerror_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\ndff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\ndff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\nif (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\nbcount != bytes_to_copy ||\n(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\nerror_line (\"%s\", WavpackGetErrorMessage (wpc));\nfree (buff);\nreturn WAVPACK_SOFT_ERROR;\n}\nfree (buff);\n}\n}\nif (debug_logging_mode)\nerror_line (\"setting configuration with %lld samples\", total_samples);\nif (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\nerror_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\nreturn WAVPACK_SOFT_ERROR;\n}\nreturn WAVPACK_NO_ERROR;\n}", "label": 0}
{"index": 178586, "code": "static void Sp_replace_regexp(js_State *J)\n{\njs_Regexp *re;\nconst char *source, *s, *r;\njs_Buffer *sb = NULL;\nint n, x;\nResub m;\nsource = checkstring(J, 0);\nre = js_toregexp(J, 1);\nif (js_regexec(re->prog, source, &m, 0)) {\njs_copy(J, 0);\nreturn;\n}\nre->last = 0;\nloop:\ns = m.sub[0].sp;\nn = m.sub[0].ep - m.sub[0].sp;\nif (js_iscallable(J, 2)) {\njs_copy(J, 2);\njs_pushundefined(J);\nfor (x = 0; m.sub[x].sp; ++x)\njs_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);\njs_pushnumber(J, s - source);\njs_copy(J, 0);\njs_call(J, 2 + x);\nr = js_tostring(J, -1);\njs_putm(J, &sb, source, s);\njs_puts(J, &sb, r);\njs_pop(J, 1);\n} else {\nr = js_tostring(J, 2);\njs_putm(J, &sb, source, s);\nwhile (*r) {\nif (*r == '$') {\nswitch (*(++r)) {\ncase 0: --r;\ncase '$': js_putc(J, &sb, '$'); break;\ncase '`': js_putm(J, &sb, source, s); break;\ncase '\\'': js_puts(J, &sb, s + n); break;\ncase '&':\njs_putm(J, &sb, s, s + n);\nbreak;\ncase '0': case '1': case '2': case '3': case '4':\ncase '5': case '6': case '7': case '8': case '9':\nx = *r - '0';\nif (r[1] >= '0' && r[1] <= '9')\nx = x * 10 + *(++r) - '0';\nif (x > 0 && x < m.nsub) {\njs_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);\n} else {\njs_putc(J, &sb, '$');\nif (x > 10) {\njs_putc(J, &sb, '0' + x / 10);\njs_putc(J, &sb, '0' + x % 10);\n} else {\njs_putc(J, &sb, '0' + x);\n}\n}\nbreak;\ndefault:\njs_putc(J, &sb, '$');\njs_putc(J, &sb, *r);\nbreak;\n}\n++r;\n} else {\njs_putc(J, &sb, *r++);\n}\n}\n}\nif (re->flags & JS_REGEXP_G) {\nsource = m.sub[0].ep;\nif (n == 0) {\nif (*source)\njs_putc(J, &sb, *source++);\nelse\ngoto end;\n}\nif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\ngoto loop;\n}\nend:\njs_puts(J, &sb, s + n);\njs_putc(J, &sb, 0);\nif (js_try(J)) {\njs_free(J, sb);\njs_throw(J);\n}\njs_pushstring(J, sb ? sb->s : \"\");\njs_endtry(J);\njs_free(J, sb);\n}", "contrast": "static void Sp_replace_regexp(js_State *J)\n{\njs_Regexp *re;\nconst char *source, *s, *r;\njs_Buffer *sb = NULL;\nint n, x;\nResub m;\nsource = checkstring(J, 0);\nre = js_toregexp(J, 1);\nif (js_doregexec(J, re->prog, source, &m, 0)) {\njs_copy(J, 0);\nreturn;\n}\nre->last = 0;\nloop:\ns = m.sub[0].sp;\nn = m.sub[0].ep - m.sub[0].sp;\nif (js_iscallable(J, 2)) {\njs_copy(J, 2);\njs_pushundefined(J);\nfor (x = 0; m.sub[x].sp; ++x)\njs_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);\njs_pushnumber(J, s - source);\njs_copy(J, 0);\njs_call(J, 2 + x);\nr = js_tostring(J, -1);\njs_putm(J, &sb, source, s);\njs_puts(J, &sb, r);\njs_pop(J, 1);\n} else {\nr = js_tostring(J, 2);\njs_putm(J, &sb, source, s);\nwhile (*r) {\nif (*r == '$') {\nswitch (*(++r)) {\ncase 0: --r;\ncase '$': js_putc(J, &sb, '$'); break;\ncase '`': js_putm(J, &sb, source, s); break;\ncase '\\'': js_puts(J, &sb, s + n); break;\ncase '&':\njs_putm(J, &sb, s, s + n);\nbreak;\ncase '0': case '1': case '2': case '3': case '4':\ncase '5': case '6': case '7': case '8': case '9':\nx = *r - '0';\nif (r[1] >= '0' && r[1] <= '9')\nx = x * 10 + *(++r) - '0';\nif (x > 0 && x < m.nsub) {\njs_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);\n} else {\njs_putc(J, &sb, '$');\nif (x > 10) {\njs_putc(J, &sb, '0' + x / 10);\njs_putc(J, &sb, '0' + x % 10);\n} else {\njs_putc(J, &sb, '0' + x);\n}\n}\nbreak;\ndefault:\njs_putc(J, &sb, '$');\njs_putc(J, &sb, *r);\nbreak;\n}\n++r;\n} else {\njs_putc(J, &sb, *r++);\n}\n}\n}\nif (re->flags & JS_REGEXP_G) {\nsource = m.sub[0].ep;\nif (n == 0) {\nif (*source)\njs_putc(J, &sb, *source++);\nelse\ngoto end;\n}\nif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\ngoto loop;\n}\nend:\njs_puts(J, &sb, s + n);\njs_putc(J, &sb, 0);\nif (js_try(J)) {\njs_free(J, sb);\njs_throw(J);\n}\njs_pushstring(J, sb ? sb->s : \"\");\njs_endtry(J);\njs_free(J, sb);\n}", "label": 0}
{"index": 178591, "code": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\nchar buf[32], *e;\nsprintf(buf, fmt, w, n);\ne = strchr(buf, 'e');\nif (e) {\nint exp = atoi(e+1);\nsprintf(e, \"e%+d\", exp);\n}\njs_pushstring(J, buf);\n}", "contrast": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\nchar buf[50], *e;\nsprintf(buf, fmt, w, n);\ne = strchr(buf, 'e');\nif (e) {\nint exp = atoi(e+1);\nsprintf(e, \"e%+d\", exp);\n}\njs_pushstring(J, buf);\n}", "label": 0}
{"index": 178623, "code": "vips_malloc( VipsObject *object, size_t size )\n{\nvoid *buf;\nbuf = g_malloc( size );\nif( object ) {\ng_signal_connect( object, \"postclose\",\nG_CALLBACK( vips_malloc_cb ), buf );\nobject->local_memory += size;\n}\nreturn( buf );\n}", "contrast": "vips_malloc( VipsObject *object, size_t size )\n{\nvoid *buf;\nbuf = g_malloc0( size );\nif( object ) {\ng_signal_connect( object, \"postclose\",\nG_CALLBACK( vips_malloc_cb ), buf );\nobject->local_memory += size;\n}\nreturn( buf );\n}", "label": 0}
{"index": 178645, "code": "static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\nstruct ib_qp_init_attr *init_attr,\nstruct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\nstruct mlx5_ib_resources *devr = &dev->devr;\nint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\nstruct mlx5_core_dev *mdev = dev->mdev;\nstruct mlx5_ib_create_qp_resp resp;\nstruct mlx5_ib_cq *send_cq;\nstruct mlx5_ib_cq *recv_cq;\nunsigned long flags;\nu32 uidx = MLX5_IB_DEFAULT_UIDX;\nstruct mlx5_ib_create_qp ucmd;\nstruct mlx5_ib_qp_base *base;\nint mlx5_st;\nvoid *qpc;\nu32 *in;\nint err;\nmutex_init(&qp->mutex);\nspin_lock_init(&qp->sq.lock);\nspin_lock_init(&qp->rq.lock);\nmlx5_st = to_mlx5_st(init_attr->qp_type);\nif (mlx5_st < 0)\nreturn -EINVAL;\nif (init_attr->rwq_ind_tbl) {\nif (!udata)\nreturn -ENOSYS;\nerr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\nreturn err;\n}\nif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\nif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\nmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\nreturn -EINVAL;\n} else {\nqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n}\n}\nif (init_attr->create_flags &\n(IB_QP_CREATE_CROSS_CHANNEL |\nIB_QP_CREATE_MANAGED_SEND |\nIB_QP_CREATE_MANAGED_RECV)) {\nif (!MLX5_CAP_GEN(mdev, cd)) {\nmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\nreturn -EINVAL;\n}\nif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\nqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\nif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\nqp->flags |= MLX5_IB_QP_MANAGED_SEND;\nif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\nqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n}\nif (init_attr->qp_type == IB_QPT_UD &&\n(init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\nif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\nmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\nif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\nmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\nreturn -EOPNOTSUPP;\n}\nif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n!MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\nmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n}\nif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\nqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\nif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\nif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\nMLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n(init_attr->qp_type != IB_QPT_RAW_PACKET))\nreturn -EOPNOTSUPP;\nqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n}\nif (pd && pd->uobject) {\nif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\nmlx5_ib_dbg(dev, \"copy failed\\n\");\nreturn -EFAULT;\n}\nerr = get_qp_user_index(to_mucontext(pd->uobject->context),\n&ucmd, udata->inlen, &uidx);\nif (err)\nreturn err;\nqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\nqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\nif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\nif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n!tunnel_offload_supported(mdev)) {\nmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nqp->tunnel_offload_en = true;\n}\nif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\nif (init_attr->qp_type != IB_QPT_UD ||\n(MLX5_CAP_GEN(dev->mdev, port_type) !=\nMLX5_CAP_PORT_TYPE_IB) ||\n!mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\nmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nqp->flags |= MLX5_IB_QP_UNDERLAY;\nqp->underlay_qpn = init_attr->source_qpn;\n}\n} else {\nqp->wq_sig = !!wq_signature;\n}\nbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\nqp->flags & MLX5_IB_QP_UNDERLAY) ?\n&qp->raw_packet_qp.rq.base :\n&qp->trans_qp.base;\nqp->has_rq = qp_has_rq(init_attr);\nerr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\nqp, (pd && pd->uobject) ? &ucmd : NULL);\nif (err) {\nmlx5_ib_dbg(dev, \"err %d\\n\", err);\nreturn err;\n}\nif (pd) {\nif (pd->uobject) {\n__u32 max_wqes =\n1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\nmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\nif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\nucmd.rq_wqe_count != qp->rq.wqe_cnt) {\nmlx5_ib_dbg(dev, \"invalid rq params\\n\");\nreturn -EINVAL;\n}\nif (ucmd.sq_wqe_count > max_wqes) {\nmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\nucmd.sq_wqe_count, max_wqes);\nreturn -EINVAL;\n}\nif (init_attr->create_flags &\nmlx5_ib_create_qp_sqpn_qp1()) {\nmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\nreturn -EINVAL;\n}\nerr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n&resp, &inlen, base);\nif (err)\nmlx5_ib_dbg(dev, \"err %d\\n\", err);\n} else {\nerr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\nbase);\nif (err)\nmlx5_ib_dbg(dev, \"err %d\\n\", err);\n}\nif (err)\nreturn err;\n} else {\nin = kvzalloc(inlen, GFP_KERNEL);\nif (!in)\nreturn -ENOMEM;\nqp->create_type = MLX5_QP_EMPTY;\n}\nif (is_sqp(init_attr->qp_type))\nqp->port = init_attr->port_num;\nqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\nMLX5_SET(qpc, qpc, st, mlx5_st);\nMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\nif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\nMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\nelse\nMLX5_SET(qpc, qpc, latency_sensitive, 1);\nif (qp->wq_sig)\nMLX5_SET(qpc, qpc, wq_signature, 1);\nif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\nMLX5_SET(qpc, qpc, block_lb_mc, 1);\nif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\nMLX5_SET(qpc, qpc, cd_master, 1);\nif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\nMLX5_SET(qpc, qpc, cd_slave_send, 1);\nif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\nMLX5_SET(qpc, qpc, cd_slave_receive, 1);\nif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\nint rcqe_sz;\nint scqe_sz;\nrcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\nscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\nif (rcqe_sz == 128)\nMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\nelse\nMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\nif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\nif (scqe_sz == 128)\nMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\nelse\nMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n}\n}\nif (qp->rq.wqe_cnt) {\nMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\nMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n}\nMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\nif (qp->sq.wqe_cnt) {\nMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n} else {\nMLX5_SET(qpc, qpc, no_sq, 1);\nif (init_attr->srq &&\ninit_attr->srq->srq_type == IB_SRQT_TM)\nMLX5_SET(qpc, qpc, offload_type,\nMLX5_QPC_OFFLOAD_TYPE_RNDV);\n}\nswitch (init_attr->qp_type) {\ncase IB_QPT_XRC_TGT:\nMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\nMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\nbreak;\ncase IB_QPT_XRC_INI:\nMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\nbreak;\ndefault:\nif (init_attr->srq) {\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n} else {\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n}\n}\nif (init_attr->send_cq)\nMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\nif (init_attr->recv_cq)\nMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\nMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\nif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\nMLX5_SET(qpc, qpc, user_index, uidx);\nif (init_attr->qp_type == IB_QPT_UD &&\n(init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\nMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\nqp->flags |= MLX5_IB_QP_LSO;\n}\nif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\nif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\nmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\nerr = -EOPNOTSUPP;\ngoto err;\n} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\nMLX5_SET(qpc, qpc, end_padding_mode,\nMLX5_WQ_END_PAD_MODE_ALIGN);\n} else {\nqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n}\n}\nif (inlen < 0) {\nerr = -EINVAL;\ngoto err;\n}\nif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\nqp->flags & MLX5_IB_QP_UNDERLAY) {\nqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\nraw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\nerr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n} else {\nerr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n}\nif (err) {\nmlx5_ib_dbg(dev, \"create qp failed\\n\");\ngoto err_create;\n}\nkvfree(in);\nbase->container_mibqp = qp;\nbase->mqp.event = mlx5_ib_qp_event;\nget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n&send_cq, &recv_cq);\nspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\nmlx5_ib_lock_cqs(send_cq, recv_cq);\nlist_add_tail(&qp->qps_list, &dev->qp_list);\nif (send_cq)\nlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\nif (recv_cq)\nlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\nmlx5_ib_unlock_cqs(send_cq, recv_cq);\nspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\nreturn 0;\nerr_create:\nif (qp->create_type == MLX5_QP_USER)\ndestroy_qp_user(dev, pd, qp, base);\nelse if (qp->create_type == MLX5_QP_KERNEL)\ndestroy_qp_kernel(dev, qp);\nerr:\nkvfree(in);\nreturn err;\n}", "contrast": "static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\nstruct ib_qp_init_attr *init_attr,\nstruct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\nstruct mlx5_ib_resources *devr = &dev->devr;\nint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\nstruct mlx5_core_dev *mdev = dev->mdev;\nstruct mlx5_ib_create_qp_resp resp = {};\nstruct mlx5_ib_cq *send_cq;\nstruct mlx5_ib_cq *recv_cq;\nunsigned long flags;\nu32 uidx = MLX5_IB_DEFAULT_UIDX;\nstruct mlx5_ib_create_qp ucmd;\nstruct mlx5_ib_qp_base *base;\nint mlx5_st;\nvoid *qpc;\nu32 *in;\nint err;\nmutex_init(&qp->mutex);\nspin_lock_init(&qp->sq.lock);\nspin_lock_init(&qp->rq.lock);\nmlx5_st = to_mlx5_st(init_attr->qp_type);\nif (mlx5_st < 0)\nreturn -EINVAL;\nif (init_attr->rwq_ind_tbl) {\nif (!udata)\nreturn -ENOSYS;\nerr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\nreturn err;\n}\nif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\nif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\nmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\nreturn -EINVAL;\n} else {\nqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n}\n}\nif (init_attr->create_flags &\n(IB_QP_CREATE_CROSS_CHANNEL |\nIB_QP_CREATE_MANAGED_SEND |\nIB_QP_CREATE_MANAGED_RECV)) {\nif (!MLX5_CAP_GEN(mdev, cd)) {\nmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\nreturn -EINVAL;\n}\nif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\nqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\nif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\nqp->flags |= MLX5_IB_QP_MANAGED_SEND;\nif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\nqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n}\nif (init_attr->qp_type == IB_QPT_UD &&\n(init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\nif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\nmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\nif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\nmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\nreturn -EOPNOTSUPP;\n}\nif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n!MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\nmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n}\nif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\nqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\nif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\nif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\nMLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n(init_attr->qp_type != IB_QPT_RAW_PACKET))\nreturn -EOPNOTSUPP;\nqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n}\nif (pd && pd->uobject) {\nif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\nmlx5_ib_dbg(dev, \"copy failed\\n\");\nreturn -EFAULT;\n}\nerr = get_qp_user_index(to_mucontext(pd->uobject->context),\n&ucmd, udata->inlen, &uidx);\nif (err)\nreturn err;\nqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\nqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\nif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\nif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n!tunnel_offload_supported(mdev)) {\nmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nqp->tunnel_offload_en = true;\n}\nif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\nif (init_attr->qp_type != IB_QPT_UD ||\n(MLX5_CAP_GEN(dev->mdev, port_type) !=\nMLX5_CAP_PORT_TYPE_IB) ||\n!mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\nmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\nreturn -EOPNOTSUPP;\n}\nqp->flags |= MLX5_IB_QP_UNDERLAY;\nqp->underlay_qpn = init_attr->source_qpn;\n}\n} else {\nqp->wq_sig = !!wq_signature;\n}\nbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\nqp->flags & MLX5_IB_QP_UNDERLAY) ?\n&qp->raw_packet_qp.rq.base :\n&qp->trans_qp.base;\nqp->has_rq = qp_has_rq(init_attr);\nerr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\nqp, (pd && pd->uobject) ? &ucmd : NULL);\nif (err) {\nmlx5_ib_dbg(dev, \"err %d\\n\", err);\nreturn err;\n}\nif (pd) {\nif (pd->uobject) {\n__u32 max_wqes =\n1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\nmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\nif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\nucmd.rq_wqe_count != qp->rq.wqe_cnt) {\nmlx5_ib_dbg(dev, \"invalid rq params\\n\");\nreturn -EINVAL;\n}\nif (ucmd.sq_wqe_count > max_wqes) {\nmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\nucmd.sq_wqe_count, max_wqes);\nreturn -EINVAL;\n}\nif (init_attr->create_flags &\nmlx5_ib_create_qp_sqpn_qp1()) {\nmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\nreturn -EINVAL;\n}\nerr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n&resp, &inlen, base);\nif (err)\nmlx5_ib_dbg(dev, \"err %d\\n\", err);\n} else {\nerr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\nbase);\nif (err)\nmlx5_ib_dbg(dev, \"err %d\\n\", err);\n}\nif (err)\nreturn err;\n} else {\nin = kvzalloc(inlen, GFP_KERNEL);\nif (!in)\nreturn -ENOMEM;\nqp->create_type = MLX5_QP_EMPTY;\n}\nif (is_sqp(init_attr->qp_type))\nqp->port = init_attr->port_num;\nqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\nMLX5_SET(qpc, qpc, st, mlx5_st);\nMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\nif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\nMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\nelse\nMLX5_SET(qpc, qpc, latency_sensitive, 1);\nif (qp->wq_sig)\nMLX5_SET(qpc, qpc, wq_signature, 1);\nif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\nMLX5_SET(qpc, qpc, block_lb_mc, 1);\nif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\nMLX5_SET(qpc, qpc, cd_master, 1);\nif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\nMLX5_SET(qpc, qpc, cd_slave_send, 1);\nif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\nMLX5_SET(qpc, qpc, cd_slave_receive, 1);\nif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\nint rcqe_sz;\nint scqe_sz;\nrcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\nscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\nif (rcqe_sz == 128)\nMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\nelse\nMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\nif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\nif (scqe_sz == 128)\nMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\nelse\nMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n}\n}\nif (qp->rq.wqe_cnt) {\nMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\nMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n}\nMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\nif (qp->sq.wqe_cnt) {\nMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n} else {\nMLX5_SET(qpc, qpc, no_sq, 1);\nif (init_attr->srq &&\ninit_attr->srq->srq_type == IB_SRQT_TM)\nMLX5_SET(qpc, qpc, offload_type,\nMLX5_QPC_OFFLOAD_TYPE_RNDV);\n}\nswitch (init_attr->qp_type) {\ncase IB_QPT_XRC_TGT:\nMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\nMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\nbreak;\ncase IB_QPT_XRC_INI:\nMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\nbreak;\ndefault:\nif (init_attr->srq) {\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n} else {\nMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\nMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n}\n}\nif (init_attr->send_cq)\nMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\nif (init_attr->recv_cq)\nMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\nMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\nif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\nMLX5_SET(qpc, qpc, user_index, uidx);\nif (init_attr->qp_type == IB_QPT_UD &&\n(init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\nMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\nqp->flags |= MLX5_IB_QP_LSO;\n}\nif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\nif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\nmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\nerr = -EOPNOTSUPP;\ngoto err;\n} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\nMLX5_SET(qpc, qpc, end_padding_mode,\nMLX5_WQ_END_PAD_MODE_ALIGN);\n} else {\nqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n}\n}\nif (inlen < 0) {\nerr = -EINVAL;\ngoto err;\n}\nif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\nqp->flags & MLX5_IB_QP_UNDERLAY) {\nqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\nraw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\nerr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n} else {\nerr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n}\nif (err) {\nmlx5_ib_dbg(dev, \"create qp failed\\n\");\ngoto err_create;\n}\nkvfree(in);\nbase->container_mibqp = qp;\nbase->mqp.event = mlx5_ib_qp_event;\nget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n&send_cq, &recv_cq);\nspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\nmlx5_ib_lock_cqs(send_cq, recv_cq);\nlist_add_tail(&qp->qps_list, &dev->qp_list);\nif (send_cq)\nlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\nif (recv_cq)\nlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\nmlx5_ib_unlock_cqs(send_cq, recv_cq);\nspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\nreturn 0;\nerr_create:\nif (qp->create_type == MLX5_QP_USER)\ndestroy_qp_user(dev, pd, qp, base);\nelse if (qp->create_type == MLX5_QP_KERNEL)\ndestroy_qp_kernel(dev, qp);\nerr:\nkvfree(in);\nreturn err;\n}", "label": 0}
{"index": 178646, "code": "static int serdes_probe(struct platform_device *pdev)\n{\nstruct phy_provider *provider;\nstruct serdes_ctrl *ctrl;\nunsigned int i;\nint ret;\nctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\nif (!ctrl)\nreturn -ENOMEM;\nctrl->dev = &pdev->dev;\nctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\nif (IS_ERR(ctrl->regs))\nreturn PTR_ERR(ctrl->regs);\nfor (i = 0; i <= SERDES_MAX; i++) {\nret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\nif (ret)\nreturn ret;\n}\ndev_set_drvdata(&pdev->dev, ctrl);\nprovider = devm_of_phy_provider_register(ctrl->dev,\nserdes_simple_xlate);\nreturn PTR_ERR_OR_ZERO(provider);\n}", "contrast": "static int serdes_probe(struct platform_device *pdev)\n{\nstruct phy_provider *provider;\nstruct serdes_ctrl *ctrl;\nunsigned int i;\nint ret;\nctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\nif (!ctrl)\nreturn -ENOMEM;\nctrl->dev = &pdev->dev;\nctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\nif (IS_ERR(ctrl->regs))\nreturn PTR_ERR(ctrl->regs);\nfor (i = 0; i < SERDES_MAX; i++) {\nret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\nif (ret)\nreturn ret;\n}\ndev_set_drvdata(&pdev->dev, ctrl);\nprovider = devm_of_phy_provider_register(ctrl->dev,\nserdes_simple_xlate);\nreturn PTR_ERR_OR_ZERO(provider);\n}", "label": 0}
{"index": 178662, "code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\nif (cfs_rq->load.weight)\nreturn false;\nif (cfs_rq->avg.load_sum)\nreturn false;\nif (cfs_rq->avg.util_sum)\nreturn false;\nif (cfs_rq->avg.runnable_load_sum)\nreturn false;\nreturn true;\n}", "contrast": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)", "label": 0}
{"index": 178670, "code": "static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)\n{\nBool has_audio, has_video;\ns32 i;\nAVFormatContext *ctx;\nAVOutputFormat *fmt_out;\nBool ret = GF_FALSE;\nchar *ext, szName[1000], szExt[20];\nconst char *szExtList;\nFFDemux *ffd;\nif (!plug || !url)\nreturn GF_FALSE;\nif (!strnicmp(url, \"rtsp://\", 7)) return GF_FALSE;\nif (!strnicmp(url, \"rtspu://\", 8)) return GF_FALSE;\nif (!strnicmp(url, \"rtp://\", 6)) return GF_FALSE;\nif (!strnicmp(url, \"plato://\", 8)) return GF_FALSE;\nif (!strnicmp(url, \"udp://\", 6)) return GF_FALSE;\nif (!strnicmp(url, \"tcp://\", 6)) return GF_FALSE;\nif (!strnicmp(url, \"data:\", 5)) return GF_FALSE;\nffd = (FFDemux*)plug->priv;\nstrcpy(szName, url);\next = strrchr(szName, '#');\nif (ext) ext[0] = 0;\next = strrchr(szName, '?');\nif (ext) ext[0] = 0;\next = strrchr(szName, '.');\nif (ext && strlen(ext) > 19) ext = NULL;\nif (ext && strlen(ext) > 1) {\nstrcpy(szExt, &ext[1]);\nstrlwr(szExt);\n#ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS\nif (strstr(\"ts m2t mts dmb trp\", szExt) ) return GF_FALSE;\n#endif\nif (!strcmp(szExt, \"mp4\") || !strcmp(szExt, \"mpg4\") || !strcmp(szExt, \"m4a\") || !strcmp(szExt, \"m21\")\n|| !strcmp(szExt, \"m4v\") || !strcmp(szExt, \"m4a\")\n|| !strcmp(szExt, \"m4s\") || !strcmp(szExt, \"3gs\")\n|| !strcmp(szExt, \"3gp\") || !strcmp(szExt, \"3gpp\") || !strcmp(szExt, \"3gp2\") || !strcmp(szExt, \"3g2\")\n|| !strcmp(szExt, \"mp3\")\n|| !strcmp(szExt, \"ac3\")\n|| !strcmp(szExt, \"amr\")\n|| !strcmp(szExt, \"bt\") || !strcmp(szExt, \"wrl\") || !strcmp(szExt, \"x3dv\")\n|| !strcmp(szExt, \"xmt\") || !strcmp(szExt, \"xmta\") || !strcmp(szExt, \"x3d\")\n|| !strcmp(szExt, \"jpg\") || !strcmp(szExt, \"jpeg\") || !strcmp(szExt, \"png\")\n) return GF_FALSE;\n{\nu32 i;\nfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {\nif (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))\nreturn GF_TRUE;\n}\n}\n}\nffd_parse_options(ffd, url);\nctx = NULL;\nif (open_file(&ctx, szName, NULL, ffd->options ? &ffd->options : NULL)<0) {\nAVInputFormat *av_in = NULL;\nif (ext && !strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");\nif (open_file(&ctx, szName, av_in, ffd->options ? &ffd->options : NULL)<0) {\nreturn GF_FALSE;\n}\n}\nif (!ctx) goto exit;\nif (av_find_stream_info(ctx) <0) goto exit;\nhas_video = has_audio = GF_FALSE;\nfor(i = 0; i < (s32)ctx->nb_streams; i++) {\nAVCodecContext *enc = ctx->streams[i]->codec;\nswitch(enc->codec_type) {\ncase AVMEDIA_TYPE_AUDIO:\nif (!has_audio) has_audio = GF_TRUE;\nbreak;\ncase AVMEDIA_TYPE_VIDEO:\nif (!has_video) has_video= GF_TRUE;\nbreak;\ndefault:\nbreak;\n}\n}\nif (!has_audio && !has_video) goto exit;\nret = GF_TRUE;\n#if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)\nfmt_out = guess_stream_format(NULL, url, NULL);\n#else\nfmt_out = av_guess_format(NULL, url, NULL);\n#endif\nif (fmt_out) gf_service_register_mime(plug, fmt_out->mime_type, fmt_out->extensions, fmt_out->name);\nelse {\next = strrchr(szName, '.');\nif (ext) {\nstrcpy(szExt, &ext[1]);\nstrlwr(szExt);\nszExtList = gf_modules_get_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\");\nif (!szExtList) {\ngf_service_register_mime(plug, \"application/x-ffmpeg\", szExt, \"Other Movies (FFMPEG)\");\n} else if (!strstr(szExtList, szExt)) {\nu32 len;\nchar *buf;\nlen = (u32) (strlen(szExtList) + strlen(szExt) + 10);\nbuf = (char*)gf_malloc(sizeof(char)*len);\nsprintf(buf, \"\\\"%s \", szExt);\nstrcat(buf, &szExtList[1]);\ngf_modules_set_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\", buf);\ngf_free(buf);\n}\n}\n}\nexit:\n#if FF_API_CLOSE_INPUT_FILE\nif (ctx) av_close_input_file(ctx);\n#else\nif (ctx) avformat_close_input(&ctx);\n#endif\nreturn ret;\n}", "contrast": "static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)\n{\nBool has_audio, has_video;\ns32 i;\nAVFormatContext *ctx;\nAVOutputFormat *fmt_out;\nBool ret = GF_FALSE;\nchar *ext, szName[1024], szExt[20];\nconst char *szExtList;\nFFDemux *ffd;\nif (!plug || !url)\nreturn GF_FALSE;\nif (!strnicmp(url, \"rtsp://\", 7)) return GF_FALSE;\nif (!strnicmp(url, \"rtspu://\", 8)) return GF_FALSE;\nif (!strnicmp(url, \"rtp://\", 6)) return GF_FALSE;\nif (!strnicmp(url, \"plato://\", 8)) return GF_FALSE;\nif (!strnicmp(url, \"udp://\", 6)) return GF_FALSE;\nif (!strnicmp(url, \"tcp://\", 6)) return GF_FALSE;\nif (!strnicmp(url, \"data:\", 5)) return GF_FALSE;\nffd = (FFDemux*)plug->priv;\nif (strlen(url) >= sizeof(szName))\nreturn GF_FALSE;\nstrcpy(szName, url);\next = strrchr(szName, '#');\nif (ext) ext[0] = 0;\next = strrchr(szName, '?');\nif (ext) ext[0] = 0;\next = strrchr(szName, '.');\nif (ext && strlen(ext) > 19) ext = NULL;\nif (ext && strlen(ext) > 1 && strlen(ext) <= sizeof(szExt)) {\nstrcpy(szExt, &ext[1]);\nstrlwr(szExt);\n#ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS\nif (strstr(\"ts m2t mts dmb trp\", szExt) ) return GF_FALSE;\n#endif\nif (!strcmp(szExt, \"mp4\") || !strcmp(szExt, \"mpg4\") || !strcmp(szExt, \"m4a\") || !strcmp(szExt, \"m21\")\n|| !strcmp(szExt, \"m4v\") || !strcmp(szExt, \"m4a\")\n|| !strcmp(szExt, \"m4s\") || !strcmp(szExt, \"3gs\")\n|| !strcmp(szExt, \"3gp\") || !strcmp(szExt, \"3gpp\") || !strcmp(szExt, \"3gp2\") || !strcmp(szExt, \"3g2\")\n|| !strcmp(szExt, \"mp3\")\n|| !strcmp(szExt, \"ac3\")\n|| !strcmp(szExt, \"amr\")\n|| !strcmp(szExt, \"bt\") || !strcmp(szExt, \"wrl\") || !strcmp(szExt, \"x3dv\")\n|| !strcmp(szExt, \"xmt\") || !strcmp(szExt, \"xmta\") || !strcmp(szExt, \"x3d\")\n|| !strcmp(szExt, \"jpg\") || !strcmp(szExt, \"jpeg\") || !strcmp(szExt, \"png\")\n) return GF_FALSE;\n{\nu32 i;\nfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {\nif (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))\nreturn GF_TRUE;\n}\n}\n}\nffd_parse_options(ffd, url);\nctx = NULL;\nif (open_file(&ctx, szName, NULL, ffd->options ? &ffd->options : NULL)<0) {\nAVInputFormat *av_in = NULL;\nif (ext && !strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");\nif (open_file(&ctx, szName, av_in, ffd->options ? &ffd->options : NULL)<0) {\nreturn GF_FALSE;\n}\n}\nif (!ctx) goto exit;\nif (av_find_stream_info(ctx) <0) goto exit;\nhas_video = has_audio = GF_FALSE;\nfor(i = 0; i < (s32)ctx->nb_streams; i++) {\nAVCodecContext *enc = ctx->streams[i]->codec;\nswitch(enc->codec_type) {\ncase AVMEDIA_TYPE_AUDIO:\nif (!has_audio) has_audio = GF_TRUE;\nbreak;\ncase AVMEDIA_TYPE_VIDEO:\nif (!has_video) has_video= GF_TRUE;\nbreak;\ndefault:\nbreak;\n}\n}\nif (!has_audio && !has_video) goto exit;\nret = GF_TRUE;\n#if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)\nfmt_out = guess_stream_format(NULL, url, NULL);\n#else\nfmt_out = av_guess_format(NULL, url, NULL);\n#endif\nif (fmt_out) gf_service_register_mime(plug, fmt_out->mime_type, fmt_out->extensions, fmt_out->name);\nelse {\next = strrchr(szName, '.');\nif (ext) {\nstrcpy(szExt, &ext[1]);\nstrlwr(szExt);\nszExtList = gf_modules_get_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\");\nif (!szExtList) {\ngf_service_register_mime(plug, \"application/x-ffmpeg\", szExt, \"Other Movies (FFMPEG)\");\n} else if (!strstr(szExtList, szExt)) {\nu32 len;\nchar *buf;\nlen = (u32) (strlen(szExtList) + strlen(szExt) + 10);\nbuf = (char*)gf_malloc(sizeof(char)*len);\nsprintf(buf, \"\\\"%s \", szExt);\nstrcat(buf, &szExtList[1]);\ngf_modules_set_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\", buf);\ngf_free(buf);\n}\n}\n}\nexit:\n#if FF_API_CLOSE_INPUT_FILE\nif (ctx) av_close_input_file(ctx);\n#else\nif (ctx) avformat_close_input(&ctx);\n#endif\nreturn ret;\n}", "label": 0}
{"index": 178678, "code": "mcs_recv_connect_response(STREAM mcs_data)\n{\nUNUSED(mcs_data);\nuint8 result;\nint length;\nSTREAM s;\nRD_BOOL is_fastpath;\nuint8 fastpath_hdr;\nlogger(Protocol, Debug, \"%s()\", __func__);\ns = iso_recv(&is_fastpath, &fastpath_hdr);\nif (s == NULL)\nreturn False;\nber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\nber_parse_header(s, BER_TAG_RESULT, &length);\nin_uint8(s, result);\nif (result != 0)\n{\nlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\nreturn False;\n}\nber_parse_header(s, BER_TAG_INTEGER, &length);\nin_uint8s(s, length);\nmcs_parse_domain_params(s);\nber_parse_header(s, BER_TAG_OCTET_STRING, &length);\nsec_process_mcs_data(s);\nreturn s_check_end(s);\n}", "contrast": "mcs_recv_connect_response(STREAM mcs_data)\n{\nUNUSED(mcs_data);\nuint8 result;\nuint32 length;\nSTREAM s;\nstruct stream packet;\nRD_BOOL is_fastpath;\nuint8 fastpath_hdr;\nlogger(Protocol, Debug, \"%s()\", __func__);\ns = iso_recv(&is_fastpath, &fastpath_hdr);\nif (s == NULL)\nreturn False;\npacket = *s;\nber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\nber_parse_header(s, BER_TAG_RESULT, &length);\nin_uint8(s, result);\nif (result != 0)\n{\nlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\nreturn False;\n}\nber_parse_header(s, BER_TAG_INTEGER, &length);\nin_uint8s(s, length);\nif (!s_check_rem(s, length))\n{\nrdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n}\nmcs_parse_domain_params(s);\nber_parse_header(s, BER_TAG_OCTET_STRING, &length);\nsec_process_mcs_data(s);\nreturn s_check_end(s);\n}", "label": 0}
{"index": 178683, "code": "rdpdr_process(STREAM s)\n{\nuint32 handle;\nuint16 vmin;\nuint16 component;\nuint16 pakid;\nlogger(Protocol, Debug, \"rdpdr_process()\");\nin_uint16(s, component);\nin_uint16(s, pakid);\nif (component == RDPDR_CTYP_CORE)\n{\nswitch (pakid)\n{\ncase PAKID_CORE_DEVICE_IOREQUEST:\nrdpdr_process_irp(s);\nbreak;\ncase PAKID_CORE_SERVER_ANNOUNCE:\nin_uint8s(s, 2);\nin_uint16_le(s, vmin);\nin_uint32_le(s, g_client_id);\nif (vmin < 0x000c)\ng_client_id = 0x815ed39d;\ng_epoch++;\n#if WITH_SCARD\nscard_release_all_contexts();\n#endif\nrdpdr_send_client_announce_reply();\nrdpdr_send_client_name_request();\nbreak;\ncase PAKID_CORE_CLIENTID_CONFIRM:\nrdpdr_send_client_device_list_announce();\nbreak;\ncase PAKID_CORE_DEVICE_REPLY:\nin_uint32(s, handle);\nlogger(Protocol, Debug,\n\"rdpdr_process(), server connected to resource %d\", handle);\nbreak;\ncase PAKID_CORE_SERVER_CAPABILITY:\nrdpdr_send_client_capability_response();\nbreak;\ndefault:\nlogger(Protocol, Debug,\n\"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\ncomponent);\nbreak;\n}\n}\nelse if (component == RDPDR_CTYP_PRN)\n{\nif (pakid == PAKID_PRN_CACHE_DATA)\nprintercache_process(s);\n}\nelse\nlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}", "contrast": "rdpdr_process(STREAM s)\n{\nuint32 handle;\nuint16 vmin;\nuint16 component;\nuint16 pakid;\nstruct stream packet = *s;\nlogger(Protocol, Debug, \"rdpdr_process()\");\nin_uint16(s, component);\nin_uint16(s, pakid);\nif (component == RDPDR_CTYP_CORE)\n{\nswitch (pakid)\n{\ncase PAKID_CORE_DEVICE_IOREQUEST:\nrdpdr_process_irp(s);\nbreak;\ncase PAKID_CORE_SERVER_ANNOUNCE:\nin_uint8s(s, 2);\nin_uint16_le(s, vmin);\nin_uint32_le(s, g_client_id);\nif (!s_check(s))\n{\nrdp_protocol_error(\"rdpdr_process(), consume of g_client_id from stream did overrun\", &packet);\n}\nif (vmin < 0x000c)\ng_client_id = 0x815ed39d;\ng_epoch++;\n#if WITH_SCARD\nscard_release_all_contexts();\n#endif\nrdpdr_send_client_announce_reply();\nrdpdr_send_client_name_request();\nbreak;\ncase PAKID_CORE_CLIENTID_CONFIRM:\nrdpdr_send_client_device_list_announce();\nbreak;\ncase PAKID_CORE_DEVICE_REPLY:\nin_uint32(s, handle);\nlogger(Protocol, Debug,\n\"rdpdr_process(), server connected to resource %d\", handle);\nbreak;\ncase PAKID_CORE_SERVER_CAPABILITY:\nrdpdr_send_client_capability_response();\nbreak;\ndefault:\nlogger(Protocol, Debug,\n\"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\ncomponent);\nbreak;\n}\n}\nelse if (component == RDPDR_CTYP_PRN)\n{\nif (pakid == PAKID_PRN_CACHE_DATA)\nprintercache_process(s);\n}\nelse\nlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}", "label": 0}
{"index": 178715, "code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\nint rc;\nstruct ssh_userdata *sshu = NULL;\nassert(lua_gettop(L) == 4);\nsshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\nwhile ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\nluaL_getmetafield(L, 3, \"filter\");\nlua_pushvalue(L, 3);\nassert(lua_status(L) == LUA_OK);\nlua_callk(L, 1, 0, 0, do_session_handshake);\n}\nif (rc) {\nlibssh2_session_free(sshu->session);\nreturn luaL_error(L, \"Unable to complete libssh2 handshake.\");\n}\nlua_settop(L, 3);\nreturn 1;\n}", "contrast": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\nint rc;\nstruct ssh_userdata *sshu = NULL;\nassert(lua_gettop(L) == 4);\nsshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\nwhile ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\nluaL_getmetafield(L, 3, \"filter\");\nlua_pushvalue(L, 3);\nassert(lua_status(L) == LUA_OK);\nlua_callk(L, 1, 0, 0, do_session_handshake);\n}\nif (rc) {\nlibssh2_session_free(sshu->session);\nsshu->session = NULL;\nreturn luaL_error(L, \"Unable to complete libssh2 handshake.\");\n}\nlua_settop(L, 3);\nreturn 1;\n}", "label": 0}
{"index": 178721, "code": "static const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\nconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\nif (*str!='\\\"') {*ep=str;return 0;}\nwhile (*end_ptr!='\\\"' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\nout=(char*)cJSON_malloc(len+1);\nif (!out) return 0;\nitem->valuestring=out;\nitem->type=cJSON_String;\nptr=str+1;ptr2=out;\nwhile (ptr < end_ptr)\n{\nif (*ptr!='\\\\') *ptr2++=*ptr++;\nelse\n{\nptr++;\nswitch (*ptr)\n{\ncase 'b': *ptr2++='\\b';\tbreak;\ncase 'f': *ptr2++='\\f';\tbreak;\ncase 'n': *ptr2++='\\n';\tbreak;\ncase 'r': *ptr2++='\\r';\tbreak;\ncase 't': *ptr2++='\\t';\tbreak;\ncase 'u':\nuc=parse_hex4(ptr+1);ptr+=4;\nif (ptr >= end_ptr) {*ep=str;return 0;}\nif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\nif (uc>=0xD800 && uc<=0xDBFF)\n{\nif (ptr+6 > end_ptr)    {*ep=str;return 0;}\nif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\nuc2=parse_hex4(ptr+3);ptr+=6;\nif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\nuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n}\nlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\nswitch (len) {\ncase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\ncase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\ncase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\ncase 1: *--ptr2 =(uc | firstByteMark[len]);\n}\nptr2+=len;\nbreak;\ndefault:  *ptr2++=*ptr; break;\n}\nptr++;\n}\n}\n*ptr2=0;\nif (*ptr=='\\\"') ptr++;\nreturn ptr;\n}", "contrast": "static const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\nconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\nif (*str!='\\\"') {*ep=str;return 0;}\nwhile (*end_ptr!='\\\"' && *end_ptr && ++len)\n{\nif (*end_ptr++ == '\\\\')\n{\nif (*end_ptr == '\\0')\n{\nreturn 0;\n}\nend_ptr++;\n}\n}\nout=(char*)cJSON_malloc(len+1);\nif (!out) return 0;\nitem->valuestring=out;\nitem->type=cJSON_String;\nptr=str+1;ptr2=out;\nwhile (ptr < end_ptr)\n{\nif (*ptr!='\\\\') *ptr2++=*ptr++;\nelse\n{\nptr++;\nswitch (*ptr)\n{\ncase 'b': *ptr2++='\\b';\tbreak;\ncase 'f': *ptr2++='\\f';\tbreak;\ncase 'n': *ptr2++='\\n';\tbreak;\ncase 'r': *ptr2++='\\r';\tbreak;\ncase 't': *ptr2++='\\t';\tbreak;\ncase 'u':\nuc=parse_hex4(ptr+1);ptr+=4;\nif (ptr >= end_ptr) {*ep=str;return 0;}\nif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\nif (uc>=0xD800 && uc<=0xDBFF)\n{\nif (ptr+6 > end_ptr)    {*ep=str;return 0;}\nif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\nuc2=parse_hex4(ptr+3);ptr+=6;\nif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\nuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n}\nlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\nswitch (len) {\ncase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\ncase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\ncase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\ncase 1: *--ptr2 =(uc | firstByteMark[len]);\n}\nptr2+=len;\nbreak;\ndefault:  *ptr2++=*ptr; break;\n}\nptr++;\n}\n}\n*ptr2=0;\nif (*ptr=='\\\"') ptr++;\nreturn ptr;\n}", "label": 0}
{"index": 178728, "code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\nif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\nIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\"addr %pM\\n\",\nsta_id, priv->stations[sta_id].sta.sta.addr);\nif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\nIWL_DEBUG_ASSOC(priv,\n\"STA id %u addr %pM already present in uCode \"\n\"(according to driver)\\n\",\nsta_id, priv->stations[sta_id].sta.sta.addr);\n} else {\npriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\nIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\nsta_id, priv->stations[sta_id].sta.sta.addr);\n}\n}", "contrast": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\nstatic int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\nif (sta_id >= IWLAGN_STATION_COUNT) {\nIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\nreturn -EINVAL;\n}\nif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\nIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\"addr %pM\\n\",\nsta_id, priv->stations[sta_id].sta.sta.addr);\nif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\nIWL_DEBUG_ASSOC(priv,\n\"STA id %u addr %pM already present in uCode \"\n\"(according to driver)\\n\",\nsta_id, priv->stations[sta_id].sta.sta.addr);\n} else {\npriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\nIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\nsta_id, priv->stations[sta_id].sta.sta.addr);\n}\nreturn 0;\n}", "label": 0}
{"index": 178740, "code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\nconst cdf_header_t *h, cdf_secid_t id)\n{\nassert((size_t)CDF_SEC_SIZE(h) == len);\nreturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n((char *)buf) + offs, len);\n}", "contrast": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\nconst cdf_header_t *h, cdf_secid_t id)\n{\nsize_t ss = CDF_SEC_SIZE(h);\nsize_t pos = CDF_SEC_POS(h, id);\nassert(ss == len);\nreturn cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);\n}", "label": 0}
{"index": 178762, "code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\nregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\nif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n(ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\njmp_rel(ctxt, ctxt->src.val);\nreturn X86EMUL_CONTINUE;\n}", "contrast": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\nint rc = X86EMUL_CONTINUE;\nregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\nif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n(ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\nrc = jmp_rel(ctxt, ctxt->src.val);\nreturn rc;\n}", "label": 0}
{"index": 178766, "code": "int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\nconst struct x86_emulate_ops *ops = ctxt->ops;\nint rc = X86EMUL_CONTINUE;\nint saved_dst_type = ctxt->dst.type;\nctxt->mem_read.pos = 0;\nif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif (unlikely(ctxt->d &\n(No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {\nif ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||\n(ctxt->d & Undefined)) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))\n|| ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\nrc = emulate_nm(ctxt);\ngoto done;\n}\nif (ctxt->d & Mmx) {\nrc = flush_pending_x87_faults(ctxt);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\nfetch_possible_mmx_operand(ctxt, &ctxt->src);\nfetch_possible_mmx_operand(ctxt, &ctxt->src2);\nif (!(ctxt->d & Mov))\nfetch_possible_mmx_operand(ctxt, &ctxt->dst);\n}\nif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\nrc = emulator_check_intercept(ctxt, ctxt->intercept,\nX86_ICPT_PRE_EXCEPT);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\nif (ctxt->d & PrivUD)\nrc = emulate_ud(ctxt);\nelse\nrc = emulate_gp(ctxt, 0);\ngoto done;\n}\nif ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif (ctxt->d & CheckPerm) {\nrc = ctxt->check_perm(ctxt);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\nrc = emulator_check_intercept(ctxt, ctxt->intercept,\nX86_ICPT_POST_EXCEPT);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (ctxt->rep_prefix && (ctxt->d & String)) {\nif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {\nctxt->eip = ctxt->_eip;\nctxt->eflags &= ~EFLG_RF;\ngoto done;\n}\n}\n}\nif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\nrc = segmented_read(ctxt, ctxt->src.addr.mem,\nctxt->src.valptr, ctxt->src.bytes);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\nctxt->src.orig_val64 = ctxt->src.val64;\n}\nif (ctxt->src2.type == OP_MEM) {\nrc = segmented_read(ctxt, ctxt->src2.addr.mem,\n&ctxt->src2.val, ctxt->src2.bytes);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif ((ctxt->d & DstMask) == ImplicitOps)\ngoto special_insn;\nif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\nrc = segmented_read(ctxt, ctxt->dst.addr.mem,\n&ctxt->dst.val, ctxt->dst.bytes);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nctxt->dst.orig_val = ctxt->dst.val;\nspecial_insn:\nif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\nrc = emulator_check_intercept(ctxt, ctxt->intercept,\nX86_ICPT_POST_MEMACCESS);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (ctxt->rep_prefix && (ctxt->d & String))\nctxt->eflags |= EFLG_RF;\nelse\nctxt->eflags &= ~EFLG_RF;\nif (ctxt->execute) {\nif (ctxt->d & Fastop) {\nvoid (*fop)(struct fastop *) = (void *)ctxt->execute;\nrc = fastop(ctxt, fop);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\ngoto writeback;\n}\nrc = ctxt->execute(ctxt);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\ngoto writeback;\n}\nif (ctxt->opcode_len == 2)\ngoto twobyte_insn;\nelse if (ctxt->opcode_len == 3)\ngoto threebyte_insn;\nswitch (ctxt->b) {\ncase 0x63:\nif (ctxt->mode != X86EMUL_MODE_PROT64)\ngoto cannot_emulate;\nctxt->dst.val = (s32) ctxt->src.val;\nbreak;\ncase 0x70 ... 0x7f:\nif (test_cc(ctxt->b, ctxt->eflags))\njmp_rel(ctxt, ctxt->src.val);\nbreak;\ncase 0x8d:\nctxt->dst.val = ctxt->src.addr.mem.ea;\nbreak;\ncase 0x90 ... 0x97:\nif (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))\nctxt->dst.type = OP_NONE;\nelse\nrc = em_xchg(ctxt);\nbreak;\ncase 0x98:\nswitch (ctxt->op_bytes) {\ncase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\ncase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\ncase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n}\nbreak;\ncase 0xcc:\nrc = emulate_int(ctxt, 3);\nbreak;\ncase 0xcd:\nrc = emulate_int(ctxt, ctxt->src.val);\nbreak;\ncase 0xce:\nif (ctxt->eflags & EFLG_OF)\nrc = emulate_int(ctxt, 4);\nbreak;\ncase 0xe9:\ncase 0xeb:\njmp_rel(ctxt, ctxt->src.val);\nctxt->dst.type = OP_NONE;\nbreak;\ncase 0xf4:\nctxt->ops->halt(ctxt);\nbreak;\ncase 0xf5:\nctxt->eflags ^= EFLG_CF;\nbreak;\ncase 0xf8:\nctxt->eflags &= ~EFLG_CF;\nbreak;\ncase 0xf9:\nctxt->eflags |= EFLG_CF;\nbreak;\ncase 0xfc:\nctxt->eflags &= ~EFLG_DF;\nbreak;\ncase 0xfd:\nctxt->eflags |= EFLG_DF;\nbreak;\ndefault:\ngoto cannot_emulate;\n}\nif (rc != X86EMUL_CONTINUE)\ngoto done;\nwriteback:\nif (ctxt->d & SrcWrite) {\nBUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);\nrc = writeback(ctxt, &ctxt->src);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (!(ctxt->d & NoWrite)) {\nrc = writeback(ctxt, &ctxt->dst);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nctxt->dst.type = saved_dst_type;\nif ((ctxt->d & SrcMask) == SrcSI)\nstring_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);\nif ((ctxt->d & DstMask) == DstDI)\nstring_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);\nif (ctxt->rep_prefix && (ctxt->d & String)) {\nunsigned int count;\nstruct read_cache *r = &ctxt->io_read;\nif ((ctxt->d & SrcMask) == SrcSI)\ncount = ctxt->src.count;\nelse\ncount = ctxt->dst.count;\nregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX),\n-count);\nif (!string_insn_completed(ctxt)) {\nif ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&\n(r->end == 0 || r->end != r->pos)) {\nctxt->mem_read.end = 0;\nwriteback_registers(ctxt);\nreturn EMULATION_RESTART;\n}\ngoto done;\n}\nctxt->eflags &= ~EFLG_RF;\n}\nctxt->eip = ctxt->_eip;\ndone:\nif (rc == X86EMUL_PROPAGATE_FAULT) {\nWARN_ON(ctxt->exception.vector > 0x1f);\nctxt->have_exception = true;\n}\nif (rc == X86EMUL_INTERCEPTED)\nreturn EMULATION_INTERCEPTED;\nif (rc == X86EMUL_CONTINUE)\nwriteback_registers(ctxt);\nreturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\ntwobyte_insn:\nswitch (ctxt->b) {\ncase 0x09:\n(ctxt->ops->wbinvd)(ctxt);\nbreak;\ncase 0x08:\ncase 0x0d:\ncase 0x18:\ncase 0x1f:\nbreak;\ncase 0x20:\nctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\nbreak;\ncase 0x21:\nops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\nbreak;\ncase 0x40 ... 0x4f:\nif (test_cc(ctxt->b, ctxt->eflags))\nctxt->dst.val = ctxt->src.val;\nelse if (ctxt->mode != X86EMUL_MODE_PROT64 ||\nctxt->op_bytes != 4)\nctxt->dst.type = OP_NONE;\nbreak;\ncase 0x80 ... 0x8f:\nif (test_cc(ctxt->b, ctxt->eflags))\njmp_rel(ctxt, ctxt->src.val);\nbreak;\ncase 0x90 ... 0x9f:\nctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\nbreak;\ncase 0xae:\nbreak;\ncase 0xb6 ... 0xb7:\nctxt->dst.bytes = ctxt->op_bytes;\nctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val\n: (u16) ctxt->src.val;\nbreak;\ncase 0xbe ... 0xbf:\nctxt->dst.bytes = ctxt->op_bytes;\nctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :\n(s16) ctxt->src.val;\nbreak;\ncase 0xc3:\nctxt->dst.bytes = ctxt->op_bytes;\nctxt->dst.val = (ctxt->op_bytes == 8) ? (u64) ctxt->src.val :\n(u32) ctxt->src.val;\nbreak;\ndefault:\ngoto cannot_emulate;\n}\nthreebyte_insn:\nif (rc != X86EMUL_CONTINUE)\ngoto done;\ngoto writeback;\ncannot_emulate:\nreturn EMULATION_FAILED;\n}", "contrast": "int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\nconst struct x86_emulate_ops *ops = ctxt->ops;\nint rc = X86EMUL_CONTINUE;\nint saved_dst_type = ctxt->dst.type;\nctxt->mem_read.pos = 0;\nif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif (unlikely(ctxt->d &\n(No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {\nif ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||\n(ctxt->d & Undefined)) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))\n|| ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\nrc = emulate_nm(ctxt);\ngoto done;\n}\nif (ctxt->d & Mmx) {\nrc = flush_pending_x87_faults(ctxt);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\nfetch_possible_mmx_operand(ctxt, &ctxt->src);\nfetch_possible_mmx_operand(ctxt, &ctxt->src2);\nif (!(ctxt->d & Mov))\nfetch_possible_mmx_operand(ctxt, &ctxt->dst);\n}\nif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\nrc = emulator_check_intercept(ctxt, ctxt->intercept,\nX86_ICPT_PRE_EXCEPT);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\nif (ctxt->d & PrivUD)\nrc = emulate_ud(ctxt);\nelse\nrc = emulate_gp(ctxt, 0);\ngoto done;\n}\nif ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {\nrc = emulate_ud(ctxt);\ngoto done;\n}\nif (ctxt->d & CheckPerm) {\nrc = ctxt->check_perm(ctxt);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\nrc = emulator_check_intercept(ctxt, ctxt->intercept,\nX86_ICPT_POST_EXCEPT);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (ctxt->rep_prefix && (ctxt->d & String)) {\nif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {\nctxt->eip = ctxt->_eip;\nctxt->eflags &= ~EFLG_RF;\ngoto done;\n}\n}\n}\nif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\nrc = segmented_read(ctxt, ctxt->src.addr.mem,\nctxt->src.valptr, ctxt->src.bytes);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\nctxt->src.orig_val64 = ctxt->src.val64;\n}\nif (ctxt->src2.type == OP_MEM) {\nrc = segmented_read(ctxt, ctxt->src2.addr.mem,\n&ctxt->src2.val, ctxt->src2.bytes);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif ((ctxt->d & DstMask) == ImplicitOps)\ngoto special_insn;\nif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\nrc = segmented_read(ctxt, ctxt->dst.addr.mem,\n&ctxt->dst.val, ctxt->dst.bytes);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nctxt->dst.orig_val = ctxt->dst.val;\nspecial_insn:\nif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\nrc = emulator_check_intercept(ctxt, ctxt->intercept,\nX86_ICPT_POST_MEMACCESS);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (ctxt->rep_prefix && (ctxt->d & String))\nctxt->eflags |= EFLG_RF;\nelse\nctxt->eflags &= ~EFLG_RF;\nif (ctxt->execute) {\nif (ctxt->d & Fastop) {\nvoid (*fop)(struct fastop *) = (void *)ctxt->execute;\nrc = fastop(ctxt, fop);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\ngoto writeback;\n}\nrc = ctxt->execute(ctxt);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\ngoto writeback;\n}\nif (ctxt->opcode_len == 2)\ngoto twobyte_insn;\nelse if (ctxt->opcode_len == 3)\ngoto threebyte_insn;\nswitch (ctxt->b) {\ncase 0x63:\nif (ctxt->mode != X86EMUL_MODE_PROT64)\ngoto cannot_emulate;\nctxt->dst.val = (s32) ctxt->src.val;\nbreak;\ncase 0x70 ... 0x7f:\nif (test_cc(ctxt->b, ctxt->eflags))\nrc = jmp_rel(ctxt, ctxt->src.val);\nbreak;\ncase 0x8d:\nctxt->dst.val = ctxt->src.addr.mem.ea;\nbreak;\ncase 0x90 ... 0x97:\nif (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))\nctxt->dst.type = OP_NONE;\nelse\nrc = em_xchg(ctxt);\nbreak;\ncase 0x98:\nswitch (ctxt->op_bytes) {\ncase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\ncase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\ncase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n}\nbreak;\ncase 0xcc:\nrc = emulate_int(ctxt, 3);\nbreak;\ncase 0xcd:\nrc = emulate_int(ctxt, ctxt->src.val);\nbreak;\ncase 0xce:\nif (ctxt->eflags & EFLG_OF)\nrc = emulate_int(ctxt, 4);\nbreak;\ncase 0xe9:\ncase 0xeb:\nrc = jmp_rel(ctxt, ctxt->src.val);\nctxt->dst.type = OP_NONE;\nbreak;\ncase 0xf4:\nctxt->ops->halt(ctxt);\nbreak;\ncase 0xf5:\nctxt->eflags ^= EFLG_CF;\nbreak;\ncase 0xf8:\nctxt->eflags &= ~EFLG_CF;\nbreak;\ncase 0xf9:\nctxt->eflags |= EFLG_CF;\nbreak;\ncase 0xfc:\nctxt->eflags &= ~EFLG_DF;\nbreak;\ncase 0xfd:\nctxt->eflags |= EFLG_DF;\nbreak;\ndefault:\ngoto cannot_emulate;\n}\nif (rc != X86EMUL_CONTINUE)\ngoto done;\nwriteback:\nif (ctxt->d & SrcWrite) {\nBUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);\nrc = writeback(ctxt, &ctxt->src);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nif (!(ctxt->d & NoWrite)) {\nrc = writeback(ctxt, &ctxt->dst);\nif (rc != X86EMUL_CONTINUE)\ngoto done;\n}\nctxt->dst.type = saved_dst_type;\nif ((ctxt->d & SrcMask) == SrcSI)\nstring_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);\nif ((ctxt->d & DstMask) == DstDI)\nstring_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);\nif (ctxt->rep_prefix && (ctxt->d & String)) {\nunsigned int count;\nstruct read_cache *r = &ctxt->io_read;\nif ((ctxt->d & SrcMask) == SrcSI)\ncount = ctxt->src.count;\nelse\ncount = ctxt->dst.count;\nregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX),\n-count);\nif (!string_insn_completed(ctxt)) {\nif ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&\n(r->end == 0 || r->end != r->pos)) {\nctxt->mem_read.end = 0;\nwriteback_registers(ctxt);\nreturn EMULATION_RESTART;\n}\ngoto done;\n}\nctxt->eflags &= ~EFLG_RF;\n}\nctxt->eip = ctxt->_eip;\ndone:\nif (rc == X86EMUL_PROPAGATE_FAULT) {\nWARN_ON(ctxt->exception.vector > 0x1f);\nctxt->have_exception = true;\n}\nif (rc == X86EMUL_INTERCEPTED)\nreturn EMULATION_INTERCEPTED;\nif (rc == X86EMUL_CONTINUE)\nwriteback_registers(ctxt);\nreturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\ntwobyte_insn:\nswitch (ctxt->b) {\ncase 0x09:\n(ctxt->ops->wbinvd)(ctxt);\nbreak;\ncase 0x08:\ncase 0x0d:\ncase 0x18:\ncase 0x1f:\nbreak;\ncase 0x20:\nctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\nbreak;\ncase 0x21:\nops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\nbreak;\ncase 0x40 ... 0x4f:\nif (test_cc(ctxt->b, ctxt->eflags))\nctxt->dst.val = ctxt->src.val;\nelse if (ctxt->mode != X86EMUL_MODE_PROT64 ||\nctxt->op_bytes != 4)\nctxt->dst.type = OP_NONE;\nbreak;\ncase 0x80 ... 0x8f:\nif (test_cc(ctxt->b, ctxt->eflags))\nrc = jmp_rel(ctxt, ctxt->src.val);\nbreak;\ncase 0x90 ... 0x9f:\nctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\nbreak;\ncase 0xae:\nbreak;\ncase 0xb6 ... 0xb7:\nctxt->dst.bytes = ctxt->op_bytes;\nctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val\n: (u16) ctxt->src.val;\nbreak;\ncase 0xbe ... 0xbf:\nctxt->dst.bytes = ctxt->op_bytes;\nctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :\n(s16) ctxt->src.val;\nbreak;\ncase 0xc3:\nctxt->dst.bytes = ctxt->op_bytes;\nctxt->dst.val = (ctxt->op_bytes == 8) ? (u64) ctxt->src.val :\n(u32) ctxt->src.val;\nbreak;\ndefault:\ngoto cannot_emulate;\n}\nthreebyte_insn:\nif (rc != X86EMUL_CONTINUE)\ngoto done;\ngoto writeback;\ncannot_emulate:\nreturn EMULATION_FAILED;\n}", "label": 0}
{"index": 178775, "code": "static int prepend_path(const struct path *path,\nconst struct path *root,\nchar **buffer, int *buflen)\n{\nstruct dentry *dentry;\nstruct vfsmount *vfsmnt;\nstruct mount *mnt;\nint error = 0;\nunsigned seq, m_seq = 0;\nchar *bptr;\nint blen;\nrcu_read_lock();\nrestart_mnt:\nread_seqbegin_or_lock(&mount_lock, &m_seq);\nseq = 0;\nrcu_read_lock();\nrestart:\nbptr = *buffer;\nblen = *buflen;\nerror = 0;\ndentry = path->dentry;\nvfsmnt = path->mnt;\nmnt = real_mount(vfsmnt);\nread_seqbegin_or_lock(&rename_lock, &seq);\nwhile (dentry != root->dentry || vfsmnt != root->mnt) {\nstruct dentry * parent;\nif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\nstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\nif (mnt != parent) {\ndentry = ACCESS_ONCE(mnt->mnt_mountpoint);\nmnt = parent;\nvfsmnt = &mnt->mnt;\ncontinue;\n}\nif (!error)\nerror = is_mounted(vfsmnt) ? 1 : 2;\nbreak;\n}\nparent = dentry->d_parent;\nprefetch(parent);\nerror = prepend_name(&bptr, &blen, &dentry->d_name);\nif (error)\nbreak;\ndentry = parent;\n}\nif (!(seq & 1))\nrcu_read_unlock();\nif (need_seqretry(&rename_lock, seq)) {\nseq = 1;\ngoto restart;\n}\ndone_seqretry(&rename_lock, seq);\nif (!(m_seq & 1))\nrcu_read_unlock();\nif (need_seqretry(&mount_lock, m_seq)) {\nm_seq = 1;\ngoto restart_mnt;\n}\ndone_seqretry(&mount_lock, m_seq);\nif (error >= 0 && bptr == *buffer) {\nif (--blen < 0)\nerror = -ENAMETOOLONG;\nelse\n*--bptr = '/';\n}\n*buffer = bptr;\n*buflen = blen;\nreturn error;\n}", "contrast": "static int prepend_path(const struct path *path,\nconst struct path *root,\nchar **buffer, int *buflen)\n{\nstruct dentry *dentry;\nstruct vfsmount *vfsmnt;\nstruct mount *mnt;\nint error = 0;\nunsigned seq, m_seq = 0;\nchar *bptr;\nint blen;\nrcu_read_lock();\nrestart_mnt:\nread_seqbegin_or_lock(&mount_lock, &m_seq);\nseq = 0;\nrcu_read_lock();\nrestart:\nbptr = *buffer;\nblen = *buflen;\nerror = 0;\ndentry = path->dentry;\nvfsmnt = path->mnt;\nmnt = real_mount(vfsmnt);\nread_seqbegin_or_lock(&rename_lock, &seq);\nwhile (dentry != root->dentry || vfsmnt != root->mnt) {\nstruct dentry * parent;\nif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\nstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\nif (dentry != vfsmnt->mnt_root) {\nbptr = *buffer;\nblen = *buflen;\nerror = 3;\nbreak;\n}\nif (mnt != parent) {\ndentry = ACCESS_ONCE(mnt->mnt_mountpoint);\nmnt = parent;\nvfsmnt = &mnt->mnt;\ncontinue;\n}\nif (!error)\nerror = is_mounted(vfsmnt) ? 1 : 2;\nbreak;\n}\nparent = dentry->d_parent;\nprefetch(parent);\nerror = prepend_name(&bptr, &blen, &dentry->d_name);\nif (error)\nbreak;\ndentry = parent;\n}\nif (!(seq & 1))\nrcu_read_unlock();\nif (need_seqretry(&rename_lock, seq)) {\nseq = 1;\ngoto restart;\n}\ndone_seqretry(&rename_lock, seq);\nif (!(m_seq & 1))\nrcu_read_unlock();\nif (need_seqretry(&mount_lock, m_seq)) {\nm_seq = 1;\ngoto restart_mnt;\n}\ndone_seqretry(&mount_lock, m_seq);\nif (error >= 0 && bptr == *buffer) {\nif (--blen < 0)\nerror = -ENAMETOOLONG;\nelse\n*--bptr = '/';\n}\n*buffer = bptr;\n*buflen = blen;\nreturn error;\n}", "label": 0}
{"index": 178793, "code": "static inline signed int ReadProfileLong(const EndianType endian,\nunsigned char *buffer)\n{\nunion\n{\nunsigned int\nunsigned_value;\nsigned int\nsigned_value;\n} quantum;\nunsigned int\nvalue;\nif (endian == LSBEndian)\n{\nvalue=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n(buffer[1] << 8 ) | (buffer[0]));\nquantum.unsigned_value=(value & 0xffffffff);\nreturn(quantum.signed_value);\n}\nvalue=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n(buffer[2] << 8) | buffer[3]);\nquantum.unsigned_value=(value & 0xffffffff);\nreturn(quantum.signed_value);\n}", "contrast": "static inline signed int ReadProfileLong(const EndianType endian,\nunsigned char *buffer)\n{\nunion\n{\nunsigned int\nunsigned_value;\nsigned int\nsigned_value;\n} quantum;\nunsigned int\nvalue;\nif (endian == LSBEndian)\n{\nvalue=(unsigned int) buffer[3] << 24;\nvalue|=(unsigned int) buffer[2] << 16;\nvalue|=(unsigned int) buffer[1] << 8;\nvalue|=(unsigned int) buffer[0];\nquantum.unsigned_value=value & 0xffffffff;\nreturn(quantum.signed_value);\n}\nvalue=(unsigned int) buffer[0] << 24;\nvalue|=(unsigned int) buffer[1] << 16;\nvalue|=(unsigned int) buffer[2] << 8;\nvalue|=(unsigned int) buffer[3];\nquantum.unsigned_value=value & 0xffffffff;\nreturn(quantum.signed_value);\n}", "label": 0}
{"index": 178822, "code": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\nstruct mb_cache_entry *ce;\nint error;\nce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\nif (!ce)\nreturn -ENOMEM;\nerror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\nif (error) {\nmb_cache_entry_free(ce);\nif (error == -EBUSY) {\nea_bdebug(bh, \"already in cache (%d cache entries)\",\natomic_read(&ext2_xattr_cache->c_entry_count));\nerror = 0;\n}\n} else {\nea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\natomic_read(&ext2_xattr_cache->c_entry_count));\nmb_cache_entry_release(ce);\n}\nreturn error;\n}", "contrast": "ext2_xattr_cache_insert(struct buffer_head *bh)\next2_xattr_cache_insert(struct mb2_cache *cache, struct buffer_head *bh)\n{\n__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\nint error;\nerror = mb2_cache_entry_create(cache, GFP_NOFS, hash, bh->b_blocknr);\nif (error) {\nif (error == -EBUSY) {\nea_bdebug(bh, \"already in cache (%d cache entries)\",\natomic_read(&ext2_xattr_cache->c_entry_count));\nerror = 0;\n}\n} else\nea_bdebug(bh, \"inserting [%x]\", (int)hash);\nreturn error;\n}", "label": 0}
{"index": 178824, "code": "ext2_xattr_get(struct inode *inode, int name_index, const char *name,\nvoid *buffer, size_t buffer_size)\n{\nstruct buffer_head *bh = NULL;\nstruct ext2_xattr_entry *entry;\nsize_t name_len, size;\nchar *end;\nint error;\nea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\nname_index, name, buffer, (long)buffer_size);\nif (name == NULL)\nreturn -EINVAL;\nname_len = strlen(name);\nif (name_len > 255)\nreturn -ERANGE;\ndown_read(&EXT2_I(inode)->xattr_sem);\nerror = -ENODATA;\nif (!EXT2_I(inode)->i_file_acl)\ngoto cleanup;\nea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\nbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\nerror = -EIO;\nif (!bh)\ngoto cleanup;\nea_bdebug(bh, \"b_count=%d, refcount=%d\",\natomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\nend = bh->b_data + bh->b_size;\nif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\nHDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\"inode %ld: bad block %d\", inode->i_ino,\nEXT2_I(inode)->i_file_acl);\nerror = -EIO;\ngoto cleanup;\n}\nentry = FIRST_ENTRY(bh);\nwhile (!IS_LAST_ENTRY(entry)) {\nstruct ext2_xattr_entry *next =\nEXT2_XATTR_NEXT(entry);\nif ((char *)next >= end)\ngoto bad_block;\nif (name_index == entry->e_name_index &&\nname_len == entry->e_name_len &&\nmemcmp(name, entry->e_name, name_len) == 0)\ngoto found;\nentry = next;\n}\nif (ext2_xattr_cache_insert(bh))\nea_idebug(inode, \"cache insert failed\");\nerror = -ENODATA;\ngoto cleanup;\nfound:\nif (entry->e_value_block != 0)\ngoto bad_block;\nsize = le32_to_cpu(entry->e_value_size);\nif (size > inode->i_sb->s_blocksize ||\nle16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\ngoto bad_block;\nif (ext2_xattr_cache_insert(bh))\nea_idebug(inode, \"cache insert failed\");\nif (buffer) {\nerror = -ERANGE;\nif (size > buffer_size)\ngoto cleanup;\nmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\nsize);\n}\nerror = size;\ncleanup:\nbrelse(bh);\nup_read(&EXT2_I(inode)->xattr_sem);\nreturn error;\n}", "contrast": "ext2_xattr_get(struct inode *inode, int name_index, const char *name,\nvoid *buffer, size_t buffer_size)\n{\nstruct buffer_head *bh = NULL;\nstruct ext2_xattr_entry *entry;\nsize_t name_len, size;\nchar *end;\nint error;\nstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\nea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\nname_index, name, buffer, (long)buffer_size);\nif (name == NULL)\nreturn -EINVAL;\nname_len = strlen(name);\nif (name_len > 255)\nreturn -ERANGE;\ndown_read(&EXT2_I(inode)->xattr_sem);\nerror = -ENODATA;\nif (!EXT2_I(inode)->i_file_acl)\ngoto cleanup;\nea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\nbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\nerror = -EIO;\nif (!bh)\ngoto cleanup;\nea_bdebug(bh, \"b_count=%d, refcount=%d\",\natomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\nend = bh->b_data + bh->b_size;\nif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\nHDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\"inode %ld: bad block %d\", inode->i_ino,\nEXT2_I(inode)->i_file_acl);\nerror = -EIO;\ngoto cleanup;\n}\nentry = FIRST_ENTRY(bh);\nwhile (!IS_LAST_ENTRY(entry)) {\nstruct ext2_xattr_entry *next =\nEXT2_XATTR_NEXT(entry);\nif ((char *)next >= end)\ngoto bad_block;\nif (name_index == entry->e_name_index &&\nname_len == entry->e_name_len &&\nmemcmp(name, entry->e_name, name_len) == 0)\ngoto found;\nentry = next;\n}\nif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\nea_idebug(inode, \"cache insert failed\");\nerror = -ENODATA;\ngoto cleanup;\nfound:\nif (entry->e_value_block != 0)\ngoto bad_block;\nsize = le32_to_cpu(entry->e_value_size);\nif (size > inode->i_sb->s_blocksize ||\nle16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\ngoto bad_block;\nif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\nea_idebug(inode, \"cache insert failed\");\nif (buffer) {\nerror = -ERANGE;\nif (size > buffer_size)\ngoto cleanup;\nmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\nsize);\n}\nerror = size;\ncleanup:\nbrelse(bh);\nup_read(&EXT2_I(inode)->xattr_sem);\nreturn error;\n}", "label": 0}
{"index": 178842, "code": "http_rxchunk(struct http *hp)\n{\nchar *q;\nint l, i;\nl = hp->prxbuf;\ndo\n(void)http_rxchar(hp, 1, 0);\nwhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\nvtc_dump(hp->vl, 4, \"len\", hp->rxbuf + l, -1);\ni = strtoul(hp->rxbuf + l, &q, 16);\nbprintf(hp->chunklen, \"%d\", i);\nif ((q == hp->rxbuf + l) ||\n(*q != '\\0' && !vct_islws(*q))) {\nvtc_log(hp->vl, hp->fatal, \"chunked fail %02x @ %d\",\n*q, q - (hp->rxbuf + l));\n}\nassert(q != hp->rxbuf + l);\nassert(*q == '\\0' || vct_islws(*q));\nhp->prxbuf = l;\nif (i > 0) {\n(void)http_rxchar(hp, i, 0);\nvtc_dump(hp->vl, 4, \"chunk\",\nhp->rxbuf + l, i);\n}\nl = hp->prxbuf;\n(void)http_rxchar(hp, 2, 0);\nif(!vct_iscrlf(hp->rxbuf[l]))\nvtc_log(hp->vl, hp->fatal,\n\"Wrong chunk tail[0] = %02x\",\nhp->rxbuf[l] & 0xff);\nif(!vct_iscrlf(hp->rxbuf[l + 1]))\nvtc_log(hp->vl, hp->fatal,\n\"Wrong chunk tail[1] = %02x\",\nhp->rxbuf[l + 1] & 0xff);\nhp->prxbuf = l;\nhp->rxbuf[l] = '\\0';\nreturn (i);\n}", "contrast": "http_rxchunk(struct http *hp)\n{\nchar *q;\nint l, i;\nl = hp->prxbuf;\ndo\n(void)http_rxchar(hp, 1, 0);\nwhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\nvtc_dump(hp->vl, 4, \"len\", hp->rxbuf + l, -1);\ni = strtoul(hp->rxbuf + l, &q, 16);\nbprintf(hp->chunklen, \"%d\", i);\nif ((q == hp->rxbuf + l) ||\n(*q != '\\0' && !vct_islws(*q))) {\nvtc_log(hp->vl, hp->fatal, \"chunked fail %02x @ %d\",\n*q, q - (hp->rxbuf + l));\n}\nassert(q != hp->rxbuf + l);\nassert(*q == '\\0' || vct_islws(*q));\nhp->prxbuf = l;\nif (i > 0) {\n(void)http_rxchar(hp, i, 0);\nvtc_dump(hp->vl, 4, \"chunk\",\nhp->rxbuf + l, i);\n}\nl = hp->prxbuf;\n(void)http_rxchar(hp, 2, 0);\nif(!vct_iscrlf(&hp->rxbuf[l]))\nvtc_log(hp->vl, hp->fatal,\n\"Wrong chunk tail[0] = %02x\",\nhp->rxbuf[l] & 0xff);\nif(!vct_iscrlf(&hp->rxbuf[l + 1]))\nvtc_log(hp->vl, hp->fatal,\n\"Wrong chunk tail[1] = %02x\",\nhp->rxbuf[l + 1] & 0xff);\nhp->prxbuf = l;\nhp->rxbuf[l] = '\\0';\nreturn (i);\n}", "label": 0}
{"index": 178861, "code": "bootp_print(netdissect_options *ndo,\nregister const u_char *cp, u_int length)\n{\nregister const struct bootp *bp;\nstatic const u_char vm_cmu[4] = VM_CMU;\nstatic const u_char vm_rfc1048[4] = VM_RFC1048;\nbp = (const struct bootp *)cp;\nND_TCHECK(bp->bp_op);\nND_PRINT((ndo, \"BOOTP/DHCP, %s\",\ntok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\nND_TCHECK(bp->bp_hlen);\nif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\nND_TCHECK2(bp->bp_chaddr[0], 6);\nND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n}\nND_PRINT((ndo, \", length %u\", length));\nif (!ndo->ndo_vflag)\nreturn;\nND_TCHECK(bp->bp_secs);\nif (bp->bp_htype != 1)\nND_PRINT((ndo, \", htype %d\", bp->bp_htype));\nif (bp->bp_htype != 1 || bp->bp_hlen != 6)\nND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\nif (bp->bp_hops)\nND_PRINT((ndo, \", hops %d\", bp->bp_hops));\nif (EXTRACT_32BITS(&bp->bp_xid))\nND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\nif (EXTRACT_16BITS(&bp->bp_secs))\nND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\nND_PRINT((ndo, \", Flags [%s]\",\nbittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\nif (ndo->ndo_vflag > 1)\nND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\nND_TCHECK(bp->bp_ciaddr);\nif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\nND_TCHECK(bp->bp_yiaddr);\nif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\nND_TCHECK(bp->bp_siaddr);\nif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\nND_TCHECK(bp->bp_giaddr);\nif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\nif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\nND_TCHECK2(bp->bp_chaddr[0], 6);\nND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n}\nND_TCHECK2(bp->bp_sname[0], 1);\nif (*bp->bp_sname) {\nND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\nif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\nndo->ndo_snapend)) {\nND_PRINT((ndo, \"\\\"\"));\nND_PRINT((ndo, \"%s\", tstr + 1));\nreturn;\n}\nND_PRINT((ndo, \"\\\"\"));\n}\nND_TCHECK2(bp->bp_file[0], 1);\nif (*bp->bp_file) {\nND_PRINT((ndo, \"\\n\\t  file \\\"\"));\nif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\nndo->ndo_snapend)) {\nND_PRINT((ndo, \"\\\"\"));\nND_PRINT((ndo, \"%s\", tstr + 1));\nreturn;\n}\nND_PRINT((ndo, \"\\\"\"));\n}\nND_TCHECK(bp->bp_vend[0]);\nif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\nsizeof(uint32_t)) == 0)\nrfc1048_print(ndo, bp->bp_vend);\nelse if (memcmp((const char *)bp->bp_vend, vm_cmu,\nsizeof(uint32_t)) == 0)\ncmu_print(ndo, bp->bp_vend);\nelse {\nuint32_t ul;\nul = EXTRACT_32BITS(&bp->bp_vend);\nif (ul != 0)\nND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n}\nreturn;\ntrunc:\nND_PRINT((ndo, \"%s\", tstr));\n}", "contrast": "bootp_print(netdissect_options *ndo,\nregister const u_char *cp, u_int length)\n{\nregister const struct bootp *bp;\nstatic const u_char vm_cmu[4] = VM_CMU;\nstatic const u_char vm_rfc1048[4] = VM_RFC1048;\nbp = (const struct bootp *)cp;\nND_TCHECK(bp->bp_op);\nND_PRINT((ndo, \"BOOTP/DHCP, %s\",\ntok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\nND_TCHECK(bp->bp_hlen);\nif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\nND_TCHECK2(bp->bp_chaddr[0], 6);\nND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n}\nND_PRINT((ndo, \", length %u\", length));\nif (!ndo->ndo_vflag)\nreturn;\nND_TCHECK(bp->bp_secs);\nif (bp->bp_htype != 1)\nND_PRINT((ndo, \", htype %d\", bp->bp_htype));\nif (bp->bp_htype != 1 || bp->bp_hlen != 6)\nND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\nif (bp->bp_hops)\nND_PRINT((ndo, \", hops %d\", bp->bp_hops));\nif (EXTRACT_32BITS(&bp->bp_xid))\nND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\nif (EXTRACT_16BITS(&bp->bp_secs))\nND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\nND_TCHECK(bp->bp_flags);\nND_PRINT((ndo, \", Flags [%s]\",\nbittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\nif (ndo->ndo_vflag > 1)\nND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\nND_TCHECK(bp->bp_ciaddr);\nif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\nND_TCHECK(bp->bp_yiaddr);\nif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\nND_TCHECK(bp->bp_siaddr);\nif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\nND_TCHECK(bp->bp_giaddr);\nif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\nND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\nif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\nND_TCHECK2(bp->bp_chaddr[0], 6);\nND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n}\nND_TCHECK2(bp->bp_sname[0], 1);\nif (*bp->bp_sname) {\nND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\nif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\nndo->ndo_snapend)) {\nND_PRINT((ndo, \"\\\"\"));\nND_PRINT((ndo, \"%s\", tstr + 1));\nreturn;\n}\nND_PRINT((ndo, \"\\\"\"));\n}\nND_TCHECK2(bp->bp_file[0], 1);\nif (*bp->bp_file) {\nND_PRINT((ndo, \"\\n\\t  file \\\"\"));\nif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\nndo->ndo_snapend)) {\nND_PRINT((ndo, \"\\\"\"));\nND_PRINT((ndo, \"%s\", tstr + 1));\nreturn;\n}\nND_PRINT((ndo, \"\\\"\"));\n}\nND_TCHECK(bp->bp_vend[0]);\nif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\nsizeof(uint32_t)) == 0)\nrfc1048_print(ndo, bp->bp_vend);\nelse if (memcmp((const char *)bp->bp_vend, vm_cmu,\nsizeof(uint32_t)) == 0)\ncmu_print(ndo, bp->bp_vend);\nelse {\nuint32_t ul;\nul = EXTRACT_32BITS(&bp->bp_vend);\nif (ul != 0)\nND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n}\nreturn;\ntrunc:\nND_PRINT((ndo, \"%s\", tstr));\n}", "label": 0}
{"index": 178870, "code": "struct bio *bio_map_user_iov(struct request_queue *q,\nconst struct iov_iter *iter,\ngfp_t gfp_mask)\n{\nint j;\nint nr_pages = 0;\nstruct page **pages;\nstruct bio *bio;\nint cur_page = 0;\nint ret, offset;\nstruct iov_iter i;\nstruct iovec iov;\niov_for_each(iov, i, *iter) {\nunsigned long uaddr = (unsigned long) iov.iov_base;\nunsigned long len = iov.iov_len;\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\nunsigned long start = uaddr >> PAGE_SHIFT;\nif (end < start)\nreturn ERR_PTR(-EINVAL);\nnr_pages += end - start;\nif (uaddr & queue_dma_alignment(q))\nreturn ERR_PTR(-EINVAL);\n}\nif (!nr_pages)\nreturn ERR_PTR(-EINVAL);\nbio = bio_kmalloc(gfp_mask, nr_pages);\nif (!bio)\nreturn ERR_PTR(-ENOMEM);\nret = -ENOMEM;\npages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\nif (!pages)\ngoto out;\niov_for_each(iov, i, *iter) {\nunsigned long uaddr = (unsigned long) iov.iov_base;\nunsigned long len = iov.iov_len;\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\nunsigned long start = uaddr >> PAGE_SHIFT;\nconst int local_nr_pages = end - start;\nconst int page_limit = cur_page + local_nr_pages;\nret = get_user_pages_fast(uaddr, local_nr_pages,\n(iter->type & WRITE) != WRITE,\n&pages[cur_page]);\nif (ret < local_nr_pages) {\nret = -EFAULT;\ngoto out_unmap;\n}\noffset = offset_in_page(uaddr);\nfor (j = cur_page; j < page_limit; j++) {\nunsigned int bytes = PAGE_SIZE - offset;\nunsigned short prev_bi_vcnt = bio->bi_vcnt;\nif (len <= 0)\nbreak;\nif (bytes > len)\nbytes = len;\nif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\nbytes)\nbreak;\nif (bio->bi_vcnt == prev_bi_vcnt)\nput_page(pages[j]);\nlen -= bytes;\noffset = 0;\n}\ncur_page = j;\nwhile (j < page_limit)\nput_page(pages[j++]);\n}\nkfree(pages);\nbio_set_flag(bio, BIO_USER_MAPPED);\nbio_get(bio);\nreturn bio;\nout_unmap:\nfor (j = 0; j < nr_pages; j++) {\nif (!pages[j])\nbreak;\nput_page(pages[j]);\n}\nout:\nkfree(pages);\nbio_put(bio);\nreturn ERR_PTR(ret);\n}", "contrast": "struct bio *bio_map_user_iov(struct request_queue *q,\nconst struct iov_iter *iter,\ngfp_t gfp_mask)\n{\nint j;\nint nr_pages = 0;\nstruct page **pages;\nstruct bio *bio;\nint cur_page = 0;\nint ret, offset;\nstruct iov_iter i;\nstruct iovec iov;\nstruct bio_vec *bvec;\niov_for_each(iov, i, *iter) {\nunsigned long uaddr = (unsigned long) iov.iov_base;\nunsigned long len = iov.iov_len;\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\nunsigned long start = uaddr >> PAGE_SHIFT;\nif (end < start)\nreturn ERR_PTR(-EINVAL);\nnr_pages += end - start;\nif (uaddr & queue_dma_alignment(q))\nreturn ERR_PTR(-EINVAL);\n}\nif (!nr_pages)\nreturn ERR_PTR(-EINVAL);\nbio = bio_kmalloc(gfp_mask, nr_pages);\nif (!bio)\nreturn ERR_PTR(-ENOMEM);\nret = -ENOMEM;\npages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\nif (!pages)\ngoto out;\niov_for_each(iov, i, *iter) {\nunsigned long uaddr = (unsigned long) iov.iov_base;\nunsigned long len = iov.iov_len;\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\nunsigned long start = uaddr >> PAGE_SHIFT;\nconst int local_nr_pages = end - start;\nconst int page_limit = cur_page + local_nr_pages;\nret = get_user_pages_fast(uaddr, local_nr_pages,\n(iter->type & WRITE) != WRITE,\n&pages[cur_page]);\nif (unlikely(ret < local_nr_pages)) {\nfor (j = cur_page; j < page_limit; j++) {\nif (!pages[j])\nbreak;\nput_page(pages[j]);\n}\nret = -EFAULT;\ngoto out_unmap;\n}\noffset = offset_in_page(uaddr);\nfor (j = cur_page; j < page_limit; j++) {\nunsigned int bytes = PAGE_SIZE - offset;\nunsigned short prev_bi_vcnt = bio->bi_vcnt;\nif (len <= 0)\nbreak;\nif (bytes > len)\nbytes = len;\nif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\nbytes)\nbreak;\nif (bio->bi_vcnt == prev_bi_vcnt)\nput_page(pages[j]);\nlen -= bytes;\noffset = 0;\n}\ncur_page = j;\nwhile (j < page_limit)\nput_page(pages[j++]);\n}\nkfree(pages);\nbio_set_flag(bio, BIO_USER_MAPPED);\nbio_get(bio);\nreturn bio;\nout_unmap:\nbio_for_each_segment_all(bvec, bio, j) {\nput_page(bvec->bv_page);\n}\nout:\nkfree(pages);\nbio_put(bio);\nreturn ERR_PTR(ret);\n}", "label": 0}
{"index": 178879, "code": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n{\tpsf->header [psf->headindex++] = (x >> 16) ;\npsf->header [psf->headindex++] = (x >> 8) ;\npsf->header [psf->headindex++] = x ;\n} ;\n}", "contrast": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\npsf->header.ptr [psf->header.indx++] = (x >> 8) ;\npsf->header.ptr [psf->header.indx++] = x ;\n}", "label": 0}
{"index": 178881, "code": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n{\tpsf->header [psf->headindex++] = (x >> 56) ;\npsf->header [psf->headindex++] = (x >> 48) ;\npsf->header [psf->headindex++] = (x >> 40) ;\npsf->header [psf->headindex++] = (x >> 32) ;\npsf->header [psf->headindex++] = (x >> 24) ;\npsf->header [psf->headindex++] = (x >> 16) ;\npsf->header [psf->headindex++] = (x >> 8) ;\npsf->header [psf->headindex++] = x ;\n} ;\n}", "contrast": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 56) ;\npsf->header.ptr [psf->header.indx++] = (x >> 48) ;\npsf->header.ptr [psf->header.indx++] = (x >> 40) ;\npsf->header.ptr [psf->header.indx++] = (x >> 32) ;\npsf->header.ptr [psf->header.indx++] = (x >> 24) ;\npsf->header.ptr [psf->header.indx++] = (x >> 16) ;\npsf->header.ptr [psf->header.indx++] = (x >> 8) ;\npsf->header.ptr [psf->header.indx++] = x ;\n}", "label": 0}
{"index": 178889, "code": "header_put_le_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n{\tpsf->header [psf->headindex++] = x ;\npsf->header [psf->headindex++] = (x >> 8) ;\n} ;\n}", "contrast": "header_put_le_short (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\npsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n}", "label": 0}
{"index": 178898, "code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\nassert (sizeof (sf_count_t) == 8) ;\nif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n{\tsf_errno = SFE_MALLOC_FAILED ;\nreturn\tNULL ;\n} ;\npsf_init_files (psf) ;\npsf_log_printf (psf, \"File : %s\\n\", path) ;\nif (copy_filename (psf, path) != 0)\n{\tsf_errno = psf->error ;\nreturn\tNULL ;\n} ;\npsf->file.mode = mode ;\nif (strcmp (path, \"-\") == 0)\npsf->error = psf_set_stdio (psf) ;\nelse\npsf->error = psf_fopen (psf) ;\nreturn psf_open_file (psf, sfinfo) ;\n}", "contrast": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\nassert (sizeof (sf_count_t) == 8) ;\nif ((psf = psf_allocate ()) == NULL)\n{\tsf_errno = SFE_MALLOC_FAILED ;\nreturn\tNULL ;\n} ;\npsf_init_files (psf) ;\npsf_log_printf (psf, \"File : %s\\n\", path) ;\nif (copy_filename (psf, path) != 0)\n{\tsf_errno = psf->error ;\nreturn\tNULL ;\n} ;\npsf->file.mode = mode ;\nif (strcmp (path, \"-\") == 0)\npsf->error = psf_set_stdio (psf) ;\nelse\npsf->error = psf_fopen (psf) ;\nreturn psf_open_file (psf, sfinfo) ;\n}", "label": 0}
{"index": 178911, "code": "void CL_Init( void ) {\nCom_Printf( \"----- Client Initialization -----\\n\" );\nCon_Init();\nif(!com_fullyInitialized)\n{\nCL_ClearState();\nclc.state = CA_DISCONNECTED;\ncl_oldGameSet = qfalse;\n}\ncls.realtime = 0;\nCL_InitInput();\ncl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\ncl_motd = Cvar_Get( \"cl_motd\", \"1\", 0 );\n#endif\ncl_timeout = Cvar_Get( \"cl_timeout\", \"200\", 0 );\ncl_timeNudge = Cvar_Get( \"cl_timeNudge\", \"0\", CVAR_TEMP );\ncl_shownet = Cvar_Get( \"cl_shownet\", \"0\", CVAR_TEMP );\ncl_showSend = Cvar_Get( \"cl_showSend\", \"0\", CVAR_TEMP );\ncl_showTimeDelta = Cvar_Get( \"cl_showTimeDelta\", \"0\", CVAR_TEMP );\ncl_freezeDemo = Cvar_Get( \"cl_freezeDemo\", \"0\", CVAR_TEMP );\nrcon_client_password = Cvar_Get( \"rconPassword\", \"\", CVAR_TEMP );\ncl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\ncl_timedemo = Cvar_Get( \"timedemo\", \"0\", 0 );\ncl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\ncl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\ncl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\ncl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\ncl_avidemo = Cvar_Get( \"cl_avidemo\", \"0\", 0 );\ncl_forceavidemo = Cvar_Get( \"cl_forceavidemo\", \"0\", 0 );\nrconAddress = Cvar_Get( \"rconAddress\", \"\", 0 );\ncl_yawspeed = Cvar_Get( \"cl_yawspeed\", \"140\", CVAR_ARCHIVE );\ncl_pitchspeed = Cvar_Get( \"cl_pitchspeed\", \"140\", CVAR_ARCHIVE );\ncl_anglespeedkey = Cvar_Get( \"cl_anglespeedkey\", \"1.5\", 0 );\ncl_maxpackets = Cvar_Get( \"cl_maxpackets\", \"38\", CVAR_ARCHIVE );\ncl_packetdup = Cvar_Get( \"cl_packetdup\", \"1\", CVAR_ARCHIVE );\ncl_run = Cvar_Get( \"cl_run\", \"1\", CVAR_ARCHIVE );\ncl_sensitivity = Cvar_Get( \"sensitivity\", \"5\", CVAR_ARCHIVE );\ncl_mouseAccel = Cvar_Get( \"cl_mouseAccel\", \"0\", CVAR_ARCHIVE );\ncl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\ncl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\ncl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\nCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\ncl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\ncl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"0\", CVAR_ARCHIVE );\n#ifdef USE_CURL_DLOPEN\ncl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n#endif\nCvar_Get( \"cg_autoswitch\", \"2\", CVAR_ARCHIVE );\nCvar_Get( \"cg_wolfparticles\", \"1\", CVAR_ARCHIVE );\ncl_conXOffset = Cvar_Get( \"cl_conXOffset\", \"0\", 0 );\ncl_inGameVideo = Cvar_Get( \"r_inGameVideo\", \"1\", CVAR_ARCHIVE );\ncl_serverStatusResendTime = Cvar_Get( \"cl_serverStatusResendTime\", \"750\", 0 );\ncl_recoilPitch = Cvar_Get( \"cg_recoilPitch\", \"0\", CVAR_ROM );\nm_pitch = Cvar_Get( \"m_pitch\", \"0.022\", CVAR_ARCHIVE );\nm_yaw = Cvar_Get( \"m_yaw\", \"0.022\", CVAR_ARCHIVE );\nm_forward = Cvar_Get( \"m_forward\", \"0.25\", CVAR_ARCHIVE );\nm_side = Cvar_Get( \"m_side\", \"0.25\", CVAR_ARCHIVE );\nm_filter = Cvar_Get( \"m_filter\", \"0\", CVAR_ARCHIVE );\nj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\nj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\nj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\nj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\nj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\nj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\nj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\nj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\nj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\nj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\nCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\ncl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\nCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\ncl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\ncl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\ncl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\nCvar_Get( \"name\", \"WolfPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\ncl_rate = Cvar_Get( \"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"model\", \"bj2\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"head\", \"default\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"color\", \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"password\", \"\", CVAR_USERINFO );\nCvar_Get( \"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n#ifdef USE_MUMBLE\ncl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\ncl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n#ifdef USE_VOIP\ncl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\ncl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\ncl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\ncl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\ncl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\ncl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\ncl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\ncl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\nCvar_CheckRange( cl_voip, 0, 1, qtrue );\ncl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\nCvar_Get( \"cg_autoactivate\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"cg_emptyswitch\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"cg_viewsize\", \"100\", CVAR_ARCHIVE );\nCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\ncl_missionStats = Cvar_Get( \"g_missionStats\", \"0\", CVAR_ROM );\ncl_waitForFire = Cvar_Get( \"cl_waitForFire\", \"0\", CVAR_ROM );\ncl_language = Cvar_Get( \"cl_language\", \"0\", CVAR_ARCHIVE );\ncl_debugTranslation = Cvar_Get( \"cl_debugTranslation\", \"0\", 0 );\nCmd_AddCommand( \"cmd\", CL_ForwardToServer_f );\nCmd_AddCommand( \"configstrings\", CL_Configstrings_f );\nCmd_AddCommand( \"clientinfo\", CL_Clientinfo_f );\nCmd_AddCommand( \"snd_restart\", CL_Snd_Restart_f );\nCmd_AddCommand( \"vid_restart\", CL_Vid_Restart_f );\nCmd_AddCommand( \"disconnect\", CL_Disconnect_f );\nCmd_AddCommand( \"record\", CL_Record_f );\nCmd_AddCommand( \"demo\", CL_PlayDemo_f );\nCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\nCmd_AddCommand( \"cinematic\", CL_PlayCinematic_f );\nCmd_AddCommand( \"stoprecord\", CL_StopRecord_f );\nCmd_AddCommand( \"connect\", CL_Connect_f );\nCmd_AddCommand( \"reconnect\", CL_Reconnect_f );\nCmd_AddCommand( \"localservers\", CL_LocalServers_f );\nCmd_AddCommand( \"globalservers\", CL_GlobalServers_f );\nCmd_AddCommand( \"rcon\", CL_Rcon_f );\nCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\nCmd_AddCommand( \"ping\", CL_Ping_f );\nCmd_AddCommand( \"serverstatus\", CL_ServerStatus_f );\nCmd_AddCommand( \"showip\", CL_ShowIP_f );\nCmd_AddCommand( \"fs_openedList\", CL_OpenedPK3List_f );\nCmd_AddCommand( \"fs_referencedList\", CL_ReferencedPK3List_f );\nCmd_AddCommand (\"video\", CL_Video_f );\nCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\nCmd_AddCommand( \"cache_startgather\", CL_Cache_StartGather_f );\nCmd_AddCommand( \"cache_usedfile\", CL_Cache_UsedFile_f );\nCmd_AddCommand( \"cache_setindex\", CL_Cache_SetIndex_f );\nCmd_AddCommand( \"cache_mapchange\", CL_Cache_MapChange_f );\nCmd_AddCommand( \"cache_endgather\", CL_Cache_EndGather_f );\nCmd_AddCommand( \"updatehunkusage\", CL_UpdateLevelHunkUsage );\nCmd_AddCommand( \"updatescreen\", SCR_UpdateScreen );\nCmd_AddCommand( \"cld\", CL_ClientDamageCommand );\nCmd_AddCommand( \"startMultiplayer\", CL_startMultiplayer_f );\nCmd_AddCommand( \"shellExecute\", CL_ShellExecute_URL_f );\nCmd_AddCommand( \"map_restart\", CL_MapRestart_f );\nCmd_AddCommand( \"setRecommended\", CL_SetRecommended_f );\nCL_InitRef();\nSCR_Init();\nCvar_Set( \"cl_running\", \"1\" );\nCL_GenerateQKey();\nCvar_Get( \"cl_guid\", \"\", CVAR_USERINFO | CVAR_ROM );\nCL_UpdateGUID( NULL, 0 );\nCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}", "contrast": "void CL_Init( void ) {\nCom_Printf( \"----- Client Initialization -----\\n\" );\nCon_Init();\nif(!com_fullyInitialized)\n{\nCL_ClearState();\nclc.state = CA_DISCONNECTED;\ncl_oldGameSet = qfalse;\n}\ncls.realtime = 0;\nCL_InitInput();\ncl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\ncl_motd = Cvar_Get( \"cl_motd\", \"1\", 0 );\n#endif\ncl_timeout = Cvar_Get( \"cl_timeout\", \"200\", 0 );\ncl_timeNudge = Cvar_Get( \"cl_timeNudge\", \"0\", CVAR_TEMP );\ncl_shownet = Cvar_Get( \"cl_shownet\", \"0\", CVAR_TEMP );\ncl_showSend = Cvar_Get( \"cl_showSend\", \"0\", CVAR_TEMP );\ncl_showTimeDelta = Cvar_Get( \"cl_showTimeDelta\", \"0\", CVAR_TEMP );\ncl_freezeDemo = Cvar_Get( \"cl_freezeDemo\", \"0\", CVAR_TEMP );\nrcon_client_password = Cvar_Get( \"rconPassword\", \"\", CVAR_TEMP );\ncl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\ncl_timedemo = Cvar_Get( \"timedemo\", \"0\", 0 );\ncl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\ncl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\ncl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\ncl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\ncl_avidemo = Cvar_Get( \"cl_avidemo\", \"0\", 0 );\ncl_forceavidemo = Cvar_Get( \"cl_forceavidemo\", \"0\", 0 );\nrconAddress = Cvar_Get( \"rconAddress\", \"\", 0 );\ncl_yawspeed = Cvar_Get( \"cl_yawspeed\", \"140\", CVAR_ARCHIVE );\ncl_pitchspeed = Cvar_Get( \"cl_pitchspeed\", \"140\", CVAR_ARCHIVE );\ncl_anglespeedkey = Cvar_Get( \"cl_anglespeedkey\", \"1.5\", 0 );\ncl_maxpackets = Cvar_Get( \"cl_maxpackets\", \"38\", CVAR_ARCHIVE );\ncl_packetdup = Cvar_Get( \"cl_packetdup\", \"1\", CVAR_ARCHIVE );\ncl_run = Cvar_Get( \"cl_run\", \"1\", CVAR_ARCHIVE );\ncl_sensitivity = Cvar_Get( \"sensitivity\", \"5\", CVAR_ARCHIVE );\ncl_mouseAccel = Cvar_Get( \"cl_mouseAccel\", \"0\", CVAR_ARCHIVE );\ncl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\ncl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\ncl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\nCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\ncl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\ncl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"0\", CVAR_ARCHIVE );\n#ifdef USE_CURL_DLOPEN\ncl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n#endif\nCvar_Get( \"cg_autoswitch\", \"2\", CVAR_ARCHIVE );\nCvar_Get( \"cg_wolfparticles\", \"1\", CVAR_ARCHIVE );\ncl_conXOffset = Cvar_Get( \"cl_conXOffset\", \"0\", 0 );\ncl_inGameVideo = Cvar_Get( \"r_inGameVideo\", \"1\", CVAR_ARCHIVE );\ncl_serverStatusResendTime = Cvar_Get( \"cl_serverStatusResendTime\", \"750\", 0 );\ncl_recoilPitch = Cvar_Get( \"cg_recoilPitch\", \"0\", CVAR_ROM );\nm_pitch = Cvar_Get( \"m_pitch\", \"0.022\", CVAR_ARCHIVE );\nm_yaw = Cvar_Get( \"m_yaw\", \"0.022\", CVAR_ARCHIVE );\nm_forward = Cvar_Get( \"m_forward\", \"0.25\", CVAR_ARCHIVE );\nm_side = Cvar_Get( \"m_side\", \"0.25\", CVAR_ARCHIVE );\nm_filter = Cvar_Get( \"m_filter\", \"0\", CVAR_ARCHIVE );\nj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\nj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\nj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\nj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\nj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\nj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\nj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\nj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\nj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\nj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\nCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\ncl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\nCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\ncl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\ncl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\ncl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\nCvar_Get( \"name\", \"WolfPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\ncl_rate = Cvar_Get( \"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"model\", \"bj2\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"head\", \"default\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"color\", \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"password\", \"\", CVAR_USERINFO );\nCvar_Get( \"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n#ifdef USE_MUMBLE\ncl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\ncl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n#ifdef USE_VOIP\ncl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\ncl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\ncl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\ncl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\ncl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\ncl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\ncl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\ncl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\nCvar_CheckRange( cl_voip, 0, 1, qtrue );\ncl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\nCvar_Get( \"cg_autoactivate\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"cg_emptyswitch\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get( \"cg_viewsize\", \"100\", CVAR_ARCHIVE );\nCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\ncl_missionStats = Cvar_Get( \"g_missionStats\", \"0\", CVAR_ROM );\ncl_waitForFire = Cvar_Get( \"cl_waitForFire\", \"0\", CVAR_ROM );\ncl_language = Cvar_Get( \"cl_language\", \"0\", CVAR_ARCHIVE );\ncl_debugTranslation = Cvar_Get( \"cl_debugTranslation\", \"0\", 0 );\nCmd_AddCommand( \"cmd\", CL_ForwardToServer_f );\nCmd_AddCommand( \"configstrings\", CL_Configstrings_f );\nCmd_AddCommand( \"clientinfo\", CL_Clientinfo_f );\nCmd_AddCommand( \"snd_restart\", CL_Snd_Restart_f );\nCmd_AddCommand( \"vid_restart\", CL_Vid_Restart_f );\nCmd_AddCommand( \"disconnect\", CL_Disconnect_f );\nCmd_AddCommand( \"record\", CL_Record_f );\nCmd_AddCommand( \"demo\", CL_PlayDemo_f );\nCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\nCmd_AddCommand( \"cinematic\", CL_PlayCinematic_f );\nCmd_AddCommand( \"stoprecord\", CL_StopRecord_f );\nCmd_AddCommand( \"connect\", CL_Connect_f );\nCmd_AddCommand( \"reconnect\", CL_Reconnect_f );\nCmd_AddCommand( \"localservers\", CL_LocalServers_f );\nCmd_AddCommand( \"globalservers\", CL_GlobalServers_f );\nCmd_AddCommand( \"rcon\", CL_Rcon_f );\nCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\nCmd_AddCommand( \"ping\", CL_Ping_f );\nCmd_AddCommand( \"serverstatus\", CL_ServerStatus_f );\nCmd_AddCommand( \"showip\", CL_ShowIP_f );\nCmd_AddCommand( \"fs_openedList\", CL_OpenedPK3List_f );\nCmd_AddCommand( \"fs_referencedList\", CL_ReferencedPK3List_f );\nCmd_AddCommand (\"video\", CL_Video_f );\nCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\nCmd_AddCommand( \"cache_startgather\", CL_Cache_StartGather_f );\nCmd_AddCommand( \"cache_usedfile\", CL_Cache_UsedFile_f );\nCmd_AddCommand( \"cache_setindex\", CL_Cache_SetIndex_f );\nCmd_AddCommand( \"cache_mapchange\", CL_Cache_MapChange_f );\nCmd_AddCommand( \"cache_endgather\", CL_Cache_EndGather_f );\nCmd_AddCommand( \"updatehunkusage\", CL_UpdateLevelHunkUsage );\nCmd_AddCommand( \"updatescreen\", SCR_UpdateScreen );\nCmd_AddCommand( \"cld\", CL_ClientDamageCommand );\nCmd_AddCommand( \"startMultiplayer\", CL_startMultiplayer_f );\nCmd_AddCommand( \"shellExecute\", CL_ShellExecute_URL_f );\nCmd_AddCommand( \"map_restart\", CL_MapRestart_f );\nCmd_AddCommand( \"setRecommended\", CL_SetRecommended_f );\nCL_InitRef();\nSCR_Init();\nCvar_Set( \"cl_running\", \"1\" );\nCL_GenerateQKey();\nCvar_Get( \"cl_guid\", \"\", CVAR_USERINFO | CVAR_ROM );\nCL_UpdateGUID( NULL, 0 );\nCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}", "label": 0}
{"index": 178913, "code": "void CL_Init( void ) {\nCom_Printf( \"----- Client Initialization -----\\n\" );\nCon_Init ();\nif(!com_fullyInitialized)\n{\nCL_ClearState();\nclc.state = CA_DISCONNECTED;\ncl_oldGameSet = qfalse;\n}\ncls.realtime = 0;\nCL_InitInput ();\ncl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\ncl_motd = Cvar_Get (\"cl_motd\", \"1\", 0);\n#endif\ncl_timeout = Cvar_Get (\"cl_timeout\", \"200\", 0);\ncl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\ncl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\ncl_showSend = Cvar_Get (\"cl_showSend\", \"0\", CVAR_TEMP );\ncl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\ncl_freezeDemo = Cvar_Get (\"cl_freezeDemo\", \"0\", CVAR_TEMP );\nrcon_client_password = Cvar_Get (\"rconPassword\", \"\", CVAR_TEMP );\ncl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\ncl_timedemo = Cvar_Get (\"timedemo\", \"0\", 0);\ncl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\ncl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\ncl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\ncl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\ncl_forceavidemo = Cvar_Get (\"cl_forceavidemo\", \"0\", 0);\nrconAddress = Cvar_Get (\"rconAddress\", \"\", 0);\ncl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\ncl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\ncl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", 0);\ncl_maxpackets = Cvar_Get (\"cl_maxpackets\", \"30\", CVAR_ARCHIVE );\ncl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\ncl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE);\ncl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE);\ncl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE);\ncl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\ncl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\ncl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\nCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\ncl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\ncl_allowDownload = Cvar_Get (\"cl_allowDownload\", \"0\", CVAR_ARCHIVE);\n#ifdef USE_CURL_DLOPEN\ncl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n#endif\ncl_conXOffset = Cvar_Get (\"cl_conXOffset\", \"0\", 0);\n#ifdef __APPLE__\ncl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"0\", CVAR_ARCHIVE);\n#else\ncl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"1\", CVAR_ARCHIVE);\n#endif\ncl_serverStatusResendTime = Cvar_Get (\"cl_serverStatusResendTime\", \"750\", 0);\nCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\nm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\nm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\nm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\nm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n#ifdef __APPLE__\nm_filter = Cvar_Get (\"m_filter\", \"1\", CVAR_ARCHIVE);\n#else\nm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n#endif\nj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\nj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\nj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\nj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\nj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\nj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\nj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\nj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\nj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\nj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\nCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\ncl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\nCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\ncl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\ncl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\ncl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\nCvar_Get (\"name\", \"UnnamedPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\ncl_rate = Cvar_Get (\"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"model\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"headmodel\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"team_model\", \"james\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"team_headmodel\", \"*james\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"g_redTeam\", \"Stroggs\", CVAR_SERVERINFO | CVAR_ARCHIVE);\nCvar_Get (\"g_blueTeam\", \"Pagans\", CVAR_SERVERINFO | CVAR_ARCHIVE);\nCvar_Get (\"color1\",  \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"color2\", \"5\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"teamtask\", \"0\", CVAR_USERINFO );\nCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"password\", \"\", CVAR_USERINFO);\nCvar_Get (\"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n#ifdef USE_MUMBLE\ncl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\ncl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n#ifdef USE_VOIP\ncl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\ncl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\ncl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\ncl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\ncl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\ncl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\ncl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\ncl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\nCvar_CheckRange( cl_voip, 0, 1, qtrue );\ncl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\nCvar_Get (\"cg_viewsize\", \"100\", CVAR_ARCHIVE );\nCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\nCmd_AddCommand (\"cmd\", CL_ForwardToServer_f);\nCmd_AddCommand (\"configstrings\", CL_Configstrings_f);\nCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f);\nCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f);\nCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f);\nCmd_AddCommand (\"disconnect\", CL_Disconnect_f);\nCmd_AddCommand (\"record\", CL_Record_f);\nCmd_AddCommand (\"demo\", CL_PlayDemo_f);\nCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\nCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f);\nCmd_AddCommand (\"stoprecord\", CL_StopRecord_f);\nCmd_AddCommand (\"connect\", CL_Connect_f);\nCmd_AddCommand (\"reconnect\", CL_Reconnect_f);\nCmd_AddCommand (\"localservers\", CL_LocalServers_f);\nCmd_AddCommand (\"globalservers\", CL_GlobalServers_f);\nCmd_AddCommand (\"rcon\", CL_Rcon_f);\nCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\nCmd_AddCommand (\"ping\", CL_Ping_f );\nCmd_AddCommand (\"serverstatus\", CL_ServerStatus_f );\nCmd_AddCommand (\"showip\", CL_ShowIP_f );\nCmd_AddCommand (\"fs_openedList\", CL_OpenedPK3List_f );\nCmd_AddCommand (\"fs_referencedList\", CL_ReferencedPK3List_f );\nCmd_AddCommand (\"model\", CL_SetModel_f );\nCmd_AddCommand (\"video\", CL_Video_f );\nCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\nif( !com_dedicated->integer ) {\nCmd_AddCommand (\"sayto\", CL_Sayto_f );\nCmd_SetCommandCompletionFunc( \"sayto\", CL_CompletePlayerName );\n}\nCL_InitRef();\nSCR_Init ();\nCvar_Set( \"cl_running\", \"1\" );\nCL_GenerateQKey();\nCvar_Get( \"cl_guid\", \"\", CVAR_USERINFO | CVAR_ROM );\nCL_UpdateGUID( NULL, 0 );\nCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}", "contrast": "void CL_Init( void ) {\nCom_Printf( \"----- Client Initialization -----\\n\" );\nCon_Init ();\nif(!com_fullyInitialized)\n{\nCL_ClearState();\nclc.state = CA_DISCONNECTED;\ncl_oldGameSet = qfalse;\n}\ncls.realtime = 0;\nCL_InitInput ();\ncl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\ncl_motd = Cvar_Get (\"cl_motd\", \"1\", 0);\n#endif\ncl_timeout = Cvar_Get (\"cl_timeout\", \"200\", 0);\ncl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\ncl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\ncl_showSend = Cvar_Get (\"cl_showSend\", \"0\", CVAR_TEMP );\ncl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\ncl_freezeDemo = Cvar_Get (\"cl_freezeDemo\", \"0\", CVAR_TEMP );\nrcon_client_password = Cvar_Get (\"rconPassword\", \"\", CVAR_TEMP );\ncl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\ncl_timedemo = Cvar_Get (\"timedemo\", \"0\", 0);\ncl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\ncl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\ncl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\ncl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\ncl_forceavidemo = Cvar_Get (\"cl_forceavidemo\", \"0\", 0);\nrconAddress = Cvar_Get (\"rconAddress\", \"\", 0);\ncl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\ncl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\ncl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", 0);\ncl_maxpackets = Cvar_Get (\"cl_maxpackets\", \"30\", CVAR_ARCHIVE );\ncl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\ncl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE);\ncl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE);\ncl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE);\ncl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\ncl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\ncl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\nCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\ncl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\ncl_allowDownload = Cvar_Get (\"cl_allowDownload\", \"0\", CVAR_ARCHIVE);\n#ifdef USE_CURL_DLOPEN\ncl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n#endif\ncl_conXOffset = Cvar_Get (\"cl_conXOffset\", \"0\", 0);\n#ifdef __APPLE__\ncl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"0\", CVAR_ARCHIVE);\n#else\ncl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"1\", CVAR_ARCHIVE);\n#endif\ncl_serverStatusResendTime = Cvar_Get (\"cl_serverStatusResendTime\", \"750\", 0);\nCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\nm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\nm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\nm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\nm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n#ifdef __APPLE__\nm_filter = Cvar_Get (\"m_filter\", \"1\", CVAR_ARCHIVE);\n#else\nm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n#endif\nj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\nj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\nj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\nj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\nj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\nj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\nj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\nj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\nj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\nj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\nCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\nCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\ncl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\nCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\ncl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\ncl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\ncl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\nCvar_Get (\"name\", \"UnnamedPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\ncl_rate = Cvar_Get (\"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"model\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"headmodel\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"team_model\", \"james\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"team_headmodel\", \"*james\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"g_redTeam\", \"Stroggs\", CVAR_SERVERINFO | CVAR_ARCHIVE);\nCvar_Get (\"g_blueTeam\", \"Pagans\", CVAR_SERVERINFO | CVAR_ARCHIVE);\nCvar_Get (\"color1\",  \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"color2\", \"5\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"teamtask\", \"0\", CVAR_USERINFO );\nCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\nCvar_Get (\"password\", \"\", CVAR_USERINFO);\nCvar_Get (\"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n#ifdef USE_MUMBLE\ncl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\ncl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n#ifdef USE_VOIP\ncl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\ncl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\ncl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\ncl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\ncl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\ncl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\ncl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\ncl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\nCvar_CheckRange( cl_voip, 0, 1, qtrue );\ncl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\nCvar_Get (\"cg_viewsize\", \"100\", CVAR_ARCHIVE );\nCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\nCmd_AddCommand (\"cmd\", CL_ForwardToServer_f);\nCmd_AddCommand (\"configstrings\", CL_Configstrings_f);\nCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f);\nCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f);\nCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f);\nCmd_AddCommand (\"disconnect\", CL_Disconnect_f);\nCmd_AddCommand (\"record\", CL_Record_f);\nCmd_AddCommand (\"demo\", CL_PlayDemo_f);\nCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\nCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f);\nCmd_AddCommand (\"stoprecord\", CL_StopRecord_f);\nCmd_AddCommand (\"connect\", CL_Connect_f);\nCmd_AddCommand (\"reconnect\", CL_Reconnect_f);\nCmd_AddCommand (\"localservers\", CL_LocalServers_f);\nCmd_AddCommand (\"globalservers\", CL_GlobalServers_f);\nCmd_AddCommand (\"rcon\", CL_Rcon_f);\nCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\nCmd_AddCommand (\"ping\", CL_Ping_f );\nCmd_AddCommand (\"serverstatus\", CL_ServerStatus_f );\nCmd_AddCommand (\"showip\", CL_ShowIP_f );\nCmd_AddCommand (\"fs_openedList\", CL_OpenedPK3List_f );\nCmd_AddCommand (\"fs_referencedList\", CL_ReferencedPK3List_f );\nCmd_AddCommand (\"model\", CL_SetModel_f );\nCmd_AddCommand (\"video\", CL_Video_f );\nCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\nif( !com_dedicated->integer ) {\nCmd_AddCommand (\"sayto\", CL_Sayto_f );\nCmd_SetCommandCompletionFunc( \"sayto\", CL_CompletePlayerName );\n}\nCL_InitRef();\nSCR_Init ();\nCvar_Set( \"cl_running\", \"1\" );\nCL_GenerateQKey();\nCvar_Get( \"cl_guid\", \"\", CVAR_USERINFO | CVAR_ROM );\nCL_UpdateGUID( NULL, 0 );\nCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}", "label": 0}
{"index": 178923, "code": "static int store_asoundrc(void) {\nfs_build_mnt_dir();\nchar *src;\nchar *dest = RUN_ASOUNDRC_FILE;\nFILE *fp = fopen(dest, \"w\");\nif (fp) {\nfprintf(fp, \"\\n\");\nSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\nfclose(fp);\n}\nif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\nerrExit(\"asprintf\");\nstruct stat s;\nif (stat(src, &s) == 0) {\nif (is_link(src)) {\nfprintf(stderr, \"Error: invalid .asoundrc file\\n\");\nexit(1);\n}\npid_t child = fork();\nif (child < 0)\nerrExit(\"fork\");\nif (child == 0) {\ndrop_privs(0);\nint rv = copy_file(src, dest);\nif (rv)\nfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");\nelse {\nfs_logger2(\"clone\", dest);\n}\n_exit(0);\n}\nwaitpid(child, NULL, 0);\nif (chown(dest, getuid(), getgid()) == -1)\nerrExit(\"fchown\");\nif (chmod(dest, 0644) == -1)\nerrExit(\"fchmod\");\nreturn 1;\n}\nreturn 0;\n}", "contrast": "static int store_asoundrc(void) {\nfs_build_mnt_dir();\nchar *src;\nchar *dest = RUN_ASOUNDRC_FILE;\nFILE *fp = fopen(dest, \"w\");\nif (fp) {\nfprintf(fp, \"\\n\");\nSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\nfclose(fp);\n}\nif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\nerrExit(\"asprintf\");\nstruct stat s;\nif (stat(src, &s) == 0) {\nif (is_link(src)) {\nchar* rp = realpath(src, NULL);\nif (!rp) {\nfprintf(stderr, \"Error: Cannot access %s\\n\", src);\nexit(1);\n}\nif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\nfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\nexit(1);\n}\nfree(rp);\n}\ncopy_file_as_user(src, dest, getuid(), getgid(), 0644);\nfs_logger2(\"clone\", dest);\nreturn 1;\n}\nreturn 0;\n}", "label": 0}
{"index": 178933, "code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\ngit_pkt *pkt;\nconst char *line, *line_end;\nsize_t line_len;\nint error;\nint reading_from_buf = data_pkt_buf->size > 0;\nif (reading_from_buf) {\ngit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\nline = data_pkt_buf->ptr;\nline_len = data_pkt_buf->size;\n}\nelse {\nline = data_pkt->data;\nline_len = data_pkt->len;\n}\nwhile (line_len > 0) {\nerror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\nif (error == GIT_EBUFS) {\nif (!reading_from_buf)\ngit_buf_put(data_pkt_buf, line, line_len);\nerror = 0;\ngoto done;\n}\nelse if (error < 0)\ngoto done;\nline_len -= (line_end - line);\nline = line_end;\nif (pkt == NULL)\ncontinue;\nerror = add_push_report_pkt(push, pkt);\ngit_pkt_free(pkt);\nif (error < 0 && error != GIT_ITEROVER)\ngoto done;\n}\nerror = 0;\ndone:\nif (reading_from_buf)\ngit_buf_consume(data_pkt_buf, line_end);\nreturn error;\n}", "contrast": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\ngit_pkt *pkt;\nconst char *line, *line_end;\nsize_t line_len;\nint error;\nint reading_from_buf = data_pkt_buf->size > 0;\nif (reading_from_buf) {\ngit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\nline = data_pkt_buf->ptr;\nline_len = data_pkt_buf->size;\n}\nelse {\nline = data_pkt->data;\nline_len = data_pkt->len;\n}\nwhile (line_len > 0) {\nerror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\nif (error == GIT_EBUFS) {\nif (!reading_from_buf)\ngit_buf_put(data_pkt_buf, line, line_len);\nerror = 0;\ngoto done;\n}\nelse if (error < 0)\ngoto done;\nline_len -= (line_end - line);\nline = line_end;\nerror = add_push_report_pkt(push, pkt);\ngit_pkt_free(pkt);\nif (error < 0 && error != GIT_ITEROVER)\ngoto done;\n}\nerror = 0;\ndone:\nif (reading_from_buf)\ngit_buf_consume(data_pkt_buf, line_end);\nreturn error;\n}", "label": 0}
{"index": 178960, "code": "QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\ntTcpIpPacketParsingResult res;\nres.value = 0;\nif (len < 4)\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nUCHAR  ver_len = pIpHeader->v4.ip_verlen;\nUCHAR  ip_version = (ver_len & 0xF0) >> 4;\nUSHORT ipHeaderSize = 0;\nUSHORT fullLength = 0;\nres.value = 0;\nif (ip_version == 4)\n{\nif (len < sizeof(IPv4Header))\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nipHeaderSize = (ver_len & 0xF) << 2;\nfullLength = swap_short(pIpHeader->v4.ip_length);\nDPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\nip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\nres.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\nif (res.ipStatus == ppresNotIP)\n{\nreturn res;\n}\nif (ipHeaderSize >= fullLength || len < fullLength)\n{\nDPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\", __FUNCTION__,\nip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\nres.ipCheckSum = ppresIPTooShort;\nreturn res;\n}\n}\nelse if (ip_version == 6)\n{\nif (len < sizeof(IPv6Header))\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nUCHAR nextHeader = pIpHeader->v6.ip6_next_header;\nBOOLEAN bParsingDone = FALSE;\nipHeaderSize = sizeof(pIpHeader->v6);\nres.ipStatus = ppresIPV6;\nres.ipCheckSum = ppresCSOK;\nfullLength = swap_short(pIpHeader->v6.ip6_payload_len);\nfullLength += ipHeaderSize;\nif (len < fullLength)\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nwhile (nextHeader != 59)\n{\nIPv6ExtHeader *pExt;\nswitch (nextHeader)\n{\ncase PROTOCOL_TCP:\nbParsingDone = TRUE;\nres.xxpStatus = ppresXxpKnown;\nres.TcpUdp = ppresIsTCP;\nres.xxpFull = len >= fullLength ? 1 : 0;\nres = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\nbreak;\ncase PROTOCOL_UDP:\nbParsingDone = TRUE;\nres.xxpStatus = ppresXxpKnown;\nres.TcpUdp = ppresIsUDP;\nres.xxpFull = len >= fullLength ? 1 : 0;\nres = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\nbreak;\ncase 0:\ncase 60:\ncase 43:\ncase 44:\ncase 51:\ncase 50:\ncase 135:\nif (len >= ((ULONG)ipHeaderSize + 8))\n{\npExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);\nnextHeader = pExt->ip6ext_next_header;\nipHeaderSize += 8;\nipHeaderSize += pExt->ip6ext_hdr_len * 8;\n}\nelse\n{\nDPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));\nres.ipStatus = ppresNotIP;\nbParsingDone = TRUE;\n}\nbreak;\ndefault:\nres.xxpStatus = ppresXxpOther;\nbParsingDone = TRUE;\nbreak;\n}\nif (bParsingDone)\nbreak;\n}\nif (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)\n{\nDPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\nip_version, ipHeaderSize, nextHeader, fullLength));\nres.ipHeaderSize = ipHeaderSize;\n}\nelse\n{\nDPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\nres.ipStatus = ppresNotIP;\n}\n}\nif (res.ipStatus == ppresIPV4)\n{\nres.ipHeaderSize = ipHeaderSize;\nres.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\nswitch (pIpHeader->v4.ip_protocol)\n{\ncase PROTOCOL_TCP:\n{\nres = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n}\nbreak;\ncase PROTOCOL_UDP:\n{\nres = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n}\nbreak;\ndefault:\nres.xxpStatus = ppresXxpOther;\nbreak;\n}\n}\nreturn res;\n}", "contrast": "QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\nQualifyIpPacket(IPHeader *pIpHeader, ULONG len, BOOLEAN verifyLength)\n{\ntTcpIpPacketParsingResult res;\nres.value = 0;\nif (len < 4)\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nUCHAR  ver_len = pIpHeader->v4.ip_verlen;\nUCHAR  ip_version = (ver_len & 0xF0) >> 4;\nUSHORT ipHeaderSize = 0;\nUSHORT fullLength = 0;\nres.value = 0;\nif (ip_version == 4)\n{\nif (len < sizeof(IPv4Header))\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nipHeaderSize = (ver_len & 0xF) << 2;\nfullLength = swap_short(pIpHeader->v4.ip_length);\nDPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\nip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\nres.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\nif (res.ipStatus == ppresNotIP)\n{\nreturn res;\n}\nif (ipHeaderSize >= fullLength || ( verifyLength && len < fullLength))\n{\nDPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d, verify = %s\\n\", __FUNCTION__,\nip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len, (verifyLength ? \"true\" : \"false\")));\nres.ipCheckSum = ppresIPTooShort;\nreturn res;\n}\n}\nelse if (ip_version == 6)\n{\nif (len < sizeof(IPv6Header))\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nUCHAR nextHeader = pIpHeader->v6.ip6_next_header;\nBOOLEAN bParsingDone = FALSE;\nipHeaderSize = sizeof(pIpHeader->v6);\nres.ipStatus = ppresIPV6;\nres.ipCheckSum = ppresCSOK;\nfullLength = swap_short(pIpHeader->v6.ip6_payload_len);\nfullLength += ipHeaderSize;\nif (verifyLength && (len < fullLength))\n{\nres.ipStatus = ppresNotIP;\nreturn res;\n}\nwhile (nextHeader != 59)\n{\nIPv6ExtHeader *pExt;\nswitch (nextHeader)\n{\ncase PROTOCOL_TCP:\nbParsingDone = TRUE;\nres.xxpStatus = ppresXxpKnown;\nres.TcpUdp = ppresIsTCP;\nres.xxpFull = len >= fullLength ? 1 : 0;\nres = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\nbreak;\ncase PROTOCOL_UDP:\nbParsingDone = TRUE;\nres.xxpStatus = ppresXxpKnown;\nres.TcpUdp = ppresIsUDP;\nres.xxpFull = len >= fullLength ? 1 : 0;\nres = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\nbreak;\ncase 0:\ncase 60:\ncase 43:\ncase 44:\ncase 51:\ncase 50:\ncase 135:\nif (len >= ((ULONG)ipHeaderSize + 8))\n{\npExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);\nnextHeader = pExt->ip6ext_next_header;\nipHeaderSize += 8;\nipHeaderSize += pExt->ip6ext_hdr_len * 8;\n}\nelse\n{\nDPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));\nres.ipStatus = ppresNotIP;\nbParsingDone = TRUE;\n}\nbreak;\ndefault:\nres.xxpStatus = ppresXxpOther;\nbParsingDone = TRUE;\nbreak;\n}\nif (bParsingDone)\nbreak;\n}\nif (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)\n{\nDPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\nip_version, ipHeaderSize, nextHeader, fullLength));\nres.ipHeaderSize = ipHeaderSize;\n}\nelse\n{\nDPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\nres.ipStatus = ppresNotIP;\n}\n}\nif (res.ipStatus == ppresIPV4)\n{\nres.ipHeaderSize = ipHeaderSize;\nres.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\nswitch (pIpHeader->v4.ip_protocol)\n{\ncase PROTOCOL_TCP:\n{\nres = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n}\nbreak;\ncase PROTOCOL_UDP:\n{\nres = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n}\nbreak;\ndefault:\nres.xxpStatus = ppresXxpOther;\nbreak;\n}\n}\nreturn res;\n}", "label": 0}
{"index": 178984, "code": "static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\nint ret;\nconst mbedtls_ssl_ciphersuite_t *ciphersuite_info =\nssl->transform_negotiate->ciphersuite_info;\nunsigned char *p = NULL, *end = NULL;\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n{\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\nssl->state++;\nreturn( 0 );\n}\n((void) p);\n((void) end);\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\ndefined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n{\nif( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\nreturn( ret );\n}\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\nssl->state++;\nreturn( 0 );\n}\n((void) p);\n((void) end);\n#endif\nif( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\nreturn( ret );\n}\nif( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\nreturn( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n}\nif( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n{\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n{\nssl->keep_current_message = 1;\ngoto exit;\n}\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n\"not be skipped\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\nreturn( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n}\np   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\nend = ssl->in_msg + ssl->in_hslen;\nMBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n{\nif( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\ndefined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n;\nelse\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\ndefined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n{\nif( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\ndefined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\ndefined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n{\nif( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n{\nret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\np, end - p );\nif( ret != 0 )\n{\nMBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\nreturn( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\nif( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n{\nsize_t sig_len, hashlen;\nunsigned char hash[64];\nmbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\nmbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\nunsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\nsize_t params_len = p - params;\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\nif( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n{\nif( ssl_parse_signature_algorithm( ssl, &p, end,\n&md_alg, &pk_alg ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\nif( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\ndefined(MBEDTLS_SSL_PROTO_TLS1_1)\nif( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n{\npk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\nif( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\nmd_alg = MBEDTLS_MD_SHA1;\n}\nelse\n#endif\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\nreturn( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\nif( p > end - 2 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\nsig_len = ( p[0] << 8 ) | p[1];\np += 2;\nif( end != p + sig_len )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\nMBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\ndefined(MBEDTLS_SSL_PROTO_TLS1_1)\nif( md_alg == MBEDTLS_MD_NONE )\n{\nhashlen = 36;\nret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\nparams_len );\nif( ret != 0 )\nreturn( ret );\n}\nelse\n#endif\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\ndefined(MBEDTLS_SSL_PROTO_TLS1_2)\nif( md_alg != MBEDTLS_MD_NONE )\n{\nhashlen = 0;\nret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\nparams_len, md_alg );\nif( ret != 0 )\nreturn( ret );\n}\nelse\n#endif\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\nreturn( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\nMBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n(unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\nif( ssl->session_negotiate->peer_cert == NULL )\n{\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\nreturn( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n}\nif( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\nreturn( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n}\nif( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\nmd_alg, hash, hashlen, p, sig_len ) ) != 0 )\n{\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\nMBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\nreturn( ret );\n}\n}\n#endif\nexit:\nssl->state++;\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\nreturn( 0 );\n}", "contrast": "static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\nint ret;\nconst mbedtls_ssl_ciphersuite_t *ciphersuite_info =\nssl->transform_negotiate->ciphersuite_info;\nunsigned char *p = NULL, *end = NULL;\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n{\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\nssl->state++;\nreturn( 0 );\n}\n((void) p);\n((void) end);\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\ndefined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n{\nif( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\nreturn( ret );\n}\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\nssl->state++;\nreturn( 0 );\n}\n((void) p);\n((void) end);\n#endif\nif( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\nreturn( ret );\n}\nif( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\nreturn( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n}\nif( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n{\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n{\nssl->keep_current_message = 1;\ngoto exit;\n}\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n\"not be skipped\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\nreturn( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n}\np   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\nend = ssl->in_msg + ssl->in_hslen;\nMBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n{\nif( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\ndefined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n;\nelse\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\ndefined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n{\nif( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\ndefined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\ndefined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\nciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n{\nif( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nif( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n{\nret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\np, end - p );\nif( ret != 0 )\n{\nMBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\nreturn( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\nif( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n{\nsize_t sig_len, hashlen;\nunsigned char hash[64];\nmbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\nmbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\nunsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\nsize_t params_len = p - params;\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\nif( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n{\nif( ssl_parse_signature_algorithm( ssl, &p, end,\n&md_alg, &pk_alg ) != 0 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\nif( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\n}\nelse\n#endif\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\ndefined(MBEDTLS_SSL_PROTO_TLS1_1)\nif( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n{\npk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\nif( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\nmd_alg = MBEDTLS_MD_SHA1;\n}\nelse\n#endif\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\nreturn( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\nif( p > end - 2 )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\nsig_len = ( p[0] << 8 ) | p[1];\np += 2;\nif( p != end - sig_len )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\nreturn( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n}\nMBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\ndefined(MBEDTLS_SSL_PROTO_TLS1_1)\nif( md_alg == MBEDTLS_MD_NONE )\n{\nhashlen = 36;\nret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\nparams_len );\nif( ret != 0 )\nreturn( ret );\n}\nelse\n#endif\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\ndefined(MBEDTLS_SSL_PROTO_TLS1_2)\nif( md_alg != MBEDTLS_MD_NONE )\n{\nhashlen = 0;\nret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\nparams_len, md_alg );\nif( ret != 0 )\nreturn( ret );\n}\nelse\n#endif\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\nreturn( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\nMBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n(unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\nif( ssl->session_negotiate->peer_cert == NULL )\n{\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\nreturn( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n}\nif( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n{\nMBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\nreturn( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n}\nif( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\nmd_alg, hash, hashlen, p, sig_len ) ) != 0 )\n{\nmbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\nMBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\nMBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\nreturn( ret );\n}\n}\n#endif\nexit:\nssl->state++;\nMBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\nreturn( 0 );\n}", "label": 0}
{"index": 178990, "code": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\nrpmpsm psm, char ** failedFile)\n{\nFD_t payload = rpmtePayload(te);\nrpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\nrpmfs fs = rpmteGetFileStates(te);\nrpmPlugins plugins = rpmtsPlugins(ts);\nstruct stat sb;\nint saveerrno = errno;\nint rc = 0;\nint nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\nint nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\nint firsthardlink = -1;\nint skip;\nrpmFileAction action;\nchar *tid = NULL;\nconst char *suffix;\nchar *fpath = NULL;\nif (fi == NULL) {\nrc = RPMERR_BAD_MAGIC;\ngoto exit;\n}\nrasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\nrc = fsmMkdirs(files, fs, plugins);\nwhile (!rc) {\nrc = rpmfiNext(fi);\nif (rc < 0) {\nif (rc == RPMERR_ITER_END)\nrc = 0;\nbreak;\n}\naction = rpmfsGetAction(fs, rpmfiFX(fi));\nskip = XFA_SKIPPING(action);\nsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\nif (action != FA_TOUCH) {\nfpath = fsmFsPath(fi, suffix);\n} else {\nfpath = fsmFsPath(fi, \"\");\n}\nrc = rpmfiStat(fi, 1, &sb);\nfsmDebug(fpath, action, &sb);\nif (rc)\nbreak;\nrc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\nsb.st_mode, action);\nif (rc) {\nskip = 1;\n} else {\nsetFileState(fs, rpmfiFX(fi));\n}\nif (!skip) {\nint setmeta = 1;\nif (!suffix) {\nrc = fsmBackup(fi, action);\n}\nif (!suffix) {\nrc = fsmVerify(fpath, fi);\n} else {\nrc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n}\nif (S_ISREG(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nrc = fsmMkfile(fi, fpath, files, psm, nodigest,\n&setmeta, &firsthardlink);\n}\n} else if (S_ISDIR(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nmode_t mode = sb.st_mode;\nmode &= ~07777;\nmode |=  00700;\nrc = fsmMkdir(fpath, mode);\n}\n} else if (S_ISLNK(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nrc = fsmSymlink(rpmfiFLink(fi), fpath);\n}\n} else if (S_ISFIFO(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nrc = fsmMkfifo(fpath, 0000);\n}\n} else if (S_ISCHR(sb.st_mode) ||\nS_ISBLK(sb.st_mode) ||\nS_ISSOCK(sb.st_mode))\n{\nif (rc == RPMERR_ENOENT) {\nrc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n}\n} else {\nif (!IS_DEV_LOG(fpath))\nrc = RPMERR_UNKNOWN_FILETYPE;\n}\nif (!rc && setmeta) {\nrc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n}\n} else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\nchar *fn = rpmfilesFN(files, firsthardlink);\nrc = expandRegular(fi, fn, psm, 0, nodigest, 0);\nfirsthardlink = -1;\nfree(fn);\n}\nif (rc) {\nif (!skip) {\nif (suffix && (action != FA_TOUCH)) {\n(void) fsmRemove(fpath, sb.st_mode);\n}\nerrno = saveerrno;\n}\n} else {\nrpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\nif (!skip) {\nif (suffix)\nrc = fsmBackup(fi, action);\nif (!rc)\nrc = fsmCommit(&fpath, fi, action, suffix);\n}\n}\nif (rc)\n*failedFile = xstrdup(fpath);\nrpmpluginsCallFsmFilePost(plugins, fi, fpath,\nsb.st_mode, action, rc);\nfpath = _free(fpath);\n}\nrpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\nrpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\nexit:\nrpmfiArchiveClose(fi);\nrpmfiFree(fi);\nFclose(payload);\nfree(tid);\nfree(fpath);\nreturn rc;\n}", "contrast": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\nrpmpsm psm, char ** failedFile)\n{\nFD_t payload = rpmtePayload(te);\nrpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\nrpmfs fs = rpmteGetFileStates(te);\nrpmPlugins plugins = rpmtsPlugins(ts);\nstruct stat sb;\nint saveerrno = errno;\nint rc = 0;\nint nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\nint nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\nint firsthardlink = -1;\nint skip;\nrpmFileAction action;\nchar *tid = NULL;\nconst char *suffix;\nchar *fpath = NULL;\nif (fi == NULL) {\nrc = RPMERR_BAD_MAGIC;\ngoto exit;\n}\nrasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\nrc = fsmMkdirs(files, fs, plugins);\nwhile (!rc) {\nrc = rpmfiNext(fi);\nif (rc < 0) {\nif (rc == RPMERR_ITER_END)\nrc = 0;\nbreak;\n}\naction = rpmfsGetAction(fs, rpmfiFX(fi));\nskip = XFA_SKIPPING(action);\nsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\nif (action != FA_TOUCH) {\nfpath = fsmFsPath(fi, suffix);\n} else {\nfpath = fsmFsPath(fi, \"\");\n}\nrc = rpmfiStat(fi, 1, &sb);\nfsmDebug(fpath, action, &sb);\nif (rc)\nbreak;\nrc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\nsb.st_mode, action);\nif (rc) {\nskip = 1;\n} else {\nsetFileState(fs, rpmfiFX(fi));\n}\nif (!skip) {\nint setmeta = 1;\nif (!suffix) {\nrc = fsmBackup(fi, action);\n}\nif (!suffix) {\nrc = fsmVerify(fpath, fi, &sb);\n} else {\nrc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n}\nif (S_ISREG(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nrc = fsmMkfile(fi, fpath, files, psm, nodigest,\n&setmeta, &firsthardlink);\n}\n} else if (S_ISDIR(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nmode_t mode = sb.st_mode;\nmode &= ~07777;\nmode |=  00700;\nrc = fsmMkdir(fpath, mode);\n}\n} else if (S_ISLNK(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nrc = fsmSymlink(rpmfiFLink(fi), fpath);\n}\n} else if (S_ISFIFO(sb.st_mode)) {\nif (rc == RPMERR_ENOENT) {\nrc = fsmMkfifo(fpath, 0000);\n}\n} else if (S_ISCHR(sb.st_mode) ||\nS_ISBLK(sb.st_mode) ||\nS_ISSOCK(sb.st_mode))\n{\nif (rc == RPMERR_ENOENT) {\nrc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n}\n} else {\nif (!IS_DEV_LOG(fpath))\nrc = RPMERR_UNKNOWN_FILETYPE;\n}\nif (!rc && setmeta) {\nrc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n}\n} else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\nchar *fn = rpmfilesFN(files, firsthardlink);\nrc = expandRegular(fi, fn, psm, 0, nodigest, 0);\nfirsthardlink = -1;\nfree(fn);\n}\nif (rc) {\nif (!skip) {\nif (suffix && (action != FA_TOUCH)) {\n(void) fsmRemove(fpath, sb.st_mode);\n}\nerrno = saveerrno;\n}\n} else {\nrpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\nif (!skip) {\nif (suffix)\nrc = fsmBackup(fi, action);\nif (!rc)\nrc = fsmCommit(&fpath, fi, action, suffix);\n}\n}\nif (rc)\n*failedFile = xstrdup(fpath);\nrpmpluginsCallFsmFilePost(plugins, fi, fpath,\nsb.st_mode, action, rc);\nfpath = _free(fpath);\n}\nrpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\nrpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\nexit:\nrpmfiArchiveClose(fi);\nrpmfiFree(fi);\nFclose(payload);\nfree(tid);\nfree(fpath);\nreturn rc;\n}", "label": 0}
{"index": 178998, "code": "static char *__filterShell(const char *arg) {\nr_return_val_if_fail (arg, NULL);\nchar *a = malloc (strlen (arg) + 1);\nif (!a) {\nreturn NULL;\n}\nchar *b = a;\nwhile (*arg) {\nswitch (*arg) {\ncase '@':\ncase '`':\ncase '|':\ncase ';':\ncase '\\n':\nbreak;\ndefault:\n*b++ = *arg;\nbreak;\n}\narg++;\n}\n*b = 0;\nreturn a;\n}", "contrast": "static char *__filterShell(const char *arg) {\nr_return_val_if_fail (arg, NULL);\nchar *a = malloc (strlen (arg) + 1);\nif (!a) {\nreturn NULL;\n}\nchar *b = a;\nwhile (*arg) {\nchar ch = *arg;\nswitch (ch) {\ncase '@':\ncase '`':\ncase '|':\ncase ';':\ncase '=':\ncase '\\n':\nbreak;\ndefault:\n*b++ = ch;\nbreak;\n}\narg++;\n}\n*b = 0;\nreturn a;\n}", "label": 0}
{"index": 179000, "code": "pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\nchar *errbuf, int *err)\n{\nbpf_u_int32 magic_int;\nsize_t amt_read;\nbpf_u_int32 total_length;\nbpf_u_int32 byte_order_magic;\nstruct block_header *bhdrp;\nstruct section_header_block *shbp;\npcap_t *p;\nint swapped = 0;\nstruct pcap_ng_sf *ps;\nint status;\nstruct block_cursor cursor;\nstruct interface_description_block *idbp;\n*err = 0;\nmemcpy(&magic_int, magic, sizeof(magic_int));\nif (magic_int != BT_SHB) {\nreturn (NULL);\n}\namt_read = fread(&total_length, 1, sizeof(total_length), fp);\nif (amt_read < sizeof(total_length)) {\nif (ferror(fp)) {\npcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\nerrno, \"error reading dump file\");\n*err = 1;\nreturn (NULL);\n}\nreturn (NULL);\n}\namt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\nif (amt_read < sizeof(byte_order_magic)) {\nif (ferror(fp)) {\npcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\nerrno, \"error reading dump file\");\n*err = 1;\nreturn (NULL);\n}\nreturn (NULL);\n}\nif (byte_order_magic != BYTE_ORDER_MAGIC) {\nbyte_order_magic = SWAPLONG(byte_order_magic);\nif (byte_order_magic != BYTE_ORDER_MAGIC) {\nreturn (NULL);\n}\nswapped = 1;\ntotal_length = SWAPLONG(total_length);\n}\nif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,\ntotal_length,\nsizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n*err = 1;\nreturn (NULL);\n}\nif (total_length > INITIAL_MAX_BLOCKSIZE) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"pcapng block size %u > maximum %u\",\ntotal_length, INITIAL_MAX_BLOCKSIZE);\n*err = 1;\nreturn (NULL);\n}\np = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\nif (p == NULL) {\n*err = 1;\nreturn (NULL);\n}\np->swapped = swapped;\nps = p->priv;\nswitch (precision) {\ncase PCAP_TSTAMP_PRECISION_MICRO:\nps->user_tsresol = 1000000;\nbreak;\ncase PCAP_TSTAMP_PRECISION_NANO:\nps->user_tsresol = 1000000000;\nbreak;\ndefault:\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"unknown time stamp resolution %u\", precision);\nfree(p);\n*err = 1;\nreturn (NULL);\n}\np->opt.tstamp_precision = precision;\np->bufsize = 2048;\nif (p->bufsize < total_length)\np->bufsize = total_length;\np->buffer = malloc(p->bufsize);\nif (p->buffer == NULL) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\nfree(p);\n*err = 1;\nreturn (NULL);\n}\nps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\nbhdrp = (struct block_header *)p->buffer;\nshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\nbhdrp->block_type = magic_int;\nbhdrp->total_length = total_length;\nshbp->byte_order_magic = byte_order_magic;\nif (read_bytes(fp,\n(u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\ntotal_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n1, errbuf) == -1)\ngoto fail;\nif (p->swapped) {\nshbp->major_version = SWAPSHORT(shbp->major_version);\nshbp->minor_version = SWAPSHORT(shbp->minor_version);\n}\nif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\nshbp->minor_version == PCAP_NG_VERSION_MINOR)) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"unsupported pcapng savefile version %u.%u\",\nshbp->major_version, shbp->minor_version);\ngoto fail;\n}\np->version_major = shbp->major_version;\np->version_minor = shbp->minor_version;\np->opt.tstamp_precision = precision;\nfor (;;) {\nstatus = read_block(fp, p, &cursor, errbuf);\nif (status == 0) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"the capture file has no Interface Description Blocks\");\ngoto fail;\n}\nif (status == -1)\ngoto fail;\nswitch (cursor.block_type) {\ncase BT_IDB:\nidbp = get_from_block_data(&cursor, sizeof(*idbp),\nerrbuf);\nif (idbp == NULL)\ngoto fail;\nif (p->swapped) {\nidbp->linktype = SWAPSHORT(idbp->linktype);\nidbp->snaplen = SWAPLONG(idbp->snaplen);\n}\nif (!add_interface(p, &cursor, errbuf))\ngoto fail;\ngoto done;\ncase BT_EPB:\ncase BT_SPB:\ncase BT_PB:\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"the capture file has a packet block before any Interface Description Blocks\");\ngoto fail;\ndefault:\nbreak;\n}\n}\ndone:\np->tzoff = 0;\np->linktype = linktype_to_dlt(idbp->linktype);\np->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\np->linktype_ext = 0;\nif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\nps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\np->next_packet_op = pcap_ng_next_packet;\np->cleanup_op = pcap_ng_cleanup;\nreturn (p);\nfail:\nfree(ps->ifaces);\nfree(p->buffer);\nfree(p);\n*err = 1;\nreturn (NULL);\n}", "contrast": "pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\nchar *errbuf, int *err)\n{\nbpf_u_int32 magic_int;\nsize_t amt_read;\nbpf_u_int32 total_length;\nbpf_u_int32 byte_order_magic;\nstruct block_header *bhdrp;\nstruct section_header_block *shbp;\npcap_t *p;\nint swapped = 0;\nstruct pcap_ng_sf *ps;\nint status;\nstruct block_cursor cursor;\nstruct interface_description_block *idbp;\n*err = 0;\nmemcpy(&magic_int, magic, sizeof(magic_int));\nif (magic_int != BT_SHB) {\nreturn (NULL);\n}\namt_read = fread(&total_length, 1, sizeof(total_length), fp);\nif (amt_read < sizeof(total_length)) {\nif (ferror(fp)) {\npcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\nerrno, \"error reading dump file\");\n*err = 1;\nreturn (NULL);\n}\nreturn (NULL);\n}\namt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\nif (amt_read < sizeof(byte_order_magic)) {\nif (ferror(fp)) {\npcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\nerrno, \"error reading dump file\");\n*err = 1;\nreturn (NULL);\n}\nreturn (NULL);\n}\nif (byte_order_magic != BYTE_ORDER_MAGIC) {\nbyte_order_magic = SWAPLONG(byte_order_magic);\nif (byte_order_magic != BYTE_ORDER_MAGIC) {\nreturn (NULL);\n}\nswapped = 1;\ntotal_length = SWAPLONG(total_length);\n}\nif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n(total_length > BT_SHB_INSANE_MAX)) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\nsizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\ntotal_length,\nBT_SHB_INSANE_MAX);\n*err = 1;\nreturn (NULL);\n}\np = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\nif (p == NULL) {\n*err = 1;\nreturn (NULL);\n}\np->swapped = swapped;\nps = p->priv;\nswitch (precision) {\ncase PCAP_TSTAMP_PRECISION_MICRO:\nps->user_tsresol = 1000000;\nbreak;\ncase PCAP_TSTAMP_PRECISION_NANO:\nps->user_tsresol = 1000000000;\nbreak;\ndefault:\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"unknown time stamp resolution %u\", precision);\nfree(p);\n*err = 1;\nreturn (NULL);\n}\np->opt.tstamp_precision = precision;\np->bufsize = 2048;\nif (p->bufsize < total_length)\np->bufsize = total_length;\np->buffer = malloc(p->bufsize);\nif (p->buffer == NULL) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\nfree(p);\n*err = 1;\nreturn (NULL);\n}\nps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\nbhdrp = (struct block_header *)p->buffer;\nshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\nbhdrp->block_type = magic_int;\nbhdrp->total_length = total_length;\nshbp->byte_order_magic = byte_order_magic;\nif (read_bytes(fp,\n(u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\ntotal_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n1, errbuf) == -1)\ngoto fail;\nif (p->swapped) {\nshbp->major_version = SWAPSHORT(shbp->major_version);\nshbp->minor_version = SWAPSHORT(shbp->minor_version);\n}\nif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\nshbp->minor_version == PCAP_NG_VERSION_MINOR)) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"unsupported pcapng savefile version %u.%u\",\nshbp->major_version, shbp->minor_version);\ngoto fail;\n}\np->version_major = shbp->major_version;\np->version_minor = shbp->minor_version;\np->opt.tstamp_precision = precision;\nfor (;;) {\nstatus = read_block(fp, p, &cursor, errbuf);\nif (status == 0) {\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"the capture file has no Interface Description Blocks\");\ngoto fail;\n}\nif (status == -1)\ngoto fail;\nswitch (cursor.block_type) {\ncase BT_IDB:\nidbp = get_from_block_data(&cursor, sizeof(*idbp),\nerrbuf);\nif (idbp == NULL)\ngoto fail;\nif (p->swapped) {\nidbp->linktype = SWAPSHORT(idbp->linktype);\nidbp->snaplen = SWAPLONG(idbp->snaplen);\n}\nif (!add_interface(p, &cursor, errbuf))\ngoto fail;\ngoto done;\ncase BT_EPB:\ncase BT_SPB:\ncase BT_PB:\npcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\"the capture file has a packet block before any Interface Description Blocks\");\ngoto fail;\ndefault:\nbreak;\n}\n}\ndone:\np->tzoff = 0;\np->linktype = linktype_to_dlt(idbp->linktype);\np->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\np->linktype_ext = 0;\nif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\nps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\np->next_packet_op = pcap_ng_next_packet;\np->cleanup_op = pcap_ng_cleanup;\nreturn (p);\nfail:\nfree(ps->ifaces);\nfree(p->buffer);\nfree(p);\n*err = 1;\nreturn (NULL);\n}", "label": 0}
{"index": 179003, "code": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\nvoid\n*data;\nassert(blob_info != (BlobInfo *) NULL);\nif (blob_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\nif (blob_info->mapped != MagickFalse)\n{\n(void) UnmapBlob(blob_info->data,blob_info->length);\nRelinquishMagickResource(MapResource,blob_info->length);\n}\nblob_info->mapped=MagickFalse;\nblob_info->length=0;\nblob_info->offset=0;\nblob_info->eof=MagickFalse;\nblob_info->error=0;\nblob_info->exempt=MagickFalse;\nblob_info->type=UndefinedStream;\nblob_info->file_info.file=(FILE *) NULL;\ndata=blob_info->data;\nblob_info->data=(unsigned char *) NULL;\nblob_info->stream=(StreamHandler) NULL;\nblob_info->custom_stream=(CustomStreamInfo *) NULL;\nreturn(data);\n}", "contrast": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\nvoid\n*data;\nassert(blob_info != (BlobInfo *) NULL);\nif (blob_info->debug != MagickFalse)\n(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\nif (blob_info->mapped != MagickFalse)\n{\n(void) UnmapBlob(blob_info->data,blob_info->length);\nblob_info->data=NULL;\nRelinquishMagickResource(MapResource,blob_info->length);\n}\nblob_info->mapped=MagickFalse;\nblob_info->length=0;\nblob_info->offset=0;\nblob_info->eof=MagickFalse;\nblob_info->error=0;\nblob_info->exempt=MagickFalse;\nblob_info->type=UndefinedStream;\nblob_info->file_info.file=(FILE *) NULL;\ndata=blob_info->data;\nblob_info->data=(unsigned char *) NULL;\nblob_info->stream=(StreamHandler) NULL;\nblob_info->custom_stream=(CustomStreamInfo *) NULL;\nreturn(data);\n}", "label": 0}
{"index": 179030, "code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\nget_page(buf->page);\n}", "contrast": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\nbool generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\nreturn try_get_page(buf->page);\n}", "label": 0}
{"index": 179037, "code": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\nunsigned long end, int write, struct page **pages, int *nr)\n{\nstruct page *head, *page;\nint refs;\nif (!pmd_access_permitted(orig, write))\nreturn 0;\nif (pmd_devmap(orig))\nreturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\nrefs = 0;\npage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\ndo {\npages[*nr] = page;\n(*nr)++;\npage++;\nrefs++;\n} while (addr += PAGE_SIZE, addr != end);\nhead = compound_head(pmd_page(orig));\nif (!page_cache_add_speculative(head, refs)) {\n*nr -= refs;\nreturn 0;\n}\nif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n*nr -= refs;\nwhile (refs--)\nput_page(head);\nreturn 0;\n}\nSetPageReferenced(head);\nreturn 1;\n}", "contrast": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\nunsigned long end, int write, struct page **pages, int *nr)\n{\nstruct page *head, *page;\nint refs;\nif (!pmd_access_permitted(orig, write))\nreturn 0;\nif (pmd_devmap(orig))\nreturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\nrefs = 0;\npage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\ndo {\npages[*nr] = page;\n(*nr)++;\npage++;\nrefs++;\n} while (addr += PAGE_SIZE, addr != end);\nhead = try_get_compound_head(pmd_page(orig), refs);\nif (!head) {\n*nr -= refs;\nreturn 0;\n}\nif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n*nr -= refs;\nwhile (refs--)\nput_page(head);\nreturn 0;\n}\nSetPageReferenced(head);\nreturn 1;\n}", "label": 0}
{"index": 179079, "code": "JSGlobalContextRef webkit_web_frame_get_global_context(WebKitWebFrame* frame)\n{\ng_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), NULL);\nFrame* coreFrame = core(frame);\nif (!coreFrame)\nreturn NULL;\nreturn toGlobalRef(coreFrame->script()->globalObject()->globalExec());\n}", "contrast": "JSGlobalContextRef webkit_web_frame_get_global_context(WebKitWebFrame* frame)\n{\ng_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), NULL);\nFrame* coreFrame = core(frame);\nif (!coreFrame)\nreturn NULL;\nreturn toGlobalRef(coreFrame->script()->globalObject(mainThreadNormalWorld())->globalExec());\n}", "label": 0}
{"index": 179314, "code": "void SetupTests() {\nRegisterTest(\"TestGraphics3DInterface\", TestGraphics3DInterface);\nRegisterTest(\"TestOpenGLES2Interface\", TestOpenGLES2Interface);\nRegisterTest(\"TestCreate\", TestCreate);\nRegisterTest(\"TestIsGraphics3D\", TestIsGraphics3D);\nRegisterTest(\"Test_glInitializePPAPI\", Test_glInitializePPAPI);\nRegisterTest(\"TestSwapBuffers\", TestSwapBuffers);\nRegisterTest(\"TestResizeBuffersWithoutDepthBuffer\",\nTestResizeBuffersWithoutDepthBuffer);\nRegisterTest(\"TestResizeBuffersWithDepthBuffer\",\nTestResizeBuffersWithDepthBuffer);\nRegisterTest(\"Test_glTerminatePPAPI\", Test_glTerminatePPAPI);\n}", "contrast": "void SetupTests() {\nRegisterTest(\"TestGraphics3DInterface\", TestGraphics3DInterface);\nRegisterTest(\"TestOpenGLES2Interface\", TestOpenGLES2Interface);\nRegisterTest(\"TestCreate\", TestCreate);\nRegisterTest(\"TestIsGraphics3D\", TestIsGraphics3D);\nRegisterTest(\"Test_glInitializePPAPI\", Test_glInitializePPAPI);\nRegisterTest(\"TestBasicSetup\", TestBasicSetup);\nRegisterTest(\"TestSwapBuffers\", TestSwapBuffers);\nRegisterTest(\"TestResizeBuffersWithoutDepthBuffer\",\nTestResizeBuffersWithoutDepthBuffer);\nRegisterTest(\"TestResizeBuffersWithDepthBuffer\",\nTestResizeBuffersWithDepthBuffer);\nRegisterTest(\"Test_glTerminatePPAPI\", Test_glTerminatePPAPI);\n}", "label": 0}
{"index": 179340, "code": "void swapBuffers()\n{\nif (m_xPixmap)\nreturn;\n#if PLATFORM(QT)\nif (!m_surface->isVisible())\nreturn;\nwhile (!m_surface->isExposed())\nQCoreApplication::processEvents();\nQOpenGLContext* glContext = QOpenGLContext::currentContext();\nif (m_surface && glContext) {\nGLint oldFBO;\nglGetIntegerv(GL_FRAMEBUFFER_BINDING, &oldFBO);\npGlBindFramebuffer(GL_FRAMEBUFFER, glContext->defaultFramebufferObject());\nglContext->swapBuffers(m_surface.get());\npGlBindFramebuffer(GL_FRAMEBUFFER, oldFBO);\n}\n#elif PLATFORM(EFL)\nGLXContext glContext = glXGetCurrentContext();\nif (m_surface && glContext) {\nGLint oldFBO;\nglGetIntegerv(GL_FRAMEBUFFER_BINDING, &oldFBO);\npGlBindFramebuffer(GL_FRAMEBUFFER, 0);\nglXSwapBuffers(m_display, m_surface);\npGlBindFramebuffer(GL_FRAMEBUFFER, oldFBO);\n}\n#endif\n}", "contrast": "void swapBuffers()\n{\nif (m_xPixmap)\nreturn;\nGLXContext glContext = glXGetCurrentContext();\nif (m_surface && glContext) {\nGLint oldFBO;\nglGetIntegerv(GL_FRAMEBUFFER_BINDING, &oldFBO);\npGlBindFramebuffer(GL_FRAMEBUFFER, 0);\nglXSwapBuffers(m_display, m_surface);\npGlBindFramebuffer(GL_FRAMEBUFFER, oldFBO);\n}\n}", "label": 0}
{"index": 179409, "code": "void AddExpectationsForSimulatedAttrib0(\nGLsizei num_vertices, GLuint buffer_id) {\nEXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, kServiceAttrib0BufferId))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BufferData(GL_ARRAY_BUFFER,\nnum_vertices * sizeof(GLfloat) * 4,\n_, GL_DYNAMIC_DRAW))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BufferSubData(\nGL_ARRAY_BUFFER, 0, num_vertices * sizeof(GLfloat) * 4, _))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, VertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, 0))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, VertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, buffer_id))\n.Times(1)\n.RetiresOnSaturation();\n}", "contrast": "void AddExpectationsForSimulatedAttrib0(\nvoid AddExpectationsForSimulatedAttrib0WithError(\nGLsizei num_vertices, GLuint buffer_id, GLenum error) {\nif (gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2) {\nreturn;\n}\nEXPECT_CALL(*gl_, GetError())\n.WillOnce(Return(GL_NO_ERROR))\n.WillOnce(Return(error))\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, kServiceAttrib0BufferId))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BufferData(GL_ARRAY_BUFFER,\nnum_vertices * sizeof(GLfloat) * 4,\n_, GL_DYNAMIC_DRAW))\n.Times(1)\n.RetiresOnSaturation();\nif (error == GL_NO_ERROR) {\nEXPECT_CALL(*gl_, BufferSubData(\nGL_ARRAY_BUFFER, 0, num_vertices * sizeof(GLfloat) * 4, _))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, VertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, 0))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, VertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL))\n.Times(1)\n.RetiresOnSaturation();\nEXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, buffer_id))\n.Times(1)\n.RetiresOnSaturation();\n}\n}\nvoid AddExpectationsForSimulatedAttrib0(\nGLsizei num_vertices, GLuint buffer_id) {\nAddExpectationsForSimulatedAttrib0WithError(\nnum_vertices, buffer_id, GL_NO_ERROR);\n}", "label": 0}
{"index": 179543, "code": "virtual void TreeNodesRemoved(TreeModel* model, TreeModelNode* parent,\nint start, int count) {\nremoved_count_++;\n}", "contrast": "virtual void TreeNodesRemoved(TreeModel* model, TreeModelNode* parent,\nvirtual void TreeNodesRemoved(TreeModel* model,\nTreeModelNode* parent,\nint start,\nint count) OVERRIDE {\nremoved_count_++;\n}", "label": 0}
{"index": 179562, "code": "virtual size_t GetNumActiveInputMethods() {\nscoped_ptr<InputMethodDescriptors> input_methods(GetActiveInputMethods());\nreturn input_methods->size();\n}", "contrast": "virtual size_t GetNumActiveInputMethods() {\nscoped_ptr<input_method::InputMethodDescriptors> input_methods(\nGetActiveInputMethods());\nreturn input_methods->size();\n}", "label": 0}
{"index": 179593, "code": "bool ChromeOSChangeInputMethod(\nInputMethodStatusConnection* connection, const char* name) {\nDCHECK(name);\nDLOG(INFO) << \"ChangeInputMethod: \" << name;\ng_return_val_if_fail(connection, false);\nreturn connection->ChangeInputMethod(name);\n}", "contrast": "bool ChromeOSChangeInputMethod(", "label": 0}
{"index": 179603, "code": "bool ConvertProperty(IBusProperty* ibus_prop,\nint selection_item_id,\nImePropertyList* out_prop_list) {\nDCHECK(ibus_prop);\nDCHECK(ibus_prop->key);\nDCHECK(out_prop_list);\nconst bool has_sub_props = PropertyHasChildren(ibus_prop);\nif (has_sub_props && (ibus_prop->type != PROP_TYPE_MENU)) {\nLOG(ERROR) << \"The property has sub properties, \"\n<< \"but the type of the property is not PROP_TYPE_MENU\";\nreturn false;\n}\nif ((!has_sub_props) && (ibus_prop->type == PROP_TYPE_MENU)) {\nDLOG(INFO) << \"Property list is empty\";\nreturn false;\n}\nif (ibus_prop->type == PROP_TYPE_SEPARATOR ||\nibus_prop->type == PROP_TYPE_MENU) {\nreturn true;\n}\nconst bool is_selection_item = (ibus_prop->type == PROP_TYPE_RADIO);\nselection_item_id = is_selection_item ?\nselection_item_id : ImeProperty::kInvalidSelectionItemId;\nbool is_selection_item_checked = false;\nif (ibus_prop->state == PROP_STATE_INCONSISTENT) {\nLOG(WARNING) << \"The property is in PROP_STATE_INCONSISTENT, \"\n<< \"which is not supported.\";\n} else if ((!is_selection_item) && (ibus_prop->state == PROP_STATE_CHECKED)) {\nLOG(WARNING) << \"PROP_STATE_CHECKED is meaningful only if the type is \"\n<< \"PROP_TYPE_RADIO.\";\n} else {\nis_selection_item_checked = (ibus_prop->state == PROP_STATE_CHECKED);\n}\nif (!ibus_prop->key) {\nLOG(ERROR) << \"key is NULL\";\n}\nif (ibus_prop->tooltip && (!ibus_prop->tooltip->text)) {\nLOG(ERROR) << \"tooltip is NOT NULL, but tooltip->text IS NULL: key=\"\n<< Or(ibus_prop->key, \"\");\n}\nif (ibus_prop->label && (!ibus_prop->label->text)) {\nLOG(ERROR) << \"label is NOT NULL, but label->text IS NULL: key=\"\n<< Or(ibus_prop->key, \"\");\n}\nstd::string label =\n((ibus_prop->tooltip &&\nibus_prop->tooltip->text) ? ibus_prop->tooltip->text : \"\");\nif (label.empty()) {\nlabel = (ibus_prop->label && ibus_prop->label->text)\n? ibus_prop->label->text : \"\";\n}\nif (label.empty()) {\nlabel = Or(ibus_prop->key, \"\");\n}\nout_prop_list->push_back(ImeProperty(ibus_prop->key,\nlabel,\nis_selection_item,\nis_selection_item_checked,\nselection_item_id));\nreturn true;\n}", "contrast": "bool ConvertProperty(IBusProperty* ibus_prop,\nint selection_item_id,\nImePropertyList* out_prop_list) {\nDCHECK(ibus_prop);\nDCHECK(ibus_prop->key);\nDCHECK(out_prop_list);\nconst bool has_sub_props = PropertyHasChildren(ibus_prop);\nif (has_sub_props && (ibus_prop->type != PROP_TYPE_MENU)) {\nLOG(ERROR) << \"The property has sub properties, \"\n<< \"but the type of the property is not PROP_TYPE_MENU\";\nreturn false;\n}\nif ((!has_sub_props) && (ibus_prop->type == PROP_TYPE_MENU)) {\nVLOG(1) << \"Property list is empty\";\nreturn false;\n}\nif (ibus_prop->type == PROP_TYPE_SEPARATOR ||\nibus_prop->type == PROP_TYPE_MENU) {\nreturn true;\n}\nconst bool is_selection_item = (ibus_prop->type == PROP_TYPE_RADIO);\nselection_item_id = is_selection_item ?\nselection_item_id : ImeProperty::kInvalidSelectionItemId;\nbool is_selection_item_checked = false;\nif (ibus_prop->state == PROP_STATE_INCONSISTENT) {\nLOG(WARNING) << \"The property is in PROP_STATE_INCONSISTENT, \"\n<< \"which is not supported.\";\n} else if ((!is_selection_item) && (ibus_prop->state == PROP_STATE_CHECKED)) {\nLOG(WARNING) << \"PROP_STATE_CHECKED is meaningful only if the type is \"\n<< \"PROP_TYPE_RADIO.\";\n} else {\nis_selection_item_checked = (ibus_prop->state == PROP_STATE_CHECKED);\n}\nif (!ibus_prop->key) {\nLOG(ERROR) << \"key is NULL\";\n}\nif (ibus_prop->tooltip && (!ibus_prop->tooltip->text)) {\nLOG(ERROR) << \"tooltip is NOT NULL, but tooltip->text IS NULL: key=\"\n<< Or(ibus_prop->key, \"\");\n}\nif (ibus_prop->label && (!ibus_prop->label->text)) {\nLOG(ERROR) << \"label is NOT NULL, but label->text IS NULL: key=\"\n<< Or(ibus_prop->key, \"\");\n}\nstd::string label =\n((ibus_prop->tooltip &&\nibus_prop->tooltip->text) ? ibus_prop->tooltip->text : \"\");\nif (label.empty()) {\nlabel = (ibus_prop->label && ibus_prop->label->text)\n? ibus_prop->label->text : \"\";\n}\nif (label.empty()) {\nlabel = Or(ibus_prop->key, \"\");\n}\nout_prop_list->push_back(ImeProperty(ibus_prop->key,\nlabel,\nis_selection_item,\nis_selection_item_checked,\nselection_item_id));\nreturn true;\n}", "label": 0}
{"index": 179609, "code": "static void IBusBusDisconnectedCallback(IBusBus* bus, gpointer user_data) {\nLOG(WARNING) << \"IBus connection is terminated.\";\ng_return_if_fail(user_data);\nInputMethodStatusConnection* self\n= static_cast<InputMethodStatusConnection*>(user_data);\nself->MaybeDestroyIBusConfig();\nif (self->connection_change_handler_) {\nLOG(INFO) << \"Notifying Chrome that IBus is terminated.\";\nself->connection_change_handler_(self->language_library_, false);\n}\n}", "contrast": "static void IBusBusDisconnectedCallback(IBusBus* bus, gpointer user_data) {\nvoid IBusBusDisconnected(IBusBus* bus) {\nLOG(WARNING) << \"IBus connection is terminated.\";\nMaybeDestroyIBusConfig();\nVLOG(1) << \"Notifying Chrome that IBus is terminated.\";\nFOR_EACH_OBSERVER(Observer, observers_, OnConnectionChange(false));\n}", "label": 0}
{"index": 179610, "code": "static void IBusBusGlobalEngineChangedCallback(\nIBusBus* bus, const gchar* engine_name, gpointer user_data) {\nDCHECK(engine_name);\nDLOG(INFO) << \"Global engine is changed to \" << engine_name;\ng_return_if_fail(user_data);\nInputMethodStatusConnection* self\n= static_cast<InputMethodStatusConnection*>(user_data);\nself->UpdateUI(engine_name);\n}", "contrast": "static void IBusBusGlobalEngineChangedCallback(\nvoid IBusBusGlobalEngineChanged(IBusBus* bus, const gchar* engine_name) {\nDCHECK(engine_name);\nVLOG(1) << \"Global engine is changed to \" << engine_name;\nUpdateUI(engine_name);\n}", "label": 0}
{"index": 179624, "code": "void UpdateUI(const char* current_global_engine_id) {\nDCHECK(current_global_engine_id);\nconst IBusEngineInfo* engine_info = NULL;\nfor (size_t i = 0; i < arraysize(kIBusEngines); ++i) {\nif (kIBusEngines[i].name == std::string(current_global_engine_id)) {\nengine_info = &kIBusEngines[i];\nbreak;\n}\n}\nif (!engine_info) {\nLOG(ERROR) << current_global_engine_id\n<< \" is not found in the input method white-list.\";\nreturn;\n}\nInputMethodDescriptor current_input_method =\nCreateInputMethodDescriptor(engine_info->name,\nengine_info->longname,\nengine_info->layout,\nengine_info->language);\nDLOG(INFO) << \"Updating the UI. ID:\" << current_input_method.id\n<< \", keyboard_layout:\" << current_input_method.keyboard_layout;\ncurrent_input_method_changed_(language_library_, current_input_method);\n}", "contrast": "void UpdateUI(const char* current_global_engine_id) {\nDCHECK(current_global_engine_id);\nconst IBusEngineInfo* engine_info = NULL;\nfor (size_t i = 0; i < arraysize(kIBusEngines); ++i) {\nif (kIBusEngines[i].name == std::string(current_global_engine_id)) {\nengine_info = &kIBusEngines[i];\nbreak;\n}\n}\nif (!engine_info) {\nLOG(ERROR) << current_global_engine_id\n<< \" is not found in the input method white-list.\";\nreturn;\n}\nInputMethodDescriptor current_input_method =\nCreateInputMethodDescriptor(engine_info->name,\nengine_info->longname,\nengine_info->layout,\nengine_info->language);\nVLOG(1) << \"Updating the UI. ID:\" << current_input_method.id\n<< \", keyboard_layout:\" << current_input_method.keyboard_layout;\nFOR_EACH_OBSERVER(Observer, observers_,\nOnCurrentInputMethodChanged(current_input_method));\n}", "label": 0}
{"index": 179630, "code": "static JSValue setDataViewMember(ExecState* exec, DataView* imp, DataViewAccessType type)\n{\nif (exec->argumentCount() < 2)\nreturn throwError(exec, createTypeError(exec, \"Not enough arguments\"));\nExceptionCode ec = 0;\nunsigned byteOffset = exec->argument(0).toUInt32(exec);\nif (exec->hadException())\nreturn jsUndefined();\nint value = exec->argument(1).toInt32(exec);\nif (exec->hadException())\nreturn jsUndefined();\nswitch (type) {\ncase AccessDataViewMemberAsInt8:\nimp->setInt8(byteOffset, static_cast<int8_t>(value), ec);\nbreak;\ncase AccessDataViewMemberAsUint8:\nimp->setUint8(byteOffset, static_cast<uint8_t>(value), ec);\nbreak;\ndefault:\nASSERT_NOT_REACHED();\nbreak;\n}\nsetDOMException(exec, ec);\nreturn jsUndefined();\n}", "contrast": "static JSValue setDataViewMember(ExecState* exec, DataView* imp, DataViewAccessType type)\n{\nif (exec->argumentCount() < 2)\nreturn throwError(exec, createNotEnoughArgumentsError(exec));\nExceptionCode ec = 0;\nunsigned byteOffset = exec->argument(0).toUInt32(exec);\nif (exec->hadException())\nreturn jsUndefined();\nint value = exec->argument(1).toInt32(exec);\nif (exec->hadException())\nreturn jsUndefined();\nswitch (type) {\ncase AccessDataViewMemberAsInt8:\nimp->setInt8(byteOffset, static_cast<int8_t>(value), ec);\nbreak;\ncase AccessDataViewMemberAsUint8:\nimp->setUint8(byteOffset, static_cast<uint8_t>(value), ec);\nbreak;\ndefault:\nASSERT_NOT_REACHED();\nbreak;\n}\nsetDOMException(exec, ec);\nreturn jsUndefined();\n}", "label": 0}
{"index": 179654, "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionAddEventListener(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 2)\nreturn throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\nJSValue listener = exec->argument(1);\nif (!listener.isObject())\nreturn JSValue::encode(jsUndefined());\nimpl->addEventListener(ustringToAtomicString(exec->argument(0).toString(exec)->value(exec)), JSEventListener::create(asObject(listener), castedThis, false, currentWorld(exec)), exec->argument(2).toBoolean(exec));\nreturn JSValue::encode(jsUndefined());\n}", "contrast": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionAddEventListener(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 2)\nreturn throwVMError(exec, createNotEnoughArgumentsError(exec));\nJSValue listener = exec->argument(1);\nif (!listener.isObject())\nreturn JSValue::encode(jsUndefined());\nimpl->addEventListener(ustringToAtomicString(exec->argument(0).toString(exec)->value(exec)), JSEventListener::create(asObject(listener), castedThis, false, currentWorld(exec)), exec->argument(2).toBoolean(exec));\nreturn JSValue::encode(jsUndefined());\n}", "label": 0}
{"index": 179660, "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIdbKey(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 1)\nreturn throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\nPassRefPtr<IDBKey> key(createIDBKeyFromValue(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nimpl->idbKey(key);\nreturn JSValue::encode(jsUndefined());\n}", "contrast": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIdbKey(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 1)\nreturn throwVMError(exec, createNotEnoughArgumentsError(exec));\nPassRefPtr<IDBKey> key(createIDBKeyFromValue(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nimpl->idbKey(key);\nreturn JSValue::encode(jsUndefined());\n}", "label": 0}
{"index": 179663, "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 2)\nreturn throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\nExceptionCode ec = 0;\nconst String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nTestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nJSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec)));\nsetDOMException(exec, ec);\nreturn JSValue::encode(result);\n}", "contrast": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 2)\nreturn throwVMError(exec, createNotEnoughArgumentsError(exec));\nExceptionCode ec = 0;\nconst String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nTestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nJSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec)));\nsetDOMException(exec, ec);\nreturn JSValue::encode(result);\n}", "label": 0}
{"index": 179666, "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 1)\nreturn throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\nint nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nsize_t argsCount = exec->argumentCount();\nif (argsCount <= 1) {\nimpl->methodWithNonOptionalArgAndOptionalArg(nonOpt);\nreturn JSValue::encode(jsUndefined());\n}\nint opt(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toInt32(exec));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nimpl->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\nreturn JSValue::encode(jsUndefined());\n}", "contrast": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 1)\nreturn throwVMError(exec, createNotEnoughArgumentsError(exec));\nint nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nsize_t argsCount = exec->argumentCount();\nif (argsCount <= 1) {\nimpl->methodWithNonOptionalArgAndOptionalArg(nonOpt);\nreturn JSValue::encode(jsUndefined());\n}\nint opt(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toInt32(exec));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nimpl->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\nreturn JSValue::encode(jsUndefined());\n}", "label": 0}
{"index": 179670, "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionObjMethodWithArgs(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 3)\nreturn throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\nint intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nconst String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toString(exec)->value(exec)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nTestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsUndefined)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nJSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->objMethodWithArgs(intArg, strArg, objArg)));\nreturn JSValue::encode(result);\n}", "contrast": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionObjMethodWithArgs(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 3)\nreturn throwVMError(exec, createNotEnoughArgumentsError(exec));\nint intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nconst String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toString(exec)->value(exec)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nTestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsUndefined)));\nif (exec->hadException())\nreturn JSValue::encode(jsUndefined());\nJSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->objMethodWithArgs(intArg, strArg, objArg)));\nreturn JSValue::encode(result);\n}", "label": 0}
{"index": 179679, "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionRemoveEventListener(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 2)\nreturn throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\nJSValue listener = exec->argument(1);\nif (!listener.isObject())\nreturn JSValue::encode(jsUndefined());\nimpl->removeEventListener(ustringToAtomicString(exec->argument(0).toString(exec)->value(exec)), JSEventListener::create(asObject(listener), castedThis, false, currentWorld(exec)).get(), exec->argument(2).toBoolean(exec));\nreturn JSValue::encode(jsUndefined());\n}", "contrast": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionRemoveEventListener(ExecState* exec)\n{\nJSValue thisValue = exec->hostThisValue();\nif (!thisValue.inherits(&JSTestObj::s_info))\nreturn throwVMTypeError(exec);\nJSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\nASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\nTestObj* impl = static_cast<TestObj*>(castedThis->impl());\nif (exec->argumentCount() < 2)\nreturn throwVMError(exec, createNotEnoughArgumentsError(exec));\nJSValue listener = exec->argument(1);\nif (!listener.isObject())\nreturn JSValue::encode(jsUndefined());\nimpl->removeEventListener(ustringToAtomicString(exec->argument(0).toString(exec)->value(exec)), JSEventListener::create(asObject(listener), castedThis, false, currentWorld(exec)).get(), exec->argument(2).toBoolean(exec));\nreturn JSValue::encode(jsUndefined());\n}", "label": 0}
{"index": 179871, "code": "static void registerStreamURLTask(void* context)\n{\nOwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\nblobRegistry().registerStreamURL(blobRegistryContext->url, blobRegistryContext->type);\n}", "contrast": "static void registerStreamURLTask(void* context)\n{\nOwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\nif (WebBlobRegistry* registry = blobRegistry())\nregistry->registerStreamURL(blobRegistryContext->url, blobRegistryContext->type);\n}", "label": 0}
{"index": 180280, "code": "virtual void SetUp() {\nurl_util::AddStandardScheme(\"tabcontentstest\");\nold_browser_client_ = content::GetContentClient()->browser();\ncontent::GetContentClient()->set_browser(&browser_client_);\nRenderViewHostTestHarness::SetUp();\n}", "contrast": "virtual void SetUp() {\nurl_util::AddStandardScheme(\"tabcontentstest\");\nold_client_ = content::GetContentClient();\ncontent::SetContentClient(&client_);\nold_browser_client_ = content::GetContentClient()->browser();\ncontent::GetContentClient()->set_browser(&browser_client_);\nRenderViewHostTestHarness::SetUp();\n}", "label": 0}
{"index": 180316, "code": "static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)\n{\nWebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);\nWebKitWebViewBasePrivate* priv = webView->priv;\nif (WEBKIT_IS_WEB_VIEW_BASE(widget)\n&& WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {\nASSERT(!priv->inspectorView);\npriv->inspectorView = widget;\npriv->inspectorViewHeight = gMinimumAttachedInspectorHeight;\n} else {\nGtkAllocation childAllocation;\ngtk_widget_get_allocation(widget, &childAllocation);\npriv->children.set(widget, childAllocation);\n}\ngtk_widget_set_parent(widget, GTK_WIDGET(container));\n}", "contrast": "static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)\n{\nWebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);\nWebKitWebViewBasePrivate* priv = webView->priv;\nif (WEBKIT_IS_WEB_VIEW_BASE(widget)\n&& WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {\nASSERT(!priv->inspectorView);\npriv->inspectorView = widget;\n} else {\nGtkAllocation childAllocation;\ngtk_widget_get_allocation(widget, &childAllocation);\npriv->children.set(widget, childAllocation);\n}\ngtk_widget_set_parent(widget, GTK_WIDGET(container));\n}", "label": 0}
{"index": 180422, "code": "static void willRemoveChildren(ContainerNode* container)\n{\nNodeVector children;\ngetChildNodes(container, children);\ncontainer->document().nodeChildrenWillBeRemoved(container);\nChildListMutationScope mutation(container);\nfor (NodeVector::const_iterator it = children.begin(); it != children.end(); it++) {\nNode* child = it->get();\nmutation.willRemoveChild(child);\nchild->notifyMutationObserversNodeWillDetach();\ndispatchChildRemovalEvents(child);\n}\nChildFrameDisconnector(container).disconnect(ChildFrameDisconnector::DescendantsOnly);\n}", "contrast": "static void willRemoveChildren(ContainerNode* container)\n{\nNodeVector children;\ngetChildNodes(container, children);\nChildListMutationScope mutation(container);\nfor (NodeVector::const_iterator it = children.begin(); it != children.end(); it++) {\nNode* child = it->get();\nmutation.willRemoveChild(child);\nchild->notifyMutationObserversNodeWillDetach();\ndispatchChildRemovalEvents(child);\n}\nChildFrameDisconnector(container).disconnect(ChildFrameDisconnector::DescendantsOnly);\n}", "label": 0}
{"index": 180423, "code": "void EnsureInitializeForAndroidLayoutTests() {\nCHECK(CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree));\nJNIEnv* env = base::android::AttachCurrentThread();\ncontent::NestedMessagePumpAndroid::RegisterJni(env);\ncontent::RegisterNativesImpl(env);\nbool success = base::MessageLoop::InitMessagePumpForUIFactory(\n&CreateMessagePumpForUI);\nCHECK(success) << \"Unable to initialize the message pump for Android.\";\nbase::FilePath files_dir(GetTestFilesDirectory(env));\nbase::FilePath stdout_fifo(files_dir.Append(FILE_PATH_LITERAL(\"test.fifo\")));\nEnsureCreateFIFO(stdout_fifo);\nbase::FilePath stderr_fifo(\nfiles_dir.Append(FILE_PATH_LITERAL(\"stderr.fifo\")));\nEnsureCreateFIFO(stderr_fifo);\nbase::FilePath stdin_fifo(files_dir.Append(FILE_PATH_LITERAL(\"stdin.fifo\")));\nEnsureCreateFIFO(stdin_fifo);\nsuccess = base::android::RedirectStream(stdout, stdout_fifo, \"w\") &&\nbase::android::RedirectStream(stdin, stdin_fifo, \"r\") &&\nbase::android::RedirectStream(stderr, stderr_fifo, \"w\");\nCHECK(success) << \"Unable to initialize the Android FIFOs.\";\n}", "contrast": "void EnsureInitializeForAndroidLayoutTests() {\nJNIEnv* env = base::android::AttachCurrentThread();\ncontent::NestedMessagePumpAndroid::RegisterJni(env);\ncontent::RegisterNativesImpl(env);\nbool success = base::MessageLoop::InitMessagePumpForUIFactory(\n&CreateMessagePumpForUI);\nCHECK(success) << \"Unable to initialize the message pump for Android.\";\nbase::FilePath files_dir(GetTestFilesDirectory(env));\nbase::FilePath stdout_fifo(files_dir.Append(FILE_PATH_LITERAL(\"test.fifo\")));\nEnsureCreateFIFO(stdout_fifo);\nbase::FilePath stderr_fifo(\nfiles_dir.Append(FILE_PATH_LITERAL(\"stderr.fifo\")));\nEnsureCreateFIFO(stderr_fifo);\nbase::FilePath stdin_fifo(files_dir.Append(FILE_PATH_LITERAL(\"stdin.fifo\")));\nEnsureCreateFIFO(stdin_fifo);\nsuccess = base::android::RedirectStream(stdout, stdout_fifo, \"w\") &&\nbase::android::RedirectStream(stdin, stdin_fifo, \"r\") &&\nbase::android::RedirectStream(stderr, stderr_fifo, \"w\");\nCHECK(success) << \"Unable to initialize the Android FIFOs.\";\n}", "label": 0}
{"index": 180424, "code": "void StackDumpSignalHandler(int signal, siginfo_t* info, void* void_context) {\nin_signal_handler = 1;\nif (BeingDebugged())\nBreakDebugger();\nPrintToStderr(\"Received signal \");\nchar buf[1024] = { 0 };\ninternal::itoa_r(signal, buf, sizeof(buf), 10, 0);\nPrintToStderr(buf);\nif (signal == SIGBUS) {\nif (info->si_code == BUS_ADRALN)\nPrintToStderr(\" BUS_ADRALN \");\nelse if (info->si_code == BUS_ADRERR)\nPrintToStderr(\" BUS_ADRERR \");\nelse if (info->si_code == BUS_OBJERR)\nPrintToStderr(\" BUS_OBJERR \");\nelse\nPrintToStderr(\" <unknown> \");\n} else if (signal == SIGFPE) {\nif (info->si_code == FPE_FLTDIV)\nPrintToStderr(\" FPE_FLTDIV \");\nelse if (info->si_code == FPE_FLTINV)\nPrintToStderr(\" FPE_FLTINV \");\nelse if (info->si_code == FPE_FLTOVF)\nPrintToStderr(\" FPE_FLTOVF \");\nelse if (info->si_code == FPE_FLTRES)\nPrintToStderr(\" FPE_FLTRES \");\nelse if (info->si_code == FPE_FLTSUB)\nPrintToStderr(\" FPE_FLTSUB \");\nelse if (info->si_code == FPE_FLTUND)\nPrintToStderr(\" FPE_FLTUND \");\nelse if (info->si_code == FPE_INTDIV)\nPrintToStderr(\" FPE_INTDIV \");\nelse if (info->si_code == FPE_INTOVF)\nPrintToStderr(\" FPE_INTOVF \");\nelse\nPrintToStderr(\" <unknown> \");\n} else if (signal == SIGILL) {\nif (info->si_code == ILL_BADSTK)\nPrintToStderr(\" ILL_BADSTK \");\nelse if (info->si_code == ILL_COPROC)\nPrintToStderr(\" ILL_COPROC \");\nelse if (info->si_code == ILL_ILLOPN)\nPrintToStderr(\" ILL_ILLOPN \");\nelse if (info->si_code == ILL_ILLADR)\nPrintToStderr(\" ILL_ILLADR \");\nelse if (info->si_code == ILL_ILLTRP)\nPrintToStderr(\" ILL_ILLTRP \");\nelse if (info->si_code == ILL_PRVOPC)\nPrintToStderr(\" ILL_PRVOPC \");\nelse if (info->si_code == ILL_PRVREG)\nPrintToStderr(\" ILL_PRVREG \");\nelse\nPrintToStderr(\" <unknown> \");\n} else if (signal == SIGSEGV) {\nif (info->si_code == SEGV_MAPERR)\nPrintToStderr(\" SEGV_MAPERR \");\nelse if (info->si_code == SEGV_ACCERR)\nPrintToStderr(\" SEGV_ACCERR \");\nelse\nPrintToStderr(\" <unknown> \");\n}\nif (signal == SIGBUS || signal == SIGFPE ||\nsignal == SIGILL || signal == SIGSEGV) {\ninternal::itoa_r(reinterpret_cast<intptr_t>(info->si_addr),\nbuf, sizeof(buf), 16, 12);\nPrintToStderr(buf);\n}\nPrintToStderr(\"\\n\");\ndebug::StackTrace().Print();\n#if defined(OS_LINUX)\n#if ARCH_CPU_X86_FAMILY\nucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);\nconst struct {\nconst char* label;\ngreg_t value;\n} registers[] = {\n#if ARCH_CPU_32_BITS\n{ \"  gs: \", context->uc_mcontext.gregs[REG_GS] },\n{ \"  fs: \", context->uc_mcontext.gregs[REG_FS] },\n{ \"  es: \", context->uc_mcontext.gregs[REG_ES] },\n{ \"  ds: \", context->uc_mcontext.gregs[REG_DS] },\n{ \" edi: \", context->uc_mcontext.gregs[REG_EDI] },\n{ \" esi: \", context->uc_mcontext.gregs[REG_ESI] },\n{ \" ebp: \", context->uc_mcontext.gregs[REG_EBP] },\n{ \" esp: \", context->uc_mcontext.gregs[REG_ESP] },\n{ \" ebx: \", context->uc_mcontext.gregs[REG_EBX] },\n{ \" edx: \", context->uc_mcontext.gregs[REG_EDX] },\n{ \" ecx: \", context->uc_mcontext.gregs[REG_ECX] },\n{ \" eax: \", context->uc_mcontext.gregs[REG_EAX] },\n{ \" trp: \", context->uc_mcontext.gregs[REG_TRAPNO] },\n{ \" err: \", context->uc_mcontext.gregs[REG_ERR] },\n{ \"  ip: \", context->uc_mcontext.gregs[REG_EIP] },\n{ \"  cs: \", context->uc_mcontext.gregs[REG_CS] },\n{ \" efl: \", context->uc_mcontext.gregs[REG_EFL] },\n{ \" usp: \", context->uc_mcontext.gregs[REG_UESP] },\n{ \"  ss: \", context->uc_mcontext.gregs[REG_SS] },\n#elif ARCH_CPU_64_BITS\n{ \"  r8: \", context->uc_mcontext.gregs[REG_R8] },\n{ \"  r9: \", context->uc_mcontext.gregs[REG_R9] },\n{ \" r10: \", context->uc_mcontext.gregs[REG_R10] },\n{ \" r11: \", context->uc_mcontext.gregs[REG_R11] },\n{ \" r12: \", context->uc_mcontext.gregs[REG_R12] },\n{ \" r13: \", context->uc_mcontext.gregs[REG_R13] },\n{ \" r14: \", context->uc_mcontext.gregs[REG_R14] },\n{ \" r15: \", context->uc_mcontext.gregs[REG_R15] },\n{ \"  di: \", context->uc_mcontext.gregs[REG_RDI] },\n{ \"  si: \", context->uc_mcontext.gregs[REG_RSI] },\n{ \"  bp: \", context->uc_mcontext.gregs[REG_RBP] },\n{ \"  bx: \", context->uc_mcontext.gregs[REG_RBX] },\n{ \"  dx: \", context->uc_mcontext.gregs[REG_RDX] },\n{ \"  ax: \", context->uc_mcontext.gregs[REG_RAX] },\n{ \"  cx: \", context->uc_mcontext.gregs[REG_RCX] },\n{ \"  sp: \", context->uc_mcontext.gregs[REG_RSP] },\n{ \"  ip: \", context->uc_mcontext.gregs[REG_RIP] },\n{ \" efl: \", context->uc_mcontext.gregs[REG_EFL] },\n{ \" cgf: \", context->uc_mcontext.gregs[REG_CSGSFS] },\n{ \" erf: \", context->uc_mcontext.gregs[REG_ERR] },\n{ \" trp: \", context->uc_mcontext.gregs[REG_TRAPNO] },\n{ \" msk: \", context->uc_mcontext.gregs[REG_OLDMASK] },\n{ \" cr2: \", context->uc_mcontext.gregs[REG_CR2] },\n#endif\n};\n#if ARCH_CPU_32_BITS\nconst int kRegisterPadding = 8;\n#elif ARCH_CPU_64_BITS\nconst int kRegisterPadding = 16;\n#endif\nfor (size_t i = 0; i < ARRAYSIZE_UNSAFE(registers); i++) {\nPrintToStderr(registers[i].label);\ninternal::itoa_r(registers[i].value, buf, sizeof(buf),\n16, kRegisterPadding);\nPrintToStderr(buf);\nif ((i + 1) % 4 == 0)\nPrintToStderr(\"\\n\");\n}\nPrintToStderr(\"\\n\");\n#endif\n#elif defined(OS_MACOSX)\n#if ARCH_CPU_X86_FAMILY && ARCH_CPU_32_BITS\nucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);\nsize_t len;\nlen = static_cast<size_t>(\nsnprintf(buf, sizeof(buf),\n\"ax: %x, bx: %x, cx: %x, dx: %x\\n\",\ncontext->uc_mcontext->__ss.__eax,\ncontext->uc_mcontext->__ss.__ebx,\ncontext->uc_mcontext->__ss.__ecx,\ncontext->uc_mcontext->__ss.__edx));\nwrite(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\nlen = static_cast<size_t>(\nsnprintf(buf, sizeof(buf),\n\"di: %x, si: %x, bp: %x, sp: %x, ss: %x, flags: %x\\n\",\ncontext->uc_mcontext->__ss.__edi,\ncontext->uc_mcontext->__ss.__esi,\ncontext->uc_mcontext->__ss.__ebp,\ncontext->uc_mcontext->__ss.__esp,\ncontext->uc_mcontext->__ss.__ss,\ncontext->uc_mcontext->__ss.__eflags));\nwrite(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\nlen = static_cast<size_t>(\nsnprintf(buf, sizeof(buf),\n\"ip: %x, cs: %x, ds: %x, es: %x, fs: %x, gs: %x\\n\",\ncontext->uc_mcontext->__ss.__eip,\ncontext->uc_mcontext->__ss.__cs,\ncontext->uc_mcontext->__ss.__ds,\ncontext->uc_mcontext->__ss.__es,\ncontext->uc_mcontext->__ss.__fs,\ncontext->uc_mcontext->__ss.__gs));\nwrite(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\n#endif\n#endif\n_exit(1);\n}", "contrast": "void StackDumpSignalHandler(int signal, siginfo_t* info, void* void_context) {\nin_signal_handler = 1;\nif (BeingDebugged())\nBreakDebugger();\nPrintToStderr(\"Received signal \");\nchar buf[1024] = { 0 };\ninternal::itoa_r(signal, buf, sizeof(buf), 10, 0);\nPrintToStderr(buf);\nif (signal == SIGBUS) {\nif (info->si_code == BUS_ADRALN)\nPrintToStderr(\" BUS_ADRALN \");\nelse if (info->si_code == BUS_ADRERR)\nPrintToStderr(\" BUS_ADRERR \");\nelse if (info->si_code == BUS_OBJERR)\nPrintToStderr(\" BUS_OBJERR \");\nelse\nPrintToStderr(\" <unknown> \");\n} else if (signal == SIGFPE) {\nif (info->si_code == FPE_FLTDIV)\nPrintToStderr(\" FPE_FLTDIV \");\nelse if (info->si_code == FPE_FLTINV)\nPrintToStderr(\" FPE_FLTINV \");\nelse if (info->si_code == FPE_FLTOVF)\nPrintToStderr(\" FPE_FLTOVF \");\nelse if (info->si_code == FPE_FLTRES)\nPrintToStderr(\" FPE_FLTRES \");\nelse if (info->si_code == FPE_FLTSUB)\nPrintToStderr(\" FPE_FLTSUB \");\nelse if (info->si_code == FPE_FLTUND)\nPrintToStderr(\" FPE_FLTUND \");\nelse if (info->si_code == FPE_INTDIV)\nPrintToStderr(\" FPE_INTDIV \");\nelse if (info->si_code == FPE_INTOVF)\nPrintToStderr(\" FPE_INTOVF \");\nelse\nPrintToStderr(\" <unknown> \");\n} else if (signal == SIGILL) {\nif (info->si_code == ILL_BADSTK)\nPrintToStderr(\" ILL_BADSTK \");\nelse if (info->si_code == ILL_COPROC)\nPrintToStderr(\" ILL_COPROC \");\nelse if (info->si_code == ILL_ILLOPN)\nPrintToStderr(\" ILL_ILLOPN \");\nelse if (info->si_code == ILL_ILLADR)\nPrintToStderr(\" ILL_ILLADR \");\nelse if (info->si_code == ILL_ILLTRP)\nPrintToStderr(\" ILL_ILLTRP \");\nelse if (info->si_code == ILL_PRVOPC)\nPrintToStderr(\" ILL_PRVOPC \");\nelse if (info->si_code == ILL_PRVREG)\nPrintToStderr(\" ILL_PRVREG \");\nelse\nPrintToStderr(\" <unknown> \");\n} else if (signal == SIGSEGV) {\nif (info->si_code == SEGV_MAPERR)\nPrintToStderr(\" SEGV_MAPERR \");\nelse if (info->si_code == SEGV_ACCERR)\nPrintToStderr(\" SEGV_ACCERR \");\nelse\nPrintToStderr(\" <unknown> \");\n}\nif (signal == SIGBUS || signal == SIGFPE ||\nsignal == SIGILL || signal == SIGSEGV) {\ninternal::itoa_r(reinterpret_cast<intptr_t>(info->si_addr),\nbuf, sizeof(buf), 16, 12);\nPrintToStderr(buf);\n}\nPrintToStderr(\"\\n\");\ndebug::StackTrace().Print();\n#if defined(OS_LINUX)\n#if ARCH_CPU_X86_FAMILY\nucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);\nconst struct {\nconst char* label;\ngreg_t value;\n} registers[] = {\n#if ARCH_CPU_32_BITS\n{ \"  gs: \", context->uc_mcontext.gregs[REG_GS] },\n{ \"  fs: \", context->uc_mcontext.gregs[REG_FS] },\n{ \"  es: \", context->uc_mcontext.gregs[REG_ES] },\n{ \"  ds: \", context->uc_mcontext.gregs[REG_DS] },\n{ \" edi: \", context->uc_mcontext.gregs[REG_EDI] },\n{ \" esi: \", context->uc_mcontext.gregs[REG_ESI] },\n{ \" ebp: \", context->uc_mcontext.gregs[REG_EBP] },\n{ \" esp: \", context->uc_mcontext.gregs[REG_ESP] },\n{ \" ebx: \", context->uc_mcontext.gregs[REG_EBX] },\n{ \" edx: \", context->uc_mcontext.gregs[REG_EDX] },\n{ \" ecx: \", context->uc_mcontext.gregs[REG_ECX] },\n{ \" eax: \", context->uc_mcontext.gregs[REG_EAX] },\n{ \" trp: \", context->uc_mcontext.gregs[REG_TRAPNO] },\n{ \" err: \", context->uc_mcontext.gregs[REG_ERR] },\n{ \"  ip: \", context->uc_mcontext.gregs[REG_EIP] },\n{ \"  cs: \", context->uc_mcontext.gregs[REG_CS] },\n{ \" efl: \", context->uc_mcontext.gregs[REG_EFL] },\n{ \" usp: \", context->uc_mcontext.gregs[REG_UESP] },\n{ \"  ss: \", context->uc_mcontext.gregs[REG_SS] },\n#elif ARCH_CPU_64_BITS\n{ \"  r8: \", context->uc_mcontext.gregs[REG_R8] },\n{ \"  r9: \", context->uc_mcontext.gregs[REG_R9] },\n{ \" r10: \", context->uc_mcontext.gregs[REG_R10] },\n{ \" r11: \", context->uc_mcontext.gregs[REG_R11] },\n{ \" r12: \", context->uc_mcontext.gregs[REG_R12] },\n{ \" r13: \", context->uc_mcontext.gregs[REG_R13] },\n{ \" r14: \", context->uc_mcontext.gregs[REG_R14] },\n{ \" r15: \", context->uc_mcontext.gregs[REG_R15] },\n{ \"  di: \", context->uc_mcontext.gregs[REG_RDI] },\n{ \"  si: \", context->uc_mcontext.gregs[REG_RSI] },\n{ \"  bp: \", context->uc_mcontext.gregs[REG_RBP] },\n{ \"  bx: \", context->uc_mcontext.gregs[REG_RBX] },\n{ \"  dx: \", context->uc_mcontext.gregs[REG_RDX] },\n{ \"  ax: \", context->uc_mcontext.gregs[REG_RAX] },\n{ \"  cx: \", context->uc_mcontext.gregs[REG_RCX] },\n{ \"  sp: \", context->uc_mcontext.gregs[REG_RSP] },\n{ \"  ip: \", context->uc_mcontext.gregs[REG_RIP] },\n{ \" efl: \", context->uc_mcontext.gregs[REG_EFL] },\n{ \" cgf: \", context->uc_mcontext.gregs[REG_CSGSFS] },\n{ \" erf: \", context->uc_mcontext.gregs[REG_ERR] },\n{ \" trp: \", context->uc_mcontext.gregs[REG_TRAPNO] },\n{ \" msk: \", context->uc_mcontext.gregs[REG_OLDMASK] },\n{ \" cr2: \", context->uc_mcontext.gregs[REG_CR2] },\n#endif\n};\n#if ARCH_CPU_32_BITS\nconst int kRegisterPadding = 8;\n#elif ARCH_CPU_64_BITS\nconst int kRegisterPadding = 16;\n#endif\nfor (size_t i = 0; i < arraysize(registers); i++) {\nPrintToStderr(registers[i].label);\ninternal::itoa_r(registers[i].value, buf, sizeof(buf),\n16, kRegisterPadding);\nPrintToStderr(buf);\nif ((i + 1) % 4 == 0)\nPrintToStderr(\"\\n\");\n}\nPrintToStderr(\"\\n\");\n#endif\n#elif defined(OS_MACOSX)\n#if ARCH_CPU_X86_FAMILY && ARCH_CPU_32_BITS\nucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);\nsize_t len;\nlen = static_cast<size_t>(\nsnprintf(buf, sizeof(buf),\n\"ax: %x, bx: %x, cx: %x, dx: %x\\n\",\ncontext->uc_mcontext->__ss.__eax,\ncontext->uc_mcontext->__ss.__ebx,\ncontext->uc_mcontext->__ss.__ecx,\ncontext->uc_mcontext->__ss.__edx));\nwrite(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\nlen = static_cast<size_t>(\nsnprintf(buf, sizeof(buf),\n\"di: %x, si: %x, bp: %x, sp: %x, ss: %x, flags: %x\\n\",\ncontext->uc_mcontext->__ss.__edi,\ncontext->uc_mcontext->__ss.__esi,\ncontext->uc_mcontext->__ss.__ebp,\ncontext->uc_mcontext->__ss.__esp,\ncontext->uc_mcontext->__ss.__ss,\ncontext->uc_mcontext->__ss.__eflags));\nwrite(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\nlen = static_cast<size_t>(\nsnprintf(buf, sizeof(buf),\n\"ip: %x, cs: %x, ds: %x, es: %x, fs: %x, gs: %x\\n\",\ncontext->uc_mcontext->__ss.__eip,\ncontext->uc_mcontext->__ss.__cs,\ncontext->uc_mcontext->__ss.__ds,\ncontext->uc_mcontext->__ss.__es,\ncontext->uc_mcontext->__ss.__fs,\ncontext->uc_mcontext->__ss.__gs));\nwrite(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\n#endif\n#endif\n_exit(1);\n}", "label": 0}
{"index": 180721, "code": "GDataFile* AddFile(GDataDirectory* parent,\nGDataDirectoryService* directory_service,\nint sequence_id) {\nGDataFile* file = new GDataFile(NULL, directory_service);\nconst std::string title = \"file\" + base::IntToString(sequence_id);\nconst std::string resource_id = std::string(\"file_resource_id:\") +\ntitle;\nfile->set_title(title);\nfile->set_resource_id(resource_id);\nfile->set_file_md5(std::string(\"file_md5:\") + title);\nGDataFileError error = GDATA_FILE_ERROR_FAILED;\nFilePath moved_file_path;\ndirectory_service->MoveEntryToDirectory(\nparent->GetFilePath(),\nfile,\nbase::Bind(&test_util::CopyResultsFromFileMoveCallback,\n&error,\n&moved_file_path));\ntest_util::RunBlockingPoolTask();\nEXPECT_EQ(GDATA_FILE_OK, error);\nEXPECT_EQ(parent->GetFilePath().AppendASCII(title), moved_file_path);\nreturn file;\n}", "contrast": "GDataFile* AddFile(GDataDirectory* parent,\nGDataDirectoryService* directory_service,\nint sequence_id) {\nGDataFile* file = directory_service->CreateGDataFile();\nconst std::string title = \"file\" + base::IntToString(sequence_id);\nconst std::string resource_id = std::string(\"file_resource_id:\") +\ntitle;\nfile->set_title(title);\nfile->set_resource_id(resource_id);\nfile->set_file_md5(std::string(\"file_md5:\") + title);\nGDataFileError error = GDATA_FILE_ERROR_FAILED;\nFilePath moved_file_path;\ndirectory_service->MoveEntryToDirectory(\nparent->GetFilePath(),\nfile,\nbase::Bind(&test_util::CopyResultsFromFileMoveCallback,\n&error,\n&moved_file_path));\ntest_util::RunBlockingPoolTask();\nEXPECT_EQ(GDATA_FILE_OK, error);\nEXPECT_EQ(parent->GetFilePath().AppendASCII(title), moved_file_path);\nreturn file;\n}", "label": 0}
{"index": 180797, "code": "void registerURL(const char* url, const char* file, const char* mimeType)\n{\nregisterMockedURLLoad(KURL(m_baseUrl, url), WebString::fromUTF8(file), m_folder, WebString::fromUTF8(mimeType));\n}", "contrast": "void registerURL(const char* url, const char* file, const char* mimeType)", "label": 0}
{"index": 180798, "code": "void serialize(const char* url)\n{\nWebURLRequest urlRequest;\nurlRequest.initialize();\nurlRequest.setURL(KURL(m_baseUrl, url));\nm_webViewImpl->mainFrame()->loadRequest(urlRequest);\nPlatform::current()->unitTestSupport()->serveAsynchronousMockedRequests();\nrunPendingTasks();\nPlatform::current()->unitTestSupport()->serveAsynchronousMockedRequests();\nPageSerializer serializer(&m_resources,\nm_rewriteURLs.isEmpty() ? 0: &m_rewriteURLs, m_rewriteFolder);\nserializer.serialize(m_webViewImpl->mainFrameImpl()->frame()->page());\n}", "contrast": "void serialize(const char* url)\n{\nWebURLRequest urlRequest;\nurlRequest.initialize();\nurlRequest.setURL(KURL(m_baseUrl, url));\nm_webViewImpl->mainFrame()->loadRequest(urlRequest);\nPlatform::current()->unitTestSupport()->serveAsynchronousMockedRequests();\nrunPendingTasks();\nPlatform::current()->unitTestSupport()->serveAsynchronousMockedRequests();\nPageSerializer serializer(&m_resources);\nserializer.serialize(m_webViewImpl->mainFrameImpl()->frame()->page());\n}", "label": 0}
{"index": 180990, "code": "bool IsSmartVirtualKeyboardEnabled() {\nif (base::CommandLine::ForCurrentProcess()->HasSwitch(\nkeyboard::switches::kEnableVirtualKeyboard)) {\nreturn false;\n}\nreturn !base::CommandLine::ForCurrentProcess()->HasSwitch(\nkeyboard::switches::kDisableSmartVirtualKeyboard);\n}", "contrast": "bool IsSmartVirtualKeyboardEnabled() {\nif (base::CommandLine::ForCurrentProcess()->HasSwitch(\nkeyboard::switches::kEnableVirtualKeyboard)) {\nreturn false;\n}\nreturn keyboard::IsSmartDeployEnabled();\n}", "label": 0}
{"index": 181117, "code": "explicit MountState(DriveFsHost* host)\n: host_(host),\nmojo_connection_delegate_(\nhost_->delegate_->CreateMojoConnectionDelegate()),\npending_token_(base::UnguessableToken::Create()),\nbinding_(this) {\nsource_path_ = base::StrCat({kMountScheme, pending_token_.ToString()});\nstd::string datadir_option = base::StrCat(\n{\"datadir=\",\nhost_->profile_path_.Append(kDataPath)\n.Append(host_->delegate_->GetAccountId().GetAccountIdKey())\n.value()});\nchromeos::disks::DiskMountManager::GetInstance()->MountPath(\nsource_path_, \"\",\nbase::StrCat(\n{\"drivefs-\", host_->delegate_->GetAccountId().GetAccountIdKey()}),\n{datadir_option}, chromeos::MOUNT_TYPE_NETWORK_STORAGE,\nchromeos::MOUNT_ACCESS_MODE_READ_WRITE);\nauto bootstrap =\nmojo::MakeProxy(mojo_connection_delegate_->InitializeMojoConnection());\nmojom::DriveFsDelegatePtr delegate;\nbinding_.Bind(mojo::MakeRequest(&delegate));\nbootstrap->Init(\n{base::in_place, host_->delegate_->GetAccountId().GetUserEmail()},\nmojo::MakeRequest(&drivefs_), std::move(delegate));\nPendingConnectionManager::Get().ExpectOpenIpcChannel(\npending_token_,\nbase::BindOnce(&DriveFsHost::MountState::AcceptMojoConnection,\nbase::Unretained(this)));\n}", "contrast": "explicit MountState(DriveFsHost* host)\n: host_(host),\nmojo_connection_delegate_(\nhost_->delegate_->CreateMojoConnectionDelegate()),\npending_token_(base::UnguessableToken::Create()),\nbinding_(this) {\nsource_path_ = base::StrCat({kMountScheme, pending_token_.ToString()});\nstd::string datadir_option = base::StrCat(\n{\"datadir=\",\nhost_->profile_path_.Append(kDataPath)\n.Append(host_->delegate_->GetAccountId().GetAccountIdKey())\n.value()});\nauto bootstrap =\nmojo::MakeProxy(mojo_connection_delegate_->InitializeMojoConnection());\nmojom::DriveFsDelegatePtr delegate;\nbinding_.Bind(mojo::MakeRequest(&delegate));\nbootstrap->Init(\n{base::in_place, host_->delegate_->GetAccountId().GetUserEmail()},\nmojo::MakeRequest(&drivefs_), std::move(delegate));\nPendingConnectionManager::Get().ExpectOpenIpcChannel(\npending_token_,\nbase::BindOnce(&DriveFsHost::MountState::AcceptMojoConnection,\nbase::Unretained(this)));\nchromeos::disks::DiskMountManager::GetInstance()->MountPath(\nsource_path_, \"\",\nbase::StrCat(\n{\"drivefs-\", host_->delegate_->GetAccountId().GetAccountIdKey()}),\n{datadir_option}, chromeos::MOUNT_TYPE_NETWORK_STORAGE,\nchromeos::MOUNT_ACCESS_MODE_READ_WRITE);\n}", "label": 0}
{"index": 181135, "code": "void SetManualFallbacksForFilling(bool enabled) {\nif (enabled) {\nscoped_feature_list_.InitAndEnableFeature(\npassword_manager::features::kEnableManualFallbacksFilling);\n} else {\nscoped_feature_list_.InitAndDisableFeature(\npassword_manager::features::kEnableManualFallbacksFilling);\n}\n}", "contrast": "void SetManualFallbacksForFilling(bool enabled) {\nif (enabled) {\nscoped_feature_list_.InitAndEnableFeature(\npassword_manager::features::kManualFallbacksFilling);\n} else {\nscoped_feature_list_.InitAndDisableFeature(\npassword_manager::features::kManualFallbacksFilling);\n}\n}", "label": 0}
{"index": 181200, "code": "CreateSampleTransformNodeWithElementId() {\nTransformPaintPropertyNode::State state;\nstate.matrix.Rotate(90);\nstate.origin = FloatPoint3D(100, 100, 0);\nstate.direct_compositing_reasons = CompositingReason::k3DTransform;\nstate.compositor_element_id = CompositorElementId(3);\nreturn TransformPaintPropertyNode::Create(TransformPaintPropertyNode::Root(),\nstd::move(state));\n}", "contrast": "CreateSampleTransformNodeWithElementId() {\nTransformPaintPropertyNode::State state;\nstate.matrix.Rotate(90);\nstate.origin = FloatPoint3D(100, 100, 0);\nstate.direct_compositing_reasons = CompositingReason::k3DTransform;\nstate.compositor_element_id = CompositorElementId(3);\nreturn TransformPaintPropertyNode::Create(t0(), std::move(state));\n}", "label": 0}
{"index": 181336, "code": "void RunCallbacksWithDisabled(LogoCallbacks callbacks) {\nif (callbacks.on_cached_encoded_logo_available) {\nstd::move(callbacks.on_cached_encoded_logo_available)\n.Run(LogoCallbackReason::DISABLED, base::nullopt);\n}\nif (callbacks.on_cached_decoded_logo_available) {\nstd::move(callbacks.on_cached_decoded_logo_available)\n.Run(LogoCallbackReason::DISABLED, base::nullopt);\n}\nif (callbacks.on_fresh_encoded_logo_available) {\nstd::move(callbacks.on_fresh_encoded_logo_available)\n.Run(LogoCallbackReason::DISABLED, base::nullopt);\n}\nif (callbacks.on_fresh_decoded_logo_available) {\nstd::move(callbacks.on_fresh_decoded_logo_available)\n.Run(LogoCallbackReason::DISABLED, base::nullopt);\n}\n}", "contrast": "void RunCallbacksWithDisabled(LogoCallbacks callbacks) {", "label": 0}
{"index": 181625, "code": "png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)\n{\npng_infop info_ptr = *ptr_ptr;\npng_debug(1, \"in png_info_init_3\");\nif (info_ptr == NULL)\nreturn;\nif (png_sizeof(png_info) > png_info_struct_size)\n{\npng_destroy_struct(info_ptr);\ninfo_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);\n*ptr_ptr = info_ptr;\n}\npng_memset(info_ptr, 0, png_sizeof(png_info));\n}", "contrast": "png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)\n{\npng_infop info_ptr = *ptr_ptr;\npng_debug(1, \"in png_info_init_3\");\nif (info_ptr == NULL)\nreturn;\nif (png_sizeof(png_info) > png_info_struct_size)\n{\npng_destroy_struct(info_ptr);\ninfo_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);\n*ptr_ptr = info_ptr;\nif (info_ptr == NULL)\nreturn;\n}\npng_memset(info_ptr, 0, png_sizeof(png_info));\n}", "label": 0}
{"index": 181636, "code": "png_set_IHDR(png_structp png_ptr, png_infop info_ptr,\npng_uint_32 width, png_uint_32 height, int bit_depth,\nint color_type, int interlace_type, int compression_type,\nint filter_type)\n{\npng_debug1(1, \"in %s storage function\", \"IHDR\");\nif (png_ptr == NULL || info_ptr == NULL)\nreturn;\ninfo_ptr->width = width;\ninfo_ptr->height = height;\ninfo_ptr->bit_depth = (png_byte)bit_depth;\ninfo_ptr->color_type = (png_byte)color_type;\ninfo_ptr->compression_type = (png_byte)compression_type;\ninfo_ptr->filter_type = (png_byte)filter_type;\ninfo_ptr->interlace_type = (png_byte)interlace_type;\npng_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,\ninfo_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,\ninfo_ptr->compression_type, info_ptr->filter_type);\nif (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\ninfo_ptr->channels = 1;\nelse if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)\ninfo_ptr->channels = 3;\nelse\ninfo_ptr->channels = 1;\nif (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)\ninfo_ptr->channels++;\ninfo_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);\nif (width > (PNG_UINT_32_MAX\n>> 3)\n- 64\n- 1\n- 7*8\n- 8)\ninfo_ptr->rowbytes = (png_size_t)0;\nelse\ninfo_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);\n}", "contrast": "png_set_IHDR(png_structp png_ptr, png_infop info_ptr,\npng_uint_32 width, png_uint_32 height, int bit_depth,\nint color_type, int interlace_type, int compression_type,\nint filter_type)\n{\npng_debug1(1, \"in %s storage function\", \"IHDR\");\nif (png_ptr == NULL || info_ptr == NULL)\nreturn;\ninfo_ptr->width = width;\ninfo_ptr->height = height;\ninfo_ptr->bit_depth = (png_byte)bit_depth;\ninfo_ptr->color_type = (png_byte)color_type;\ninfo_ptr->compression_type = (png_byte)compression_type;\ninfo_ptr->filter_type = (png_byte)filter_type;\ninfo_ptr->interlace_type = (png_byte)interlace_type;\npng_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,\ninfo_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,\ninfo_ptr->compression_type, info_ptr->filter_type);\nif (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\ninfo_ptr->channels = 1;\nelse if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)\ninfo_ptr->channels = 3;\nelse\ninfo_ptr->channels = 1;\nif (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)\ninfo_ptr->channels++;\ninfo_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);\nif (width > (PNG_UINT_32_MAX\n>> 3)\n- 64\n- 1\n- 7*8\n- 8)\n{\ninfo_ptr->rowbytes = (png_size_t)0;\npng_error(png_ptr, \"Image width is too large for this architecture\");\n}\nelse\ninfo_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);\n}", "label": 0}
{"index": 181926, "code": "bool dstBufferSizeHasOverflow(ParsedOptions options) {\nCheckedNumeric<size_t> totalBytes = options.cropRect.width();\ntotalBytes *= options.cropRect.height();\ntotalBytes *= options.bytesPerPixel;\nif (!totalBytes.IsValid())\nreturn true;\nif (!options.shouldScaleInput)\nreturn false;\ntotalBytes = options.resizeWidth;\ntotalBytes *= options.resizeHeight;\ntotalBytes *= options.bytesPerPixel;\nif (!totalBytes.IsValid())\nreturn true;\nreturn false;\n}", "contrast": "bool dstBufferSizeHasOverflow(ParsedOptions options) {\nCheckedNumeric<unsigned> totalBytes = options.cropRect.width();\ntotalBytes *= options.cropRect.height();\ntotalBytes *= options.bytesPerPixel;\nif (!totalBytes.IsValid())\nreturn true;\nif (!options.shouldScaleInput)\nreturn false;\ntotalBytes = options.resizeWidth;\ntotalBytes *= options.resizeHeight;\ntotalBytes *= options.bytesPerPixel;\nif (!totalBytes.IsValid())\nreturn true;\nreturn false;\n}", "label": 0}
{"index": 181984, "code": "void TestGamepadMinimumDataImpl(WebXrVrBrowserTestBase* t) {\nWebXrControllerInputMock my_mock;\nunsigned int controller_index =\nmy_mock.CreateAndConnectMinimalGamepad(t->GetPrimaryAxisType());\nt->LoadUrlAndAwaitInitialization(\nt->GetFileUrlForHtmlTestFile(\"test_webxr_gamepad_support\"));\nt->EnterSessionWithUserGestureOrFail();\nmy_mock.TogglePrimaryTrigger(controller_index);\nmy_mock.SetAxes(controller_index, device::XrButtonId::kAxisPrimary, 0.5,\n-0.5);\nmy_mock.ToggleButtonTouches(controller_index,\ndevice::XrButtonId::kAxisPrimary);\nt->PollJavaScriptBooleanOrFail(\"isMappingEqualTo('xr-standard')\",\nWebXrVrBrowserTestBase::kPollTimeoutShort);\nt->PollJavaScriptBooleanOrFail(\"isButtonPressedEqualTo(0, true)\",\nWebXrVrBrowserTestBase::kPollTimeoutShort);\nt->PollJavaScriptBooleanOrFail(\"areAxesValuesEqualTo(0, 0.5, -0.5)\",\nWebXrVrBrowserTestBase::kPollTimeoutShort);\nt->RunJavaScriptOrFail(\"done()\");\nt->EndTest();\n}", "contrast": "void TestGamepadMinimumDataImpl(WebXrVrBrowserTestBase* t) {\nWebXrControllerInputMock my_mock;\nunsigned int controller_index =\nmy_mock.CreateAndConnectMinimalGamepad(t->GetPrimaryAxisType());\nt->LoadUrlAndAwaitInitialization(\nt->GetFileUrlForHtmlTestFile(\"test_webxr_gamepad_support\"));\nt->EnterSessionWithUserGestureOrFail();\nstd::string button_count = \"2\";\nif (t->GetRuntimeType() == XrBrowserTestBase::RuntimeType::RUNTIME_WMR)\nbutton_count = \"4\";\nt->PollJavaScriptBooleanOrFail(\"isButtonCountEqualTo(\" + button_count + \")\",\nWebXrVrBrowserTestBase::kPollTimeoutShort);\nmy_mock.TogglePrimaryTrigger(controller_index);\nmy_mock.SetAxes(controller_index, device::XrButtonId::kAxisPrimary, 0.5,\n-0.5);\nmy_mock.ToggleButtonTouches(controller_index,\ndevice::XrButtonId::kAxisPrimary);\nt->PollJavaScriptBooleanOrFail(\"isMappingEqualTo('xr-standard')\",\nWebXrVrBrowserTestBase::kPollTimeoutShort);\nt->PollJavaScriptBooleanOrFail(\"isButtonPressedEqualTo(0, true)\",\nWebXrVrBrowserTestBase::kPollTimeoutShort);\nt->PollJavaScriptBooleanOrFail(\"areAxesValuesEqualTo(0, 0.5, -0.5)\",\nWebXrVrBrowserTestBase::kPollTimeoutShort);\nt->RunJavaScriptOrFail(\"done()\");\nt->EndTest();\n}", "label": 0}
{"index": 182374, "code": "void Verify_StoreExistingGroup() {\nEXPECT_TRUE(delegate()->stored_group_success_);\nEXPECT_EQ(group_.get(), delegate()->stored_group_.get());\nEXPECT_EQ(cache2_.get(), group_->newest_complete_cache());\nEXPECT_TRUE(cache2_->is_complete());\nAppCacheDatabase::GroupRecord group_record;\nAppCacheDatabase::CacheRecord cache_record;\nEXPECT_TRUE(database()->FindGroup(1, &group_record));\nEXPECT_TRUE(database()->FindCache(2, &cache_record));\nEXPECT_FALSE(database()->FindCache(1, &cache_record));\nEXPECT_EQ(kDefaultEntrySize + 100, storage()->usage_map_[kOrigin]);\nEXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);\nEXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);\nEXPECT_EQ(100, mock_quota_manager_proxy_->last_delta_);\nTestFinished();\n}", "contrast": "void Verify_StoreExistingGroup() {\nEXPECT_TRUE(delegate()->stored_group_success_);\nEXPECT_EQ(group_.get(), delegate()->stored_group_.get());\nEXPECT_EQ(cache2_.get(), group_->newest_complete_cache());\nEXPECT_TRUE(cache2_->is_complete());\nAppCacheDatabase::GroupRecord group_record;\nAppCacheDatabase::CacheRecord cache_record;\nEXPECT_TRUE(database()->FindGroup(1, &group_record));\nEXPECT_TRUE(database()->FindCache(2, &cache_record));\nEXPECT_FALSE(database()->FindCache(1, &cache_record));\nEXPECT_EQ(kDefaultEntrySize + 100 + kDefaultEntryPadding + 1000,\nstorage()->usage_map_[kOrigin]);\nEXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);\nEXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);\nEXPECT_EQ(100 + 1000, mock_quota_manager_proxy_->last_delta_);\nTestFinished();\n}", "label": 0}
{"index": 182397, "code": "static bool CheckDts(const uint8_t* buffer, int buffer_size) {\nRCHECK(buffer_size > 11);\nint offset = 0;\nwhile (offset + 11 < buffer_size) {\nBitReader reader(buffer + offset, 11);\nRCHECK(ReadBits(&reader, 32) == 0x7ffe8001);\nreader.SkipBits(1 + 5);\nRCHECK(ReadBits(&reader, 1) == 0);\nRCHECK(ReadBits(&reader, 7) >= 5);\nint frame_size = ReadBits(&reader, 14);\nRCHECK(frame_size >= 95);\nreader.SkipBits(6);\nRCHECK(kSamplingFrequencyValid[ReadBits(&reader, 4)]);\nRCHECK(ReadBits(&reader, 5) <= 25);\nRCHECK(ReadBits(&reader, 1) == 0);\nreader.SkipBits(1 + 1 + 1 + 1);\nRCHECK(kExtAudioIdValid[ReadBits(&reader, 3)]);\nreader.SkipBits(1 + 1);\nRCHECK(ReadBits(&reader, 2) != 3);\noffset += frame_size + 1;\n}\nreturn true;\n}", "contrast": "static bool CheckDts(const uint8_t* buffer, int buffer_size) {\nRCHECK(buffer_size > 11);\nint offset = 0;\nwhile (offset + 11 < buffer_size) {\nBitReader reader(buffer + offset, 11);\nRCHECK(ReadBits(&reader, 32) == 0x7ffe8001);\nreader.SkipBits(1 + 5);\nRCHECK(ReadBits(&reader, 1) == 0);\nRCHECK(ReadBits(&reader, 7) >= 5);\nint frame_size = ReadBits(&reader, 14);\nRCHECK(frame_size >= 95);\nreader.SkipBits(6);\nsize_t sampling_freq_index = ReadBits(&reader, 4);\nRCHECK(sampling_freq_index < base::size(kSamplingFrequencyValid));\nRCHECK(kSamplingFrequencyValid[sampling_freq_index]);\nRCHECK(ReadBits(&reader, 5) <= 25);\nRCHECK(ReadBits(&reader, 1) == 0);\nreader.SkipBits(1 + 1 + 1 + 1);\nsize_t audio_id_index = ReadBits(&reader, 3);\nRCHECK(audio_id_index < base::size(kExtAudioIdValid));\nRCHECK(kExtAudioIdValid[audio_id_index]);\nreader.SkipBits(1 + 1);\nRCHECK(ReadBits(&reader, 2) != 3);\noffset += frame_size + 1;\n}\nreturn true;\n}", "label": 0}
{"index": 182591, "code": "static void composite_close(int sub_api, struct libusb_device_handle *dev_handle)\n{\nstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\nuint8_t i;\nbool available[SUB_API_MAX];\nbool has_hid = false;\nfor (i = 0; i<SUB_API_MAX; i++) {\navailable[i] = false;\n}\nfor (i=0; i<USB_MAXINTERFACES; i++) {\nif ( (priv->usb_interface[i].apib->id == USB_API_WINUSBX)\n&& (priv->usb_interface[i].sub_api != SUB_API_NOTSET) ) {\navailable[priv->usb_interface[i].sub_api] = true;\n} else if (priv->usb_interface[i].apib->id == USB_API_HID) {\nhas_hid = true;\n}\n}\nfor (i=0; i<SUB_API_MAX; i++) {\nif (available[i]) {\nusb_api_backend[USB_API_WINUSBX].close(i, dev_handle);\n}\n}\nif (has_hid) {\nusb_api_backend[USB_API_HID].close(sub_api, dev_handle);\n}\n}", "contrast": "static void composite_close(int sub_api, struct libusb_device_handle *dev_handle)\n{\nstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\nuint8_t i;\nbool available[SUB_API_MAX];\nfor (i = 0; i<SUB_API_MAX; i++) {\navailable[i] = false;\n}\nfor (i=0; i<USB_MAXINTERFACES; i++) {\nif ( (priv->usb_interface[i].apib->id == USB_API_WINUSBX)\n&& (priv->usb_interface[i].sub_api != SUB_API_NOTSET) ) {\navailable[priv->usb_interface[i].sub_api] = true;\n}\n}\nfor (i=0; i<SUB_API_MAX; i++) {\nif (available[i]) {\nusb_api_backend[USB_API_WINUSBX].close(i, dev_handle);\n}\n}\n}", "label": 0}
{"index": 182608, "code": "static int set_hid_interface(struct libusb_context* ctx, struct libusb_device* dev,\nchar* dev_interface_path)\n{\nint i;\nstruct windows_device_priv *priv = _device_priv(dev);\nif (priv->hid == NULL) {\nusbi_err(ctx, \"program assertion failed: parent is not HID\");\nreturn LIBUSB_ERROR_NO_DEVICE;\n}\nif (priv->hid->nb_interfaces == USB_MAXINTERFACES) {\nusbi_err(ctx, \"program assertion failed: max USB interfaces reached for HID device\");\nreturn LIBUSB_ERROR_NO_DEVICE;\n}\nfor (i=0; i<priv->hid->nb_interfaces; i++) {\nif (safe_strcmp(priv->usb_interface[i].path, dev_interface_path) == 0) {\nusbi_dbg(\"interface[%d] already set to %s\", i, dev_interface_path);\nreturn LIBUSB_SUCCESS;\n}\n}\npriv->usb_interface[priv->hid->nb_interfaces].path = dev_interface_path;\npriv->usb_interface[priv->hid->nb_interfaces].apib = &usb_api_backend[USB_API_HID];\nusbi_dbg(\"interface[%d] = %s\", priv->hid->nb_interfaces, dev_interface_path);\npriv->hid->nb_interfaces++;\nreturn LIBUSB_SUCCESS;\n}", "contrast": "static int set_hid_interface(struct libusb_context* ctx, struct libusb_device* dev,\nreturn LIBUSB_SUCCESS;\n}", "label": 0}
{"index": 182613, "code": "void OnSuggestionModelAdded(UiScene* scene,\nUiBrowserInterface* browser,\nModel* model,\nSuggestionBinding* element_binding) {\nauto icon = base::MakeUnique<VectorIcon>(100);\nicon->SetDrawPhase(kPhaseForeground);\nicon->SetType(kTypeOmniboxSuggestionIcon);\nicon->set_hit_testable(false);\nicon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);\nBindColor(model, icon.get(), &ColorScheme::omnibox_icon,\n&VectorIcon::SetColor);\nVectorIcon* p_icon = icon.get();\nauto icon_box = base::MakeUnique<UiElement>();\nicon_box->SetDrawPhase(kPhaseNone);\nicon_box->SetType(kTypeOmniboxSuggestionIconField);\nicon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);\nicon_box->AddChild(std::move(icon));\nauto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);\ncontent_text->SetDrawPhase(kPhaseForeground);\ncontent_text->SetType(kTypeOmniboxSuggestionContentText);\ncontent_text->set_hit_testable(false);\ncontent_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\ncontent_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\ncontent_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\nBindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,\n&Text::SetColor);\nText* p_content_text = content_text.get();\nauto description_text =\nbase::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);\ndescription_text->SetDrawPhase(kPhaseForeground);\ndescription_text->SetType(kTypeOmniboxSuggestionDescriptionText);\ndescription_text->set_hit_testable(false);\ncontent_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\ndescription_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\ndescription_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\nBindColor(model, description_text.get(),\n&ColorScheme::omnibox_suggestion_description, &Text::SetColor);\nText* p_description_text = description_text.get();\nauto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);\ntext_layout->SetType(kTypeOmniboxSuggestionTextLayout);\ntext_layout->set_hit_testable(false);\ntext_layout->set_margin(kSuggestionLineGapDMM);\ntext_layout->AddChild(std::move(content_text));\ntext_layout->AddChild(std::move(description_text));\nauto right_margin = base::MakeUnique<UiElement>();\nright_margin->SetDrawPhase(kPhaseNone);\nright_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);\nauto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);\nsuggestion_layout->SetType(kTypeOmniboxSuggestionLayout);\nsuggestion_layout->set_hit_testable(false);\nsuggestion_layout->AddChild(std::move(icon_box));\nsuggestion_layout->AddChild(std::move(text_layout));\nsuggestion_layout->AddChild(std::move(right_margin));\nauto background = Create<Button>(\nkNone, kPhaseForeground,\nbase::BindRepeating(\n[](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {\nb->Navigate(e->model()->destination);\nm->omnibox_input_active = false;\n},\nbase::Unretained(browser), base::Unretained(model),\nbase::Unretained(element_binding)));\nbackground->SetType(kTypeOmniboxSuggestionBackground);\nbackground->set_hit_testable(true);\nbackground->set_bubble_events(true);\nbackground->set_bounds_contain_children(true);\nbackground->set_hover_offset(0.0);\nBindButtonColors(model, background.get(),\n&ColorScheme::suggestion_button_colors,\n&Button::SetButtonColors);\nbackground->AddChild(std::move(suggestion_layout));\nelement_binding->bindings().push_back(\nVR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,\nmodel()->content, Text, p_content_text, SetText));\nelement_binding->bindings().push_back(\nbase::MakeUnique<Binding<base::string16>>(\nbase::BindRepeating(\n[](SuggestionBinding* m) { return m->model()->description; },\nbase::Unretained(element_binding)),\nbase::BindRepeating(\n[](Text* v, const base::string16& text) {\nv->SetVisibleImmediately(!text.empty());\nv->set_requires_layout(!text.empty());\nif (!text.empty()) {\nv->SetText(text);\n}\n},\nbase::Unretained(p_description_text))));\nelement_binding->bindings().push_back(\nVR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,\nmodel()->type, VectorIcon, p_icon,\nSetIcon(AutocompleteMatch::TypeToVectorIcon(value))));\nelement_binding->set_view(background.get());\nscene->AddUiElement(kOmniboxSuggestions, std::move(background));\n}", "contrast": "void OnSuggestionModelAdded(UiScene* scene,\nUiBrowserInterface* browser,\nModel* model,\nSuggestionBinding* element_binding) {\nauto icon = base::MakeUnique<VectorIcon>(100);\nicon->SetDrawPhase(kPhaseForeground);\nicon->SetType(kTypeOmniboxSuggestionIcon);\nicon->set_hit_testable(false);\nicon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);\nBindColor(model, icon.get(), &ColorScheme::omnibox_icon,\n&VectorIcon::SetColor);\nVectorIcon* p_icon = icon.get();\nauto icon_box = base::MakeUnique<UiElement>();\nicon_box->SetDrawPhase(kPhaseNone);\nicon_box->SetType(kTypeOmniboxSuggestionIconField);\nicon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);\nicon_box->AddChild(std::move(icon));\nauto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);\ncontent_text->SetDrawPhase(kPhaseForeground);\ncontent_text->SetType(kTypeOmniboxSuggestionContentText);\ncontent_text->set_hit_testable(false);\ncontent_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\ncontent_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\ncontent_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\nBindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,\n&Text::SetColor);\nText* p_content_text = content_text.get();\nauto description_text =\nbase::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);\ndescription_text->SetDrawPhase(kPhaseForeground);\ndescription_text->SetType(kTypeOmniboxSuggestionDescriptionText);\ndescription_text->set_hit_testable(false);\ndescription_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\ndescription_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\ndescription_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\nBindColor(model, description_text.get(),\n&ColorScheme::omnibox_suggestion_description, &Text::SetColor);\nText* p_description_text = description_text.get();\nauto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);\ntext_layout->SetType(kTypeOmniboxSuggestionTextLayout);\ntext_layout->set_hit_testable(false);\ntext_layout->set_margin(kSuggestionLineGapDMM);\ntext_layout->AddChild(std::move(content_text));\ntext_layout->AddChild(std::move(description_text));\nauto right_margin = base::MakeUnique<UiElement>();\nright_margin->SetDrawPhase(kPhaseNone);\nright_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);\nauto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);\nsuggestion_layout->SetType(kTypeOmniboxSuggestionLayout);\nsuggestion_layout->set_hit_testable(false);\nsuggestion_layout->AddChild(std::move(icon_box));\nsuggestion_layout->AddChild(std::move(text_layout));\nsuggestion_layout->AddChild(std::move(right_margin));\nauto background = Create<Button>(\nkNone, kPhaseForeground,\nbase::BindRepeating(\n[](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {\nb->Navigate(e->model()->destination);\nm->omnibox_input_active = false;\n},\nbase::Unretained(browser), base::Unretained(model),\nbase::Unretained(element_binding)));\nbackground->SetType(kTypeOmniboxSuggestionBackground);\nbackground->set_hit_testable(true);\nbackground->set_bubble_events(true);\nbackground->set_bounds_contain_children(true);\nbackground->set_hover_offset(0.0);\nBindButtonColors(model, background.get(),\n&ColorScheme::suggestion_button_colors,\n&Button::SetButtonColors);\nbackground->AddChild(std::move(suggestion_layout));\nelement_binding->bindings().push_back(\nVR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,\nmodel()->content, Text, p_content_text, SetText));\nelement_binding->bindings().push_back(\nbase::MakeUnique<Binding<base::string16>>(\nbase::BindRepeating(\n[](SuggestionBinding* m) { return m->model()->description; },\nbase::Unretained(element_binding)),\nbase::BindRepeating(\n[](Text* v, const base::string16& text) {\nv->SetVisibleImmediately(!text.empty());\nv->set_requires_layout(!text.empty());\nif (!text.empty()) {\nv->SetText(text);\n}\n},\nbase::Unretained(p_description_text))));\nelement_binding->bindings().push_back(\nVR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,\nmodel()->type, VectorIcon, p_icon,\nSetIcon(AutocompleteMatch::TypeToVectorIcon(value))));\nelement_binding->set_view(background.get());\nscene->AddUiElement(kOmniboxSuggestions, std::move(background));\n}", "label": 0}
{"index": 182677, "code": "exsltCryptoRc4EncryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {\nint key_len = 0, key_size = 0;\nint str_len = 0, bin_len = 0, hex_len = 0;\nxmlChar *key = NULL, *str = NULL, *padkey = NULL;\nxmlChar *bin = NULL, *hex = NULL;\nxsltTransformContextPtr tctxt = NULL;\nif (nargs != 2) {\nxmlXPathSetArityError (ctxt);\nreturn;\n}\ntctxt = xsltXPathGetTransformContext(ctxt);\nstr = xmlXPathPopString (ctxt);\nstr_len = xmlUTF8Strlen (str);\nif (str_len == 0) {\nxmlXPathReturnEmptyString (ctxt);\nxmlFree (str);\nreturn;\n}\nkey = xmlXPathPopString (ctxt);\nkey_len = xmlUTF8Strlen (key);\nif (key_len == 0) {\nxmlXPathReturnEmptyString (ctxt);\nxmlFree (key);\nxmlFree (str);\nreturn;\n}\npadkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);\nif (padkey == NULL) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: Failed to allocate padkey\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nmemset(padkey, 0, RC4_KEY_LENGTH + 1);\nkey_size = xmlUTF8Strsize (key, key_len);\nif ((key_size > RC4_KEY_LENGTH) || (key_size < 0)) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: key size too long or key broken\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nmemcpy (padkey, key, key_size);\nbin_len = str_len;\nbin = xmlStrdup (str);\nif (bin == NULL) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: Failed to allocate string\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nPLATFORM_RC4_ENCRYPT (ctxt, padkey, str, str_len, bin, bin_len);\nhex_len = str_len * 2 + 1;\nhex = xmlMallocAtomic (hex_len);\nif (hex == NULL) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: Failed to allocate result\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nexsltCryptoBin2Hex (bin, str_len, hex, hex_len);\nxmlXPathReturnString (ctxt, hex);\ndone:\nif (key != NULL)\nxmlFree (key);\nif (str != NULL)\nxmlFree (str);\nif (padkey != NULL)\nxmlFree (padkey);\nif (bin != NULL)\nxmlFree (bin);\n}", "contrast": "exsltCryptoRc4EncryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {\nint key_len = 0;\nint str_len = 0, bin_len = 0, hex_len = 0;\nxmlChar *key = NULL, *str = NULL, *padkey = NULL;\nxmlChar *bin = NULL, *hex = NULL;\nxsltTransformContextPtr tctxt = NULL;\nif (nargs != 2) {\nxmlXPathSetArityError (ctxt);\nreturn;\n}\ntctxt = xsltXPathGetTransformContext(ctxt);\nstr = xmlXPathPopString (ctxt);\nstr_len = xmlStrlen (str);\nif (str_len == 0) {\nxmlXPathReturnEmptyString (ctxt);\nxmlFree (str);\nreturn;\n}\nkey = xmlXPathPopString (ctxt);\nkey_len = xmlStrlen (key);\nif (key_len == 0) {\nxmlXPathReturnEmptyString (ctxt);\nxmlFree (key);\nxmlFree (str);\nreturn;\n}\npadkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);\nif (padkey == NULL) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: Failed to allocate padkey\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nmemset(padkey, 0, RC4_KEY_LENGTH + 1);\nif ((key_len > RC4_KEY_LENGTH) || (key_len < 0)) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: key size too long or key broken\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nmemcpy (padkey, key, key_len);\nbin_len = str_len;\nbin = xmlStrdup (str);\nif (bin == NULL) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: Failed to allocate string\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nPLATFORM_RC4_ENCRYPT (ctxt, padkey, str, str_len, bin, bin_len);\nhex_len = str_len * 2 + 1;\nhex = xmlMallocAtomic (hex_len);\nif (hex == NULL) {\nxsltTransformError(tctxt, NULL, tctxt->inst,\n\"exsltCryptoRc4EncryptFunction: Failed to allocate result\\n\");\ntctxt->state = XSLT_STATE_STOPPED;\nxmlXPathReturnEmptyString (ctxt);\ngoto done;\n}\nexsltCryptoBin2Hex (bin, str_len, hex, hex_len);\nxmlXPathReturnString (ctxt, hex);\ndone:\nif (key != NULL)\nxmlFree (key);\nif (str != NULL)\nxmlFree (str);\nif (padkey != NULL)\nxmlFree (padkey);\nif (bin != NULL)\nxmlFree (bin);\n}", "label": 0}
{"index": 182680, "code": "exsltDateCreateDate (exsltDateType type)\n{\nexsltDateValPtr ret;\nret = (exsltDateValPtr) xmlMalloc(sizeof(exsltDateVal));\nif (ret == NULL) {\nxsltGenericError(xsltGenericErrorContext,\n\"exsltDateCreateDate: out of memory\\n\");\nreturn (NULL);\n}\nmemset (ret, 0, sizeof(exsltDateVal));\nif (type != EXSLT_UNKNOWN)\nret->type = type;\nreturn ret;\n}", "contrast": "exsltDateCreateDate (exsltDateType type)\n{\nexsltDateValPtr ret;\nret = (exsltDateValPtr) xmlMalloc(sizeof(exsltDateVal));\nif (ret == NULL) {\nxsltGenericError(xsltGenericErrorContext,\n\"exsltDateCreateDate: out of memory\\n\");\nreturn (NULL);\n}\nmemset (ret, 0, sizeof(exsltDateVal));\nif (type != XS_DURATION) {\nret->value.date.mon = 1;\nret->value.date.day = 1;\n}\nif (type != EXSLT_UNKNOWN)\nret->type = type;\nreturn ret;\n}", "label": 0}
{"index": 182710, "code": "xsltDocumentElem(xsltTransformContextPtr ctxt, xmlNodePtr node,\nxmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\nxsltStyleItemDocumentPtr comp = (xsltStyleItemDocumentPtr) castedComp;\n#else\nxsltStylePreCompPtr comp = castedComp;\n#endif\nxsltStylesheetPtr style = NULL;\nint ret;\nxmlChar *filename = NULL, *prop, *elements;\nxmlChar *element, *end;\nxmlDocPtr res = NULL;\nxmlDocPtr oldOutput;\nxmlNodePtr oldInsert, root;\nconst char *oldOutputFile;\nxsltOutputType oldType;\nxmlChar *URL = NULL;\nconst xmlChar *method;\nconst xmlChar *doctypePublic;\nconst xmlChar *doctypeSystem;\nconst xmlChar *version;\nconst xmlChar *encoding;\nint redirect_write_append = 0;\nif ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\nreturn;\nif (comp->filename == NULL) {\nif (xmlStrEqual(inst->name, (const xmlChar *) \"output\")) {\n#ifdef WITH_XSLT_DEBUG_EXTRA\nxsltGenericDebug(xsltGenericDebugContext,\n\"Found saxon:output extension\\n\");\n#endif\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"file\",\nXSLT_SAXON_NAMESPACE);\nif (URL == NULL)\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"href\",\nXSLT_SAXON_NAMESPACE);\n} else if (xmlStrEqual(inst->name, (const xmlChar *) \"write\")) {\n#ifdef WITH_XSLT_DEBUG_EXTRA\nxsltGenericDebug(xsltGenericDebugContext,\n\"Found xalan:write extension\\n\");\n#endif\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"select\",\nXSLT_XALAN_NAMESPACE);\nif (URL != NULL) {\nxmlXPathCompExprPtr cmp;\nxmlChar *val;\ncmp = xmlXPathCompile(URL);\nval = xsltEvalXPathString(ctxt, cmp);\nxmlXPathFreeCompExpr(cmp);\nxmlFree(URL);\nURL = val;\n}\nif (URL == NULL)\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"file\",\nXSLT_XALAN_NAMESPACE);\nif (URL == NULL)\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"href\",\nXSLT_XALAN_NAMESPACE);\n} else if (xmlStrEqual(inst->name, (const xmlChar *) \"document\")) {\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"href\",\nNULL);\n}\n} else {\nURL = xmlStrdup(comp->filename);\n}\nif (URL == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: href/URI-Reference not found\\n\");\nreturn;\n}\nfilename = xmlBuildURI(URL, (const xmlChar *) ctxt->outputFile);\nif (filename == NULL) {\nxmlChar *escURL;\nescURL=xmlURIEscapeStr(URL, BAD_CAST \":/.?,\");\nif (escURL != NULL) {\nfilename = xmlBuildURI(escURL, (const xmlChar *) ctxt->outputFile);\nxmlFree(escURL);\n}\n}\nif (filename == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: URL computation failed for %s\\n\",\nURL);\nxmlFree(URL);\nreturn;\n}\nif (ctxt->sec != NULL) {\nret = xsltCheckWrite(ctxt->sec, ctxt, filename);\nif (ret == 0) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: write rights for %s denied\\n\",\nfilename);\nxmlFree(URL);\nxmlFree(filename);\nreturn;\n}\n}\noldOutputFile = ctxt->outputFile;\noldOutput = ctxt->output;\noldInsert = ctxt->insert;\noldType = ctxt->type;\nctxt->outputFile = (const char *) filename;\nstyle = xsltNewStylesheet();\nif (style == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: out of memory\\n\");\ngoto error;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"version\",\nNULL);\nif (prop != NULL) {\nif (style->version != NULL)\nxmlFree(style->version);\nstyle->version = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"encoding\",\nNULL);\nif (prop != NULL) {\nif (style->encoding != NULL)\nxmlFree(style->encoding);\nstyle->encoding = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"method\",\nNULL);\nif (prop != NULL) {\nconst xmlChar *URI;\nif (style->method != NULL)\nxmlFree(style->method);\nstyle->method = NULL;\nif (style->methodURI != NULL)\nxmlFree(style->methodURI);\nstyle->methodURI = NULL;\nURI = xsltGetQNameURI(inst, &prop);\nif (prop == NULL) {\nif (style != NULL) style->errors++;\n} else if (URI == NULL) {\nif ((xmlStrEqual(prop, (const xmlChar *) \"xml\")) ||\n(xmlStrEqual(prop, (const xmlChar *) \"html\")) ||\n(xmlStrEqual(prop, (const xmlChar *) \"text\"))) {\nstyle->method = prop;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for method: %s\\n\", prop);\nif (style != NULL) style->warnings++;\n}\n} else {\nstyle->method = prop;\nstyle->methodURI = xmlStrdup(URI);\n}\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"doctype-system\", NULL);\nif (prop != NULL) {\nif (style->doctypeSystem != NULL)\nxmlFree(style->doctypeSystem);\nstyle->doctypeSystem = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"doctype-public\", NULL);\nif (prop != NULL) {\nif (style->doctypePublic != NULL)\nxmlFree(style->doctypePublic);\nstyle->doctypePublic = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"standalone\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->standalone = 1;\n} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\nstyle->standalone = 0;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for standalone: %s\\n\",\nprop);\nif (style != NULL) style->warnings++;\n}\nxmlFree(prop);\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"indent\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->indent = 1;\n} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\nstyle->indent = 0;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for indent: %s\\n\", prop);\nif (style != NULL) style->warnings++;\n}\nxmlFree(prop);\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"omit-xml-declaration\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->omitXmlDeclaration = 1;\n} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\nstyle->omitXmlDeclaration = 0;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for omit-xml-declaration: %s\\n\",\nprop);\nif (style != NULL) style->warnings++;\n}\nxmlFree(prop);\n}\nelements = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"cdata-section-elements\",\nNULL);\nif (elements != NULL) {\nif (style->stripSpaces == NULL)\nstyle->stripSpaces = xmlHashCreate(10);\nif (style->stripSpaces == NULL)\nreturn;\nelement = elements;\nwhile (*element != 0) {\nwhile (IS_BLANK_CH(*element))\nelement++;\nif (*element == 0)\nbreak;\nend = element;\nwhile ((*end != 0) && (!IS_BLANK_CH(*end)))\nend++;\nelement = xmlStrndup(element, end - element);\nif (element) {\nconst xmlChar *URI;\n#ifdef WITH_XSLT_DEBUG_PARSING\nxsltGenericDebug(xsltGenericDebugContext,\n\"add cdata section output element %s\\n\",\nelement);\n#endif\nURI = xsltGetQNameURI(inst, &element);\nxmlHashAddEntry2(style->stripSpaces, element, URI,\n(xmlChar *) \"cdata\");\nxmlFree(element);\n}\nelement = end;\n}\nxmlFree(elements);\n}\nXSLT_GET_IMPORT_PTR(method, style, method)\nXSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\nXSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\nXSLT_GET_IMPORT_PTR(version, style, version)\nXSLT_GET_IMPORT_PTR(encoding, style, encoding)\nif ((method != NULL) &&\n(!xmlStrEqual(method, (const xmlChar *) \"xml\"))) {\nif (xmlStrEqual(method, (const xmlChar *) \"html\")) {\nctxt->type = XSLT_OUTPUT_HTML;\nif (((doctypePublic != NULL) || (doctypeSystem != NULL)))\nres = htmlNewDoc(doctypeSystem, doctypePublic);\nelse {\nif (version != NULL) {\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\nxsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n#endif\n}\nres = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n}\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n} else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: unsupported method xhtml\\n\",\nstyle->method);\nctxt->type = XSLT_OUTPUT_HTML;\nres = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n} else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\nctxt->type = XSLT_OUTPUT_TEXT;\nres = xmlNewDoc(style->version);\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\nxsltGenericDebug(xsltGenericDebugContext,\n\"reusing transformation dict for output\\n\");\n#endif\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: unsupported method %s\\n\",\nstyle->method);\ngoto error;\n}\n} else {\nctxt->type = XSLT_OUTPUT_XML;\nres = xmlNewDoc(style->version);\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\nxsltGenericDebug(xsltGenericDebugContext,\n\"reusing transformation dict for output\\n\");\n#endif\n}\nres->charset = XML_CHAR_ENCODING_UTF8;\nif (encoding != NULL)\nres->encoding = xmlStrdup(encoding);\nctxt->output = res;\nctxt->insert = (xmlNodePtr) res;\nxsltApplySequenceConstructor(ctxt, node, inst->children, NULL);\nroot = xmlDocGetRootElement(res);\nif (root != NULL) {\nconst xmlChar *doctype = NULL;\nif ((root->ns != NULL) && (root->ns->prefix != NULL))\ndoctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\nif (doctype == NULL)\ndoctype = root->name;\nif ((method == NULL) &&\n(root->ns == NULL) &&\n(!xmlStrcasecmp(root->name, (const xmlChar *) \"html\"))) {\nxmlNodePtr tmp;\ntmp = res->children;\nwhile ((tmp != NULL) && (tmp != root)) {\nif (tmp->type == XML_ELEMENT_NODE)\nbreak;\nif ((tmp->type == XML_TEXT_NODE) && (!xmlIsBlankNode(tmp)))\nbreak;\ntmp = tmp->next;\n}\nif (tmp == root) {\nctxt->type = XSLT_OUTPUT_HTML;\nres->type = XML_HTML_DOCUMENT_NODE;\nif (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\nres->intSubset = xmlCreateIntSubset(res, doctype,\ndoctypePublic,\ndoctypeSystem);\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n} else if (version != NULL) {\nxsltGetHTMLIDs(version, &doctypePublic,\n&doctypeSystem);\nif (((doctypePublic != NULL) || (doctypeSystem != NULL)))\nres->intSubset =\nxmlCreateIntSubset(res, doctype,\ndoctypePublic,\ndoctypeSystem);\n#endif\n}\n}\n}\nif (ctxt->type == XSLT_OUTPUT_XML) {\nXSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\nXSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\nif (((doctypePublic != NULL) || (doctypeSystem != NULL)))\nres->intSubset = xmlCreateIntSubset(res, doctype,\ndoctypePublic,\ndoctypeSystem);\n}\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst, (const xmlChar *)\"append\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"true\") ||\nxmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->omitXmlDeclaration = 1;\nredirect_write_append = 1;\n} else\nstyle->omitXmlDeclaration = 0;\nxmlFree(prop);\n}\nif (redirect_write_append) {\nFILE *f;\nf = fopen((const char *) filename, \"ab\");\nif (f == NULL) {\nret = -1;\n} else {\nret = xsltSaveResultToFile(f, res, style);\nfclose(f);\n}\n} else {\nret = xsltSaveResultToFilename((const char *) filename, res, style, 0);\n}\nif (ret < 0) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: unable to save to %s\\n\",\nfilename);\nctxt->state = XSLT_STATE_ERROR;\n#ifdef WITH_XSLT_DEBUG_EXTRA\n} else {\nxsltGenericDebug(xsltGenericDebugContext,\n\"Wrote %d bytes to %s\\n\", ret, filename);\n#endif\n}\nerror:\nctxt->output = oldOutput;\nctxt->insert = oldInsert;\nctxt->type = oldType;\nctxt->outputFile = oldOutputFile;\nif (URL != NULL)\nxmlFree(URL);\nif (filename != NULL)\nxmlFree(filename);\nif (style != NULL)\nxsltFreeStylesheet(style);\nif (res != NULL)\nxmlFreeDoc(res);\n}", "contrast": "xsltDocumentElem(xsltTransformContextPtr ctxt, xmlNodePtr node,\nxmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\nxsltStyleItemDocumentPtr comp = (xsltStyleItemDocumentPtr) castedComp;\n#else\nxsltStylePreCompPtr comp = castedComp;\n#endif\nxsltStylesheetPtr style = NULL;\nint ret;\nxmlChar *filename = NULL, *prop, *elements;\nxmlChar *element, *end;\nxmlDocPtr res = NULL;\nxmlDocPtr oldOutput;\nxmlNodePtr oldInsert, root;\nconst char *oldOutputFile;\nxsltOutputType oldType;\nxmlChar *URL = NULL;\nconst xmlChar *method;\nconst xmlChar *doctypePublic;\nconst xmlChar *doctypeSystem;\nconst xmlChar *version;\nconst xmlChar *encoding;\nint redirect_write_append = 0;\nif ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\nreturn;\nif (comp->filename == NULL) {\nif (xmlStrEqual(inst->name, (const xmlChar *) \"output\")) {\n#ifdef WITH_XSLT_DEBUG_EXTRA\nxsltGenericDebug(xsltGenericDebugContext,\n\"Found saxon:output extension\\n\");\n#endif\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"file\",\nXSLT_SAXON_NAMESPACE);\nif (URL == NULL)\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"href\",\nXSLT_SAXON_NAMESPACE);\n} else if (xmlStrEqual(inst->name, (const xmlChar *) \"write\")) {\n#ifdef WITH_XSLT_DEBUG_EXTRA\nxsltGenericDebug(xsltGenericDebugContext,\n\"Found xalan:write extension\\n\");\n#endif\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"select\",\nXSLT_XALAN_NAMESPACE);\nif (URL != NULL) {\nxmlXPathCompExprPtr cmp;\nxmlChar *val;\ncmp = xmlXPathCompile(URL);\nval = xsltEvalXPathString(ctxt, cmp);\nxmlXPathFreeCompExpr(cmp);\nxmlFree(URL);\nURL = val;\n}\nif (URL == NULL)\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"file\",\nXSLT_XALAN_NAMESPACE);\nif (URL == NULL)\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"href\",\nXSLT_XALAN_NAMESPACE);\n} else if (xmlStrEqual(inst->name, (const xmlChar *) \"document\")) {\nURL = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"href\",\nNULL);\n}\n} else {\nURL = xmlStrdup(comp->filename);\n}\nif (URL == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: href/URI-Reference not found\\n\");\nreturn;\n}\nfilename = xmlBuildURI(URL, (const xmlChar *) ctxt->outputFile);\nif (filename == NULL) {\nxmlChar *escURL;\nescURL=xmlURIEscapeStr(URL, BAD_CAST \":/.?,\");\nif (escURL != NULL) {\nfilename = xmlBuildURI(escURL, (const xmlChar *) ctxt->outputFile);\nxmlFree(escURL);\n}\n}\nif (filename == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: URL computation failed for %s\\n\",\nURL);\nxmlFree(URL);\nreturn;\n}\nif (ctxt->sec != NULL) {\nret = xsltCheckWrite(ctxt->sec, ctxt, filename);\nif (ret == 0) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: write rights for %s denied\\n\",\nfilename);\nxmlFree(URL);\nxmlFree(filename);\nreturn;\n}\n}\noldOutputFile = ctxt->outputFile;\noldOutput = ctxt->output;\noldInsert = ctxt->insert;\noldType = ctxt->type;\nctxt->outputFile = (const char *) filename;\nstyle = xsltNewStylesheet();\nif (style == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: out of memory\\n\");\ngoto error;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"version\",\nNULL);\nif (prop != NULL) {\nif (style->version != NULL)\nxmlFree(style->version);\nstyle->version = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"encoding\",\nNULL);\nif (prop != NULL) {\nif (style->encoding != NULL)\nxmlFree(style->encoding);\nstyle->encoding = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"method\",\nNULL);\nif (prop != NULL) {\nconst xmlChar *URI;\nif (style->method != NULL)\nxmlFree(style->method);\nstyle->method = NULL;\nif (style->methodURI != NULL)\nxmlFree(style->methodURI);\nstyle->methodURI = NULL;\nURI = xsltGetQNameURI(inst, &prop);\nif (prop == NULL) {\nif (style != NULL) style->errors++;\n} else if (URI == NULL) {\nif ((xmlStrEqual(prop, (const xmlChar *) \"xml\")) ||\n(xmlStrEqual(prop, (const xmlChar *) \"html\")) ||\n(xmlStrEqual(prop, (const xmlChar *) \"text\"))) {\nstyle->method = prop;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for method: %s\\n\", prop);\nif (style != NULL) style->warnings++;\n}\n} else {\nstyle->method = prop;\nstyle->methodURI = xmlStrdup(URI);\n}\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"doctype-system\", NULL);\nif (prop != NULL) {\nif (style->doctypeSystem != NULL)\nxmlFree(style->doctypeSystem);\nstyle->doctypeSystem = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"doctype-public\", NULL);\nif (prop != NULL) {\nif (style->doctypePublic != NULL)\nxmlFree(style->doctypePublic);\nstyle->doctypePublic = prop;\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"standalone\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->standalone = 1;\n} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\nstyle->standalone = 0;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for standalone: %s\\n\",\nprop);\nif (style != NULL) style->warnings++;\n}\nxmlFree(prop);\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *) \"indent\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->indent = 1;\n} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\nstyle->indent = 0;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for indent: %s\\n\", prop);\nif (style != NULL) style->warnings++;\n}\nxmlFree(prop);\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"omit-xml-declaration\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->omitXmlDeclaration = 1;\n} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\nstyle->omitXmlDeclaration = 0;\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"invalid value for omit-xml-declaration: %s\\n\",\nprop);\nif (style != NULL) style->warnings++;\n}\nxmlFree(prop);\n}\nelements = xsltEvalAttrValueTemplate(ctxt, inst,\n(const xmlChar *)\n\"cdata-section-elements\",\nNULL);\nif (elements != NULL) {\nif (style->stripSpaces == NULL)\nstyle->stripSpaces = xmlHashCreate(10);\nif (style->stripSpaces == NULL)\nreturn;\nelement = elements;\nwhile (*element != 0) {\nwhile (IS_BLANK_CH(*element))\nelement++;\nif (*element == 0)\nbreak;\nend = element;\nwhile ((*end != 0) && (!IS_BLANK_CH(*end)))\nend++;\nelement = xmlStrndup(element, end - element);\nif (element) {\nconst xmlChar *URI;\n#ifdef WITH_XSLT_DEBUG_PARSING\nxsltGenericDebug(xsltGenericDebugContext,\n\"add cdata section output element %s\\n\",\nelement);\n#endif\nURI = xsltGetQNameURI(inst, &element);\nxmlHashAddEntry2(style->stripSpaces, element, URI,\n(xmlChar *) \"cdata\");\nxmlFree(element);\n}\nelement = end;\n}\nxmlFree(elements);\n}\nXSLT_GET_IMPORT_PTR(method, style, method)\nXSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\nXSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\nXSLT_GET_IMPORT_PTR(version, style, version)\nXSLT_GET_IMPORT_PTR(encoding, style, encoding)\nif ((method != NULL) &&\n(!xmlStrEqual(method, (const xmlChar *) \"xml\"))) {\nif (xmlStrEqual(method, (const xmlChar *) \"html\")) {\nctxt->type = XSLT_OUTPUT_HTML;\nif (((doctypePublic != NULL) || (doctypeSystem != NULL)))\nres = htmlNewDoc(doctypeSystem, doctypePublic);\nelse {\nif (version != NULL) {\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\nxsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n#endif\n}\nres = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n}\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n} else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: unsupported method xhtml\\n\");\nctxt->type = XSLT_OUTPUT_HTML;\nres = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n} else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\nctxt->type = XSLT_OUTPUT_TEXT;\nres = xmlNewDoc(style->version);\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\nxsltGenericDebug(xsltGenericDebugContext,\n\"reusing transformation dict for output\\n\");\n#endif\n} else {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: unsupported method (%s)\\n\",\nmethod);\ngoto error;\n}\n} else {\nctxt->type = XSLT_OUTPUT_XML;\nres = xmlNewDoc(style->version);\nif (res == NULL)\ngoto error;\nres->dict = ctxt->dict;\nxmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\nxsltGenericDebug(xsltGenericDebugContext,\n\"reusing transformation dict for output\\n\");\n#endif\n}\nres->charset = XML_CHAR_ENCODING_UTF8;\nif (encoding != NULL)\nres->encoding = xmlStrdup(encoding);\nctxt->output = res;\nctxt->insert = (xmlNodePtr) res;\nxsltApplySequenceConstructor(ctxt, node, inst->children, NULL);\nroot = xmlDocGetRootElement(res);\nif (root != NULL) {\nconst xmlChar *doctype = NULL;\nif ((root->ns != NULL) && (root->ns->prefix != NULL))\ndoctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\nif (doctype == NULL)\ndoctype = root->name;\nif ((method == NULL) &&\n(root->ns == NULL) &&\n(!xmlStrcasecmp(root->name, (const xmlChar *) \"html\"))) {\nxmlNodePtr tmp;\ntmp = res->children;\nwhile ((tmp != NULL) && (tmp != root)) {\nif (tmp->type == XML_ELEMENT_NODE)\nbreak;\nif ((tmp->type == XML_TEXT_NODE) && (!xmlIsBlankNode(tmp)))\nbreak;\ntmp = tmp->next;\n}\nif (tmp == root) {\nctxt->type = XSLT_OUTPUT_HTML;\nres->type = XML_HTML_DOCUMENT_NODE;\nif (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\nres->intSubset = xmlCreateIntSubset(res, doctype,\ndoctypePublic,\ndoctypeSystem);\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n} else if (version != NULL) {\nxsltGetHTMLIDs(version, &doctypePublic,\n&doctypeSystem);\nif (((doctypePublic != NULL) || (doctypeSystem != NULL)))\nres->intSubset =\nxmlCreateIntSubset(res, doctype,\ndoctypePublic,\ndoctypeSystem);\n#endif\n}\n}\n}\nif (ctxt->type == XSLT_OUTPUT_XML) {\nXSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\nXSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\nif (((doctypePublic != NULL) || (doctypeSystem != NULL)))\nres->intSubset = xmlCreateIntSubset(res, doctype,\ndoctypePublic,\ndoctypeSystem);\n}\n}\nprop = xsltEvalAttrValueTemplate(ctxt, inst, (const xmlChar *)\"append\",\nNULL);\nif (prop != NULL) {\nif (xmlStrEqual(prop, (const xmlChar *) \"true\") ||\nxmlStrEqual(prop, (const xmlChar *) \"yes\")) {\nstyle->omitXmlDeclaration = 1;\nredirect_write_append = 1;\n} else\nstyle->omitXmlDeclaration = 0;\nxmlFree(prop);\n}\nif (redirect_write_append) {\nFILE *f;\nf = fopen((const char *) filename, \"ab\");\nif (f == NULL) {\nret = -1;\n} else {\nret = xsltSaveResultToFile(f, res, style);\nfclose(f);\n}\n} else {\nret = xsltSaveResultToFilename((const char *) filename, res, style, 0);\n}\nif (ret < 0) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsltDocumentElem: unable to save to %s\\n\",\nfilename);\nctxt->state = XSLT_STATE_ERROR;\n#ifdef WITH_XSLT_DEBUG_EXTRA\n} else {\nxsltGenericDebug(xsltGenericDebugContext,\n\"Wrote %d bytes to %s\\n\", ret, filename);\n#endif\n}\nerror:\nctxt->output = oldOutput;\nctxt->insert = oldInsert;\nctxt->type = oldType;\nctxt->outputFile = oldOutputFile;\nif (URL != NULL)\nxmlFree(URL);\nif (filename != NULL)\nxmlFree(filename);\nif (style != NULL)\nxsltFreeStylesheet(style);\nif (res != NULL)\nxmlFreeDoc(res);\n}", "label": 0}
{"index": 182714, "code": "xsltNumber(xsltTransformContextPtr ctxt, xmlNodePtr node,\nxmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\nxsltStyleItemNumberPtr comp = (xsltStyleItemNumberPtr) castedComp;\n#else\nxsltStylePreCompPtr comp = castedComp;\n#endif\nif (comp == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsl:number : compilation failed\\n\");\nreturn;\n}\nif ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\nreturn;\ncomp->numdata.doc = inst->doc;\ncomp->numdata.node = inst;\nxsltNumberFormat(ctxt, &comp->numdata, node);\n}", "contrast": "xsltNumber(xsltTransformContextPtr ctxt, xmlNodePtr node,\nxmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\nxsltStyleItemNumberPtr comp = (xsltStyleItemNumberPtr) castedComp;\n#else\nxsltStylePreCompPtr comp = castedComp;\n#endif\nxmlXPathContextPtr xpctxt;\nxmlNsPtr *oldXPNamespaces;\nint oldXPNsNr;\nif (comp == NULL) {\nxsltTransformError(ctxt, NULL, inst,\n\"xsl:number : compilation failed\\n\");\nreturn;\n}\nif ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\nreturn;\ncomp->numdata.doc = inst->doc;\ncomp->numdata.node = inst;\nxpctxt = ctxt->xpathCtxt;\noldXPNsNr = xpctxt->nsNr;\noldXPNamespaces = xpctxt->namespaces;\n#ifdef XSLT_REFACTORED\nif (comp->inScopeNs != NULL) {\nxpctxt->namespaces = comp->inScopeNs->list;\nxpctxt->nsNr = comp->inScopeNs->xpathNumber;\n} else {\nxpctxt->namespaces = NULL;\nxpctxt->nsNr = 0;\n}\n#else\nxpctxt->namespaces = comp->nsList;\nxpctxt->nsNr = comp->nsNr;\n#endif\nxsltNumberFormat(ctxt, &comp->numdata, node);\nxpctxt->nsNr = oldXPNsNr;\nxpctxt->namespaces = oldXPNamespaces;\n}", "label": 0}
{"index": 182725, "code": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\nif (parcel == NULL) {\nreturn NULL;\n}\nandroid::Parcel* p = android::parcelForJavaObject(env, parcel);\nSkRegion* region = new SkRegion;\nsize_t size = p->readInt32();\nregion->readFromMemory(p->readInplace(size), size);\nreturn reinterpret_cast<jlong>(region);\n}", "contrast": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\nif (parcel == NULL) {\nreturn NULL;\n}\nandroid::Parcel* p = android::parcelForJavaObject(env, parcel);\nconst size_t size = p->readInt32();\nconst void* regionData = p->readInplace(size);\nif (regionData == NULL) {\nreturn NULL;\n}\nSkRegion* region = new SkRegion;\nregion->readFromMemory(regionData, size);\nreturn reinterpret_cast<jlong>(region);\n}", "label": 0}
{"index": 182733, "code": "int Reverb_command(effect_handle_t  self,\nuint32_t            cmdCode,\nuint32_t            cmdSize,\nvoid *pCmdData,\nuint32_t *replySize,\nvoid *pReplyData){\nandroid::ReverbContext * pContext = (android::ReverbContext *) self;\nint retsize;\nLVREV_ControlParams_st    ActiveParams;\nLVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS;\nif (pContext == NULL){\nALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\nreturn -EINVAL;\n}\nswitch (cmdCode){\ncase EFFECT_CMD_INIT:\nif (pReplyData == NULL || *replySize != sizeof(int)){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_INIT: ERROR\");\nreturn -EINVAL;\n}\n*(int *) pReplyData = 0;\nbreak;\ncase EFFECT_CMD_SET_CONFIG:\nif (pCmdData == NULL ||\ncmdSize != sizeof(effect_config_t) ||\npReplyData == NULL ||\n*replySize != sizeof(int)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_CONFIG: ERROR\");\nreturn -EINVAL;\n}\n*(int *) pReplyData = android::Reverb_setConfig(pContext,\n(effect_config_t *) pCmdData);\nbreak;\ncase EFFECT_CMD_GET_CONFIG:\nif (pReplyData == NULL ||\n*replySize != sizeof(effect_config_t)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_GET_CONFIG: ERROR\");\nreturn -EINVAL;\n}\nandroid::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\nbreak;\ncase EFFECT_CMD_RESET:\nReverb_setConfig(pContext, &pContext->config);\nbreak;\ncase EFFECT_CMD_GET_PARAM:{\nif (pCmdData == NULL ||\ncmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\npReplyData == NULL ||\n*replySize < (sizeof(effect_param_t) + sizeof(int32_t))){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_GET_PARAM: ERROR\");\nreturn -EINVAL;\n}\neffect_param_t *p = (effect_param_t *)pCmdData;\nmemcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\np = (effect_param_t *)pReplyData;\nint voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\np->status = android::Reverb_getParameter(pContext,\n(void *)p->data,\n&p->vsize,\np->data + voffset);\n*replySize = sizeof(effect_param_t) + voffset + p->vsize;\n} break;\ncase EFFECT_CMD_SET_PARAM:{\nif (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)))\n|| pReplyData == NULL || *replySize != sizeof(int32_t)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_PARAM: ERROR\");\nreturn -EINVAL;\n}\neffect_param_t *p = (effect_param_t *) pCmdData;\nif (p->psize != sizeof(int32_t)){\nALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\nreturn -EINVAL;\n}\n*(int *)pReplyData = android::Reverb_setParameter(pContext,\n(void *)p->data,\np->data + p->psize);\n} break;\ncase EFFECT_CMD_ENABLE:\nif (pReplyData == NULL || *replySize != sizeof(int)){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_ENABLE: ERROR\");\nreturn -EINVAL;\n}\nif(pContext->bEnabled == LVM_TRUE){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\nreturn -EINVAL;\n}\n*(int *)pReplyData = 0;\npContext->bEnabled = LVM_TRUE;\nLvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\nLVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\npContext->SamplesToExitCount =\n(ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\npContext->volumeMode = android::REVERB_VOLUME_FLAT;\nbreak;\ncase EFFECT_CMD_DISABLE:\nif (pReplyData == NULL || *replySize != sizeof(int)){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_DISABLE: ERROR\");\nreturn -EINVAL;\n}\nif(pContext->bEnabled == LVM_FALSE){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\nreturn -EINVAL;\n}\n*(int *)pReplyData = 0;\npContext->bEnabled = LVM_FALSE;\nbreak;\ncase EFFECT_CMD_SET_VOLUME:\nif (pCmdData == NULL ||\ncmdSize != 2 * sizeof(uint32_t)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_VOLUME: ERROR\");\nreturn -EINVAL;\n}\nif (pReplyData != NULL) {\npContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\npContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n*(uint32_t *)pReplyData = (1 << 24);\n*((uint32_t *)pReplyData + 1) = (1 << 24);\nif (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\npContext->volumeMode = android::REVERB_VOLUME_FLAT;\n}\n} else {\npContext->leftVolume = REVERB_UNIT_VOLUME;\npContext->rightVolume = REVERB_UNIT_VOLUME;\npContext->volumeMode = android::REVERB_VOLUME_OFF;\n}\nALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\npContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\nbreak;\ncase EFFECT_CMD_SET_DEVICE:\ncase EFFECT_CMD_SET_AUDIO_MODE:\nbreak;\ndefault:\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"DEFAULT start %d ERROR\",cmdCode);\nreturn -EINVAL;\n}\nreturn 0;\n}", "contrast": "int Reverb_command(effect_handle_t  self,\nuint32_t            cmdCode,\nuint32_t            cmdSize,\nvoid *pCmdData,\nuint32_t *replySize,\nvoid *pReplyData){\nandroid::ReverbContext * pContext = (android::ReverbContext *) self;\nint retsize;\nLVREV_ControlParams_st    ActiveParams;\nLVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS;\nif (pContext == NULL){\nALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\nreturn -EINVAL;\n}\nswitch (cmdCode){\ncase EFFECT_CMD_INIT:\nif (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_INIT: ERROR\");\nreturn -EINVAL;\n}\n*(int *) pReplyData = 0;\nbreak;\ncase EFFECT_CMD_SET_CONFIG:\nif (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\npReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_CONFIG: ERROR\");\nreturn -EINVAL;\n}\n*(int *) pReplyData = android::Reverb_setConfig(pContext,\n(effect_config_t *) pCmdData);\nbreak;\ncase EFFECT_CMD_GET_CONFIG:\nif (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_GET_CONFIG: ERROR\");\nreturn -EINVAL;\n}\nandroid::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\nbreak;\ncase EFFECT_CMD_RESET:\nReverb_setConfig(pContext, &pContext->config);\nbreak;\ncase EFFECT_CMD_GET_PARAM:{\neffect_param_t *p = (effect_param_t *)pCmdData;\nif (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\ncmdSize < (sizeof(effect_param_t) + p->psize) ||\npReplyData == NULL || replySize == NULL ||\n*replySize < (sizeof(effect_param_t) + p->psize)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_GET_PARAM: ERROR\");\nreturn -EINVAL;\n}\nmemcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\np = (effect_param_t *)pReplyData;\nint voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\np->status = android::Reverb_getParameter(pContext,\n(void *)p->data,\n&p->vsize,\np->data + voffset);\n*replySize = sizeof(effect_param_t) + voffset + p->vsize;\n} break;\ncase EFFECT_CMD_SET_PARAM:{\nif (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\npReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_PARAM: ERROR\");\nreturn -EINVAL;\n}\neffect_param_t *p = (effect_param_t *) pCmdData;\nif (p->psize != sizeof(int32_t)){\nALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\nreturn -EINVAL;\n}\n*(int *)pReplyData = android::Reverb_setParameter(pContext,\n(void *)p->data,\np->data + p->psize);\n} break;\ncase EFFECT_CMD_ENABLE:\nif (pReplyData == NULL || *replySize != sizeof(int)){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_ENABLE: ERROR\");\nreturn -EINVAL;\n}\nif(pContext->bEnabled == LVM_TRUE){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\nreturn -EINVAL;\n}\n*(int *)pReplyData = 0;\npContext->bEnabled = LVM_TRUE;\nLvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\nLVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\npContext->SamplesToExitCount =\n(ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\npContext->volumeMode = android::REVERB_VOLUME_FLAT;\nbreak;\ncase EFFECT_CMD_DISABLE:\nif (pReplyData == NULL || *replySize != sizeof(int)){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_DISABLE: ERROR\");\nreturn -EINVAL;\n}\nif(pContext->bEnabled == LVM_FALSE){\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\nreturn -EINVAL;\n}\n*(int *)pReplyData = 0;\npContext->bEnabled = LVM_FALSE;\nbreak;\ncase EFFECT_CMD_SET_VOLUME:\nif (pCmdData == NULL ||\ncmdSize != 2 * sizeof(uint32_t)) {\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"EFFECT_CMD_SET_VOLUME: ERROR\");\nreturn -EINVAL;\n}\nif (pReplyData != NULL) {\npContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\npContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n*(uint32_t *)pReplyData = (1 << 24);\n*((uint32_t *)pReplyData + 1) = (1 << 24);\nif (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\npContext->volumeMode = android::REVERB_VOLUME_FLAT;\n}\n} else {\npContext->leftVolume = REVERB_UNIT_VOLUME;\npContext->rightVolume = REVERB_UNIT_VOLUME;\npContext->volumeMode = android::REVERB_VOLUME_OFF;\n}\nALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\npContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\nbreak;\ncase EFFECT_CMD_SET_DEVICE:\ncase EFFECT_CMD_SET_AUDIO_MODE:\nbreak;\ndefault:\nALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n\"DEFAULT start %d ERROR\",cmdCode);\nreturn -EINVAL;\n}\nreturn 0;\n}", "label": 0}
{"index": 182794, "code": "static ssize_t in_read(struct audio_stream_in *stream, void* buffer,\nsize_t bytes)\n{\nstruct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;\nint read;\nDEBUG(\"read %zu bytes, state: %d\", bytes, in->common.state);\nif (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)\n{\nDEBUG(\"stream suspended\");\nreturn -1;\n}\nif ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||\n(in->common.state == AUDIO_A2DP_STATE_STANDBY))\n{\npthread_mutex_lock(&in->common.lock);\nif (start_audio_datapath(&in->common) < 0)\n{\nint us_delay = calc_audiotime(in->common.cfg, bytes);\nDEBUG(\"emulate a2dp read delay (%d us)\", us_delay);\nusleep(us_delay);\npthread_mutex_unlock(&in->common.lock);\nreturn -1;\n}\npthread_mutex_unlock(&in->common.lock);\n}\nelse if (in->common.state != AUDIO_A2DP_STATE_STARTED)\n{\nERROR(\"stream not in stopped or standby\");\nreturn -1;\n}\nread = skt_read(in->common.audio_fd, buffer, bytes);\nif (read == -1)\n{\nskt_disconnect(in->common.audio_fd);\nin->common.audio_fd = AUDIO_SKT_DISCONNECTED;\nin->common.state = AUDIO_A2DP_STATE_STOPPED;\n} else if (read == 0) {\nDEBUG(\"read time out - return zeros\");\nmemset(buffer, 0, bytes);\nread = bytes;\n}\nDEBUG(\"read %d bytes out of %zu bytes\", read, bytes);\nreturn read;\n}", "contrast": "static ssize_t in_read(struct audio_stream_in *stream, void* buffer,\nsize_t bytes)\n{\nstruct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;\nint read;\nDEBUG(\"read %zu bytes, state: %d\", bytes, in->common.state);\nif (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)\n{\nDEBUG(\"stream suspended\");\nreturn -1;\n}\nif ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||\n(in->common.state == AUDIO_A2DP_STATE_STANDBY))\n{\npthread_mutex_lock(&in->common.lock);\nif (start_audio_datapath(&in->common) < 0)\n{\nint us_delay = calc_audiotime(in->common.cfg, bytes);\nDEBUG(\"emulate a2dp read delay (%d us)\", us_delay);\nTEMP_FAILURE_RETRY(usleep(us_delay));\npthread_mutex_unlock(&in->common.lock);\nreturn -1;\n}\npthread_mutex_unlock(&in->common.lock);\n}\nelse if (in->common.state != AUDIO_A2DP_STATE_STARTED)\n{\nERROR(\"stream not in stopped or standby\");\nreturn -1;\n}\nread = skt_read(in->common.audio_fd, buffer, bytes);\nif (read == -1)\n{\nskt_disconnect(in->common.audio_fd);\nin->common.audio_fd = AUDIO_SKT_DISCONNECTED;\nin->common.state = AUDIO_A2DP_STATE_STOPPED;\n} else if (read == 0) {\nDEBUG(\"read time out - return zeros\");\nmemset(buffer, 0, bytes);\nread = bytes;\n}\nDEBUG(\"read %d bytes out of %zu bytes\", read, bytes);\nreturn read;\n}", "label": 0}
{"index": 182797, "code": "static int skt_write(int fd, const void *p, size_t len)\n{\nint sent;\nstruct pollfd pfd;\nFNLOG();\npfd.fd = fd;\npfd.events = POLLOUT;\nif (poll(&pfd, 1, 500) == 0)\nreturn 0;\nts_log(\"skt_write\", len, NULL);\nif ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)\n{\nERROR(\"write failed with errno=%d\\n\", errno);\nreturn -1;\n}\nreturn sent;\n}", "contrast": "static int skt_write(int fd, const void *p, size_t len)\n{\nint sent;\nstruct pollfd pfd;\nFNLOG();\npfd.fd = fd;\npfd.events = POLLOUT;\nif (TEMP_FAILURE_RETRY(poll(&pfd, 1, 500)) == 0)\nreturn 0;\nts_log(\"skt_write\", len, NULL);\nif ((sent = TEMP_FAILURE_RETRY(send(fd, p, len, MSG_NOSIGNAL))) == -1)\n{\nERROR(\"write failed with errno=%d\\n\", errno);\nreturn -1;\n}\nreturn sent;\n}", "label": 0}
{"index": 182806, "code": "static inline int btif_hl_select_close_connected(void){\nchar sig_on = btif_hl_signal_select_close_connected;\nBTIF_TRACE_DEBUG(\"btif_hl_select_close_connected\");\nreturn send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n}", "contrast": "static inline int btif_hl_select_close_connected(void){\nchar sig_on = btif_hl_signal_select_close_connected;\nBTIF_TRACE_DEBUG(\"btif_hl_select_close_connected\");\nreturn TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));\n}", "label": 0}
{"index": 182824, "code": "static sent_status_t send_data_to_app(int fd, BT_HDR *p_buf) {\nif (p_buf->len == 0)\nreturn SENT_ALL;\nssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);\nif (sent == -1) {\nif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\nreturn SENT_NONE;\nLOG_ERROR(\"%s error writing RFCOMM data back to app: %s\", __func__, strerror(errno));\nreturn SENT_FAILED;\n}\nif (sent == 0)\nreturn SENT_FAILED;\nif (sent == p_buf->len)\nreturn SENT_ALL;\np_buf->offset += sent;\np_buf->len -= sent;\nreturn SENT_PARTIAL;\n}", "contrast": "static sent_status_t send_data_to_app(int fd, BT_HDR *p_buf) {\nif (p_buf->len == 0)\nreturn SENT_ALL;\nssize_t sent = TEMP_FAILURE_RETRY(send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT));\nif (sent == -1) {\nif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\nreturn SENT_NONE;\nLOG_ERROR(\"%s error writing RFCOMM data back to app: %s\", __func__, strerror(errno));\nreturn SENT_FAILED;\n}\nif (sent == 0)\nreturn SENT_FAILED;\nif (sent == p_buf->len)\nreturn SENT_ALL;\np_buf->offset += sent;\np_buf->len -= sent;\nreturn SENT_PARTIAL;\n}", "label": 0}
{"index": 182829, "code": "bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)\n{\nif (thread_handle < 0 || thread_handle >= MAX_THREAD)\n{\nAPPL_TRACE_ERROR(\"%s invalid thread handle: %d\", __func__, thread_handle);\nreturn false;\n}\nif (fd == -1)\n{\nAPPL_TRACE_ERROR(\"%s invalid file descriptor.\", __func__);\nreturn false;\n}\nsock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};\nreturn send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n}", "contrast": "bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)\n{\nif (thread_handle < 0 || thread_handle >= MAX_THREAD)\n{\nAPPL_TRACE_ERROR(\"%s invalid thread handle: %d\", __func__, thread_handle);\nreturn false;\n}\nif (fd == -1)\n{\nAPPL_TRACE_ERROR(\"%s invalid file descriptor.\", __func__);\nreturn false;\n}\nsock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};\nreturn TEMP_FAILURE_RETRY(send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n}", "label": 0}
{"index": 182830, "code": "int btsock_thread_wakeup(int h)\n{\nif(h < 0 || h >= MAX_THREAD)\n{\nAPPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\nreturn FALSE;\n}\nif(ts[h].cmd_fdw == -1)\n{\nAPPL_TRACE_ERROR(\"thread handle:%d, cmd socket is not created\", h);\nreturn FALSE;\n}\nsock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};\nreturn send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n}", "contrast": "int btsock_thread_wakeup(int h)\n{\nif(h < 0 || h >= MAX_THREAD)\n{\nAPPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\nreturn FALSE;\n}\nif(ts[h].cmd_fdw == -1)\n{\nAPPL_TRACE_ERROR(\"thread handle:%d, cmd socket is not created\", h);\nreturn FALSE;\n}\nsock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};\nreturn TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n}", "label": 0}
{"index": 182838, "code": "static void btsnoop_write(const void *data, size_t length) {\nif (logfile_fd != INVALID_FD)\nwrite(logfile_fd, data, length);\nbtsnoop_net_write(data, length);\n}", "contrast": "static void btsnoop_write(const void *data, size_t length) {\nif (logfile_fd != INVALID_FD)\nTEMP_FAILURE_RETRY(write(logfile_fd, data, length));\nbtsnoop_net_write(data, length);\n}", "label": 0}
{"index": 182852, "code": "ssize_t socket_read(const socket_t *socket, void *buf, size_t count) {\nassert(socket != NULL);\nassert(buf != NULL);\nreturn recv(socket->fd, buf, count, MSG_DONTWAIT);\n}", "contrast": "ssize_t socket_read(const socket_t *socket, void *buf, size_t count) {\nassert(socket != NULL);\nassert(buf != NULL);\nreturn TEMP_FAILURE_RETRY(recv(socket->fd, buf, count, MSG_DONTWAIT));\n}", "label": 0}
{"index": 182858, "code": "static bool write_hci_command(hci_packet_t type, const void *packet, size_t length) {\nint sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\nif (sock == INVALID_FD)\ngoto error;\nstruct sockaddr_in addr;\naddr.sin_family = AF_INET;\naddr.sin_addr.s_addr = htonl(0x7F000001);\naddr.sin_port = htons(8873);\nif (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)\ngoto error;\nif (send(sock, &type, 1, 0) != 1)\ngoto error;\nif (send(sock, &length, 2, 0) != 2)\ngoto error;\nif (send(sock, packet, length, 0) != (ssize_t)length)\ngoto error;\nclose(sock);\nreturn true;\nerror:;\nclose(sock);\nreturn false;\n}", "contrast": "static bool write_hci_command(hci_packet_t type, const void *packet, size_t length) {\nint sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\nif (sock == INVALID_FD)\ngoto error;\nstruct sockaddr_in addr;\naddr.sin_family = AF_INET;\naddr.sin_addr.s_addr = htonl(0x7F000001);\naddr.sin_port = htons(8873);\nif (TEMP_FAILURE_RETRY(connect(sock, (const struct sockaddr *)&addr, sizeof(addr))) == -1)\ngoto error;\nif (TEMP_FAILURE_RETRY(send(sock, &type, 1, 0)) != 1)\ngoto error;\nif (TEMP_FAILURE_RETRY(send(sock, &length, 2, 0)) != 2)\ngoto error;\nif (TEMP_FAILURE_RETRY(send(sock, packet, length, 0)) != (ssize_t)length)\ngoto error;\nclose(sock);\nreturn true;\nerror:;\nclose(sock);\nreturn false;\n}", "label": 0}
{"index": 182897, "code": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\nWORD32 i4_poc,\npocstruct_t *ps_temp_poc,\nUWORD16 u2_frame_num,\ndec_pic_params_t *ps_pps)\n{\npocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\npocstruct_t *ps_cur_poc = ps_temp_poc;\npic_buffer_t *pic_buf;\nivd_video_decode_op_t * ps_dec_output =\n(ivd_video_decode_op_t *)ps_dec->pv_dec_out;\ndec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\ndec_seq_params_t *ps_seq = ps_pps->ps_sps;\nUWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\nUWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\nhigh_profile_tools_t s_high_profile;\nWORD32 ret;\nH264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\nps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\nps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\nps_prev_poc->i4_delta_pic_order_cnt_bottom =\nps_cur_poc->i4_delta_pic_order_cnt_bottom;\nps_prev_poc->i4_delta_pic_order_cnt[0] =\nps_cur_poc->i4_delta_pic_order_cnt[0];\nps_prev_poc->i4_delta_pic_order_cnt[1] =\nps_cur_poc->i4_delta_pic_order_cnt[1];\nps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\nps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\nps_prev_poc->u2_frame_num = u2_frame_num;\nps_dec->i1_prev_mb_qp_delta = 0;\nps_dec->i1_next_ctxt_idx = 0;\nps_dec->u4_nmb_deblk = 0;\nif(ps_dec->u4_num_cores == 1)\nps_dec->u4_nmb_deblk = 1;\nif(ps_seq->u1_mb_aff_flag == 1)\n{\nps_dec->u4_nmb_deblk = 0;\nif(ps_dec->u4_num_cores > 2)\nps_dec->u4_num_cores = 2;\n}\nps_dec->u4_use_intrapred_line_copy = 0;\nif (ps_seq->u1_mb_aff_flag == 0)\n{\nps_dec->u4_use_intrapred_line_copy = 1;\n}\nps_dec->u4_app_disable_deblk_frm = 0;\nif(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n{\nWORD32 degrade_pic;\nps_dec->i4_degrade_pic_cnt++;\ndegrade_pic = 0;\nswitch(ps_dec->i4_degrade_pics)\n{\ncase 4:\n{\ndegrade_pic = 1;\nbreak;\n}\ncase 3:\n{\nif(ps_cur_slice->u1_slice_type != I_SLICE)\ndegrade_pic = 1;\nbreak;\n}\ncase 2:\n{\nif((ps_cur_slice->u1_slice_type != I_SLICE)\n&& (ps_dec->i4_degrade_pic_cnt\n!= ps_dec->i4_nondegrade_interval))\ndegrade_pic = 1;\nbreak;\n}\ncase 1:\n{\nif(0 == ps_cur_slice->u1_nal_ref_idc)\n{\ndegrade_pic = 1;\n}\nbreak;\n}\n}\nif(degrade_pic)\n{\nif(ps_dec->i4_degrade_type & 0x2)\nps_dec->u4_app_disable_deblk_frm = 1;\nif(0 == ps_cur_slice->u1_nal_ref_idc)\n{\nif(ps_dec->i4_degrade_type & 0x4)\nps_dec->i4_mv_frac_mask = 0;\nif(ps_dec->i4_degrade_type & 0x8)\nps_dec->i4_mv_frac_mask = 0;\n}\n}\nelse\nps_dec->i4_degrade_pic_cnt = 0;\n}\n{\ndec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\nif(ps_dec->u1_sl_typ_5_9\n&& ((ps_cur_slice->u1_slice_type == I_SLICE)\n|| (ps_cur_slice->u1_slice_type\n== SI_SLICE)))\nps_err->u1_cur_pic_type = PIC_TYPE_I;\nelse\nps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\nif(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n{\nps_err->u1_cur_pic_type = PIC_TYPE_I;\nps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n}\nif(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n{\nif(ps_err->u1_err_flag)\nih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\nps_err->u1_err_flag = ACCEPT_ALL_PICS;\n}\n}\nif(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n{\nWORD32 j;\nfor(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n{\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\nps_dec->au1_pic_buf_id_mv_buf_id_map[j],\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_IO);\n}\nps_dec->u1_second_field = 0;\nps_dec->i4_cur_display_seq = 0;\nps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n}\nret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\nif(ret != OK)\nreturn ret;\nps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\nps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\nps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\nif(ps_dec->u1_separate_parse)\n{\nUWORD16 pic_wd;\nUWORD16 pic_ht;\nUWORD32 num_mbs;\npic_wd = ps_dec->u2_pic_wd;\npic_ht = ps_dec->u2_pic_ht;\nnum_mbs = (pic_wd * pic_ht) >> 8;\nif(ps_dec->pu1_dec_mb_map)\n{\nmemset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n}\nif(ps_dec->pu1_recon_mb_map)\n{\nmemset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n}\nif(ps_dec->pu2_slice_num_map)\n{\nmemset((void *)ps_dec->pu2_slice_num_map, 0,\n(num_mbs * sizeof(UWORD16)));\n}\n}\nps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\nps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\nps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\nps_dec->s_high_profile.u1_scaling_present = 0;\nps_dec->s_high_profile.u1_transform8x8_present = 0;\nif(1 == ps_dec->u4_share_disp_buf)\n{\nUWORD32 i;\nfor(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n{\nif(0 == ps_dec->u4_disp_buf_to_be_freed[i])\ncontinue;\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\nBUF_MGR_IO);\nps_dec->u4_disp_buf_to_be_freed[i] = 0;\nps_dec->u4_disp_buf_mapping[i] = 0;\n}\n}\nif(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))\n{\npic_buffer_t *ps_cur_pic;\nWORD32 cur_pic_buf_id, cur_mv_buf_id;\ncol_mv_buf_t *ps_col_mv;\nwhile(1)\n{\nps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n&cur_pic_buf_id);\nif(ps_cur_pic == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\nreturn ERROR_UNAVAIL_PICBUF_T;\n}\nif(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n{\nbreak;\n}\n}\nps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n&cur_mv_buf_id);\nif(ps_col_mv == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\nreturn ERROR_UNAVAIL_MVBUF_T;\n}\nps_dec->ps_cur_pic = ps_cur_pic;\nps_dec->u1_pic_buf_id = cur_pic_buf_id;\nps_cur_pic->u4_ts = ps_dec->u4_ts;\nps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\nps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\nps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\nps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\nps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\nif(ps_dec->u1_first_slice_in_stream)\n{\nps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n*(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n}\nif(!ps_dec->ps_cur_pic)\n{\nWORD32 j;\nH264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\nfor(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n{\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\nps_dec->au1_pic_buf_id_mv_buf_id_map[j],\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_IO);\n}\nps_dec->i4_cur_display_seq = 0;\nps_dec->i4_prev_max_display_seq = 0;\nps_dec->i4_max_poc = 0;\nps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n&cur_pic_buf_id);\nif(ps_cur_pic == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\nreturn ERROR_UNAVAIL_PICBUF_T;\n}\nps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n&cur_mv_buf_id);\nif(ps_col_mv == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\nreturn ERROR_UNAVAIL_MVBUF_T;\n}\nps_dec->ps_cur_pic = ps_cur_pic;\nps_dec->u1_pic_buf_id = cur_pic_buf_id;\nps_cur_pic->u4_ts = ps_dec->u4_ts;\nps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\nps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\nps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\nps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\nps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\nps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n}\nps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\nps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\nH264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n}\nelse\n{\nH264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n}\nps_dec->u4_pic_buf_got = 1;\nps_dec->ps_cur_pic->i4_poc = i4_poc;\nps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\nps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\nps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\nps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\nps_pps->i4_bottom_field_order_cnt;\nps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\nps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\nps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\nif(u1_field_pic_flag && u1_bottom_field_flag)\n{\nWORD32 i4_temp_poc;\nWORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\nps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\nps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\nps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\nps_dec->s_cur_pic.ps_mv +=\n((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\nps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n* ps_dec->u2_pic_wd) >> 5);\nps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\ni4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\ni4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\ni4_temp_poc = MIN(i4_top_field_order_poc,\ni4_bot_field_order_poc);\nps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n}\nps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n&& (!u1_field_pic_flag);\nps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n<< 2);\nps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;\nps_dec->ps_cur_mb_row += 2;\nps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;\nps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\nps_dec->ps_top_mb_row += 2;\nps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\nps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\nps_dec->u1_mv_top_p = 0;\nps_dec->u1_mb_idx = 0;\nps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\nps_dec->u2_total_mbs_coded = 0;\nps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\nps_dec->u4_pred_info_idx = 0;\nps_dec->u4_pred_info_pkd_idx = 0;\nps_dec->u4_dma_buf_idx = 0;\nps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\nps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\nps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nps_dec->i2_prev_slice_mbx = -1;\nps_dec->i2_prev_slice_mby = 0;\nps_dec->u2_mv_2mb[0] = 0;\nps_dec->u2_mv_2mb[1] = 0;\nps_dec->u1_last_pic_not_decoded = 0;\nps_dec->u2_cur_slice_num = 0;\nps_dec->u2_cur_slice_num_dec_thread = 0;\nps_dec->u2_cur_slice_num_bs = 0;\nps_dec->u4_intra_pred_line_ofst = 0;\nps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\nps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\nps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\nps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\nps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\nps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\nps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n+ (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\nps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\nps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\nps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n{\nif(ps_cur_slice->u1_mbaff_frame_flag)\n{\nps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\nps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n}\nelse\n{\nps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\nps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n}\n}\n{\nUWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\nUWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\nUWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n% (ps_dec->u1_recon_mb_grp >> u1_mbaff));\nUWORD16 ui16_lastmbs_widthY =\n(uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n>> u1_mbaff) << 4));\nUWORD16 ui16_lastmbs_widthUV =\nuc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n>> u1_mbaff) << 3);\nps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\nps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\nps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\nps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n<< u1_field_pic_flag;\nps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n<< u1_field_pic_flag;\nif(u1_field_pic_flag)\n{\nui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\nui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n}\nps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n>> u1_mbaff);\nps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n>> u1_mbaff);\nps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n+ (PAD_LEN_Y_H << 1)\n+ ps_dec->s_tran_addrecon.u2_frm_wd_y\n* ((15 << u1_mbaff) + u1_mbaff));\nps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n+ (PAD_LEN_UV_H << 2)\n+ ps_dec->s_tran_addrecon.u2_frm_wd_uv\n* ((15 << u1_mbaff) + u1_mbaff));\nih264d_assign_pic_num(ps_dec);\nps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n<< 2) - 1 - (u1_mbaff << 2);\nps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n>> u1_mbaff) - 1) << (4 + u1_mbaff);\n}\nif(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n{\nif((ps_seq->i4_seq_scaling_matrix_present_flag)\n|| (ps_pps->i4_pic_scaling_matrix_present_flag))\n{\nih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\nps_dec->s_high_profile.u1_scaling_present = 1;\n}\nelse\n{\nih264d_form_default_scaling_matrix(ps_dec);\n}\nif(ps_pps->i4_transform_8x8_mode_flag)\n{\nps_dec->s_high_profile.u1_transform8x8_present = 1;\n}\n}\nelse\n{\nih264d_form_default_scaling_matrix(ps_dec);\n}\nps_dec->s_high_profile.u1_direct_8x8_inference_flag =\nps_seq->u1_direct_8x8_inference_flag;\nps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\nps_dec->i1_recon_in_thread3_flag = 1;\nps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\nif(ps_dec->u1_separate_parse)\n{\nmemcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\nsizeof(tfr_ctxt_t));\nif(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n{\nmemcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\nsizeof(tfr_ctxt_t));\nps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n}\n}\nih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\nps_dec->u2_frm_wd_in_mbs, 0);\nps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\nps_dec->u4_cur_deblk_mb_num = 0;\nps_dec->u4_deblk_mb_x = 0;\nps_dec->u4_deblk_mb_y = 0;\nps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\nH264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\nreturn OK;\n}", "contrast": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\nWORD32 i4_poc,\npocstruct_t *ps_temp_poc,\nUWORD16 u2_frame_num,\ndec_pic_params_t *ps_pps)\n{\npocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\npocstruct_t *ps_cur_poc = ps_temp_poc;\npic_buffer_t *pic_buf;\nivd_video_decode_op_t * ps_dec_output =\n(ivd_video_decode_op_t *)ps_dec->pv_dec_out;\ndec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\ndec_seq_params_t *ps_seq = ps_pps->ps_sps;\nUWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\nUWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\nhigh_profile_tools_t s_high_profile;\nWORD32 ret;\nH264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\nps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\nps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\nps_prev_poc->i4_delta_pic_order_cnt_bottom =\nps_cur_poc->i4_delta_pic_order_cnt_bottom;\nps_prev_poc->i4_delta_pic_order_cnt[0] =\nps_cur_poc->i4_delta_pic_order_cnt[0];\nps_prev_poc->i4_delta_pic_order_cnt[1] =\nps_cur_poc->i4_delta_pic_order_cnt[1];\nps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\nps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\nps_prev_poc->u2_frame_num = u2_frame_num;\nps_dec->i1_prev_mb_qp_delta = 0;\nps_dec->i1_next_ctxt_idx = 0;\nps_dec->u4_nmb_deblk = 0;\nif(ps_dec->u4_num_cores == 1)\nps_dec->u4_nmb_deblk = 1;\nif(ps_seq->u1_mb_aff_flag == 1)\n{\nps_dec->u4_nmb_deblk = 0;\nif(ps_dec->u4_num_cores > 2)\nps_dec->u4_num_cores = 2;\n}\nps_dec->u4_use_intrapred_line_copy = 0;\nif (ps_seq->u1_mb_aff_flag == 0)\n{\nps_dec->u4_use_intrapred_line_copy = 1;\n}\nps_dec->u4_app_disable_deblk_frm = 0;\nif(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n{\nWORD32 degrade_pic;\nps_dec->i4_degrade_pic_cnt++;\ndegrade_pic = 0;\nswitch(ps_dec->i4_degrade_pics)\n{\ncase 4:\n{\ndegrade_pic = 1;\nbreak;\n}\ncase 3:\n{\nif(ps_cur_slice->u1_slice_type != I_SLICE)\ndegrade_pic = 1;\nbreak;\n}\ncase 2:\n{\nif((ps_cur_slice->u1_slice_type != I_SLICE)\n&& (ps_dec->i4_degrade_pic_cnt\n!= ps_dec->i4_nondegrade_interval))\ndegrade_pic = 1;\nbreak;\n}\ncase 1:\n{\nif(0 == ps_cur_slice->u1_nal_ref_idc)\n{\ndegrade_pic = 1;\n}\nbreak;\n}\n}\nif(degrade_pic)\n{\nif(ps_dec->i4_degrade_type & 0x2)\nps_dec->u4_app_disable_deblk_frm = 1;\nif(0 == ps_cur_slice->u1_nal_ref_idc)\n{\nif(ps_dec->i4_degrade_type & 0x4)\nps_dec->i4_mv_frac_mask = 0;\nif(ps_dec->i4_degrade_type & 0x8)\nps_dec->i4_mv_frac_mask = 0;\n}\n}\nelse\nps_dec->i4_degrade_pic_cnt = 0;\n}\n{\ndec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\nif(ps_dec->u1_sl_typ_5_9\n&& ((ps_cur_slice->u1_slice_type == I_SLICE)\n|| (ps_cur_slice->u1_slice_type\n== SI_SLICE)))\nps_err->u1_cur_pic_type = PIC_TYPE_I;\nelse\nps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\nif(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n{\nps_err->u1_cur_pic_type = PIC_TYPE_I;\nps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n}\nif(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n{\nif(ps_err->u1_err_flag)\nih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\nps_err->u1_err_flag = ACCEPT_ALL_PICS;\n}\n}\nif(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n{\nWORD32 j;\nfor(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n{\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\nps_dec->au1_pic_buf_id_mv_buf_id_map[j],\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_IO);\n}\nps_dec->u1_second_field = 0;\nps_dec->i4_cur_display_seq = 0;\nps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n}\nret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\nif(ret != OK)\nreturn ret;\nps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\nps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\nps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\nif(ps_dec->u1_separate_parse)\n{\nUWORD16 pic_wd;\nUWORD16 pic_ht;\nUWORD32 num_mbs;\npic_wd = ps_dec->u2_pic_wd;\npic_ht = ps_dec->u2_pic_ht;\nnum_mbs = (pic_wd * pic_ht) >> 8;\nif(ps_dec->pu1_dec_mb_map)\n{\nmemset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n}\nif(ps_dec->pu1_recon_mb_map)\n{\nmemset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n}\nif(ps_dec->pu2_slice_num_map)\n{\nmemset((void *)ps_dec->pu2_slice_num_map, 0,\n(num_mbs * sizeof(UWORD16)));\n}\n}\nps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\nps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\nps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\nps_dec->u2_cur_slice_num = 0;\nps_dec->s_high_profile.u1_scaling_present = 0;\nps_dec->s_high_profile.u1_transform8x8_present = 0;\nif(1 == ps_dec->u4_share_disp_buf)\n{\nUWORD32 i;\nfor(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n{\nif(0 == ps_dec->u4_disp_buf_to_be_freed[i])\ncontinue;\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\nBUF_MGR_IO);\nps_dec->u4_disp_buf_to_be_freed[i] = 0;\nps_dec->u4_disp_buf_mapping[i] = 0;\n}\n}\nif(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))\n{\npic_buffer_t *ps_cur_pic;\nWORD32 cur_pic_buf_id, cur_mv_buf_id;\ncol_mv_buf_t *ps_col_mv;\nwhile(1)\n{\nps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n&cur_pic_buf_id);\nif(ps_cur_pic == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\nreturn ERROR_UNAVAIL_PICBUF_T;\n}\nif(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n{\nbreak;\n}\n}\nps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n&cur_mv_buf_id);\nif(ps_col_mv == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\nreturn ERROR_UNAVAIL_MVBUF_T;\n}\nps_dec->ps_cur_pic = ps_cur_pic;\nps_dec->u1_pic_buf_id = cur_pic_buf_id;\nps_cur_pic->u4_ts = ps_dec->u4_ts;\nps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\nps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\nps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\nps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\nps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\nif(ps_dec->u1_first_slice_in_stream)\n{\nps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n*(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n}\nif(!ps_dec->ps_cur_pic)\n{\nWORD32 j;\nH264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\nfor(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n{\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\nps_dec->au1_pic_buf_id_mv_buf_id_map[j],\nBUF_MGR_REF);\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nj,\nBUF_MGR_IO);\n}\nps_dec->i4_cur_display_seq = 0;\nps_dec->i4_prev_max_display_seq = 0;\nps_dec->i4_max_poc = 0;\nps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n&cur_pic_buf_id);\nif(ps_cur_pic == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\nreturn ERROR_UNAVAIL_PICBUF_T;\n}\nps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n&cur_mv_buf_id);\nif(ps_col_mv == NULL)\n{\nps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\nreturn ERROR_UNAVAIL_MVBUF_T;\n}\nps_dec->ps_cur_pic = ps_cur_pic;\nps_dec->u1_pic_buf_id = cur_pic_buf_id;\nps_cur_pic->u4_ts = ps_dec->u4_ts;\nps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\nps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\nps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\nps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\nps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\nps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n}\nps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\nps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\nH264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n}\nelse\n{\nH264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n}\nps_dec->u4_pic_buf_got = 1;\nps_dec->ps_cur_pic->i4_poc = i4_poc;\nps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\nps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\nps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\nps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\nps_pps->i4_bottom_field_order_cnt;\nps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\nps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\nps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\nif(u1_field_pic_flag && u1_bottom_field_flag)\n{\nWORD32 i4_temp_poc;\nWORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\nps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\nps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\nps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\nps_dec->s_cur_pic.ps_mv +=\n((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\nps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n* ps_dec->u2_pic_wd) >> 5);\nps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\ni4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\ni4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\ni4_temp_poc = MIN(i4_top_field_order_poc,\ni4_bot_field_order_poc);\nps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n}\nps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n&& (!u1_field_pic_flag);\nps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n<< 2);\nps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;\nps_dec->ps_cur_mb_row += 2;\nps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;\nps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\nps_dec->ps_top_mb_row += 2;\nps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\nps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\nps_dec->u1_mv_top_p = 0;\nps_dec->u1_mb_idx = 0;\nps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\nps_dec->u2_total_mbs_coded = 0;\nps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\nps_dec->u4_pred_info_idx = 0;\nps_dec->u4_pred_info_pkd_idx = 0;\nps_dec->u4_dma_buf_idx = 0;\nps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\nps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\nps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nps_dec->i2_prev_slice_mbx = -1;\nps_dec->i2_prev_slice_mby = 0;\nps_dec->u2_mv_2mb[0] = 0;\nps_dec->u2_mv_2mb[1] = 0;\nps_dec->u1_last_pic_not_decoded = 0;\nps_dec->u2_cur_slice_num_dec_thread = 0;\nps_dec->u2_cur_slice_num_bs = 0;\nps_dec->u4_intra_pred_line_ofst = 0;\nps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\nps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\nps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\nps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\nps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\nps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\nps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n+ (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\nps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\nps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\nps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n{\nif(ps_cur_slice->u1_mbaff_frame_flag)\n{\nps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\nps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n}\nelse\n{\nps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\nps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n}\n}\n{\nUWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\nUWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\nUWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n% (ps_dec->u1_recon_mb_grp >> u1_mbaff));\nUWORD16 ui16_lastmbs_widthY =\n(uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n>> u1_mbaff) << 4));\nUWORD16 ui16_lastmbs_widthUV =\nuc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n>> u1_mbaff) << 3);\nps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\nps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\nps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\nps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n<< u1_field_pic_flag;\nps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n<< u1_field_pic_flag;\nif(u1_field_pic_flag)\n{\nui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\nui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n}\nps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n>> u1_mbaff);\nps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n>> u1_mbaff);\nps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n+ (PAD_LEN_Y_H << 1)\n+ ps_dec->s_tran_addrecon.u2_frm_wd_y\n* ((15 << u1_mbaff) + u1_mbaff));\nps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n+ (PAD_LEN_UV_H << 2)\n+ ps_dec->s_tran_addrecon.u2_frm_wd_uv\n* ((15 << u1_mbaff) + u1_mbaff));\nih264d_assign_pic_num(ps_dec);\nps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n<< 2) - 1 - (u1_mbaff << 2);\nps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n>> u1_mbaff) - 1) << (4 + u1_mbaff);\n}\nif(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n{\nif((ps_seq->i4_seq_scaling_matrix_present_flag)\n|| (ps_pps->i4_pic_scaling_matrix_present_flag))\n{\nih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\nps_dec->s_high_profile.u1_scaling_present = 1;\n}\nelse\n{\nih264d_form_default_scaling_matrix(ps_dec);\n}\nif(ps_pps->i4_transform_8x8_mode_flag)\n{\nps_dec->s_high_profile.u1_transform8x8_present = 1;\n}\n}\nelse\n{\nih264d_form_default_scaling_matrix(ps_dec);\n}\nps_dec->s_high_profile.u1_direct_8x8_inference_flag =\nps_seq->u1_direct_8x8_inference_flag;\nps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\nps_dec->i1_recon_in_thread3_flag = 1;\nps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\nif(ps_dec->u1_separate_parse)\n{\nmemcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\nsizeof(tfr_ctxt_t));\nif(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n{\nmemcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\nsizeof(tfr_ctxt_t));\nps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n}\n}\nih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\nps_dec->u2_frm_wd_in_mbs, 0);\nps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\nps_dec->u4_cur_deblk_mb_num = 0;\nps_dec->u4_deblk_mb_x = 0;\nps_dec->u4_deblk_mb_y = 0;\nps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\nH264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\nreturn OK;\n}", "label": 0}
{"index": 182909, "code": "int main(int argc, char **argv) {\nconst char *test_name = NULL;\nbool skip_sanity_suite = false;\nfor (int i = 1; i < argc; ++i) {\nif (!strcmp(\"--help\", argv[i])) {\nprint_usage(argv[0]);\nreturn 0;\n}\nif (!strcmp(\"--insanity\", argv[i])) {\nskip_sanity_suite = true;\ncontinue;\n}\nif (!is_valid(argv[i])) {\nprintf(\"Error: invalid test name.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\nif (test_name != NULL) {\nprintf(\"Error: invalid arguments.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\ntest_name = argv[i];\n}\nif (is_shell_running()) {\nprintf(\"Run 'adb shell stop' before running %s.\\n\", argv[0]);\nreturn -1;\n}\nconfig_t *config = config_new(CONFIG_FILE_PATH);\nif (!config) {\nprintf(\"Error: unable to open stack config file.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\nfor (const config_section_node_t *node = config_section_begin(config); node != config_section_end(config); node = config_section_next(node)) {\nconst char *name = config_section_name(node);\nif (config_has_key(config, name, \"LinkKey\") && string_to_bdaddr(name, &bt_remote_bdaddr)) {\nbreak;\n}\n}\nconfig_free(config);\nif (bdaddr_is_empty(&bt_remote_bdaddr)) {\nprintf(\"Error: unable to find paired device in config file.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\nif (!hal_open(callbacks_get_adapter_struct())) {\nprintf(\"Unable to open Bluetooth HAL.\\n\");\nreturn 1;\n}\nif (!btsocket_init()) {\nprintf(\"Unable to initialize Bluetooth sockets.\\n\");\nreturn 2;\n}\nif (!pan_init()) {\nprintf(\"Unable to initialize PAN.\\n\");\nreturn 3;\n}\nif (!gatt_init()) {\nprintf(\"Unable to initialize GATT.\\n\");\nreturn 4;\n}\nwatchdog_running = true;\npthread_create(&watchdog_thread, NULL, watchdog_fn, NULL);\nstatic const char *DEFAULT  = \"\\x1b[0m\";\nstatic const char *GREEN = \"\\x1b[0;32m\";\nstatic const char *RED   = \"\\x1b[0;31m\";\nif (!isatty(fileno(stdout))) {\nDEFAULT = GREEN = RED = \"\";\n}\nint pass = 0;\nint fail = 0;\nint case_num = 0;\nif (!skip_sanity_suite) {\nfor (size_t i = 0; i < sanity_suite_size; ++i) {\nif (!test_name || !strcmp(test_name, sanity_suite[i].function_name)) {\ncallbacks_init();\nif (sanity_suite[i].function()) {\nprintf(\"[%4d] %-64s [%sPASS%s]\\n\", ++case_num, sanity_suite[i].function_name, GREEN, DEFAULT);\n++pass;\n} else {\nprintf(\"[%4d] %-64s [%sFAIL%s]\\n\", ++case_num, sanity_suite[i].function_name, RED, DEFAULT);\n++fail;\n}\ncallbacks_cleanup();\n++watchdog_id;\n}\n}\n}\nif (fail) {\nprintf(\"\\n%sSanity suite failed with %d errors.%s\\n\", RED, fail, DEFAULT);\nhal_close();\nreturn 4;\n}\nfor (size_t i = 0; i < test_suite_size; ++i) {\nif (!test_name || !strcmp(test_name, test_suite[i].function_name)) {\ncallbacks_init();\nCALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);\nif (test_suite[i].function()) {\nprintf(\"[%4d] %-64s [%sPASS%s]\\n\", ++case_num, test_suite[i].function_name, GREEN, DEFAULT);\n++pass;\n} else {\nprintf(\"[%4d] %-64s [%sFAIL%s]\\n\", ++case_num, test_suite[i].function_name, RED, DEFAULT);\n++fail;\n}\nCALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);\ncallbacks_cleanup();\n++watchdog_id;\n}\n}\nprintf(\"\\n\");\nif (fail) {\nprintf(\"%d/%d tests failed. See above for failed test cases.\\n\", fail, sanity_suite_size + test_suite_size);\n} else {\nprintf(\"All tests passed!\\n\");\n}\nwatchdog_running = false;\npthread_join(watchdog_thread, NULL);\nhal_close();\nreturn 0;\n}", "contrast": "int main(int argc, char **argv) {\nconst char *test_name = NULL;\nbool skip_sanity_suite = false;\nfor (int i = 1; i < argc; ++i) {\nif (!strcmp(\"--help\", argv[i])) {\nprint_usage(argv[0]);\nreturn 0;\n}\nif (!strcmp(\"--insanity\", argv[i])) {\nskip_sanity_suite = true;\ncontinue;\n}\nif (!is_valid(argv[i])) {\nprintf(\"Error: invalid test name.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\nif (test_name != NULL) {\nprintf(\"Error: invalid arguments.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\ntest_name = argv[i];\n}\nif (is_shell_running()) {\nprintf(\"Run 'adb shell stop' before running %s.\\n\", argv[0]);\nreturn -1;\n}\nconfig_t *config = config_new(CONFIG_FILE_PATH);\nif (!config) {\nprintf(\"Error: unable to open stack config file.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\nfor (const config_section_node_t *node = config_section_begin(config); node != config_section_end(config); node = config_section_next(node)) {\nconst char *name = config_section_name(node);\nif (config_has_key(config, name, \"LinkKey\") && string_to_bdaddr(name, &bt_remote_bdaddr)) {\nbreak;\n}\n}\nconfig_free(config);\nif (bdaddr_is_empty(&bt_remote_bdaddr)) {\nprintf(\"Error: unable to find paired device in config file.\\n\");\nprint_usage(argv[0]);\nreturn -1;\n}\nif (!hal_open(callbacks_get_adapter_struct())) {\nprintf(\"Unable to open Bluetooth HAL.\\n\");\nreturn 1;\n}\nif (!btsocket_init()) {\nprintf(\"Unable to initialize Bluetooth sockets.\\n\");\nreturn 2;\n}\nif (!pan_init()) {\nprintf(\"Unable to initialize PAN.\\n\");\nreturn 3;\n}\nif (!gatt_init()) {\nprintf(\"Unable to initialize GATT.\\n\");\nreturn 4;\n}\nwatchdog_running = true;\npthread_create(&watchdog_thread, NULL, watchdog_fn, NULL);\nstatic const char *DEFAULT  = \"\\x1b[0m\";\nstatic const char *GREEN = \"\\x1b[0;32m\";\nstatic const char *RED   = \"\\x1b[0;31m\";\nif (!isatty(fileno(stdout))) {\nDEFAULT = GREEN = RED = \"\";\n}\nint pass = 0;\nint fail = 0;\nint case_num = 0;\nif (!skip_sanity_suite) {\nfor (size_t i = 0; i < sanity_suite_size; ++i) {\nif (!test_name || !strcmp(test_name, sanity_suite[i].function_name)) {\ncallbacks_init();\nif (sanity_suite[i].function()) {\nprintf(\"[%4d] %-64s [%sPASS%s]\\n\", ++case_num, sanity_suite[i].function_name, GREEN, DEFAULT);\n++pass;\n} else {\nprintf(\"[%4d] %-64s [%sFAIL%s]\\n\", ++case_num, sanity_suite[i].function_name, RED, DEFAULT);\n++fail;\n}\ncallbacks_cleanup();\n++watchdog_id;\n}\n}\n}\nif (fail) {\nprintf(\"\\n%sSanity suite failed with %d errors.%s\\n\", RED, fail, DEFAULT);\nhal_close();\nreturn 4;\n}\nfor (size_t i = 0; i < test_suite_size; ++i) {\nif (!test_name || !strcmp(test_name, test_suite[i].function_name)) {\ncallbacks_init();\nCALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);\nif (test_suite[i].function()) {\nprintf(\"[%4d] %-64s [%sPASS%s]\\n\", ++case_num, test_suite[i].function_name, GREEN, DEFAULT);\n++pass;\n} else {\nprintf(\"[%4d] %-64s [%sFAIL%s]\\n\", ++case_num, test_suite[i].function_name, RED, DEFAULT);\n++fail;\n}\nCALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);\ncallbacks_cleanup();\n++watchdog_id;\n}\n}\nprintf(\"\\n\");\nif (fail) {\nprintf(\"%d/%d tests failed. See above for failed test cases.\\n\", fail, sanity_suite_size + test_suite_size);\n} else {\nprintf(\"All tests passed!\\n\");\n}\nwatchdog_running = false;\npthread_join(watchdog_thread, NULL);\nhal_close();\nreturn 0;\n}", "label": 0}
{"index": 182920, "code": "static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr)\n{\nmainprog_info  *mainprog_ptr;\nint  color_type, bit_depth;\npng_uint_32 width, height;\n#ifdef PNG_FLOATING_POINT_SUPPORTED\ndouble  gamma;\n#else\npng_fixed_point gamma;\n#endif\nmainprog_ptr = png_get_progressive_ptr(png_ptr);\nif (mainprog_ptr == NULL) {\nfprintf(stderr,\n\"readpng2 error:  main struct not recoverable in info_callback.\\n\");\nfflush(stderr);\nreturn;\n}\npng_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\nNULL, NULL, NULL);\nmainprog_ptr->width = (ulg)width;\nmainprog_ptr->height = (ulg)height;\nif (mainprog_ptr->need_bgcolor &&\npng_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))\n{\npng_color_16p pBackground;\npng_get_bKGD(png_ptr, info_ptr, &pBackground);\nif (bit_depth == 16) {\nmainprog_ptr->bg_red   = pBackground->red   >> 8;\nmainprog_ptr->bg_green = pBackground->green >> 8;\nmainprog_ptr->bg_blue  = pBackground->blue  >> 8;\n} else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {\nif (bit_depth == 1)\nmainprog_ptr->bg_red = mainprog_ptr->bg_green =\nmainprog_ptr->bg_blue = pBackground->gray? 255 : 0;\nelse if (bit_depth == 2)\nmainprog_ptr->bg_red = mainprog_ptr->bg_green =\nmainprog_ptr->bg_blue = (255/3) * pBackground->gray;\nelse\nmainprog_ptr->bg_red = mainprog_ptr->bg_green =\nmainprog_ptr->bg_blue = (255/15) * pBackground->gray;\n} else {\nmainprog_ptr->bg_red   = (uch)pBackground->red;\nmainprog_ptr->bg_green = (uch)pBackground->green;\nmainprog_ptr->bg_blue  = (uch)pBackground->blue;\n}\n}\nif (color_type == PNG_COLOR_TYPE_PALETTE)\npng_set_expand(png_ptr);\nif (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\npng_set_expand(png_ptr);\nif (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\npng_set_expand(png_ptr);\n#ifdef PNG_READ_16_TO_8_SUPPORTED\nif (bit_depth == 16)\n#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\npng_set_scale_16(png_ptr);\n#  else\npng_set_strip_16(png_ptr);\n#  endif\n#endif\nif (color_type == PNG_COLOR_TYPE_GRAY ||\ncolor_type == PNG_COLOR_TYPE_GRAY_ALPHA)\npng_set_gray_to_rgb(png_ptr);\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nif (png_get_gAMA(png_ptr, info_ptr, &gamma))\npng_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);\nelse\npng_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);\n#else\nif (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma))\npng_set_gamma_fixed(png_ptr,\n(png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma);\nelse\npng_set_gamma_fixed(png_ptr,\n(png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455);\n#endif\nmainprog_ptr->passes = png_set_interlace_handling(png_ptr);\npng_read_update_info(png_ptr, info_ptr);\nmainprog_ptr->rowbytes = (int)png_get_rowbytes(png_ptr, info_ptr);\nmainprog_ptr->channels = png_get_channels(png_ptr, info_ptr);\n(*mainprog_ptr->mainprog_init)();\nreturn;\n}", "contrast": "static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr)\n{\nmainprog_info  *mainprog_ptr;\nint  color_type, bit_depth;\npng_uint_32 width, height;\n#ifdef PNG_FLOATING_POINT_SUPPORTED\ndouble  gamma;\n#else\npng_fixed_point gamma;\n#endif\nmainprog_ptr = png_get_progressive_ptr(png_ptr);\nif (mainprog_ptr == NULL) {\nfprintf(stderr,\n\"readpng2 error:  main struct not recoverable in info_callback.\\n\");\nfflush(stderr);\nreturn;\n}\npng_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\nNULL, NULL, NULL);\nmainprog_ptr->width = (ulg)width;\nmainprog_ptr->height = (ulg)height;\nif (mainprog_ptr->need_bgcolor)\n{\npng_color_16p pBackground;\nif (png_get_bKGD(png_ptr, info_ptr, &pBackground))\n{\nif (bit_depth == 16) {\nmainprog_ptr->bg_red   = pBackground->red   >> 8;\nmainprog_ptr->bg_green = pBackground->green >> 8;\nmainprog_ptr->bg_blue  = pBackground->blue  >> 8;\n} else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {\nif (bit_depth == 1)\nmainprog_ptr->bg_red = mainprog_ptr->bg_green =\nmainprog_ptr->bg_blue = pBackground->gray? 255 : 0;\nelse if (bit_depth == 2)\nmainprog_ptr->bg_red = mainprog_ptr->bg_green =\nmainprog_ptr->bg_blue = (255/3) * pBackground->gray;\nelse\nmainprog_ptr->bg_red = mainprog_ptr->bg_green =\nmainprog_ptr->bg_blue = (255/15) * pBackground->gray;\n} else {\nmainprog_ptr->bg_red   = (uch)pBackground->red;\nmainprog_ptr->bg_green = (uch)pBackground->green;\nmainprog_ptr->bg_blue  = (uch)pBackground->blue;\n}\n}\n}\nif (color_type == PNG_COLOR_TYPE_PALETTE)\npng_set_expand(png_ptr);\nif (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\npng_set_expand(png_ptr);\nif (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\npng_set_expand(png_ptr);\n#ifdef PNG_READ_16_TO_8_SUPPORTED\nif (bit_depth == 16)\n#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\npng_set_scale_16(png_ptr);\n#  else\npng_set_strip_16(png_ptr);\n#  endif\n#endif\nif (color_type == PNG_COLOR_TYPE_GRAY ||\ncolor_type == PNG_COLOR_TYPE_GRAY_ALPHA)\npng_set_gray_to_rgb(png_ptr);\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nif (png_get_gAMA(png_ptr, info_ptr, &gamma))\npng_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);\nelse\npng_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);\n#else\nif (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma))\npng_set_gamma_fixed(png_ptr,\n(png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma);\nelse\npng_set_gamma_fixed(png_ptr,\n(png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455);\n#endif\nmainprog_ptr->passes = png_set_interlace_handling(png_ptr);\npng_read_update_info(png_ptr, info_ptr);\nmainprog_ptr->rowbytes = (int)png_get_rowbytes(png_ptr, info_ptr);\nmainprog_ptr->channels = png_get_channels(png_ptr, info_ptr);\n(*mainprog_ptr->mainprog_init)();\nreturn;\n}", "label": 0}
{"index": 182932, "code": "image_size_of_type(int color_type, int bit_depth, unsigned int *colors)\n{\nif (*colors)\nreturn 16;\nelse\n{\nint pixel_depth = pixel_depth_of_type(color_type, bit_depth);\nif (pixel_depth < 8)\nreturn 64;\nelse if (pixel_depth > 16)\nreturn 1024;\nelse\nreturn 256;\n}\n}", "contrast": "image_size_of_type(int color_type, int bit_depth, unsigned int *colors)\nimage_size_of_type(int color_type, int bit_depth, unsigned int *colors,\nint small)\n{\nif (*colors)\nreturn 16;\nelse\n{\nint pixel_depth = pixel_depth_of_type(color_type, bit_depth);\nif (small)\n{\nif (pixel_depth <= 8)\nreturn 1 << pixel_depth;\nelse\nreturn 256;\n}\nelse if (pixel_depth < 8)\nreturn 64;\nelse if (pixel_depth > 16)\nreturn 1024;\nelse\nreturn 256;\n}\n}", "label": 0}
{"index": 182939, "code": "display_log(struct display *dp, error_level level, const char *fmt, ...)\n{\ndp->results |= 1U << level;\nif (level > (error_level)(dp->options & LEVEL_MASK))\n{\nconst char *lp;\nva_list ap;\nswitch (level)\n{\ncase INFORMATION:    lp = \"information\"; break;\ncase LIBPNG_WARNING: lp = \"warning(libpng)\"; break;\ncase APP_WARNING:    lp = \"warning(pngimage)\"; break;\ncase APP_FAIL:       lp = \"error(continuable)\"; break;\ncase LIBPNG_ERROR:   lp = \"error(libpng)\"; break;\ncase LIBPNG_BUG:     lp = \"bug(libpng)\"; break;\ncase APP_ERROR:      lp = \"error(pngimage)\"; break;\ncase USER_ERROR:     lp = \"error(user)\"; break;\ncase INTERNAL_ERROR:\ncase VERBOSE: case WARNINGS: case ERRORS: case QUIET:\ndefault:             lp = \"bug(pngimage)\"; break;\n}\nfprintf(stderr, \"%s: %s: %s\",\ndp->filename != NULL ? dp->filename : \"<stdin>\", lp, dp->operation);\nif (dp->transforms != 0)\n{\nint tr = dp->transforms;\nif (is_combo(tr))\nfprintf(stderr, \"(0x%x)\", tr);\nelse\nfprintf(stderr, \"(%s)\", transform_name(tr));\n}\nfprintf(stderr, \": \");\nva_start(ap, fmt);\nvfprintf(stderr, fmt, ap);\nva_end(ap);\nfputc('\\n', stderr);\n}\nif (level > APP_FAIL || (level > ERRORS && !(dp->options & CONTINUE)))\nlongjmp(dp->error_return, level);\n}", "contrast": "display_log(struct display *dp, error_level level, const char *fmt, ...)\n{\ndp->results |= 1U << level;\nif (level > (error_level)(dp->options & LEVEL_MASK))\n{\nconst char *lp;\nva_list ap;\nswitch (level)\n{\ncase INFORMATION:    lp = \"information\"; break;\ncase LIBPNG_WARNING: lp = \"warning(libpng)\"; break;\ncase APP_WARNING:    lp = \"warning(pngimage)\"; break;\ncase APP_FAIL:       lp = \"error(continuable)\"; break;\ncase LIBPNG_ERROR:   lp = \"error(libpng)\"; break;\ncase LIBPNG_BUG:     lp = \"bug(libpng)\"; break;\ncase APP_ERROR:      lp = \"error(pngimage)\"; break;\ncase USER_ERROR:     lp = \"error(user)\"; break;\ncase INTERNAL_ERROR:\ncase VERBOSE: case WARNINGS: case ERRORS: case QUIET:\ndefault:             lp = \"bug(pngimage)\"; break;\n}\nfprintf(stderr, \"%s: %s: %s\",\ndp->filename != NULL ? dp->filename : \"<stdin>\", lp, dp->operation);\nif (dp->transforms != 0)\n{\nint tr = dp->transforms;\nif (is_combo(tr))\n{\nif (dp->options & LIST_COMBOS)\n{\nint trx = tr;\nfprintf(stderr, \"(\");\nif (trx)\n{\nint start = 0;\nwhile (trx)\n{\nint trz = trx & -trx;\nif (start) fprintf(stderr, \"+\");\nfprintf(stderr, \"%s\", transform_name(trz));\nstart = 1;\ntrx &= ~trz;\n}\n}\nelse\nfprintf(stderr, \"-\");\nfprintf(stderr, \")\");\n}\nelse\nfprintf(stderr, \"(0x%x)\", tr);\n}\nelse\nfprintf(stderr, \"(%s)\", transform_name(tr));\n}\nfprintf(stderr, \": \");\nva_start(ap, fmt);\nvfprintf(stderr, fmt, ap);\nva_end(ap);\nfputc('\\n', stderr);\n}\nif (level > APP_FAIL || (level > ERRORS && !(dp->options & CONTINUE)))\nlongjmp(dp->error_return, level);\n}", "label": 0}
{"index": 182940, "code": "main(const int argc, const char * const * const argv)\n{\nint option_end, ilog = 0;\nstruct display d;\nvalidate_T();\ndisplay_init(&d);\nfor (option_end=1; option_end<argc; ++option_end)\n{\nconst char *name = argv[option_end];\nif (strcmp(name, \"--verbose\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | VERBOSE;\nelse if (strcmp(name, \"--warnings\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | WARNINGS;\nelse if (strcmp(name, \"--errors\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | ERRORS;\nelse if (strcmp(name, \"--quiet\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | QUIET;\nelse if (strcmp(name, \"--exhaustive\") == 0)\nd.options |= EXHAUSTIVE;\nelse if (strcmp(name, \"--fast\") == 0)\nd.options &= ~EXHAUSTIVE;\nelse if (strcmp(name, \"--strict\") == 0)\nd.options |= STRICT;\nelse if (strcmp(name, \"--relaxed\") == 0)\nd.options &= ~STRICT;\nelse if (strcmp(name, \"--log\") == 0)\n{\nilog = option_end;\nd.options |= LOG;\n}\nelse if (strcmp(name, \"--nolog\") == 0)\nd.options &= ~LOG;\nelse if (strcmp(name, \"--continue\") == 0)\nd.options |= CONTINUE;\nelse if (strcmp(name, \"--stop\") == 0)\nd.options &= ~CONTINUE;\nelse if (strcmp(name, \"--skip-bugs\") == 0)\nd.options |= SKIP_BUGS;\nelse if (strcmp(name, \"--test-all\") == 0)\nd.options &= ~SKIP_BUGS;\nelse if (strcmp(name, \"--log-skipped\") == 0)\nd.options |= LOG_SKIPPED;\nelse if (strcmp(name, \"--nolog-skipped\") == 0)\nd.options &= ~LOG_SKIPPED;\nelse if (strcmp(name, \"--find-bad-combos\") == 0)\nd.options |= FIND_BAD_COMBOS;\nelse if (strcmp(name, \"--nofind-bad-combos\") == 0)\nd.options &= ~FIND_BAD_COMBOS;\nelse if (name[0] == '-' && name[1] == '-')\n{\nfprintf(stderr, \"pngimage: %s: unknown option\\n\", name);\nreturn 99;\n}\nelse\nbreak;\n}\n{\nint i;\nint errors = 0;\nfor (i=option_end; i<argc; ++i)\n{\n{\nint ret = do_test(&d, argv[i]);\nif (ret > QUIET)\nreturn 99;\n}\n{\nconst int pass = (d.options & STRICT) ?\nRESULT_STRICT(d.results) : RESULT_RELAXED(d.results);\nif (!pass)\n++errors;\nif (d.options & LOG)\n{\nint j;\nprintf(\"%s: pngimage \", pass ? \"PASS\" : \"FAIL\");\nfor (j=1; j<option_end; ++j) if (j != ilog)\nprintf(\"%s \", argv[j]);\nprintf(\"%s\\n\", d.filename);\n}\n}\ndisplay_clean(&d);\n}\nreturn errors != 0;\n}\n}", "contrast": "main(const int argc, const char * const * const argv)\n{\nint option_end, ilog = 0;\nstruct display d;\nvalidate_T();\ndisplay_init(&d);\nfor (option_end=1; option_end<argc; ++option_end)\n{\nconst char *name = argv[option_end];\nif (strcmp(name, \"--verbose\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | VERBOSE;\nelse if (strcmp(name, \"--warnings\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | WARNINGS;\nelse if (strcmp(name, \"--errors\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | ERRORS;\nelse if (strcmp(name, \"--quiet\") == 0)\nd.options = (d.options & ~LEVEL_MASK) | QUIET;\nelse if (strcmp(name, \"--exhaustive\") == 0)\nd.options |= EXHAUSTIVE;\nelse if (strcmp(name, \"--fast\") == 0)\nd.options &= ~EXHAUSTIVE;\nelse if (strcmp(name, \"--strict\") == 0)\nd.options |= STRICT;\nelse if (strcmp(name, \"--relaxed\") == 0)\nd.options &= ~STRICT;\nelse if (strcmp(name, \"--log\") == 0)\n{\nilog = option_end;\nd.options |= LOG;\n}\nelse if (strcmp(name, \"--nolog\") == 0)\nd.options &= ~LOG;\nelse if (strcmp(name, \"--continue\") == 0)\nd.options |= CONTINUE;\nelse if (strcmp(name, \"--stop\") == 0)\nd.options &= ~CONTINUE;\nelse if (strcmp(name, \"--skip-bugs\") == 0)\nd.options |= SKIP_BUGS;\nelse if (strcmp(name, \"--test-all\") == 0)\nd.options &= ~SKIP_BUGS;\nelse if (strcmp(name, \"--log-skipped\") == 0)\nd.options |= LOG_SKIPPED;\nelse if (strcmp(name, \"--nolog-skipped\") == 0)\nd.options &= ~LOG_SKIPPED;\nelse if (strcmp(name, \"--find-bad-combos\") == 0)\nd.options |= FIND_BAD_COMBOS;\nelse if (strcmp(name, \"--nofind-bad-combos\") == 0)\nd.options &= ~FIND_BAD_COMBOS;\nelse if (strcmp(name, \"--list-combos\") == 0)\nd.options |= LIST_COMBOS;\nelse if (strcmp(name, \"--nolist-combos\") == 0)\nd.options &= ~LIST_COMBOS;\nelse if (name[0] == '-' && name[1] == '-')\n{\nfprintf(stderr, \"pngimage: %s: unknown option\\n\", name);\nreturn 99;\n}\nelse\nbreak;\n}\n{\nint i;\nint errors = 0;\nfor (i=option_end; i<argc; ++i)\n{\n{\nint ret = do_test(&d, argv[i]);\nif (ret > QUIET)\nreturn 99;\n}\n{\nconst int pass = (d.options & STRICT) ?\nRESULT_STRICT(d.results) : RESULT_RELAXED(d.results);\nif (!pass)\n++errors;\nif (d.options & LOG)\n{\nint j;\nprintf(\"%s: pngimage \", pass ? \"PASS\" : \"FAIL\");\nfor (j=1; j<option_end; ++j) if (j != ilog)\nprintf(\"%s \", argv[j]);\nprintf(\"%s\\n\", d.filename);\n}\n}\ndisplay_clean(&d);\n}\ndisplay_destroy(&d);\nreturn errors != 0;\n}\n}", "label": 0}
{"index": 183010, "code": "interlace_row(png_bytep buffer, png_const_bytep imageRow,\nunsigned int pixel_size, png_uint_32 w, int pass)\n{\npng_uint_32 xin, xout, xstep;\nxin = PNG_PASS_START_COL(pass);\nxstep = 1U<<PNG_PASS_COL_SHIFT(pass);\nfor (xout=0; xin<w; xin+=xstep)\n{\npixel_copy(buffer, xout, imageRow, xin, pixel_size);\n++xout;\n}\n}", "contrast": "interlace_row(png_bytep buffer, png_const_bytep imageRow,", "label": 0}
{"index": 183023, "code": "next_format(png_bytep colour_type, png_bytep bit_depth,\nunsigned int* palette_number, int no_low_depth_gray)\n{\nif (*bit_depth == 0)\n{\n*colour_type = 0;\nif (no_low_depth_gray)\n*bit_depth = 8;\nelse\n*bit_depth = 1;\n*palette_number = 0;\nreturn 1;\n}\nif (*colour_type == 3)\n{\nif (++*palette_number < PALETTE_COUNT(*bit_depth))\nreturn 1;\n*palette_number = 0;\n}\n*bit_depth = (png_byte)(*bit_depth << 1);\nif (*bit_depth <= 8\n#     ifdef DO_16BIT\n|| (*colour_type != 3 && *bit_depth <= 16)\n#     endif\n)\nreturn 1;\nswitch (*colour_type)\n{\ncase 0:\n*colour_type = 2;\n*bit_depth = 8;\nreturn 1;\ncase 2:\n*colour_type = 3;\n*bit_depth = 1;\nreturn 1;\ncase 3:\n*colour_type = 4;\n*bit_depth = 8;\nreturn 1;\ncase 4:\n*colour_type = 6;\n*bit_depth = 8;\nreturn 1;\ndefault:\nreturn 0;\n}\n}", "contrast": "next_format(png_bytep colour_type, png_bytep bit_depth,\nunsigned int* palette_number, int low_depth_gray, int tRNS)\n{\nif (*bit_depth == 0)\n{\n*colour_type = 0;\nif (low_depth_gray)\n*bit_depth = 1;\nelse\n*bit_depth = 8;\n*palette_number = 0;\nreturn 1;\n}\nif  (*colour_type < 4 )\n{\nunsigned int pn = ++*palette_number;\npng_byte ct = *colour_type;\nif (((ct == 0  || ct  == 2) && tRNS && pn < 2) ||\n(ct == 3  && pn < PALETTE_COUNT(*bit_depth)))\nreturn 1;\n*palette_number = 0;\n}\n*bit_depth = (png_byte)(*bit_depth << 1);\nif (*bit_depth <= 8\n#ifdef DO_16BIT\n|| (*colour_type != 3 && *bit_depth <= 16)\n#endif\n)\nreturn 1;\nswitch (*colour_type)\n{\ncase 0:\n*colour_type = 2;\n*bit_depth = 8;\nreturn 1;\ncase 2:\n*colour_type = 3;\n*bit_depth = 1;\nreturn 1;\ncase 3:\n*colour_type = 4;\n*bit_depth = 8;\nreturn 1;\ncase 4:\n*colour_type = 6;\n*bit_depth = 8;\nreturn 1;\ndefault:\nreturn 0;\n}\n}", "label": 0}
{"index": 183035, "code": "perform_transform_test(png_modifier *pm)\n{\npng_byte colour_type = 0;\npng_byte bit_depth = 0;\nunsigned int palette_number = 0;\nwhile (next_format(&colour_type, &bit_depth, &palette_number, 0))\n{\npng_uint_32 counter = 0;\nsize_t base_pos;\nchar name[64];\nbase_pos = safecat(name, sizeof name, 0, \"transform:\");\nfor (;;)\n{\nsize_t pos = base_pos;\nPNG_CONST image_transform *list = 0;\ncounter = image_transform_add(&list, 1 , counter,\nname, sizeof name, &pos, colour_type, bit_depth);\nif (counter == 0)\nbreak;\ndo\n{\npm->repeat = 0;\ntransform_test(pm, FILEID(colour_type, bit_depth, palette_number,\npm->interlace_type, 0, 0, 0), list, name);\nif (fail(pm))\nreturn;\n}\nwhile (pm->repeat);\n}\n}\n}", "contrast": "perform_transform_test(png_modifier *pm)\n{\npng_byte colour_type = 0;\npng_byte bit_depth = 0;\nunsigned int palette_number = 0;\nwhile (next_format(&colour_type, &bit_depth, &palette_number, pm->test_lbg,\npm->test_tRNS))\n{\npng_uint_32 counter = 0;\nsize_t base_pos;\nchar name[64];\nbase_pos = safecat(name, sizeof name, 0, \"transform:\");\nfor (;;)\n{\nsize_t pos = base_pos;\nconst image_transform *list = 0;\ncounter = image_transform_add(&list, 1 , counter,\nname, sizeof name, &pos, colour_type, bit_depth);\nif (counter == 0)\nbreak;\ndo\n{\npm->repeat = 0;\ntransform_test(pm, FILEID(colour_type, bit_depth, palette_number,\npm->interlace_type, 0, 0, 0), list, name);\nif (fail(pm))\nreturn;\n}\nwhile (pm->repeat);\n}\n}\n}", "label": 0}
{"index": 183050, "code": "standard_info_part2(standard_display *dp, png_const_structp pp,\npng_const_infop pi, int nImages)\n{\ndp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),\npng_get_bit_depth(pp, pi));\ndp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;\ndp->cbRow = png_get_rowbytes(pp, pi);\nif (dp->cbRow != (dp->bit_width+7)/8)\npng_error(pp, \"bad png_get_rowbytes calculation\");\nstore_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);\n}", "contrast": "standard_info_part2(standard_display *dp, png_const_structp pp,\npng_const_infop pi, int nImages)\n{\n{\npng_byte ct = png_get_color_type(pp, pi);\npng_byte bd = png_get_bit_depth(pp, pi);\nif (bd >= 8 && (ct == PNG_COLOR_TYPE_RGB || ct == PNG_COLOR_TYPE_GRAY) &&\ndp->filler)\nct |= 4;\ndp->pixel_size = bit_size(pp, ct, bd);\n}\ndp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;\ndp->cbRow = png_get_rowbytes(pp, pi);\nif (dp->cbRow != (dp->bit_width+7)/8)\npng_error(pp, \"bad png_get_rowbytes calculation\");\nstore_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);\n}", "label": 0}
{"index": 183084, "code": "main(void)\n{\nfprintf(stderr, \"pngfix does not work without read support\\n\");\nreturn 77;\n}", "contrast": "main(void)\n{\nfprintf(stderr, \"pngfix does not work without read deinterlace support\\n\");\nreturn 77;\n}", "label": 0}
{"index": 183094, "code": "WORD32 ih264d_process_intra_mb(dec_struct_t * ps_dec,\ndec_mb_info_t * ps_cur_mb_info,\nUWORD8 u1_mb_num)\n{\nUWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;\nUWORD8 uc_temp = ps_cur_mb_info->u1_mb_ngbr_availablity;\nUWORD8 u1_top_available = BOOLEAN(uc_temp & TOP_MB_AVAILABLE_MASK);\nUWORD8 u1_left_available = BOOLEAN(uc_temp & LEFT_MB_AVAILABLE_MASK);\nUWORD8 u1_use_top_right_mb = BOOLEAN(uc_temp & TOP_RIGHT_MB_AVAILABLE_MASK);\nUWORD8 u1_use_top_left_mb = BOOLEAN(uc_temp & TOP_LEFT_MB_AVAILABLE_MASK);\nUWORD8 uc_useTopMB = u1_top_available;\nUWORD16 u2_use_left_mb = u1_left_available;\nUWORD16 u2_use_left_mb_pack;\nUWORD8 *pu1_luma_pred_buffer;\nUWORD8 *pu1_luma_rec_buffer;\nUWORD8 *puc_top;\nmb_neigbour_params_t *ps_left_mb;\nmb_neigbour_params_t *ps_top_mb;\nmb_neigbour_params_t *ps_top_right_mb;\nmb_neigbour_params_t *ps_curmb;\nUWORD16 u2_mbx = ps_cur_mb_info->u2_mbx;\nUWORD32 ui_pred_width, ui_rec_width;\nWORD16 *pi2_y_coeff;\nUWORD8 u1_mbaff, u1_topmb, u1_mb_field_decoding_flag;\nUWORD32 u4_num_pmbair;\nUWORD16 ui2_luma_csbp = ps_cur_mb_info->u2_luma_csbp;\nUWORD8 *pu1_yleft, *pu1_ytop_left;\nUWORD8 *pu1_top_u;\nUWORD8 *pu1_uleft;\nUWORD8 *pu1_u_top_left;\nUWORD8 *pu1_mb_cb_rei1_buffer, *pu1_mb_cr_rei1_buffer;\nUWORD32 u4_recwidth_cr;\ntfr_ctxt_t *ps_frame_buf = ps_dec->ps_frame_buf_ip_recon;\nUWORD32 u4_luma_dc_only_csbp = 0;\nUWORD32 u4_luma_dc_only_cbp = 0;\nUWORD8 *pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;\nu1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;\nu1_topmb = ps_cur_mb_info->u1_topmb;\nu4_num_pmbair = (u1_mb_num >> u1_mbaff);\nu1_mb_field_decoding_flag = ps_cur_mb_info->u1_mb_field_decodingflag;\nps_curmb = ps_cur_mb_info->ps_curmb;\nps_top_mb = ps_cur_mb_info->ps_top_mb;\nps_left_mb = ps_cur_mb_info->ps_left_mb;\nps_top_right_mb = ps_cur_mb_info->ps_top_right_mb;\nu2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\nif(ps_dec->ps_cur_pps->u1_constrained_intra_pred_flag)\n{\nUWORD8 u1_left = (UWORD8)u2_use_left_mb;\nuc_useTopMB = uc_useTopMB\n&& ((ps_top_mb->u1_mb_type != P_MB)\n&& (ps_top_mb->u1_mb_type != B_MB));\nu2_use_left_mb = u2_use_left_mb\n&& ((ps_left_mb->u1_mb_type != P_MB)\n&& (ps_left_mb->u1_mb_type != B_MB));\nu2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\nif(u1_mbaff)\n{\nif(u1_mb_field_decoding_flag ^ ps_left_mb->u1_mb_fld)\n{\nu1_left = u1_left\n&& (((ps_left_mb + 1)->u1_mb_type != P_MB)\n&& ((ps_left_mb + 1)->u1_mb_type\n!= B_MB));\nu2_use_left_mb = u2_use_left_mb && u1_left;\nif(u1_mb_field_decoding_flag)\nu2_use_left_mb_pack = (u1_left << 8)\n+ (u2_use_left_mb_pack & 0xff);\nelse\nu2_use_left_mb_pack = (u2_use_left_mb << 8)\n+ (u2_use_left_mb);\n}\n}\nu1_use_top_right_mb =\nu1_use_top_right_mb\n&& ((ps_top_right_mb->u1_mb_type != P_MB)\n&& (ps_top_right_mb->u1_mb_type\n!= B_MB));\nu1_use_top_left_mb =\nu1_use_top_left_mb\n&& ((ps_cur_mb_info->u1_topleft_mbtype != P_MB)\n&& (ps_cur_mb_info->u1_topleft_mbtype\n!= B_MB));\n}\npu1_luma_pred_buffer = ps_dec->pu1_y;\npu1_luma_rec_buffer = ps_frame_buf->pu1_dest_y + (u4_num_pmbair << 4);\npu1_mb_cb_rei1_buffer = ps_frame_buf->pu1_dest_u\n+ (u4_num_pmbair << 3) * YUV420SP_FACTOR;\npu1_mb_cr_rei1_buffer = ps_frame_buf->pu1_dest_v + (u4_num_pmbair << 3);\nui_pred_width = MB_SIZE;\nui_rec_width = ps_dec->u2_frm_wd_y << u1_mb_field_decoding_flag;\nu4_recwidth_cr = ps_dec->u2_frm_wd_uv << u1_mb_field_decoding_flag;\nif(u1_mbaff)\n{\nif(u1_topmb == 0)\n{\npu1_luma_rec_buffer += (\nu1_mb_field_decoding_flag ?\n(ui_rec_width >> 1) :\n(ui_rec_width << 4));\npu1_mb_cb_rei1_buffer += (\nu1_mb_field_decoding_flag ?\n(u4_recwidth_cr >> 1) :\n(u4_recwidth_cr << 3));\npu1_mb_cr_rei1_buffer += (\nu1_mb_field_decoding_flag ?\n(u4_recwidth_cr >> 1) :\n(u4_recwidth_cr << 3));\n}\n}\nif(ps_dec->u4_use_intrapred_line_copy == 1)\n{\npuc_top = ps_dec->pu1_prev_y_intra_pred_line + (ps_cur_mb_info->u2_mbx << 4);\npu1_top_u = ps_dec->pu1_prev_u_intra_pred_line\n+ (ps_cur_mb_info->u2_mbx << 3) * YUV420SP_FACTOR;\n}\nelse\n{\npuc_top = pu1_luma_rec_buffer - ui_rec_width;\npu1_top_u = pu1_mb_cb_rei1_buffer - u4_recwidth_cr;\n}\npu1_yleft = pu1_luma_rec_buffer - 1;\npu1_uleft = pu1_mb_cb_rei1_buffer - 1 * YUV420SP_FACTOR;\npu1_ytop_left = puc_top - 1;\npu1_u_top_left = pu1_top_u - 1 * YUV420SP_FACTOR;\nPROFILE_DISABLE_INTRA_PRED()\n{\npu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;\nif(u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 0)\n{\nps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 32);\n}\nelse if (u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 1)\n{\nps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 8);\n}\n}\nif(!ps_cur_mb_info->u1_tran_form8x8)\n{\nu4_luma_dc_only_csbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\nps_cur_mb_info,\n1);\n}\nelse\n{\nif(!ps_dec->ps_cur_pps->u1_entropy_coding_mode)\n{\nu4_luma_dc_only_cbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\nps_cur_mb_info,\n1);\n}\nelse\n{\nu4_luma_dc_only_cbp = ih264d_unpack_luma_coeff8x8_mb(ps_dec,\nps_cur_mb_info);\n}\n}\npi2_y_coeff = ps_dec->pi2_coeff_data;\nif(u1_mb_type != I_4x4_MB)\n{\nUWORD8 u1_intrapred_mode = MB_TYPE_TO_INTRA_16x16_MODE(u1_mb_type);\n{\nUWORD8 u1_packed_modes = (u1_top_available << 1)\n+ u1_left_available;\nUWORD8 u1_err_code =\n(u1_intrapred_mode & 1) ?\nu1_intrapred_mode :\n(u1_intrapred_mode ^ 2);\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\nu1_intrapred_mode = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\n{\nUWORD8 au1_ngbr_pels[33];\nif(u2_use_left_mb)\n{\nWORD32 i;\nfor(i = 0; i < 16; i++)\nau1_ngbr_pels[16 - 1 - i] = pu1_yleft[i * ui_rec_width];\n}\nelse\n{\nmemset(au1_ngbr_pels, 0, 16);\n}\nau1_ngbr_pels[16] = *pu1_ytop_left;\nif(uc_useTopMB)\n{\nmemcpy(au1_ngbr_pels + 16 + 1, puc_top, 16);\n}\nelse\n{\nmemset(au1_ngbr_pels + 16 + 1, 0, 16);\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_luma_16x16[u1_intrapred_mode](\nau1_ngbr_pels, pu1_luma_rec_buffer, 1, ui_rec_width,\n((uc_useTopMB << 2) | u2_use_left_mb));\n}\n{\nUWORD32 i;\nWORD16 ai2_tmp[16];\nfor(i = 0; i < 16; i++)\n{\nWORD16 *pi2_level = pi2_y_coeff + (i << 4);\nUWORD8 *pu1_pred_sblk = pu1_luma_rec_buffer\n+ ((i & 0x3) * BLK_SIZE)\n+ (i >> 2) * (ui_rec_width << 2);\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(ps_cur_mb_info->u2_luma_csbp, i))\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\npi2_level);\n}\nelse if((CHECKBIT(u4_luma_dc_only_csbp, i)) && pi2_level[0] != 0)\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\npi2_level);\n}\n}\n}\n}\n}\nelse if(!ps_cur_mb_info->u1_tran_form8x8)\n{\nUWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\nUWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\nWORD8 i1_top_pred_mode;\nWORD8 i1_left_pred_mode;\nUWORD8 *pu1_top, *pu1_left, *pu1_top_left, *pu1_top_right;\nWORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\nUWORD16 ui2_left_pred_buf_width = 0xffff;\nWORD8 i1_intra_pred;\nUWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\nUWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 16;\nWORD16 *pi2_y_coeff1;\nUWORD8 u1_cur_sub_block;\nUWORD16 ui2_top_rt_mask;\npu1_top = puc_top;\nui2_top_rt_mask = (u1_use_top_right_mb << 3) | (0x5750);\nif(uc_useTopMB)\nui2_top_rt_mask |= 0x7;\npi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\npc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\nif(u1_top_available)\n{\nif(ps_top_mb->u1_mb_type == I_4x4_MB)\n*(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\nelse\n*(WORD32*)pi1_cur_pred_mode =\n(uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n}\nelse\n*(WORD32*)pi1_cur_pred_mode = NOT_VALID;\npi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\nif(!u1_mbaff)\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\nelse\n{\nUWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\nUWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\nif(u1_curMbfld ^ u1_leftMbfld)\n{\nif(u1_topmb\n| ((u1_topmb == 0)\n&& ((ps_curmb - 1)->u1_mb_type\n!= I_4x4_MB)))\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\nif(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\nelse\n*(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n}\n}\nelse\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\nif(u1_curMbfld)\n{\nif(u1_left_available)\n{\nif((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n{\nif(u2_use_left_mb_pack >> 8)\n*(WORD32*)(pi1_left_pred_mode + 4) =\nDC_DC_DC_DC;\nelse\n*(WORD32*)(pi1_left_pred_mode + 4) =\nNOT_VALID;\n}\n}\nelse\n*(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\npi1_left_pred_mode[1] = pi1_left_pred_mode[2];\npi1_left_pred_mode[2] = pi1_left_pred_mode[4];\npi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n*(WORD32*)(pi1_left_pred_mode + 4) =\n*(WORD32*)pi1_left_pred_mode;\n}\nelse\n{\npi1_left_pred_mode[7] = pi1_left_pred_mode[3];\npi1_left_pred_mode[6] = pi1_left_pred_mode[3];\npi1_left_pred_mode[5] = pi1_left_pred_mode[2];\npi1_left_pred_mode[4] = pi1_left_pred_mode[2];\npi1_left_pred_mode[3] = pi1_left_pred_mode[1];\npi1_left_pred_mode[2] = pi1_left_pred_mode[1];\npi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n}\n}\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n}\nelse\n{\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\nelse\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\npi2_y_coeff1 = pi2_y_coeff;\npu1_top_left = pu1_ytop_left;\nfor(u1_sub_mb_num = 0; u1_sub_mb_num < 16; u1_sub_mb_num++)\n{\nUWORD8 au1_ngbr_pels[13];\nu1_sub_blk_x = u1_sub_mb_num & 0x3;\nu1_sub_blk_y = u1_sub_mb_num >> 2;\ni1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x];\ni1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y];\nu1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\nif(u1_sub_blk_x)\nu1_is_left_sub_block = 1;\nelse\nu1_is_left_sub_block =\n(u1_sub_blk_y < 2) ?\n(CHECKBIT(u2_use_left_mb_pack,\n0)) :\n(u2_use_left_mb_pack >> 8);\nif(u1_sub_blk_y)\nu1_is_top_sub_block = 1;\nif(ps_dec->u4_use_intrapred_line_copy == 1)\n{\nif(u1_sub_blk_y)\npu1_top = pu1_luma_rec_buffer - ui_rec_width;\nelse\npu1_top = puc_top + (u1_sub_blk_x << 2);\n}\nelse\n{\npu1_top = pu1_luma_rec_buffer - ui_rec_width;\n}\npu1_top_right = pu1_top + 4;\npu1_top_left = pu1_top - 1;\npu1_left = pu1_luma_rec_buffer - 1;\ni1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\nDC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n{\nUWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n+ u1_is_left_sub_block;\nUWORD8 *pu1_intra_err_codes =\n(UWORD8 *)gau1_ih264d_intra_pred_err_code;\nUWORD8 uc_b2b0 = ((u1_sub_mb_num & 4) >> 1) | (u1_sub_mb_num & 1);\nUWORD8 uc_b3b1 = ((u1_sub_mb_num & 8) >> 2)\n| ((u1_sub_mb_num & 2) >> 1);\nu1_cur_sub_block = (uc_b3b1 << 2) + uc_b2b0;\nPROFILE_DISABLE_INTRA_PRED()\nif(!pu1_prev_intra4x4_pred_mode_flag[u1_cur_sub_block])\n{\ni1_intra_pred =\npu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n+ (pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n>= i1_intra_pred);\n}\n{\nUWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\ni1_intra_pred = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\n}\n{\nif(u1_is_left_sub_block)\n{\nWORD32 i;\nfor(i = 0; i < 4; i++)\nau1_ngbr_pels[4 - 1 - i] = pu1_left[i * ui_rec_width];\n}\nelse\n{\nmemset(au1_ngbr_pels, 0, 4);\n}\nau1_ngbr_pels[4] = *pu1_top_left;\nif(u1_is_top_sub_block)\n{\nmemcpy(au1_ngbr_pels + 4 + 1, pu1_top, 4);\n}\nelse\n{\nmemset(au1_ngbr_pels + 4 + 1, 0, 4);\n}\nif(u1_use_top_right_mb)\n{\nmemcpy(au1_ngbr_pels + 4 * 2 + 1, pu1_top_right, 4);\n}\nelse if(u1_is_top_sub_block)\n{\nmemset(au1_ngbr_pels + 4 * 2 + 1, au1_ngbr_pels[4 * 2], 4);\n}\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_luma_4x4[i1_intra_pred](\nau1_ngbr_pels, pu1_luma_rec_buffer, 1,\nui_rec_width,\n((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\nif(CHECKBIT(ui2_luma_csbp, u1_sub_mb_num))\n{\nWORD16 ai2_tmp[16];\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u4_luma_dc_only_csbp, u1_sub_mb_num))\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\nelse\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\n}\n}\npi2_y_coeff1 += 16;\npu1_luma_rec_buffer +=\n(u1_sub_blk_x == 3) ? (ui_rec_width << 2) - 12 : 4;\npu1_luma_pred_buffer +=\n(u1_sub_blk_x == 3) ? (ui_pred_width << 2) - 12 : 4;\npi1_cur_pred_mode[u1_sub_blk_x] = i1_intra_pred;\npi1_left_pred_mode[u1_sub_blk_y] = i1_intra_pred;\n}\n}\nelse if((u1_mb_type == I_4x4_MB) && (ps_cur_mb_info->u1_tran_form8x8 == 1))\n{\nUWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\nUWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\nWORD8 i1_top_pred_mode;\nWORD8 i1_left_pred_mode;\nUWORD8 *pu1_top, *pu1_left, *pu1_top_left;\nWORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\nUWORD16 ui2_left_pred_buf_width = 0xffff;\nWORD8 i1_intra_pred;\nUWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\nUWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 4;\nWORD16 *pi2_y_coeff1;\nUWORD16 ui2_top_rt_mask;\nUWORD32 u4_4x4_left_offset = 0;\nui2_top_rt_mask = (u1_use_top_right_mb << 1) | (0x4);\nif(uc_useTopMB)\n{\nui2_top_rt_mask |= 0x1;\n}\npi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\npc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\nif(u1_top_available)\n{\nif(ps_top_mb->u1_mb_type == I_4x4_MB)\n{\n*(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\n}\nelse\n{\n*(WORD32*)pi1_cur_pred_mode =\n(uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n}\n}\nelse\n{\n*(WORD32*)pi1_cur_pred_mode = NOT_VALID;\n}\npu1_top = puc_top - 8;\npi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\nif(!u1_mbaff)\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\nelse\n{\nUWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\nUWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\nif((!u1_curMbfld) && (u1_leftMbfld))\n{\nu4_4x4_left_offset = 1;\n}\nif(u1_curMbfld ^ u1_leftMbfld)\n{\nif(u1_topmb\n| ((u1_topmb == 0)\n&& ((ps_curmb - 1)->u1_mb_type\n!= I_4x4_MB)))\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\nif(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n}\n}\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\nif(u1_curMbfld)\n{\nif(u1_left_available)\n{\nif((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n{\nif(u2_use_left_mb_pack >> 8)\n{\n*(WORD32*)(pi1_left_pred_mode + 4) =\nDC_DC_DC_DC;\n}\nelse\n{\n*(WORD32*)(pi1_left_pred_mode + 4) =\nNOT_VALID;\n}\n}\n}\nelse\n{\n*(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\n}\npi1_left_pred_mode[1] = pi1_left_pred_mode[2];\npi1_left_pred_mode[2] = pi1_left_pred_mode[4];\npi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n*(WORD32*)(pi1_left_pred_mode + 4) =\n*(WORD32*)pi1_left_pred_mode;\n}\nelse\n{\npi1_left_pred_mode[7] = pi1_left_pred_mode[3];\npi1_left_pred_mode[6] = pi1_left_pred_mode[3];\npi1_left_pred_mode[5] = pi1_left_pred_mode[2];\npi1_left_pred_mode[4] = pi1_left_pred_mode[2];\npi1_left_pred_mode[3] = pi1_left_pred_mode[1];\npi1_left_pred_mode[2] = pi1_left_pred_mode[1];\npi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n}\n}\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n}\nelse\n{\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\n}\npi2_y_coeff1 = pi2_y_coeff;\nif(u1_use_top_left_mb)\n{\npu1_top_left = pu1_ytop_left;\n}\nelse\n{\npu1_top_left = NULL;\n}\nfor(u1_sub_mb_num = 0; u1_sub_mb_num < 4; u1_sub_mb_num++)\n{\nu1_sub_blk_x = (u1_sub_mb_num & 0x1);\nu1_sub_blk_y = (u1_sub_mb_num >> 1);\ni1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x << 1];\ni1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y << 1];\nif(2 == u1_sub_mb_num)\n{\ni1_left_pred_mode = pi1_left_pred_mode[(u1_sub_blk_y << 1)\n+ u4_4x4_left_offset];\n}\nu1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\nif(u1_sub_blk_x)\n{\nu1_is_left_sub_block = 1;\n}\nelse\n{\nu1_is_left_sub_block =\n(u1_sub_blk_y < 1) ?\n(CHECKBIT(u2_use_left_mb_pack,\n0)) :\n(u2_use_left_mb_pack >> 8);\n}\nif(u1_sub_blk_y)\n{\nu1_is_top_sub_block = 1;\npu1_top =  pu1_luma_rec_buffer - ui_rec_width;\n}\nelse\n{\npu1_top += 8;\n}\nif((u1_sub_blk_x) | (u4_num_pmbair != 0))\n{\npu1_left =  pu1_luma_rec_buffer - 1;\nui2_left_pred_buf_width = ui_rec_width;\n}\nelse\n{\npu1_left = pu1_yleft;\npu1_yleft += (ui_rec_width << 3);\nui2_left_pred_buf_width = ui_rec_width;\n}\nif(u1_sub_mb_num)\n{\npu1_top_left = (u1_sub_blk_x) ?\npu1_top - 1 : pu1_left - ui_rec_width;\nif((u1_sub_blk_x && (!u1_is_top_sub_block))\n|| ((!u1_sub_blk_x) && (!u1_is_left_sub_block)))\n{\npu1_top_left = NULL;\n}\n}\ni1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\nDC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n{\nUWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n+ u1_is_left_sub_block;\nUWORD8 *pu1_intra_err_codes =\n(UWORD8 *)gau1_ih264d_intra_pred_err_code;\nPROFILE_DISABLE_INTRA_PRED()\nif(!pu1_prev_intra4x4_pred_mode_flag[u1_sub_mb_num])\n{\ni1_intra_pred = pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n+ (pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n>= i1_intra_pred);\n}\n{\nUWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\ni1_intra_pred = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\n}\n{\nUWORD8 au1_ngbr_pels[25];\nWORD32 ngbr_avail;\nngbr_avail = u1_is_left_sub_block << 0;\nngbr_avail |= u1_is_top_sub_block << 2;\nif(pu1_top_left)\nngbr_avail |= 1 << 1;\nngbr_avail |= u1_use_top_right_mb << 3;\nPROFILE_DISABLE_INTRA_PRED()\n{\nps_dec->pf_intra_pred_ref_filtering(pu1_left, pu1_top_left,\npu1_top, au1_ngbr_pels,\nui2_left_pred_buf_width,\nngbr_avail);\nps_dec->apf_intra_pred_luma_8x8[i1_intra_pred](\nau1_ngbr_pels, pu1_luma_rec_buffer, 1,\nui_rec_width,\n((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\n}\n}\nif(CHECKBIT(ps_cur_mb_info->u1_cbp, u1_sub_mb_num))\n{\nWORD16 *pi2_scale_matrix_ptr;\nWORD16 ai2_tmp[64];\npi2_scale_matrix_ptr =\nps_dec->s_high_profile.i2_scalinglist8x8[0];\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u4_luma_dc_only_cbp, u1_sub_mb_num))\n{\nps_dec->pf_iquant_itrans_recon_luma_8x8_dc(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)pi2_scale_matrix_ptr,\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\nelse\n{\nps_dec->pf_iquant_itrans_recon_luma_8x8(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)pi2_scale_matrix_ptr,\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\n}\n}\npi2_y_coeff1 += 64;\npu1_luma_rec_buffer +=\n(u1_sub_blk_x == 1) ?\n(ui_rec_width << 3) - (8 * 1) : 8;\npi1_cur_pred_mode[u1_sub_blk_x << 1] = i1_intra_pred;\npi1_cur_pred_mode[(u1_sub_blk_x << 1) + 1] = i1_intra_pred;\npi1_left_pred_mode[u1_sub_blk_y << 1] = i1_intra_pred;\npi1_left_pred_mode[(u1_sub_blk_y << 1) + 1] = i1_intra_pred;\n}\n}\nih264d_unpack_chroma_coeff4x4_mb(ps_dec,\nps_cur_mb_info);\n{\nUWORD8 u1_intra_chrom_pred_mode;\nUWORD8 u1_chroma_cbp = (UWORD8)(ps_cur_mb_info->u1_cbp >> 4);\nu1_intra_chrom_pred_mode = CHROMA_TO_LUMA_INTRA_MODE(\nps_cur_mb_info->u1_chroma_pred_mode);\n{\nUWORD8 u1_packed_modes = (u1_top_available << 1)\n+ u1_left_available;\nUWORD8 u1_err_code =\n(u1_intra_chrom_pred_mode & 1) ?\nu1_intra_chrom_pred_mode :\n(u1_intra_chrom_pred_mode ^ 2);\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\nu1_intra_chrom_pred_mode = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\nif(u1_chroma_cbp != CBPC_ALLZERO)\n{\nUWORD16 u2_chroma_csbp =\n(u1_chroma_cbp == CBPC_ACZERO) ?\n0 : ps_cur_mb_info->u2_chroma_csbp;\nUWORD32 u4_scale_u;\nUWORD32 u4_scale_v;\n{\nUWORD16 au2_ngbr_pels[33];\nUWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\nUWORD16 *pu2_left_uv;\nUWORD16 *pu2_topleft_uv;\nWORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\nWORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\npu2_left_uv = (UWORD16 *)pu1_uleft;\npu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\nif(u2_use_left_mb_pack)\n{\nWORD32 i;\nif(use_left1)\n{\nfor(i = 0; i < 4; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n}\nif(use_left2)\n{\nfor(i = 4; i < 8; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n}\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n}\nau2_ngbr_pels[8] = *pu2_topleft_uv;\nif(uc_useTopMB)\n{\nmemcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n8 * sizeof(UWORD16));\n}\nelse\n{\nmemset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\npu1_ngbr_pels,\npu1_mb_cb_rei1_buffer,\n1,\nu4_recwidth_cr,\n((uc_useTopMB << 2) | (use_left2 << 4)\n| use_left1));\n}\nu4_scale_u = ps_cur_mb_info->u1_qpc_div6;\nu4_scale_v = ps_cur_mb_info->u1_qpcr_div6;\npi2_y_coeff = ps_dec->pi2_coeff_data;\n{\nUWORD32 i;\nWORD16 ai2_tmp[16];\nfor(i = 0; i < 4; i++)\n{\nWORD16 *pi2_level = pi2_y_coeff + (i << 4);\nUWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer\n+ ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n+ (i >> 1) * (u4_recwidth_cr << 2);\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u2_chroma_csbp, i))\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\nu4_scale_u, ai2_tmp, pi2_level);\n}\nelse if(pi2_level[0] != 0)\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\nu4_scale_u, ai2_tmp, pi2_level);\n}\n}\n}\n}\npi2_y_coeff += MB_CHROM_SIZE;\nu2_chroma_csbp = u2_chroma_csbp >> 4;\n{\nUWORD32 i;\nWORD16 ai2_tmp[16];\nfor(i = 0; i < 4; i++)\n{\nWORD16 *pi2_level = pi2_y_coeff + (i << 4);\nUWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer + 1\n+ ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n+ (i >> 1) * (u4_recwidth_cr << 2);\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u2_chroma_csbp, i))\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\nu4_scale_v, ai2_tmp, pi2_level);\n}\nelse if(pi2_level[0] != 0)\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\nu4_scale_v, ai2_tmp, pi2_level);\n}\n}\n}\n}\n}\nelse\n{\n{\nUWORD16 au2_ngbr_pels[33];\nUWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\nUWORD16 *pu2_left_uv;\nUWORD16 *pu2_topleft_uv;\nWORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\nWORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\npu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\npu2_left_uv = (UWORD16 *)pu1_uleft;\nif(u2_use_left_mb_pack)\n{\nWORD32 i;\nif(use_left1)\n{\nfor(i = 0; i < 4; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n}\nif(use_left2)\n{\nfor(i = 4; i < 8; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n}\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n}\nau2_ngbr_pels[8] = *pu2_topleft_uv;\nif(uc_useTopMB)\n{\nmemcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n8 * sizeof(UWORD16));\n}\nelse\n{\nmemset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\npu1_ngbr_pels,\npu1_mb_cb_rei1_buffer,\n1,\nu4_recwidth_cr,\n((uc_useTopMB << 2) | (use_left2 << 4)\n| use_left1));\n}\n}\n}\nreturn OK;\n}", "contrast": "WORD32 ih264d_process_intra_mb(dec_struct_t * ps_dec,\ndec_mb_info_t * ps_cur_mb_info,\nUWORD8 u1_mb_num)\n{\nUWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;\nUWORD8 uc_temp = ps_cur_mb_info->u1_mb_ngbr_availablity;\nUWORD8 u1_top_available = BOOLEAN(uc_temp & TOP_MB_AVAILABLE_MASK);\nUWORD8 u1_left_available = BOOLEAN(uc_temp & LEFT_MB_AVAILABLE_MASK);\nUWORD8 u1_use_top_right_mb = BOOLEAN(uc_temp & TOP_RIGHT_MB_AVAILABLE_MASK);\nUWORD8 u1_use_top_left_mb = BOOLEAN(uc_temp & TOP_LEFT_MB_AVAILABLE_MASK);\nUWORD8 uc_useTopMB = u1_top_available;\nUWORD16 u2_use_left_mb = u1_left_available;\nUWORD16 u2_use_left_mb_pack;\nUWORD8 *pu1_luma_pred_buffer;\nUWORD8 *pu1_luma_rec_buffer;\nUWORD8 *puc_top;\nmb_neigbour_params_t *ps_left_mb;\nmb_neigbour_params_t *ps_top_mb;\nmb_neigbour_params_t *ps_top_right_mb;\nmb_neigbour_params_t *ps_curmb;\nUWORD16 u2_mbx = ps_cur_mb_info->u2_mbx;\nUWORD32 ui_pred_width, ui_rec_width;\nWORD16 *pi2_y_coeff;\nUWORD8 u1_mbaff, u1_topmb, u1_mb_field_decoding_flag;\nUWORD32 u4_num_pmbair;\nUWORD16 ui2_luma_csbp = ps_cur_mb_info->u2_luma_csbp;\nUWORD8 *pu1_yleft, *pu1_ytop_left;\nUWORD8 *pu1_top_u;\nUWORD8 *pu1_uleft;\nUWORD8 *pu1_u_top_left;\nUWORD8 *pu1_mb_cb_rei1_buffer, *pu1_mb_cr_rei1_buffer;\nUWORD32 u4_recwidth_cr;\ntfr_ctxt_t *ps_frame_buf = ps_dec->ps_frame_buf_ip_recon;\nUWORD32 u4_luma_dc_only_csbp = 0;\nUWORD32 u4_luma_dc_only_cbp = 0;\nUWORD8 *pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;\nu1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;\nu1_topmb = ps_cur_mb_info->u1_topmb;\nu4_num_pmbair = (u1_mb_num >> u1_mbaff);\nu1_mb_field_decoding_flag = ps_cur_mb_info->u1_mb_field_decodingflag;\nps_curmb = ps_cur_mb_info->ps_curmb;\nps_top_mb = ps_cur_mb_info->ps_top_mb;\nps_left_mb = ps_cur_mb_info->ps_left_mb;\nps_top_right_mb = ps_cur_mb_info->ps_top_right_mb;\nu2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\nif(ps_dec->ps_cur_pps->u1_constrained_intra_pred_flag)\n{\nUWORD8 u1_left = (UWORD8)u2_use_left_mb;\nuc_useTopMB = uc_useTopMB\n&& ((ps_top_mb->u1_mb_type != P_MB)\n&& (ps_top_mb->u1_mb_type != B_MB));\nu2_use_left_mb = u2_use_left_mb\n&& ((ps_left_mb->u1_mb_type != P_MB)\n&& (ps_left_mb->u1_mb_type != B_MB));\nu2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\nif(u1_mbaff)\n{\nif(u1_mb_field_decoding_flag ^ ps_left_mb->u1_mb_fld)\n{\nu1_left = u1_left\n&& (((ps_left_mb + 1)->u1_mb_type != P_MB)\n&& ((ps_left_mb + 1)->u1_mb_type\n!= B_MB));\nu2_use_left_mb = u2_use_left_mb && u1_left;\nif(u1_mb_field_decoding_flag)\nu2_use_left_mb_pack = (u1_left << 8)\n+ (u2_use_left_mb_pack & 0xff);\nelse\nu2_use_left_mb_pack = (u2_use_left_mb << 8)\n+ (u2_use_left_mb);\n}\n}\nu1_use_top_right_mb =\nu1_use_top_right_mb\n&& ((ps_top_right_mb->u1_mb_type != P_MB)\n&& (ps_top_right_mb->u1_mb_type\n!= B_MB));\nu1_use_top_left_mb =\nu1_use_top_left_mb\n&& ((ps_cur_mb_info->u1_topleft_mbtype != P_MB)\n&& (ps_cur_mb_info->u1_topleft_mbtype\n!= B_MB));\n}\npu1_luma_pred_buffer = ps_dec->pu1_y;\npu1_luma_rec_buffer = ps_frame_buf->pu1_dest_y + (u4_num_pmbair << 4);\npu1_mb_cb_rei1_buffer = ps_frame_buf->pu1_dest_u\n+ (u4_num_pmbair << 3) * YUV420SP_FACTOR;\npu1_mb_cr_rei1_buffer = ps_frame_buf->pu1_dest_v + (u4_num_pmbair << 3);\nui_pred_width = MB_SIZE;\nui_rec_width = ps_dec->u2_frm_wd_y << u1_mb_field_decoding_flag;\nu4_recwidth_cr = ps_dec->u2_frm_wd_uv << u1_mb_field_decoding_flag;\nif(u1_mbaff)\n{\nif(u1_topmb == 0)\n{\npu1_luma_rec_buffer += (\nu1_mb_field_decoding_flag ?\n(ui_rec_width >> 1) :\n(ui_rec_width << 4));\npu1_mb_cb_rei1_buffer += (\nu1_mb_field_decoding_flag ?\n(u4_recwidth_cr >> 1) :\n(u4_recwidth_cr << 3));\npu1_mb_cr_rei1_buffer += (\nu1_mb_field_decoding_flag ?\n(u4_recwidth_cr >> 1) :\n(u4_recwidth_cr << 3));\n}\n}\nif(ps_dec->u4_use_intrapred_line_copy == 1)\n{\npuc_top = ps_dec->pu1_prev_y_intra_pred_line + (ps_cur_mb_info->u2_mbx << 4);\npu1_top_u = ps_dec->pu1_prev_u_intra_pred_line\n+ (ps_cur_mb_info->u2_mbx << 3) * YUV420SP_FACTOR;\n}\nelse\n{\npuc_top = pu1_luma_rec_buffer - ui_rec_width;\npu1_top_u = pu1_mb_cb_rei1_buffer - u4_recwidth_cr;\n}\npu1_yleft = pu1_luma_rec_buffer - 1;\npu1_uleft = pu1_mb_cb_rei1_buffer - 1 * YUV420SP_FACTOR;\npu1_ytop_left = puc_top - 1;\npu1_u_top_left = pu1_top_u - 1 * YUV420SP_FACTOR;\nPROFILE_DISABLE_INTRA_PRED()\n{\npu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;\nif(u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 0)\n{\nps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 32);\n}\nelse if (u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 1)\n{\nps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 8);\n}\n}\nif(!ps_cur_mb_info->u1_tran_form8x8)\n{\nu4_luma_dc_only_csbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\nps_cur_mb_info,\n1);\n}\nelse\n{\nif(!ps_dec->ps_cur_pps->u1_entropy_coding_mode)\n{\nu4_luma_dc_only_cbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\nps_cur_mb_info,\n1);\n}\nelse\n{\nu4_luma_dc_only_cbp = ih264d_unpack_luma_coeff8x8_mb(ps_dec,\nps_cur_mb_info);\n}\n}\npi2_y_coeff = ps_dec->pi2_coeff_data;\nif(u1_mb_type != I_4x4_MB)\n{\nUWORD8 u1_intrapred_mode = MB_TYPE_TO_INTRA_16x16_MODE(u1_mb_type);\n{\nUWORD8 u1_packed_modes = (u1_top_available << 1)\n+ u1_left_available;\nUWORD8 u1_err_code =\n(u1_intrapred_mode & 1) ?\nu1_intrapred_mode :\n(u1_intrapred_mode ^ 2);\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\nu1_intrapred_mode = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\n{\nUWORD8 au1_ngbr_pels[33];\nif(u2_use_left_mb)\n{\nWORD32 i;\nfor(i = 0; i < 16; i++)\nau1_ngbr_pels[16 - 1 - i] = pu1_yleft[i * ui_rec_width];\n}\nelse\n{\nmemset(au1_ngbr_pels, 0, 16);\n}\nau1_ngbr_pels[16] = *pu1_ytop_left;\nif(uc_useTopMB)\n{\nmemcpy(au1_ngbr_pels + 16 + 1, puc_top, 16);\n}\nelse\n{\nmemset(au1_ngbr_pels + 16 + 1, 0, 16);\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_luma_16x16[u1_intrapred_mode](\nau1_ngbr_pels, pu1_luma_rec_buffer, 1, ui_rec_width,\n((uc_useTopMB << 2) | u2_use_left_mb));\n}\n{\nUWORD32 i;\nWORD16 ai2_tmp[16];\nfor(i = 0; i < 16; i++)\n{\nWORD16 *pi2_level = pi2_y_coeff + (i << 4);\nUWORD8 *pu1_pred_sblk = pu1_luma_rec_buffer\n+ ((i & 0x3) * BLK_SIZE)\n+ (i >> 2) * (ui_rec_width << 2);\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(ps_cur_mb_info->u2_luma_csbp, i))\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\npi2_level);\n}\nelse if((CHECKBIT(u4_luma_dc_only_csbp, i)) && pi2_level[0] != 0)\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\npi2_level);\n}\n}\n}\n}\n}\nelse if(!ps_cur_mb_info->u1_tran_form8x8)\n{\nUWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\nUWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\nWORD8 i1_top_pred_mode;\nWORD8 i1_left_pred_mode;\nUWORD8 *pu1_top, *pu1_left, *pu1_top_left, *pu1_top_right;\nWORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\nUWORD16 ui2_left_pred_buf_width = 0xffff;\nWORD8 i1_intra_pred;\nUWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\nUWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 16;\nWORD16 *pi2_y_coeff1;\nUWORD8 u1_cur_sub_block;\nUWORD16 ui2_top_rt_mask;\npu1_top = puc_top;\nui2_top_rt_mask = (u1_use_top_right_mb << 3) | (0x5750);\nif(uc_useTopMB)\nui2_top_rt_mask |= 0x7;\npi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\npc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\nif(u1_top_available)\n{\nif(ps_top_mb->u1_mb_type == I_4x4_MB)\n*(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\nelse\n*(WORD32*)pi1_cur_pred_mode =\n(uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n}\nelse\n*(WORD32*)pi1_cur_pred_mode = NOT_VALID;\npi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\nif(!u1_mbaff)\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\nelse\n{\nUWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\nUWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\nif(u1_curMbfld ^ u1_leftMbfld)\n{\nif(u1_topmb\n| ((u1_topmb == 0)\n&& ((ps_curmb - 1)->u1_mb_type\n!= I_4x4_MB)))\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\nif(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\nelse\n*(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n}\n}\nelse\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\nif(u1_curMbfld)\n{\nif(u1_left_available)\n{\nif((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n{\nif(u2_use_left_mb_pack >> 8)\n*(WORD32*)(pi1_left_pred_mode + 4) =\nDC_DC_DC_DC;\nelse\n*(WORD32*)(pi1_left_pred_mode + 4) =\nNOT_VALID;\n}\n}\nelse\n*(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\npi1_left_pred_mode[1] = pi1_left_pred_mode[2];\npi1_left_pred_mode[2] = pi1_left_pred_mode[4];\npi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n*(WORD32*)(pi1_left_pred_mode + 4) =\n*(WORD32*)pi1_left_pred_mode;\n}\nelse\n{\npi1_left_pred_mode[7] = pi1_left_pred_mode[3];\npi1_left_pred_mode[6] = pi1_left_pred_mode[3];\npi1_left_pred_mode[5] = pi1_left_pred_mode[2];\npi1_left_pred_mode[4] = pi1_left_pred_mode[2];\npi1_left_pred_mode[3] = pi1_left_pred_mode[1];\npi1_left_pred_mode[2] = pi1_left_pred_mode[1];\npi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n}\n}\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n}\nelse\n{\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\nelse\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\npi2_y_coeff1 = pi2_y_coeff;\npu1_top_left = pu1_ytop_left;\nfor(u1_sub_mb_num = 0; u1_sub_mb_num < 16; u1_sub_mb_num++)\n{\nUWORD8 au1_ngbr_pels[13];\nu1_sub_blk_x = u1_sub_mb_num & 0x3;\nu1_sub_blk_y = u1_sub_mb_num >> 2;\ni1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x];\ni1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y];\nu1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\nif(u1_sub_blk_x)\nu1_is_left_sub_block = 1;\nelse\nu1_is_left_sub_block =\n(u1_sub_blk_y < 2) ?\n(CHECKBIT(u2_use_left_mb_pack,\n0)) :\n(u2_use_left_mb_pack >> 8);\nif(u1_sub_blk_y)\nu1_is_top_sub_block = 1;\nif(ps_dec->u4_use_intrapred_line_copy == 1)\n{\nif(u1_sub_blk_y)\npu1_top = pu1_luma_rec_buffer - ui_rec_width;\nelse\npu1_top = puc_top + (u1_sub_blk_x << 2);\n}\nelse\n{\npu1_top = pu1_luma_rec_buffer - ui_rec_width;\n}\npu1_top_right = pu1_top + 4;\npu1_top_left = pu1_top - 1;\npu1_left = pu1_luma_rec_buffer - 1;\ni1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\nDC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n{\nUWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n+ u1_is_left_sub_block;\nUWORD8 *pu1_intra_err_codes =\n(UWORD8 *)gau1_ih264d_intra_pred_err_code;\nUWORD8 uc_b2b0 = ((u1_sub_mb_num & 4) >> 1) | (u1_sub_mb_num & 1);\nUWORD8 uc_b3b1 = ((u1_sub_mb_num & 8) >> 2)\n| ((u1_sub_mb_num & 2) >> 1);\nu1_cur_sub_block = (uc_b3b1 << 2) + uc_b2b0;\nPROFILE_DISABLE_INTRA_PRED()\nif(!pu1_prev_intra4x4_pred_mode_flag[u1_cur_sub_block])\n{\ni1_intra_pred =\npu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n+ (pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n>= i1_intra_pred);\n}\ni1_intra_pred = CLIP3(0, 8, i1_intra_pred);\n{\nUWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\ni1_intra_pred = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\n}\n{\nif(u1_is_left_sub_block)\n{\nWORD32 i;\nfor(i = 0; i < 4; i++)\nau1_ngbr_pels[4 - 1 - i] = pu1_left[i * ui_rec_width];\n}\nelse\n{\nmemset(au1_ngbr_pels, 0, 4);\n}\nau1_ngbr_pels[4] = *pu1_top_left;\nif(u1_is_top_sub_block)\n{\nmemcpy(au1_ngbr_pels + 4 + 1, pu1_top, 4);\n}\nelse\n{\nmemset(au1_ngbr_pels + 4 + 1, 0, 4);\n}\nif(u1_use_top_right_mb)\n{\nmemcpy(au1_ngbr_pels + 4 * 2 + 1, pu1_top_right, 4);\n}\nelse if(u1_is_top_sub_block)\n{\nmemset(au1_ngbr_pels + 4 * 2 + 1, au1_ngbr_pels[4 * 2], 4);\n}\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_luma_4x4[i1_intra_pred](\nau1_ngbr_pels, pu1_luma_rec_buffer, 1,\nui_rec_width,\n((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\nif(CHECKBIT(ui2_luma_csbp, u1_sub_mb_num))\n{\nWORD16 ai2_tmp[16];\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u4_luma_dc_only_csbp, u1_sub_mb_num))\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\nelse\n{\nps_dec->pf_iquant_itrans_recon_luma_4x4(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\n}\n}\npi2_y_coeff1 += 16;\npu1_luma_rec_buffer +=\n(u1_sub_blk_x == 3) ? (ui_rec_width << 2) - 12 : 4;\npu1_luma_pred_buffer +=\n(u1_sub_blk_x == 3) ? (ui_pred_width << 2) - 12 : 4;\npi1_cur_pred_mode[u1_sub_blk_x] = i1_intra_pred;\npi1_left_pred_mode[u1_sub_blk_y] = i1_intra_pred;\n}\n}\nelse if((u1_mb_type == I_4x4_MB) && (ps_cur_mb_info->u1_tran_form8x8 == 1))\n{\nUWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\nUWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\nWORD8 i1_top_pred_mode;\nWORD8 i1_left_pred_mode;\nUWORD8 *pu1_top, *pu1_left, *pu1_top_left;\nWORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\nUWORD16 ui2_left_pred_buf_width = 0xffff;\nWORD8 i1_intra_pred;\nUWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\nUWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 4;\nWORD16 *pi2_y_coeff1;\nUWORD16 ui2_top_rt_mask;\nUWORD32 u4_4x4_left_offset = 0;\nui2_top_rt_mask = (u1_use_top_right_mb << 1) | (0x4);\nif(uc_useTopMB)\n{\nui2_top_rt_mask |= 0x1;\n}\npi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\npc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\nif(u1_top_available)\n{\nif(ps_top_mb->u1_mb_type == I_4x4_MB)\n{\n*(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\n}\nelse\n{\n*(WORD32*)pi1_cur_pred_mode =\n(uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n}\n}\nelse\n{\n*(WORD32*)pi1_cur_pred_mode = NOT_VALID;\n}\npu1_top = puc_top - 8;\npi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\nif(!u1_mbaff)\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\nelse\n{\nUWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\nUWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\nif((!u1_curMbfld) && (u1_leftMbfld))\n{\nu4_4x4_left_offset = 1;\n}\nif(u1_curMbfld ^ u1_leftMbfld)\n{\nif(u1_topmb\n| ((u1_topmb == 0)\n&& ((ps_curmb - 1)->u1_mb_type\n!= I_4x4_MB)))\n{\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\nif(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n}\n}\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\nif(u1_curMbfld)\n{\nif(u1_left_available)\n{\nif((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n{\nif(u2_use_left_mb_pack >> 8)\n{\n*(WORD32*)(pi1_left_pred_mode + 4) =\nDC_DC_DC_DC;\n}\nelse\n{\n*(WORD32*)(pi1_left_pred_mode + 4) =\nNOT_VALID;\n}\n}\n}\nelse\n{\n*(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\n}\npi1_left_pred_mode[1] = pi1_left_pred_mode[2];\npi1_left_pred_mode[2] = pi1_left_pred_mode[4];\npi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n*(WORD32*)(pi1_left_pred_mode + 4) =\n*(WORD32*)pi1_left_pred_mode;\n}\nelse\n{\npi1_left_pred_mode[7] = pi1_left_pred_mode[3];\npi1_left_pred_mode[6] = pi1_left_pred_mode[3];\npi1_left_pred_mode[5] = pi1_left_pred_mode[2];\npi1_left_pred_mode[4] = pi1_left_pred_mode[2];\npi1_left_pred_mode[3] = pi1_left_pred_mode[1];\npi1_left_pred_mode[2] = pi1_left_pred_mode[1];\npi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n}\n}\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n}\nelse\n{\npi1_left_pred_mode += (u1_topmb) ? 0 : 4;\nif(u1_left_available)\n{\nif(ps_left_mb->u1_mb_type != I_4x4_MB)\n{\n*(WORD32*)pi1_left_pred_mode =\n(u2_use_left_mb_pack) ?\nDC_DC_DC_DC :\nNOT_VALID;\n}\n}\nelse\n{\n*(WORD32*)pi1_left_pred_mode = NOT_VALID;\n}\n}\n}\npi2_y_coeff1 = pi2_y_coeff;\nif(u1_use_top_left_mb)\n{\npu1_top_left = pu1_ytop_left;\n}\nelse\n{\npu1_top_left = NULL;\n}\nfor(u1_sub_mb_num = 0; u1_sub_mb_num < 4; u1_sub_mb_num++)\n{\nu1_sub_blk_x = (u1_sub_mb_num & 0x1);\nu1_sub_blk_y = (u1_sub_mb_num >> 1);\ni1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x << 1];\ni1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y << 1];\nif(2 == u1_sub_mb_num)\n{\ni1_left_pred_mode = pi1_left_pred_mode[(u1_sub_blk_y << 1)\n+ u4_4x4_left_offset];\n}\nu1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\nif(u1_sub_blk_x)\n{\nu1_is_left_sub_block = 1;\n}\nelse\n{\nu1_is_left_sub_block =\n(u1_sub_blk_y < 1) ?\n(CHECKBIT(u2_use_left_mb_pack,\n0)) :\n(u2_use_left_mb_pack >> 8);\n}\nif(u1_sub_blk_y)\n{\nu1_is_top_sub_block = 1;\npu1_top =  pu1_luma_rec_buffer - ui_rec_width;\n}\nelse\n{\npu1_top += 8;\n}\nif((u1_sub_blk_x) | (u4_num_pmbair != 0))\n{\npu1_left =  pu1_luma_rec_buffer - 1;\nui2_left_pred_buf_width = ui_rec_width;\n}\nelse\n{\npu1_left = pu1_yleft;\npu1_yleft += (ui_rec_width << 3);\nui2_left_pred_buf_width = ui_rec_width;\n}\nif(u1_sub_mb_num)\n{\npu1_top_left = (u1_sub_blk_x) ?\npu1_top - 1 : pu1_left - ui_rec_width;\nif((u1_sub_blk_x && (!u1_is_top_sub_block))\n|| ((!u1_sub_blk_x) && (!u1_is_left_sub_block)))\n{\npu1_top_left = NULL;\n}\n}\ni1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\nDC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n{\nUWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n+ u1_is_left_sub_block;\nUWORD8 *pu1_intra_err_codes =\n(UWORD8 *)gau1_ih264d_intra_pred_err_code;\nPROFILE_DISABLE_INTRA_PRED()\nif(!pu1_prev_intra4x4_pred_mode_flag[u1_sub_mb_num])\n{\ni1_intra_pred = pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n+ (pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n>= i1_intra_pred);\n}\ni1_intra_pred = CLIP3(0, 8, i1_intra_pred);\n{\nUWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\ni1_intra_pred = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\n}\n{\nUWORD8 au1_ngbr_pels[25];\nWORD32 ngbr_avail;\nngbr_avail = u1_is_left_sub_block << 0;\nngbr_avail |= u1_is_top_sub_block << 2;\nif(pu1_top_left)\nngbr_avail |= 1 << 1;\nngbr_avail |= u1_use_top_right_mb << 3;\nPROFILE_DISABLE_INTRA_PRED()\n{\nps_dec->pf_intra_pred_ref_filtering(pu1_left, pu1_top_left,\npu1_top, au1_ngbr_pels,\nui2_left_pred_buf_width,\nngbr_avail);\nps_dec->apf_intra_pred_luma_8x8[i1_intra_pred](\nau1_ngbr_pels, pu1_luma_rec_buffer, 1,\nui_rec_width,\n((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\n}\n}\nif(CHECKBIT(ps_cur_mb_info->u1_cbp, u1_sub_mb_num))\n{\nWORD16 *pi2_scale_matrix_ptr;\nWORD16 ai2_tmp[64];\npi2_scale_matrix_ptr =\nps_dec->s_high_profile.i2_scalinglist8x8[0];\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u4_luma_dc_only_cbp, u1_sub_mb_num))\n{\nps_dec->pf_iquant_itrans_recon_luma_8x8_dc(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)pi2_scale_matrix_ptr,\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\nelse\n{\nps_dec->pf_iquant_itrans_recon_luma_8x8(\npi2_y_coeff1,\npu1_luma_rec_buffer,\npu1_luma_rec_buffer,\nui_rec_width,\nui_rec_width,\ngau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n(UWORD16 *)pi2_scale_matrix_ptr,\nps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\nNULL);\n}\n}\n}\npi2_y_coeff1 += 64;\npu1_luma_rec_buffer +=\n(u1_sub_blk_x == 1) ?\n(ui_rec_width << 3) - (8 * 1) : 8;\npi1_cur_pred_mode[u1_sub_blk_x << 1] = i1_intra_pred;\npi1_cur_pred_mode[(u1_sub_blk_x << 1) + 1] = i1_intra_pred;\npi1_left_pred_mode[u1_sub_blk_y << 1] = i1_intra_pred;\npi1_left_pred_mode[(u1_sub_blk_y << 1) + 1] = i1_intra_pred;\n}\n}\nih264d_unpack_chroma_coeff4x4_mb(ps_dec,\nps_cur_mb_info);\n{\nUWORD8 u1_intra_chrom_pred_mode;\nUWORD8 u1_chroma_cbp = (UWORD8)(ps_cur_mb_info->u1_cbp >> 4);\nu1_intra_chrom_pred_mode = CHROMA_TO_LUMA_INTRA_MODE(\nps_cur_mb_info->u1_chroma_pred_mode);\n{\nUWORD8 u1_packed_modes = (u1_top_available << 1)\n+ u1_left_available;\nUWORD8 u1_err_code =\n(u1_intra_chrom_pred_mode & 1) ?\nu1_intra_chrom_pred_mode :\n(u1_intra_chrom_pred_mode ^ 2);\nif((u1_err_code & u1_packed_modes) ^ u1_err_code)\n{\nu1_intra_chrom_pred_mode = 0;\nps_dec->i4_error_code = ERROR_INTRAPRED;\n}\n}\nif(u1_chroma_cbp != CBPC_ALLZERO)\n{\nUWORD16 u2_chroma_csbp =\n(u1_chroma_cbp == CBPC_ACZERO) ?\n0 : ps_cur_mb_info->u2_chroma_csbp;\nUWORD32 u4_scale_u;\nUWORD32 u4_scale_v;\n{\nUWORD16 au2_ngbr_pels[33];\nUWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\nUWORD16 *pu2_left_uv;\nUWORD16 *pu2_topleft_uv;\nWORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\nWORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\npu2_left_uv = (UWORD16 *)pu1_uleft;\npu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\nif(u2_use_left_mb_pack)\n{\nWORD32 i;\nif(use_left1)\n{\nfor(i = 0; i < 4; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n}\nif(use_left2)\n{\nfor(i = 4; i < 8; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n}\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n}\nau2_ngbr_pels[8] = *pu2_topleft_uv;\nif(uc_useTopMB)\n{\nmemcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n8 * sizeof(UWORD16));\n}\nelse\n{\nmemset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\npu1_ngbr_pels,\npu1_mb_cb_rei1_buffer,\n1,\nu4_recwidth_cr,\n((uc_useTopMB << 2) | (use_left2 << 4)\n| use_left1));\n}\nu4_scale_u = ps_cur_mb_info->u1_qpc_div6;\nu4_scale_v = ps_cur_mb_info->u1_qpcr_div6;\npi2_y_coeff = ps_dec->pi2_coeff_data;\n{\nUWORD32 i;\nWORD16 ai2_tmp[16];\nfor(i = 0; i < 4; i++)\n{\nWORD16 *pi2_level = pi2_y_coeff + (i << 4);\nUWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer\n+ ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n+ (i >> 1) * (u4_recwidth_cr << 2);\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u2_chroma_csbp, i))\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\nu4_scale_u, ai2_tmp, pi2_level);\n}\nelse if(pi2_level[0] != 0)\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\nu4_scale_u, ai2_tmp, pi2_level);\n}\n}\n}\n}\npi2_y_coeff += MB_CHROM_SIZE;\nu2_chroma_csbp = u2_chroma_csbp >> 4;\n{\nUWORD32 i;\nWORD16 ai2_tmp[16];\nfor(i = 0; i < 4; i++)\n{\nWORD16 *pi2_level = pi2_y_coeff + (i << 4);\nUWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer + 1\n+ ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n+ (i >> 1) * (u4_recwidth_cr << 2);\nPROFILE_DISABLE_IQ_IT_RECON()\n{\nif(CHECKBIT(u2_chroma_csbp, i))\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\nu4_scale_v, ai2_tmp, pi2_level);\n}\nelse if(pi2_level[0] != 0)\n{\nps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\npi2_level,\npu1_pred_sblk,\npu1_pred_sblk,\nu4_recwidth_cr,\nu4_recwidth_cr,\ngau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n(UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\nu4_scale_v, ai2_tmp, pi2_level);\n}\n}\n}\n}\n}\nelse\n{\n{\nUWORD16 au2_ngbr_pels[33];\nUWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\nUWORD16 *pu2_left_uv;\nUWORD16 *pu2_topleft_uv;\nWORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\nWORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\npu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\npu2_left_uv = (UWORD16 *)pu1_uleft;\nif(u2_use_left_mb_pack)\n{\nWORD32 i;\nif(use_left1)\n{\nfor(i = 0; i < 4; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n}\nif(use_left2)\n{\nfor(i = 4; i < 8; i++)\nau2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n* u4_recwidth_cr / YUV420SP_FACTOR];\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n}\n}\nelse\n{\nmemset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n}\nau2_ngbr_pels[8] = *pu2_topleft_uv;\nif(uc_useTopMB)\n{\nmemcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n8 * sizeof(UWORD16));\n}\nelse\n{\nmemset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n}\nPROFILE_DISABLE_INTRA_PRED()\nps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\npu1_ngbr_pels,\npu1_mb_cb_rei1_buffer,\n1,\nu4_recwidth_cr,\n((uc_useTopMB << 2) | (use_left2 << 4)\n| use_left1));\n}\n}\n}\nreturn OK;\n}", "label": 0}
{"index": 183095, "code": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\nWORD32 num_mb_skip,\nUWORD8 u1_is_idr_slice,\nUWORD16 u2_frame_num,\npocstruct_t *ps_cur_poc,\nWORD32 prev_slice_err)\n{\nWORD32 i2_cur_mb_addr;\nUWORD32 u1_num_mbs, u1_num_mbsNby2;\nUWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\nUWORD32 i2_mb_skip_run;\nUWORD32 u1_num_mbs_next, u1_end_of_row;\nconst UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\nUWORD32 u1_slice_end;\nUWORD32 u1_tfr_n_mb;\nUWORD32 u1_decode_nmb;\ndec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\ndec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\nUWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\nUWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\ndeblk_mb_t *ps_cur_deblk_mb;\ndec_mb_info_t *ps_cur_mb_info;\nparse_pmbarams_t *ps_parse_mb_data;\nUWORD32 u1_inter_mb_type;\nUWORD32 u1_deblk_mb_type;\nUWORD16 u2_total_mbs_coded;\nUWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\nparse_part_params_t *ps_part_info;\nWORD32 ret;\nif(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n{\nih264d_err_pic_dispbuf_mgr(ps_dec);\nreturn 0;\n}\nps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\nif(prev_slice_err == 1)\n{\nps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\nif(!ps_dec->u1_first_slice_in_stream)\n{\nih264d_end_of_pic(ps_dec, u1_is_idr_slice,\nps_dec->ps_cur_slice->u2_frame_num);\nps_dec->s_cur_pic_poc.u2_frame_num =\nps_dec->ps_cur_slice->u2_frame_num;\n}\n{\nWORD32 i, j, poc = 0;\nps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\nps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\nps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\nps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\nif(ps_dec->ps_cur_pic != NULL)\npoc = ps_dec->ps_cur_pic->i4_poc + 2;\nj = 0;\nfor(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\nif(ps_dec->ps_pps[i].u1_is_valid == TRUE)\nj = i;\n{\nps_dec->ps_cur_slice->u1_bottom_field_flag = 0;\nps_dec->ps_cur_slice->u1_field_pic_flag = 0;\nps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\nps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\nps_dec->ps_cur_slice->u1_nal_unit_type = 1;\nret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\nps_dec->ps_cur_slice->u2_frame_num,\n&ps_dec->ps_pps[j]);\nif(ret != OK)\n{\nreturn ret;\n}\n}\nps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\nps_dec->u4_output_present = 0;\n{\nih264d_get_next_display_field(ps_dec,\nps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 != ps_dec->s_disp_op.u4_error_code)\n{\nps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n}\nelse\nps_dec->u4_output_present = 1;\n}\nif(ps_dec->u1_separate_parse == 1)\n{\nif(ps_dec->u4_dec_thread_created == 0)\n{\nithread_create(ps_dec->pv_dec_thread_handle, NULL,\n(void *)ih264d_decode_picture_thread,\n(void *)ps_dec);\nps_dec->u4_dec_thread_created = 1;\n}\nif((ps_dec->u4_num_cores == 3) &&\n((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n&& (ps_dec->u4_bs_deblk_thread_created == 0))\n{\nps_dec->u4_start_recon_deblk = 0;\nithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n(void *)ih264d_recon_deblk_thread,\n(void *)ps_dec);\nps_dec->u4_bs_deblk_thread_created = 1;\n}\n}\n}\n}\nelse\n{\ndec_slice_struct_t *ps_parse_cur_slice;\nps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\nif(ps_dec->u1_slice_header_done\n&& ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n{\nu1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\nif(u1_num_mbs)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n}\nelse\n{\nif(ps_dec->u1_separate_parse)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n}\nelse\n{\nps_cur_mb_info = ps_dec->ps_nmb_info\n+ ps_dec->u4_num_mbs_prev_nmb - 1;\n}\n}\nps_dec->u2_mby = ps_cur_mb_info->u2_mby;\nps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\nps_dec->u1_mb_ngbr_availablity =\nps_cur_mb_info->u1_mb_ngbr_availablity;\nps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\nps_dec->u2_cur_mb_addr--;\nps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\nif(u1_num_mbs)\n{\nif (ps_dec->u1_pr_sl_type == P_SLICE\n|| ps_dec->u1_pr_sl_type == B_SLICE)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\nps_dec->ps_part = ps_dec->ps_parse_part_params;\n}\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next)\n&& (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = 1;\nu1_tfr_n_mb = 1;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info += u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n}\nps_dec->u2_total_mbs_coded += u1_num_mbs;\nps_dec->u1_mb_idx = 0;\nps_dec->u4_num_mbs_cur_nmb = 0;\n}\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\nreturn 0;\n}\nps_dec->u2_cur_slice_num++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nps_dec->ps_parse_cur_slice++;\n}\nelse\n{\nps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n+ ps_dec->u2_cur_slice_num;\n}\n}\n{\nWORD32 num_entries;\nWORD32 size;\nUWORD8 *pu1_buf;\nnum_entries = MAX_FRAMES;\nif((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n(0 == ps_dec->i4_display_delay))\n{\nnum_entries = 1;\n}\nnum_entries = ((2 * num_entries) + 1);\nif(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n{\nnum_entries *= 2;\n}\nsize = num_entries * sizeof(void *);\nsize += PAD_MAP_IDX_POC * sizeof(void *);\npu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\npu1_buf += size * ps_dec->u2_cur_slice_num;\nps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n}\nps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\nps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\nif(ps_dec->ps_cur_slice->u1_field_pic_flag)\nps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\nps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\nif(ps_dec->u1_separate_parse)\n{\nps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n}\nelse\n{\nps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n}\nu1_inter_mb_type = P_MB;\nu1_deblk_mb_type = D_INTER_MB;\nps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\nps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\nps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nps_dec->u1_slice_header_done = 2;\nps_dec->u1_qp = ps_slice->u1_slice_qp;\nih264d_update_qp(ps_dec, 0);\nu1_mb_idx = ps_dec->u1_mb_idx;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nu1_num_mbs = u1_mb_idx;\nu1_slice_end = 0;\nu1_tfr_n_mb = 0;\nu1_decode_nmb = 0;\nu1_num_mbsNby2 = 0;\ni2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\ni2_mb_skip_run = num_mb_skip;\nwhile(!u1_slice_end)\n{\nUWORD8 u1_mb_type;\nif(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\nbreak;\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\nps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\nps_cur_mb_info->u1_Mux = 0;\nps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\nps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\nps_cur_mb_info->u1_end_of_slice = 0;\nps_parse_mb_data->u1_num_part = 1;\nps_parse_mb_data->u1_isI_mb = 0;\nif (u1_mbaff)\nih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nelse\nih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nif(ps_dec->u4_app_disable_deblk_frm == 0)\n{\nih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\nps_dec->u1_mb_ngbr_availablity,\nps_dec->u1_cur_mb_fld_dec_flag);\n}\nps_dec->i1_prev_mb_qp_delta = 0;\nps_dec->u1_sub_mb_num = 0;\nps_cur_mb_info->u1_mb_type = MB_SKIP;\nps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\nps_cur_mb_info->u1_cbp = 0;\nps_part_info = ps_dec->ps_part;\nps_part_info->u1_is_direct = PART_DIRECT_16x16;\nps_part_info->u1_sub_mb_num = 0;\nps_dec->ps_part++;\nih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\nps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\nps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\ni2_mb_skip_run--;\nps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\nif (u1_mbaff)\n{\nih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n}\ni2_cur_mb_addr++;\nu1_num_mbs++;\nu1_num_mbsNby2++;\nps_parse_mb_data++;\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = !i2_mb_skip_run;\nu1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n|| u1_slice_end;\nu1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(u1_decode_nmb)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\nu1_num_mbsNby2 = 0;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info +=  u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\nu1_tfr_n_mb, u1_end_of_row);\n}\nps_dec->u2_total_mbs_coded += u1_num_mbs;\nif(u1_tfr_n_mb)\nu1_num_mbs = 0;\nu1_mb_idx = u1_num_mbs;\nps_dec->u1_mb_idx = u1_num_mbs;\n}\n}\nps_dec->u4_num_mbs_cur_nmb = 0;\nps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n- ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\nH264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\nps_dec->u2_cur_slice_num++;\nif(ps_dec->u4_first_slice_in_pic != 0)\nps_dec->ps_parse_cur_slice++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\n}\nreturn 0;\n}", "contrast": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\nWORD32 num_mb_skip,\nUWORD8 u1_is_idr_slice,\nUWORD16 u2_frame_num,\npocstruct_t *ps_cur_poc,\nWORD32 prev_slice_err)\n{\nWORD32 i2_cur_mb_addr;\nUWORD32 u1_num_mbs, u1_num_mbsNby2;\nUWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\nUWORD32 i2_mb_skip_run;\nUWORD32 u1_num_mbs_next, u1_end_of_row;\nconst UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\nUWORD32 u1_slice_end;\nUWORD32 u1_tfr_n_mb;\nUWORD32 u1_decode_nmb;\ndec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\ndec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\nUWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\nUWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\ndeblk_mb_t *ps_cur_deblk_mb;\ndec_mb_info_t *ps_cur_mb_info;\nparse_pmbarams_t *ps_parse_mb_data;\nUWORD32 u1_inter_mb_type;\nUWORD32 u1_deblk_mb_type;\nUWORD16 u2_total_mbs_coded;\nUWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\nparse_part_params_t *ps_part_info;\nWORD32 ret;\nif(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n{\nih264d_err_pic_dispbuf_mgr(ps_dec);\nreturn 0;\n}\nps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\nif(prev_slice_err == 1)\n{\nps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\nif(!ps_dec->u1_first_slice_in_stream)\n{\nih264d_end_of_pic(ps_dec, u1_is_idr_slice,\nps_dec->ps_cur_slice->u2_frame_num);\nps_dec->s_cur_pic_poc.u2_frame_num =\nps_dec->ps_cur_slice->u2_frame_num;\n}\n{\nWORD32 i, j, poc = 0;\nps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\nps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\nps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\nps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\nif(ps_dec->ps_cur_pic != NULL)\npoc = ps_dec->ps_cur_pic->i4_poc + 2;\nj = 0;\nfor(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\nif(ps_dec->ps_pps[i].u1_is_valid == TRUE)\nj = i;\n{\nps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\nps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\nps_dec->ps_cur_slice->u1_nal_unit_type = 1;\nret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\nps_dec->ps_cur_slice->u2_frame_num,\n&ps_dec->ps_pps[j]);\nif(ret != OK)\n{\nreturn ret;\n}\n}\nps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\nps_dec->u4_output_present = 0;\n{\nih264d_get_next_display_field(ps_dec,\nps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 != ps_dec->s_disp_op.u4_error_code)\n{\nps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n}\nelse\nps_dec->u4_output_present = 1;\n}\nif(ps_dec->u1_separate_parse == 1)\n{\nif(ps_dec->u4_dec_thread_created == 0)\n{\nithread_create(ps_dec->pv_dec_thread_handle, NULL,\n(void *)ih264d_decode_picture_thread,\n(void *)ps_dec);\nps_dec->u4_dec_thread_created = 1;\n}\nif((ps_dec->u4_num_cores == 3) &&\n((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n&& (ps_dec->u4_bs_deblk_thread_created == 0))\n{\nps_dec->u4_start_recon_deblk = 0;\nithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n(void *)ih264d_recon_deblk_thread,\n(void *)ps_dec);\nps_dec->u4_bs_deblk_thread_created = 1;\n}\n}\n}\n}\nelse\n{\ndec_slice_struct_t *ps_parse_cur_slice;\nps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\nif(ps_dec->u1_slice_header_done\n&& ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n{\nu1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\nif(u1_num_mbs)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n}\nelse\n{\nif(ps_dec->u1_separate_parse)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n}\nelse\n{\nps_cur_mb_info = ps_dec->ps_nmb_info\n+ ps_dec->u4_num_mbs_prev_nmb - 1;\n}\n}\nps_dec->u2_mby = ps_cur_mb_info->u2_mby;\nps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\nps_dec->u1_mb_ngbr_availablity =\nps_cur_mb_info->u1_mb_ngbr_availablity;\nps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\nps_dec->u2_cur_mb_addr--;\nps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\nif(u1_num_mbs)\n{\nif (ps_dec->u1_pr_sl_type == P_SLICE\n|| ps_dec->u1_pr_sl_type == B_SLICE)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\nps_dec->ps_part = ps_dec->ps_parse_part_params;\n}\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next)\n&& (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = 1;\nu1_tfr_n_mb = 1;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info += u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n}\nps_dec->u2_total_mbs_coded += u1_num_mbs;\nps_dec->u1_mb_idx = 0;\nps_dec->u4_num_mbs_cur_nmb = 0;\n}\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\nreturn 0;\n}\nps_dec->u2_cur_slice_num++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nps_dec->ps_parse_cur_slice++;\n}\nelse\n{\nps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n+ ps_dec->u2_cur_slice_num;\n}\n}\n{\nWORD32 num_entries;\nWORD32 size;\nUWORD8 *pu1_buf;\nnum_entries = MAX_FRAMES;\nif((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n(0 == ps_dec->i4_display_delay))\n{\nnum_entries = 1;\n}\nnum_entries = ((2 * num_entries) + 1);\nif(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n{\nnum_entries *= 2;\n}\nsize = num_entries * sizeof(void *);\nsize += PAD_MAP_IDX_POC * sizeof(void *);\npu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\npu1_buf += size * ps_dec->u2_cur_slice_num;\nps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n}\nps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\nps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\nif(ps_dec->ps_cur_slice->u1_field_pic_flag)\nps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\nps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\nif(ps_dec->u1_separate_parse)\n{\nps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n}\nelse\n{\nps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n}\nu1_inter_mb_type = P_MB;\nu1_deblk_mb_type = D_INTER_MB;\nps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\nps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\nps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nps_dec->u1_slice_header_done = 2;\nps_dec->u1_qp = ps_slice->u1_slice_qp;\nih264d_update_qp(ps_dec, 0);\nu1_mb_idx = ps_dec->u1_mb_idx;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nu1_num_mbs = u1_mb_idx;\nu1_slice_end = 0;\nu1_tfr_n_mb = 0;\nu1_decode_nmb = 0;\nu1_num_mbsNby2 = 0;\ni2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\ni2_mb_skip_run = num_mb_skip;\nwhile(!u1_slice_end)\n{\nUWORD8 u1_mb_type;\nif(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\nbreak;\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\nps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\nps_cur_mb_info->u1_Mux = 0;\nps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\nps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\nps_cur_mb_info->u1_end_of_slice = 0;\nps_parse_mb_data->u1_num_part = 1;\nps_parse_mb_data->u1_isI_mb = 0;\nif (u1_mbaff)\nih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nelse\nih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nif(ps_dec->u4_app_disable_deblk_frm == 0)\n{\nih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\nps_dec->u1_mb_ngbr_availablity,\nps_dec->u1_cur_mb_fld_dec_flag);\n}\nps_dec->i1_prev_mb_qp_delta = 0;\nps_dec->u1_sub_mb_num = 0;\nps_cur_mb_info->u1_mb_type = MB_SKIP;\nps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\nps_cur_mb_info->u1_cbp = 0;\nps_part_info = ps_dec->ps_part;\nps_part_info->u1_is_direct = PART_DIRECT_16x16;\nps_part_info->u1_sub_mb_num = 0;\nps_dec->ps_part++;\nih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\nps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\nps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\ni2_mb_skip_run--;\nps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\nif (u1_mbaff)\n{\nih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n}\ni2_cur_mb_addr++;\nu1_num_mbs++;\nu1_num_mbsNby2++;\nps_parse_mb_data++;\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = !i2_mb_skip_run;\nu1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n|| u1_slice_end;\nu1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(u1_decode_nmb)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\nu1_num_mbsNby2 = 0;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info +=  u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\nu1_tfr_n_mb, u1_end_of_row);\n}\nps_dec->u2_total_mbs_coded += u1_num_mbs;\nif(u1_tfr_n_mb)\nu1_num_mbs = 0;\nu1_mb_idx = u1_num_mbs;\nps_dec->u1_mb_idx = u1_num_mbs;\n}\n}\nps_dec->u4_num_mbs_cur_nmb = 0;\nps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n- ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\nH264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\nps_dec->u2_cur_slice_num++;\nif(ps_dec->u4_first_slice_in_pic != 0)\nps_dec->ps_parse_cur_slice++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\n}\nreturn 0;\n}", "label": 0}
{"index": 183107, "code": "static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\nconst char* name;\nsize_t namelen;\nif (node->graft_path) {\nname = node->graft_path;\nnamelen = node->graft_pathlen;\n} else if (node->actual_name) {\nname = node->actual_name;\nnamelen = node->namelen;\n} else {\nname = node->name;\nnamelen = node->namelen;\n}\nif (bufsize < namelen + 1) {\nreturn -1;\n}\nssize_t pathlen = 0;\nif (node->parent && node->graft_path == NULL) {\npathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\nif (pathlen < 0) {\nreturn -1;\n}\nbuf[pathlen++] = '/';\n}\nmemcpy(buf + pathlen, name, namelen + 1);\nreturn pathlen + namelen;\n}", "contrast": "static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\nconst char* name;\nsize_t namelen;\nif (node->graft_path) {\nname = node->graft_path;\nnamelen = node->graft_pathlen;\n} else if (node->actual_name) {\nname = node->actual_name;\nnamelen = node->namelen;\n} else {\nname = node->name;\nnamelen = node->namelen;\n}\nif (bufsize < namelen + 1) {\nreturn -1;\n}\nssize_t pathlen = 0;\nif (node->parent && node->graft_path == NULL) {\npathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);\nif (pathlen < 0) {\nreturn -1;\n}\nbuf[pathlen++] = '/';\n}\nmemcpy(buf + pathlen, name, namelen + 1);\nreturn pathlen + namelen;\n}", "label": 0}
{"index": 183206, "code": "bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,\nuint8_t pin_len, bt_pin_code_t *pin_code)\n{\nBTIF_TRACE_EVENT(\"%s: accept=%d\", __FUNCTION__, accept);\nif (pin_code == NULL)\nreturn BT_STATUS_FAIL;\n#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))\nif (pairing_cb.is_le_only)\n{\nint i;\nUINT32 passkey = 0;\nint multi[] = {100000, 10000, 1000, 100, 10,1};\nBD_ADDR remote_bd_addr;\nbdcpy(remote_bd_addr, bd_addr->address);\nfor (i = 0; i < 6; i++)\n{\npasskey += (multi[i] * (pin_code->pin[i] - '0'));\n}\nBTIF_TRACE_DEBUG(\"btif_dm_pin_reply: passkey: %d\", passkey);\nBTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);\n}\nelse\n{\nBTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\nif (accept)\npairing_cb.pin_code_len = pin_len;\n}\n#else\nBTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\nif (accept)\npairing_cb.pin_code_len = pin_len;\n#endif\nreturn BT_STATUS_SUCCESS;\n}", "contrast": "bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,\nuint8_t pin_len, bt_pin_code_t *pin_code)\n{\nBTIF_TRACE_EVENT(\"%s: accept=%d\", __FUNCTION__, accept);\nif (pin_code == NULL || pin_len > PIN_CODE_LEN)\nreturn BT_STATUS_FAIL;\n#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))\nif (pairing_cb.is_le_only)\n{\nint i;\nUINT32 passkey = 0;\nint multi[] = {100000, 10000, 1000, 100, 10,1};\nBD_ADDR remote_bd_addr;\nbdcpy(remote_bd_addr, bd_addr->address);\nfor (i = 0; i < 6; i++)\n{\npasskey += (multi[i] * (pin_code->pin[i] - '0'));\n}\nBTIF_TRACE_DEBUG(\"btif_dm_pin_reply: passkey: %d\", passkey);\nBTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);\n}\nelse\n{\nBTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\nif (accept)\npairing_cb.pin_code_len = pin_len;\n}\n#else\nBTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\nif (accept)\npairing_cb.pin_code_len = pin_len;\n#endif\nreturn BT_STATUS_SUCCESS;\n}", "label": 0}
{"index": 183209, "code": "static int aacDecoder_drcExtractAndMap (\nHANDLE_AAC_DRC  self,\nHANDLE_FDK_BITSTREAM hBs,\nCAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo[],\nUCHAR  pceInstanceTag,\nUCHAR  channelMapping[],\nint    validChannels )\n{\nCDrcPayload  threadBs[MAX_DRC_THREADS];\nCDrcPayload *validThreadBs[MAX_DRC_THREADS];\nCDrcParams *pParams;\nUINT backupBsPosition;\nint  i, thread, validThreads = 0;\nint  numExcludedChns[MAX_DRC_THREADS];\nFDK_ASSERT(self != NULL);\nFDK_ASSERT(hBs != NULL);\nFDK_ASSERT(pAacDecoderStaticChannelInfo != NULL);\npParams = &self->params;\nself->numThreads = 0;\nbackupBsPosition = FDKgetValidBits(hBs);\nfor (i = 0; i < self->numPayloads && self->numThreads < MAX_DRC_THREADS; i++) {\nint bitsParsed;\nFDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\nthreadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\nbitsParsed = aacDecoder_drcParse( hBs,\n&threadBs[self->numThreads],\nself->drcPayloadPosition[i] );\nif (bitsParsed > 0) {\nself->numThreads++;\n}\n}\nself->numPayloads = 0;\nif (self->dvbAncDataAvailable)\n{\nint bitsParsed;\nFDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\nthreadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\nbitsParsed = aacDecoder_drcReadCompression( hBs,\n&threadBs[self->numThreads],\nself->dvbAncDataPosition );\nif (bitsParsed > 0) {\nself->numThreads++;\n}\n}\nself->dvbAncDataAvailable = 0;\nFDKpushBiDirectional(hBs, FDKgetValidBits(hBs) - backupBsPosition);\nfor (thread = 0; thread < self->numThreads; thread++) {\nCDrcPayload *pThreadBs = &threadBs[thread];\nint numExclChns = 0;\nswitch ((AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType) {\ndefault:\ncontinue;\ncase MPEG_DRC_EXT_DATA:\ncase DVB_DRC_ANC_DATA:\nbreak;\n}\nif (pThreadBs->pceInstanceTag >= 0) {\nif (pThreadBs->pceInstanceTag != pceInstanceTag) {\ncontinue;\n}\n}\nif (pThreadBs->excludedChnsMask > 0) {\nINT exclMask = pThreadBs->excludedChnsMask;\nint ch;\nfor (ch = 0; ch < validChannels; ch++) {\nnumExclChns += exclMask & 0x1;\nexclMask >>= 1;\n}\n}\nif (numExclChns < validChannels) {\nvalidThreadBs[validThreads] = pThreadBs;\nnumExcludedChns[validThreads] = numExclChns;\nvalidThreads++;\n}\n}\nif (validThreads > 1) {\nint ch;\nfor (ch = 0; ch < validChannels; ch++) {\nint present = 0;\nfor (thread = 0; thread < validThreads; thread++) {\nCDrcPayload *pThreadBs = validThreadBs[thread];\nif ( (pThreadBs->channelData.drcDataType == MPEG_DRC_EXT_DATA)\n&& ( (numExcludedChns[thread] == 0)\n|| (!(pThreadBs->excludedChnsMask & (1<<ch))) ) ) {\npresent++;\n}\n}\nif (present > 1) {\nreturn -1;\n}\n}\n}\nfor (thread = 0; thread < validThreads; thread++)\n{\nCDrcPayload *pThreadBs = validThreadBs[thread];\nINT exclMask = pThreadBs->excludedChnsMask;\nAACDEC_DRC_PAYLOAD_TYPE drcPayloadType = (AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType;\nint ch;\nif (pThreadBs->progRefLevel >= 0) {\nself->progRefLevel = pThreadBs->progRefLevel;\nself->progRefLevelPresent = 1;\nself->prlExpiryCount = 0;\n}\nif (drcPayloadType == DVB_DRC_ANC_DATA) {\nself->presMode = pThreadBs->presMode;\n}\nfor (ch = 0; ch < validChannels; ch++) {\nint mapedChannel = channelMapping[ch];\nif ( ((exclMask & (1<<mapedChannel)) == 0)\n&& ( (drcPayloadType == MPEG_DRC_EXT_DATA)\n|| ((drcPayloadType == DVB_DRC_ANC_DATA) && self->params.applyHeavyCompression)\n) ) {\npAacDecoderStaticChannelInfo[ch]->drcData = pThreadBs->channelData;\n}\n}\n}\nif ( (pParams->expiryFrame > 0)\n&& (self->prlExpiryCount++ > pParams->expiryFrame) )\n{\nself->progRefLevelPresent = 0;\nself->progRefLevel = pParams->targetRefLevel;\nself->prlExpiryCount = 0;\n}\nreturn 0;\n}", "contrast": "static int aacDecoder_drcExtractAndMap (\nHANDLE_AAC_DRC  self,\nHANDLE_FDK_BITSTREAM hBs,\nCAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo[],\nUCHAR  pceInstanceTag,\nUCHAR  channelMapping[],\nint    validChannels )\n{\nCDrcPayload  threadBs[MAX_DRC_THREADS];\nCDrcPayload *validThreadBs[MAX_DRC_THREADS];\nCDrcParams *pParams;\nUINT backupBsPosition;\nint  i, thread, validThreads = 0;\nint  numExcludedChns[MAX_DRC_THREADS];\nFDK_ASSERT(self != NULL);\nFDK_ASSERT(hBs != NULL);\nFDK_ASSERT(pAacDecoderStaticChannelInfo != NULL);\npParams = &self->params;\nself->numThreads = 0;\nbackupBsPosition = FDKgetValidBits(hBs);\nfor (i = 0; i < self->numPayloads && self->numThreads < MAX_DRC_THREADS; i++) {\nint bitsParsed;\nFDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\nthreadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\nbitsParsed = aacDecoder_drcParse( hBs,\n&threadBs[self->numThreads],\nself->drcPayloadPosition[i] );\nif (bitsParsed > 0) {\nself->numThreads++;\n}\n}\nself->numPayloads = 0;\nif (self->numThreads >= MAX_DRC_THREADS) {\nself->numThreads = MAX_DRC_THREADS - 1;\n}\nif (self->dvbAncDataAvailable)\n{\nint bitsParsed;\nFDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\nthreadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\nbitsParsed = aacDecoder_drcReadCompression( hBs,\n&threadBs[self->numThreads],\nself->dvbAncDataPosition );\nif (bitsParsed > 0) {\nself->numThreads++;\n}\n}\nself->dvbAncDataAvailable = 0;\nFDKpushBiDirectional(hBs, FDKgetValidBits(hBs) - backupBsPosition);\nif (self->numThreads >= MAX_DRC_THREADS) {\nself->numThreads = MAX_DRC_THREADS - 1;\n}\nfor (thread = 0; thread < self->numThreads; thread++) {\nCDrcPayload *pThreadBs = &threadBs[thread];\nint numExclChns = 0;\nswitch ((AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType) {\ndefault:\ncontinue;\ncase MPEG_DRC_EXT_DATA:\ncase DVB_DRC_ANC_DATA:\nbreak;\n}\nif (pThreadBs->pceInstanceTag >= 0) {\nif (pThreadBs->pceInstanceTag != pceInstanceTag) {\ncontinue;\n}\n}\nif (pThreadBs->excludedChnsMask > 0) {\nINT exclMask = pThreadBs->excludedChnsMask;\nint ch;\nfor (ch = 0; ch < validChannels; ch++) {\nnumExclChns += exclMask & 0x1;\nexclMask >>= 1;\n}\n}\nif (numExclChns < validChannels) {\nvalidThreadBs[validThreads] = pThreadBs;\nnumExcludedChns[validThreads] = numExclChns;\nvalidThreads++;\n}\n}\nif (validThreads > 1) {\nint ch;\nfor (ch = 0; ch < validChannels; ch++) {\nint present = 0;\nfor (thread = 0; thread < validThreads; thread++) {\nCDrcPayload *pThreadBs = validThreadBs[thread];\nif ( (pThreadBs->channelData.drcDataType == MPEG_DRC_EXT_DATA)\n&& ( (numExcludedChns[thread] == 0)\n|| (!(pThreadBs->excludedChnsMask & (1<<ch))) ) ) {\npresent++;\n}\n}\nif (present > 1) {\nreturn -1;\n}\n}\n}\nfor (thread = 0; thread < validThreads; thread++)\n{\nCDrcPayload *pThreadBs = validThreadBs[thread];\nINT exclMask = pThreadBs->excludedChnsMask;\nAACDEC_DRC_PAYLOAD_TYPE drcPayloadType = (AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType;\nint ch;\nif (pThreadBs->progRefLevel >= 0) {\nself->progRefLevel = pThreadBs->progRefLevel;\nself->progRefLevelPresent = 1;\nself->prlExpiryCount = 0;\n}\nif (drcPayloadType == DVB_DRC_ANC_DATA) {\nself->presMode = pThreadBs->presMode;\n}\nfor (ch = 0; ch < validChannels; ch++) {\nint mapedChannel = channelMapping[ch];\nif ( ((exclMask & (1<<mapedChannel)) == 0)\n&& ( (drcPayloadType == MPEG_DRC_EXT_DATA)\n|| ((drcPayloadType == DVB_DRC_ANC_DATA) && self->params.applyHeavyCompression)\n) ) {\npAacDecoderStaticChannelInfo[ch]->drcData = pThreadBs->channelData;\n}\n}\n}\nif ( (pParams->expiryFrame > 0)\n&& (self->prlExpiryCount++ > pParams->expiryFrame) )\n{\nself->progRefLevelPresent = 0;\nself->progRefLevel = pParams->targetRefLevel;\nself->prlExpiryCount = 0;\n}\nreturn 0;\n}", "label": 0}
{"index": 183262, "code": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)\n{\nstream_t *ps_stream;\nUWORD32     u4_start_code;\nIMPEG2D_ERROR_CODES_T e_error;\ne_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;\nps_stream      = &ps_dec->s_bit_stream;\nu4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\nwhile( (u4_start_code == EXTENSION_START_CODE ||\nu4_start_code == USER_DATA_START_CODE) &&\n(IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n{\nif(u4_start_code == USER_DATA_START_CODE)\n{\nimpeg2d_dec_user_data(ps_dec);\n}\nelse\n{\nimpeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\nu4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\nswitch(u4_start_code)\n{\ncase SEQ_DISPLAY_EXT_ID:\nimpeg2d_dec_seq_disp_ext(ps_dec);\nbreak;\ncase SEQ_SCALABLE_EXT_ID:\ne_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;\nbreak;\ndefault:\nimpeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\nimpeg2d_peek_next_start_code(ps_dec);\nbreak;\n}\n}\nu4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n}\nreturn e_error;\n}", "contrast": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)\n{\nstream_t *ps_stream;\nUWORD32     u4_start_code;\nIMPEG2D_ERROR_CODES_T e_error;\ne_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;\nps_stream      = &ps_dec->s_bit_stream;\nu4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\nwhile( (u4_start_code == EXTENSION_START_CODE ||\nu4_start_code == USER_DATA_START_CODE) &&\n(IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n(ps_stream->u4_offset < ps_stream->u4_max_offset))\n{\nif(u4_start_code == USER_DATA_START_CODE)\n{\nimpeg2d_dec_user_data(ps_dec);\n}\nelse\n{\nimpeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\nu4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\nswitch(u4_start_code)\n{\ncase SEQ_DISPLAY_EXT_ID:\nimpeg2d_dec_seq_disp_ext(ps_dec);\nbreak;\ncase SEQ_SCALABLE_EXT_ID:\ne_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;\nbreak;\ndefault:\nimpeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\nimpeg2d_peek_next_start_code(ps_dec);\nbreak;\n}\n}\nu4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n}\nreturn e_error;\n}", "label": 0}
{"index": 183271, "code": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\nWORD32 num_mb_skip,\nUWORD8 u1_is_idr_slice,\nUWORD16 u2_frame_num,\npocstruct_t *ps_cur_poc,\nWORD32 prev_slice_err)\n{\nWORD32 i2_cur_mb_addr;\nUWORD32 u1_num_mbs, u1_num_mbsNby2;\nUWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\nUWORD32 i2_mb_skip_run;\nUWORD32 u1_num_mbs_next, u1_end_of_row;\nconst UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\nUWORD32 u1_slice_end;\nUWORD32 u1_tfr_n_mb;\nUWORD32 u1_decode_nmb;\ndec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\ndec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\nUWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\nUWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\ndeblk_mb_t *ps_cur_deblk_mb;\ndec_mb_info_t *ps_cur_mb_info;\nparse_pmbarams_t *ps_parse_mb_data;\nUWORD32 u1_inter_mb_type;\nUWORD32 u1_deblk_mb_type;\nUWORD16 u2_total_mbs_coded;\nUWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\nparse_part_params_t *ps_part_info;\nWORD32 ret;\nif(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n{\nih264d_err_pic_dispbuf_mgr(ps_dec);\nreturn 0;\n}\nif(prev_slice_err == 1)\n{\nps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\nif(!ps_dec->u1_first_slice_in_stream)\n{\nih264d_end_of_pic(ps_dec, u1_is_idr_slice,\nps_dec->ps_cur_slice->u2_frame_num);\nps_dec->s_cur_pic_poc.u2_frame_num =\nps_dec->ps_cur_slice->u2_frame_num;\n}\n{\nWORD32 i, j, poc = 0;\nps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\nps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\nps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\nps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\nif(ps_dec->ps_cur_pic != NULL)\npoc = ps_dec->ps_cur_pic->i4_poc + 2;\nj = 0;\nfor(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\nif(ps_dec->ps_pps[i].u1_is_valid == TRUE)\nj = i;\n{\nret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\nps_dec->ps_cur_slice->u2_frame_num,\n&ps_dec->ps_pps[j]);\nif(ret != OK)\n{\nreturn ret;\n}\n}\nps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\nps_dec->u4_output_present = 0;\n{\nih264d_get_next_display_field(ps_dec,\nps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 != ps_dec->s_disp_op.u4_error_code)\n{\nps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n}\nelse\nps_dec->u4_output_present = 1;\n}\nif(ps_dec->u1_separate_parse == 1)\n{\nif(ps_dec->u4_dec_thread_created == 0)\n{\nithread_create(ps_dec->pv_dec_thread_handle, NULL,\n(void *)ih264d_decode_picture_thread,\n(void *)ps_dec);\nps_dec->u4_dec_thread_created = 1;\n}\nif((ps_dec->u4_num_cores == 3) &&\n((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n&& (ps_dec->u4_bs_deblk_thread_created == 0))\n{\nps_dec->u4_start_recon_deblk = 0;\nithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n(void *)ih264d_recon_deblk_thread,\n(void *)ps_dec);\nps_dec->u4_bs_deblk_thread_created = 1;\n}\n}\n}\n}\nelse\n{\ndec_slice_struct_t *ps_parse_cur_slice;\nps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\nif(ps_dec->u1_slice_header_done\n&& ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n{\nu1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\nif(u1_num_mbs)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n}\nelse\n{\nif(ps_dec->u1_separate_parse)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n}\nelse\n{\nps_cur_mb_info = ps_dec->ps_nmb_info\n+ ps_dec->u4_num_mbs_prev_nmb - 1;\n}\n}\nps_dec->u2_mby = ps_cur_mb_info->u2_mby;\nps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\nps_dec->u1_mb_ngbr_availablity =\nps_cur_mb_info->u1_mb_ngbr_availablity;\nps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\nps_dec->u2_cur_mb_addr--;\nps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\nif(u1_num_mbs)\n{\nif (ps_dec->u1_pr_sl_type == P_SLICE\n|| ps_dec->u1_pr_sl_type == B_SLICE)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\nps_dec->ps_part = ps_dec->ps_parse_part_params;\n}\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next)\n&& (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = 1;\nu1_tfr_n_mb = 1;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info += u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n}\nps_dec->u1_mb_idx = 0;\nps_dec->u4_num_mbs_cur_nmb = 0;\n}\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\nreturn 0;\n}\nps_dec->u2_cur_slice_num++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nps_dec->ps_parse_cur_slice++;\n}\nelse\n{\nps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n+ ps_dec->u2_cur_slice_num;\n}\n}\n{\nWORD32 num_entries;\nWORD32 size;\nUWORD8 *pu1_buf;\nnum_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\nnum_entries = 2 * ((2 * num_entries) + 1);\nsize = num_entries * sizeof(void *);\nsize += PAD_MAP_IDX_POC * sizeof(void *);\npu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\npu1_buf += size * ps_dec->u2_cur_slice_num;\nps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n}\nps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nif(ps_dec->ps_cur_slice->u1_field_pic_flag)\nps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\nps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\nif(ps_dec->u1_separate_parse)\n{\nps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n}\nelse\n{\nps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n}\nu1_inter_mb_type = P_MB;\nu1_deblk_mb_type = D_INTER_MB;\nps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\nps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\nps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nps_dec->u1_slice_header_done = 2;\nps_dec->u1_qp = ps_slice->u1_slice_qp;\nih264d_update_qp(ps_dec, 0);\nu1_mb_idx = ps_dec->u1_mb_idx;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nu1_num_mbs = u1_mb_idx;\nu1_slice_end = 0;\nu1_tfr_n_mb = 0;\nu1_decode_nmb = 0;\nu1_num_mbsNby2 = 0;\ni2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\ni2_mb_skip_run = num_mb_skip;\nwhile(!u1_slice_end)\n{\nUWORD8 u1_mb_type;\nif(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\nbreak;\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\nps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\nps_cur_mb_info->u1_Mux = 0;\nps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\nps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\nps_cur_mb_info->u1_end_of_slice = 0;\nps_parse_mb_data->u1_num_part = 1;\nps_parse_mb_data->u1_isI_mb = 0;\nif (u1_mbaff)\nih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nelse\nih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nif(ps_dec->u4_app_disable_deblk_frm == 0)\n{\nih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\nps_dec->u1_mb_ngbr_availablity,\nps_dec->u1_cur_mb_fld_dec_flag);\n}\nps_dec->i1_prev_mb_qp_delta = 0;\nps_dec->u1_sub_mb_num = 0;\nps_cur_mb_info->u1_mb_type = MB_SKIP;\nps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\nps_cur_mb_info->u1_cbp = 0;\nps_part_info = ps_dec->ps_part;\nps_part_info->u1_is_direct = PART_DIRECT_16x16;\nps_part_info->u1_sub_mb_num = 0;\nps_dec->ps_part++;\nih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\nps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\nps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\ni2_mb_skip_run--;\nps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\nif (u1_mbaff)\n{\nih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n}\ni2_cur_mb_addr++;\nu1_num_mbs++;\nps_dec->u2_total_mbs_coded++;\nu1_num_mbsNby2++;\nps_parse_mb_data++;\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = !i2_mb_skip_run;\nu1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n|| u1_slice_end;\nu1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(u1_decode_nmb)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\nu1_num_mbsNby2 = 0;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info +=  u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\nu1_tfr_n_mb, u1_end_of_row);\n}\nif(u1_tfr_n_mb)\nu1_num_mbs = 0;\nu1_mb_idx = u1_num_mbs;\nps_dec->u1_mb_idx = u1_num_mbs;\n}\n}\nps_dec->u4_num_mbs_cur_nmb = 0;\nps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n- ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\nH264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\nps_dec->u2_cur_slice_num++;\nif(ps_dec->u4_first_slice_in_pic != 0)\nps_dec->ps_parse_cur_slice++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\n}\nreturn 0;\n}", "contrast": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\nWORD32 num_mb_skip,\nUWORD8 u1_is_idr_slice,\nUWORD16 u2_frame_num,\npocstruct_t *ps_cur_poc,\nWORD32 prev_slice_err)\n{\nWORD32 i2_cur_mb_addr;\nUWORD32 u1_num_mbs, u1_num_mbsNby2;\nUWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\nUWORD32 i2_mb_skip_run;\nUWORD32 u1_num_mbs_next, u1_end_of_row;\nconst UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\nUWORD32 u1_slice_end;\nUWORD32 u1_tfr_n_mb;\nUWORD32 u1_decode_nmb;\ndec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\ndec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\nUWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\nUWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\ndeblk_mb_t *ps_cur_deblk_mb;\ndec_mb_info_t *ps_cur_mb_info;\nparse_pmbarams_t *ps_parse_mb_data;\nUWORD32 u1_inter_mb_type;\nUWORD32 u1_deblk_mb_type;\nUWORD16 u2_total_mbs_coded;\nUWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\nparse_part_params_t *ps_part_info;\nWORD32 ret;\nif(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n{\nih264d_err_pic_dispbuf_mgr(ps_dec);\nreturn 0;\n}\nif(prev_slice_err == 1)\n{\nps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\nif(!ps_dec->u1_first_slice_in_stream)\n{\nih264d_end_of_pic(ps_dec, u1_is_idr_slice,\nps_dec->ps_cur_slice->u2_frame_num);\nps_dec->s_cur_pic_poc.u2_frame_num =\nps_dec->ps_cur_slice->u2_frame_num;\n}\n{\nWORD32 i, j, poc = 0;\nps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\nps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\nps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\nps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\nif(ps_dec->ps_cur_pic != NULL)\npoc = ps_dec->ps_cur_pic->i4_poc + 2;\nj = 0;\nfor(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\nif(ps_dec->ps_pps[i].u1_is_valid == TRUE)\nj = i;\n{\nret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\nps_dec->ps_cur_slice->u2_frame_num,\n&ps_dec->ps_pps[j]);\nif(ret != OK)\n{\nreturn ret;\n}\n}\nps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\nps_dec->u4_output_present = 0;\n{\nih264d_get_next_display_field(ps_dec,\nps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 != ps_dec->s_disp_op.u4_error_code)\n{\nps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n}\nelse\nps_dec->u4_output_present = 1;\n}\nif(ps_dec->u1_separate_parse == 1)\n{\nif(ps_dec->u4_dec_thread_created == 0)\n{\nithread_create(ps_dec->pv_dec_thread_handle, NULL,\n(void *)ih264d_decode_picture_thread,\n(void *)ps_dec);\nps_dec->u4_dec_thread_created = 1;\n}\nif((ps_dec->u4_num_cores == 3) &&\n((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n&& (ps_dec->u4_bs_deblk_thread_created == 0))\n{\nps_dec->u4_start_recon_deblk = 0;\nithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n(void *)ih264d_recon_deblk_thread,\n(void *)ps_dec);\nps_dec->u4_bs_deblk_thread_created = 1;\n}\n}\n}\n}\nelse\n{\ndec_slice_struct_t *ps_parse_cur_slice;\nps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\nif(ps_dec->u1_slice_header_done\n&& ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n{\nu1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\nif(u1_num_mbs)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n}\nelse\n{\nif(ps_dec->u1_separate_parse)\n{\nps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n}\nelse\n{\nps_cur_mb_info = ps_dec->ps_nmb_info\n+ ps_dec->u4_num_mbs_prev_nmb - 1;\n}\n}\nps_dec->u2_mby = ps_cur_mb_info->u2_mby;\nps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\nps_dec->u1_mb_ngbr_availablity =\nps_cur_mb_info->u1_mb_ngbr_availablity;\nps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\nps_dec->u2_cur_mb_addr--;\nps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\nif(u1_num_mbs)\n{\nif (ps_dec->u1_pr_sl_type == P_SLICE\n|| ps_dec->u1_pr_sl_type == B_SLICE)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\nps_dec->ps_part = ps_dec->ps_parse_part_params;\n}\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next)\n&& (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = 1;\nu1_tfr_n_mb = 1;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info += u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n}\nps_dec->u2_total_mbs_coded += u1_num_mbs;\nps_dec->u1_mb_idx = 0;\nps_dec->u4_num_mbs_cur_nmb = 0;\n}\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\nreturn 0;\n}\nps_dec->u2_cur_slice_num++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nps_dec->ps_parse_cur_slice++;\n}\nelse\n{\nps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n+ ps_dec->u2_cur_slice_num;\n}\n}\n{\nWORD32 num_entries;\nWORD32 size;\nUWORD8 *pu1_buf;\nnum_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\nnum_entries = 2 * ((2 * num_entries) + 1);\nsize = num_entries * sizeof(void *);\nsize += PAD_MAP_IDX_POC * sizeof(void *);\npu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\npu1_buf += size * ps_dec->u2_cur_slice_num;\nps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n}\nps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nif(ps_dec->ps_cur_slice->u1_field_pic_flag)\nps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\nps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\nps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\nif(ps_dec->u1_separate_parse)\n{\nps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n}\nelse\n{\nps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n}\nu1_inter_mb_type = P_MB;\nu1_deblk_mb_type = D_INTER_MB;\nps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\nps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\nps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nps_dec->u1_slice_header_done = 2;\nps_dec->u1_qp = ps_slice->u1_slice_qp;\nih264d_update_qp(ps_dec, 0);\nu1_mb_idx = ps_dec->u1_mb_idx;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nu1_num_mbs = u1_mb_idx;\nu1_slice_end = 0;\nu1_tfr_n_mb = 0;\nu1_decode_nmb = 0;\nu1_num_mbsNby2 = 0;\ni2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\ni2_mb_skip_run = num_mb_skip;\nwhile(!u1_slice_end)\n{\nUWORD8 u1_mb_type;\nif(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\nbreak;\nps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\nps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\nps_cur_mb_info->u1_Mux = 0;\nps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\nps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\nps_cur_mb_info->u1_end_of_slice = 0;\nps_parse_mb_data->u1_num_part = 1;\nps_parse_mb_data->u1_isI_mb = 0;\nif (u1_mbaff)\nih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nelse\nih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\nif(ps_dec->u4_app_disable_deblk_frm == 0)\n{\nih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\nps_dec->u1_mb_ngbr_availablity,\nps_dec->u1_cur_mb_fld_dec_flag);\n}\nps_dec->i1_prev_mb_qp_delta = 0;\nps_dec->u1_sub_mb_num = 0;\nps_cur_mb_info->u1_mb_type = MB_SKIP;\nps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\nps_cur_mb_info->u1_cbp = 0;\nps_part_info = ps_dec->ps_part;\nps_part_info->u1_is_direct = PART_DIRECT_16x16;\nps_part_info->u1_sub_mb_num = 0;\nps_dec->ps_part++;\nih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\nps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\nps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\ni2_mb_skip_run--;\nps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\nif (u1_mbaff)\n{\nih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n}\ni2_cur_mb_addr++;\nu1_num_mbs++;\nu1_num_mbsNby2++;\nps_parse_mb_data++;\nu1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\nu1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\nu1_slice_end = !i2_mb_skip_run;\nu1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n|| u1_slice_end;\nu1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\nps_cur_mb_info->u1_end_of_slice = u1_slice_end;\nif(u1_decode_nmb)\n{\nps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\nu1_num_mbsNby2 = 0;\nps_parse_mb_data = ps_dec->ps_parse_mb_data;\nps_dec->ps_part = ps_dec->ps_parse_part_params;\nif(ps_dec->u1_separate_parse)\n{\nih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\nu1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\nps_dec->ps_nmb_info +=  u1_num_mbs;\n}\nelse\n{\nih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\nu1_tfr_n_mb, u1_end_of_row);\n}\nps_dec->u2_total_mbs_coded += u1_num_mbs;\nif(u1_tfr_n_mb)\nu1_num_mbs = 0;\nu1_mb_idx = u1_num_mbs;\nps_dec->u1_mb_idx = u1_num_mbs;\n}\n}\nps_dec->u4_num_mbs_cur_nmb = 0;\nps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n- ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\nH264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\nps_dec->u2_cur_slice_num++;\nif(ps_dec->u4_first_slice_in_pic != 0)\nps_dec->ps_parse_cur_slice++;\nps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\nps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\nif(ps_dec->u2_total_mbs_coded\n>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nps_dec->u1_pic_decode_done = 1;\n}\nreturn 0;\n}", "label": 0}
{"index": 183282, "code": "static uint32_t readU16(const uint8_t* data, size_t offset) {\nreturn data[offset] << 8 | data[offset + 1];\n}", "contrast": "static uint32_t readU16(const uint8_t* data, size_t offset) {\nreturn ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);\n}", "label": 0}
{"index": 183320, "code": "static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\n{\nfor (unsigned i = 0; i < nSamples; ++i) {\nfor (unsigned c = 0; c < nChannels; ++c) {\n*dst++ = src[c][i] << 8;\n}\n}\n}", "contrast": "static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\nstatic void copyMultiCh8(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)\n{\nfor (unsigned i = 0; i < nSamples; ++i) {\nfor (unsigned c = 0; c < nChannels; ++c) {\n*dst++ = src[c][i] << 8;\n}\n}\n}", "label": 0}
{"index": 183321, "code": "static void copyStereo16(\nshort *dst,\nconst int *const *src,\nunsigned nSamples,\nunsigned  ) {\nfor (unsigned i = 0; i < nSamples; ++i) {\n*dst++ = src[0][i];\n*dst++ = src[1][i];\n}\n}", "contrast": "static void copyStereo16(\nshort *dst,\nconst int * src[FLACParser::kMaxChannels],\nunsigned nSamples,\nunsigned  ) {\nfor (unsigned i = 0; i < nSamples; ++i) {\n*dst++ = src[0][i];\n*dst++ = src[1][i];\n}\n}", "label": 0}
{"index": 183323, "code": "static void copyStereo8(\nshort *dst,\nconst int *const *src,\nunsigned nSamples,\nunsigned  ) {\nfor (unsigned i = 0; i < nSamples; ++i) {\n*dst++ = src[0][i] << 8;\n*dst++ = src[1][i] << 8;\n}\n}", "contrast": "static void copyStereo8(\nshort *dst,\nconst int * src[FLACParser::kMaxChannels],\nunsigned nSamples,\nunsigned  ) {\nfor (unsigned i = 0; i < nSamples; ++i) {\n*dst++ = src[0][i] << 8;\n*dst++ = src[1][i] << 8;\n}\n}", "label": 0}
{"index": 183344, "code": "IHEVCD_ERROR_T ihevcd_parse_sps(codec_t *ps_codec)\n{\nIHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\nWORD32 value;\nWORD32 i;\nWORD32 vps_id;\nWORD32 sps_max_sub_layers;\nWORD32 sps_id;\nWORD32 sps_temporal_id_nesting_flag;\nsps_t *ps_sps;\nprofile_tier_lvl_info_t s_ptl;\nbitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\nBITS_PARSE(\"video_parameter_set_id\", value, ps_bitstrm, 4);\nvps_id = value;\nvps_id = CLIP3(vps_id, 0, MAX_VPS_CNT - 1);\nBITS_PARSE(\"sps_max_sub_layers_minus1\", value, ps_bitstrm, 3);\nsps_max_sub_layers = value + 1;\nsps_max_sub_layers = CLIP3(sps_max_sub_layers, 1, 7);\nBITS_PARSE(\"sps_temporal_id_nesting_flag\", value, ps_bitstrm, 1);\nsps_temporal_id_nesting_flag = value;\nret = ihevcd_profile_tier_level(ps_bitstrm, &(s_ptl), 1,\n(sps_max_sub_layers - 1));\nUEV_PARSE(\"seq_parameter_set_id\", value, ps_bitstrm);\nsps_id = value;\nif((sps_id >= MAX_SPS_CNT) || (sps_id < 0))\n{\nif(ps_codec->i4_sps_done)\nreturn IHEVCD_UNSUPPORTED_SPS_ID;\nelse\nsps_id = 0;\n}\nps_sps = (ps_codec->s_parse.ps_sps_base + MAX_SPS_CNT - 1);\nps_sps->i1_sps_id = sps_id;\nps_sps->i1_vps_id = vps_id;\nps_sps->i1_sps_max_sub_layers = sps_max_sub_layers;\nps_sps->i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag;\nps_codec->i4_sps_id = sps_id;\nmemcpy(&ps_sps->s_ptl, &s_ptl, sizeof(profile_tier_lvl_info_t));\nUEV_PARSE(\"chroma_format_idc\", value, ps_bitstrm);\nps_sps->i1_chroma_format_idc = value;\nif(ps_sps->i1_chroma_format_idc != CHROMA_FMT_IDC_YUV420)\n{\nps_codec->s_parse.i4_error_code = IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\nreturn (IHEVCD_ERROR_T)IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\n}\nif(CHROMA_FMT_IDC_YUV444_PLANES == ps_sps->i1_chroma_format_idc)\n{\nBITS_PARSE(\"separate_colour_plane_flag\", value, ps_bitstrm, 1);\nps_sps->i1_separate_colour_plane_flag = value;\n}\nelse\n{\nps_sps->i1_separate_colour_plane_flag = 0;\n}\nUEV_PARSE(\"pic_width_in_luma_samples\", value, ps_bitstrm);\nps_sps->i2_pic_width_in_luma_samples = value;\nUEV_PARSE(\"pic_height_in_luma_samples\", value, ps_bitstrm);\nps_sps->i2_pic_height_in_luma_samples = value;\nif((0 >= ps_sps->i2_pic_width_in_luma_samples) || (0 >= ps_sps->i2_pic_height_in_luma_samples))\nreturn IHEVCD_INVALID_PARAMETER;\nps_sps->i2_pic_width_in_luma_samples = ALIGN8(ps_sps->i2_pic_width_in_luma_samples);\nps_sps->i2_pic_height_in_luma_samples = ALIGN8(ps_sps->i2_pic_height_in_luma_samples);\nif((ps_sps->i2_pic_width_in_luma_samples > ps_codec->i4_max_wd) ||\n(ps_sps->i2_pic_width_in_luma_samples * ps_sps->i2_pic_height_in_luma_samples >\nps_codec->i4_max_wd * ps_codec->i4_max_ht) ||\n(ps_sps->i2_pic_height_in_luma_samples > MAX(ps_codec->i4_max_wd, ps_codec->i4_max_ht)))\n{\nps_codec->i4_new_max_wd = ps_sps->i2_pic_width_in_luma_samples;\nps_codec->i4_new_max_ht = ps_sps->i2_pic_height_in_luma_samples;\nreturn (IHEVCD_ERROR_T)IHEVCD_UNSUPPORTED_DIMENSIONS;\n}\nBITS_PARSE(\"pic_cropping_flag\", value, ps_bitstrm, 1);\nps_sps->i1_pic_cropping_flag = value;\nif(ps_sps->i1_pic_cropping_flag)\n{\nUEV_PARSE(\"pic_crop_left_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_left_offset = value;\nUEV_PARSE(\"pic_crop_right_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_right_offset = value;\nUEV_PARSE(\"pic_crop_top_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_top_offset = value;\nUEV_PARSE(\"pic_crop_bottom_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_bottom_offset = value;\n}\nelse\n{\nps_sps->i2_pic_crop_left_offset = 0;\nps_sps->i2_pic_crop_right_offset = 0;\nps_sps->i2_pic_crop_top_offset = 0;\nps_sps->i2_pic_crop_bottom_offset = 0;\n}\nUEV_PARSE(\"bit_depth_luma_minus8\", value, ps_bitstrm);\nif(0 != value)\nreturn IHEVCD_UNSUPPORTED_BIT_DEPTH;\nUEV_PARSE(\"bit_depth_chroma_minus8\", value, ps_bitstrm);\nif(0 != value)\nreturn IHEVCD_UNSUPPORTED_BIT_DEPTH;\nUEV_PARSE(\"log2_max_pic_order_cnt_lsb_minus4\", value, ps_bitstrm);\nps_sps->i1_log2_max_pic_order_cnt_lsb = value + 4;\nBITS_PARSE(\"sps_sub_layer_ordering_info_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sps_sub_layer_ordering_info_present_flag = value;\ni = (ps_sps->i1_sps_sub_layer_ordering_info_present_flag ? 0 : (ps_sps->i1_sps_max_sub_layers - 1));\nfor(; i < ps_sps->i1_sps_max_sub_layers; i++)\n{\nUEV_PARSE(\"max_dec_pic_buffering\", value, ps_bitstrm);\nps_sps->ai1_sps_max_dec_pic_buffering[i] = value + 1;\nUEV_PARSE(\"num_reorder_pics\", value, ps_bitstrm);\nps_sps->ai1_sps_max_num_reorder_pics[i] = value;\nUEV_PARSE(\"max_latency_increase\", value, ps_bitstrm);\nps_sps->ai1_sps_max_latency_increase[i] = value;\n}\nUEV_PARSE(\"log2_min_coding_block_size_minus3\", value, ps_bitstrm);\nps_sps->i1_log2_min_coding_block_size = value + 3;\nUEV_PARSE(\"log2_diff_max_min_coding_block_size\", value, ps_bitstrm);\nps_sps->i1_log2_diff_max_min_coding_block_size = value;\nUEV_PARSE(\"log2_min_transform_block_size_minus2\", value, ps_bitstrm);\nps_sps->i1_log2_min_transform_block_size = value + 2;\nUEV_PARSE(\"log2_diff_max_min_transform_block_size\", value, ps_bitstrm);\nps_sps->i1_log2_diff_max_min_transform_block_size = value;\nps_sps->i1_log2_max_transform_block_size = ps_sps->i1_log2_min_transform_block_size +\nps_sps->i1_log2_diff_max_min_transform_block_size;\nps_sps->i1_log2_ctb_size = ps_sps->i1_log2_min_coding_block_size +\nps_sps->i1_log2_diff_max_min_coding_block_size;\nif((ps_sps->i1_log2_min_coding_block_size < 3) ||\n(ps_sps->i1_log2_min_transform_block_size < 2) ||\n(ps_sps->i1_log2_diff_max_min_transform_block_size < 0) ||\n(ps_sps->i1_log2_max_transform_block_size > ps_sps->i1_log2_ctb_size) ||\n(ps_sps->i1_log2_ctb_size < 4) ||\n(ps_sps->i1_log2_ctb_size > 6))\n{\nreturn IHEVCD_INVALID_PARAMETER;\n}\nps_sps->i1_log2_min_pcm_coding_block_size = 0;\nps_sps->i1_log2_diff_max_min_pcm_coding_block_size = 0;\nUEV_PARSE(\"max_transform_hierarchy_depth_inter\", value, ps_bitstrm);\nps_sps->i1_max_transform_hierarchy_depth_inter = value;\nUEV_PARSE(\"max_transform_hierarchy_depth_intra\", value, ps_bitstrm);\nps_sps->i1_max_transform_hierarchy_depth_intra = value;\nBITS_PARSE(\"scaling_list_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_scaling_list_enable_flag = value;\nif(ps_sps->i1_scaling_list_enable_flag)\n{\nCOPY_DEFAULT_SCALING_LIST(ps_sps->pi2_scaling_mat);\nBITS_PARSE(\"sps_scaling_list_data_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sps_scaling_list_data_present_flag = value;\nif(ps_sps->i1_sps_scaling_list_data_present_flag)\nihevcd_scaling_list_data(ps_codec, ps_sps->pi2_scaling_mat);\n}\nelse\n{\nCOPY_FLAT_SCALING_LIST(ps_sps->pi2_scaling_mat);\n}\nBITS_PARSE(\"asymmetric_motion_partitions_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_amp_enabled_flag = value;\nBITS_PARSE(\"sample_adaptive_offset_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sample_adaptive_offset_enabled_flag = value;\nBITS_PARSE(\"pcm_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_pcm_enabled_flag = value;\nif(ps_sps->i1_pcm_enabled_flag)\n{\nBITS_PARSE(\"pcm_sample_bit_depth_luma\", value, ps_bitstrm, 4);\nps_sps->i1_pcm_sample_bit_depth_luma = value + 1;\nBITS_PARSE(\"pcm_sample_bit_depth_chroma\", value, ps_bitstrm, 4);\nps_sps->i1_pcm_sample_bit_depth_chroma = value + 1;\nUEV_PARSE(\"log2_min_pcm_coding_block_size_minus3\", value, ps_bitstrm);\nps_sps->i1_log2_min_pcm_coding_block_size = value + 3;\nUEV_PARSE(\"log2_diff_max_min_pcm_coding_block_size\", value, ps_bitstrm);\nps_sps->i1_log2_diff_max_min_pcm_coding_block_size = value;\nBITS_PARSE(\"pcm_loop_filter_disable_flag\", value, ps_bitstrm, 1);\nps_sps->i1_pcm_loop_filter_disable_flag = value;\n}\nUEV_PARSE(\"num_short_term_ref_pic_sets\", value, ps_bitstrm);\nps_sps->i1_num_short_term_ref_pic_sets = value;\nps_sps->i1_num_short_term_ref_pic_sets = CLIP3(ps_sps->i1_num_short_term_ref_pic_sets, 0, MAX_STREF_PICS_SPS);\nfor(i = 0; i < ps_sps->i1_num_short_term_ref_pic_sets; i++)\nihevcd_short_term_ref_pic_set(ps_bitstrm, &ps_sps->as_stref_picset[0], ps_sps->i1_num_short_term_ref_pic_sets, i, &ps_sps->as_stref_picset[i]);\nBITS_PARSE(\"long_term_ref_pics_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_long_term_ref_pics_present_flag = value;\nif(ps_sps->i1_long_term_ref_pics_present_flag)\n{\nUEV_PARSE(\"num_long_term_ref_pics_sps\", value, ps_bitstrm);\nps_sps->i1_num_long_term_ref_pics_sps = value;\nfor(i = 0; i < ps_sps->i1_num_long_term_ref_pics_sps; i++)\n{\nBITS_PARSE(\"lt_ref_pic_poc_lsb_sps[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\nps_sps->ai1_lt_ref_pic_poc_lsb_sps[i] = value;\nBITS_PARSE(\"used_by_curr_pic_lt_sps_flag[ i ]\", value, ps_bitstrm, 1);\nps_sps->ai1_used_by_curr_pic_lt_sps_flag[i] = value;\n}\n}\nBITS_PARSE(\"sps_temporal_mvp_enable_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sps_temporal_mvp_enable_flag = value;\nBITS_PARSE(\"sps_strong_intra_smoothing_enable_flag\", value, ps_bitstrm, 1);\nps_sps->i1_strong_intra_smoothing_enable_flag = value;\nBITS_PARSE(\"vui_parameters_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_vui_parameters_present_flag = value;\nif(ps_sps->i1_vui_parameters_present_flag)\nihevcd_parse_vui_parameters(ps_bitstrm,\n&ps_sps->s_vui_parameters,\nps_sps->i1_sps_max_sub_layers - 1);\nBITS_PARSE(\"sps_extension_flag\", value, ps_bitstrm, 1);\n{\nWORD32 numerator;\nWORD32 ceil_offset;\nceil_offset = (1 << ps_sps->i1_log2_ctb_size) - 1;\nnumerator = ps_sps->i2_pic_width_in_luma_samples;\nps_sps->i2_pic_wd_in_ctb = ((numerator + ceil_offset) /\n(1 << ps_sps->i1_log2_ctb_size));\nnumerator = ps_sps->i2_pic_height_in_luma_samples;\nps_sps->i2_pic_ht_in_ctb = ((numerator + ceil_offset) /\n(1 << ps_sps->i1_log2_ctb_size));\nps_sps->i4_pic_size_in_ctb = ps_sps->i2_pic_ht_in_ctb *\nps_sps->i2_pic_wd_in_ctb;\nif(0 == ps_codec->i4_sps_done)\nps_codec->s_parse.i4_next_ctb_indx = ps_sps->i4_pic_size_in_ctb;\nnumerator = ps_sps->i2_pic_width_in_luma_samples;\nps_sps->i2_pic_wd_in_min_cb = numerator  /\n(1 << ps_sps->i1_log2_min_coding_block_size);\nnumerator = ps_sps->i2_pic_height_in_luma_samples;\nps_sps->i2_pic_ht_in_min_cb = numerator  /\n(1 << ps_sps->i1_log2_min_coding_block_size);\n}\nif((0 != ps_codec->i4_first_pic_done) &&\n((ps_codec->i4_wd != ps_sps->i2_pic_width_in_luma_samples) ||\n(ps_codec->i4_ht != ps_sps->i2_pic_height_in_luma_samples)))\n{\nps_codec->i4_reset_flag = 1;\nps_codec->i4_error_code = IVD_RES_CHANGED;\nreturn (IHEVCD_ERROR_T)IHEVCD_FAIL;\n}\n{\nWORD32 disp_wd, disp_ht;\nWORD32 crop_unit_x, crop_unit_y;\ncrop_unit_x = 1;\ncrop_unit_y = 1;\nif(CHROMA_FMT_IDC_YUV420 == ps_sps->i1_chroma_format_idc)\n{\ncrop_unit_x = 2;\ncrop_unit_y = 2;\n}\ndisp_wd = ps_sps->i2_pic_width_in_luma_samples;\ndisp_wd -= ps_sps->i2_pic_crop_left_offset * crop_unit_x;\ndisp_wd -= ps_sps->i2_pic_crop_right_offset * crop_unit_x;\ndisp_ht = ps_sps->i2_pic_height_in_luma_samples;\ndisp_ht -= ps_sps->i2_pic_crop_top_offset * crop_unit_y;\ndisp_ht -= ps_sps->i2_pic_crop_bottom_offset * crop_unit_y;\nif((0 >= disp_wd) || (0 >= disp_ht))\nreturn IHEVCD_INVALID_PARAMETER;\nps_codec->i4_disp_wd = disp_wd;\nps_codec->i4_disp_ht = disp_ht;\nps_codec->i4_wd = ps_sps->i2_pic_width_in_luma_samples;\nps_codec->i4_ht = ps_sps->i2_pic_height_in_luma_samples;\n{\nWORD32 ref_strd;\nref_strd = ALIGN32(ps_sps->i2_pic_width_in_luma_samples + PAD_WD);\nif(ps_codec->i4_strd < ref_strd)\n{\nps_codec->i4_strd = ref_strd;\n}\n}\nif(0 == ps_codec->i4_share_disp_buf)\n{\nif(ps_codec->i4_disp_strd < ps_codec->i4_disp_wd)\n{\nps_codec->i4_disp_strd = ps_codec->i4_disp_wd;\n}\n}\nelse\n{\nif(ps_codec->i4_disp_strd < ps_codec->i4_strd)\n{\nps_codec->i4_disp_strd = ps_codec->i4_strd;\n}\n}\n}\nps_codec->i4_sps_done = 1;\nreturn ret;\n}", "contrast": "IHEVCD_ERROR_T ihevcd_parse_sps(codec_t *ps_codec)\n{\nIHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\nWORD32 value;\nWORD32 i;\nWORD32 vps_id;\nWORD32 sps_max_sub_layers;\nWORD32 sps_id;\nWORD32 sps_temporal_id_nesting_flag;\nsps_t *ps_sps;\nprofile_tier_lvl_info_t s_ptl;\nbitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\nBITS_PARSE(\"video_parameter_set_id\", value, ps_bitstrm, 4);\nvps_id = value;\nvps_id = CLIP3(vps_id, 0, MAX_VPS_CNT - 1);\nBITS_PARSE(\"sps_max_sub_layers_minus1\", value, ps_bitstrm, 3);\nsps_max_sub_layers = value + 1;\nsps_max_sub_layers = CLIP3(sps_max_sub_layers, 1, 7);\nBITS_PARSE(\"sps_temporal_id_nesting_flag\", value, ps_bitstrm, 1);\nsps_temporal_id_nesting_flag = value;\nret = ihevcd_profile_tier_level(ps_bitstrm, &(s_ptl), 1,\n(sps_max_sub_layers - 1));\nUEV_PARSE(\"seq_parameter_set_id\", value, ps_bitstrm);\nsps_id = value;\nif((sps_id >= MAX_SPS_CNT) || (sps_id < 0))\n{\nif(ps_codec->i4_sps_done)\nreturn IHEVCD_UNSUPPORTED_SPS_ID;\nelse\nsps_id = 0;\n}\nps_sps = (ps_codec->s_parse.ps_sps_base + MAX_SPS_CNT - 1);\nps_sps->i1_sps_id = sps_id;\nps_sps->i1_vps_id = vps_id;\nps_sps->i1_sps_max_sub_layers = sps_max_sub_layers;\nps_sps->i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag;\nps_codec->i4_sps_id = sps_id;\nmemcpy(&ps_sps->s_ptl, &s_ptl, sizeof(profile_tier_lvl_info_t));\nUEV_PARSE(\"chroma_format_idc\", value, ps_bitstrm);\nps_sps->i1_chroma_format_idc = value;\nif(ps_sps->i1_chroma_format_idc != CHROMA_FMT_IDC_YUV420)\n{\nps_codec->s_parse.i4_error_code = IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\nreturn (IHEVCD_ERROR_T)IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\n}\nif(CHROMA_FMT_IDC_YUV444_PLANES == ps_sps->i1_chroma_format_idc)\n{\nBITS_PARSE(\"separate_colour_plane_flag\", value, ps_bitstrm, 1);\nps_sps->i1_separate_colour_plane_flag = value;\n}\nelse\n{\nps_sps->i1_separate_colour_plane_flag = 0;\n}\nUEV_PARSE(\"pic_width_in_luma_samples\", value, ps_bitstrm);\nps_sps->i2_pic_width_in_luma_samples = value;\nUEV_PARSE(\"pic_height_in_luma_samples\", value, ps_bitstrm);\nps_sps->i2_pic_height_in_luma_samples = value;\nif((0 >= ps_sps->i2_pic_width_in_luma_samples) || (0 >= ps_sps->i2_pic_height_in_luma_samples))\nreturn IHEVCD_INVALID_PARAMETER;\nps_sps->i2_pic_width_in_luma_samples = ALIGN8(ps_sps->i2_pic_width_in_luma_samples);\nps_sps->i2_pic_height_in_luma_samples = ALIGN8(ps_sps->i2_pic_height_in_luma_samples);\nif((ps_sps->i2_pic_width_in_luma_samples > ps_codec->i4_max_wd) ||\n(ps_sps->i2_pic_width_in_luma_samples * ps_sps->i2_pic_height_in_luma_samples >\nps_codec->i4_max_wd * ps_codec->i4_max_ht) ||\n(ps_sps->i2_pic_height_in_luma_samples > MAX(ps_codec->i4_max_wd, ps_codec->i4_max_ht)))\n{\nps_codec->i4_new_max_wd = ps_sps->i2_pic_width_in_luma_samples;\nps_codec->i4_new_max_ht = ps_sps->i2_pic_height_in_luma_samples;\nreturn (IHEVCD_ERROR_T)IHEVCD_UNSUPPORTED_DIMENSIONS;\n}\nBITS_PARSE(\"pic_cropping_flag\", value, ps_bitstrm, 1);\nps_sps->i1_pic_cropping_flag = value;\nif(ps_sps->i1_pic_cropping_flag)\n{\nUEV_PARSE(\"pic_crop_left_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_left_offset = value;\nUEV_PARSE(\"pic_crop_right_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_right_offset = value;\nUEV_PARSE(\"pic_crop_top_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_top_offset = value;\nUEV_PARSE(\"pic_crop_bottom_offset\", value, ps_bitstrm);\nps_sps->i2_pic_crop_bottom_offset = value;\n}\nelse\n{\nps_sps->i2_pic_crop_left_offset = 0;\nps_sps->i2_pic_crop_right_offset = 0;\nps_sps->i2_pic_crop_top_offset = 0;\nps_sps->i2_pic_crop_bottom_offset = 0;\n}\nUEV_PARSE(\"bit_depth_luma_minus8\", value, ps_bitstrm);\nif(0 != value)\nreturn IHEVCD_UNSUPPORTED_BIT_DEPTH;\nUEV_PARSE(\"bit_depth_chroma_minus8\", value, ps_bitstrm);\nif(0 != value)\nreturn IHEVCD_UNSUPPORTED_BIT_DEPTH;\nUEV_PARSE(\"log2_max_pic_order_cnt_lsb_minus4\", value, ps_bitstrm);\nps_sps->i1_log2_max_pic_order_cnt_lsb = value + 4;\nBITS_PARSE(\"sps_sub_layer_ordering_info_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sps_sub_layer_ordering_info_present_flag = value;\ni = (ps_sps->i1_sps_sub_layer_ordering_info_present_flag ? 0 : (ps_sps->i1_sps_max_sub_layers - 1));\nfor(; i < ps_sps->i1_sps_max_sub_layers; i++)\n{\nUEV_PARSE(\"max_dec_pic_buffering\", value, ps_bitstrm);\nps_sps->ai1_sps_max_dec_pic_buffering[i] = value + 1;\nif(ps_sps->ai1_sps_max_dec_pic_buffering[i] > MAX_DPB_SIZE)\n{\nreturn IHEVCD_INVALID_PARAMETER;\n}\nUEV_PARSE(\"num_reorder_pics\", value, ps_bitstrm);\nps_sps->ai1_sps_max_num_reorder_pics[i] = value;\nif(ps_sps->ai1_sps_max_num_reorder_pics[i] > ps_sps->ai1_sps_max_dec_pic_buffering[i])\n{\nreturn IHEVCD_INVALID_PARAMETER;\n}\nUEV_PARSE(\"max_latency_increase\", value, ps_bitstrm);\nps_sps->ai1_sps_max_latency_increase[i] = value;\n}\nUEV_PARSE(\"log2_min_coding_block_size_minus3\", value, ps_bitstrm);\nps_sps->i1_log2_min_coding_block_size = value + 3;\nUEV_PARSE(\"log2_diff_max_min_coding_block_size\", value, ps_bitstrm);\nps_sps->i1_log2_diff_max_min_coding_block_size = value;\nUEV_PARSE(\"log2_min_transform_block_size_minus2\", value, ps_bitstrm);\nps_sps->i1_log2_min_transform_block_size = value + 2;\nUEV_PARSE(\"log2_diff_max_min_transform_block_size\", value, ps_bitstrm);\nps_sps->i1_log2_diff_max_min_transform_block_size = value;\nps_sps->i1_log2_max_transform_block_size = ps_sps->i1_log2_min_transform_block_size +\nps_sps->i1_log2_diff_max_min_transform_block_size;\nps_sps->i1_log2_ctb_size = ps_sps->i1_log2_min_coding_block_size +\nps_sps->i1_log2_diff_max_min_coding_block_size;\nif((ps_sps->i1_log2_min_coding_block_size < 3) ||\n(ps_sps->i1_log2_min_transform_block_size < 2) ||\n(ps_sps->i1_log2_diff_max_min_transform_block_size < 0) ||\n(ps_sps->i1_log2_max_transform_block_size > ps_sps->i1_log2_ctb_size) ||\n(ps_sps->i1_log2_ctb_size < 4) ||\n(ps_sps->i1_log2_ctb_size > 6))\n{\nreturn IHEVCD_INVALID_PARAMETER;\n}\nps_sps->i1_log2_min_pcm_coding_block_size = 0;\nps_sps->i1_log2_diff_max_min_pcm_coding_block_size = 0;\nUEV_PARSE(\"max_transform_hierarchy_depth_inter\", value, ps_bitstrm);\nps_sps->i1_max_transform_hierarchy_depth_inter = value;\nUEV_PARSE(\"max_transform_hierarchy_depth_intra\", value, ps_bitstrm);\nps_sps->i1_max_transform_hierarchy_depth_intra = value;\nBITS_PARSE(\"scaling_list_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_scaling_list_enable_flag = value;\nif(ps_sps->i1_scaling_list_enable_flag)\n{\nCOPY_DEFAULT_SCALING_LIST(ps_sps->pi2_scaling_mat);\nBITS_PARSE(\"sps_scaling_list_data_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sps_scaling_list_data_present_flag = value;\nif(ps_sps->i1_sps_scaling_list_data_present_flag)\nihevcd_scaling_list_data(ps_codec, ps_sps->pi2_scaling_mat);\n}\nelse\n{\nCOPY_FLAT_SCALING_LIST(ps_sps->pi2_scaling_mat);\n}\nBITS_PARSE(\"asymmetric_motion_partitions_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_amp_enabled_flag = value;\nBITS_PARSE(\"sample_adaptive_offset_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sample_adaptive_offset_enabled_flag = value;\nBITS_PARSE(\"pcm_enabled_flag\", value, ps_bitstrm, 1);\nps_sps->i1_pcm_enabled_flag = value;\nif(ps_sps->i1_pcm_enabled_flag)\n{\nBITS_PARSE(\"pcm_sample_bit_depth_luma\", value, ps_bitstrm, 4);\nps_sps->i1_pcm_sample_bit_depth_luma = value + 1;\nBITS_PARSE(\"pcm_sample_bit_depth_chroma\", value, ps_bitstrm, 4);\nps_sps->i1_pcm_sample_bit_depth_chroma = value + 1;\nUEV_PARSE(\"log2_min_pcm_coding_block_size_minus3\", value, ps_bitstrm);\nps_sps->i1_log2_min_pcm_coding_block_size = value + 3;\nUEV_PARSE(\"log2_diff_max_min_pcm_coding_block_size\", value, ps_bitstrm);\nps_sps->i1_log2_diff_max_min_pcm_coding_block_size = value;\nBITS_PARSE(\"pcm_loop_filter_disable_flag\", value, ps_bitstrm, 1);\nps_sps->i1_pcm_loop_filter_disable_flag = value;\n}\nUEV_PARSE(\"num_short_term_ref_pic_sets\", value, ps_bitstrm);\nps_sps->i1_num_short_term_ref_pic_sets = value;\nps_sps->i1_num_short_term_ref_pic_sets = CLIP3(ps_sps->i1_num_short_term_ref_pic_sets, 0, MAX_STREF_PICS_SPS);\nfor(i = 0; i < ps_sps->i1_num_short_term_ref_pic_sets; i++)\nihevcd_short_term_ref_pic_set(ps_bitstrm, &ps_sps->as_stref_picset[0], ps_sps->i1_num_short_term_ref_pic_sets, i, &ps_sps->as_stref_picset[i]);\nBITS_PARSE(\"long_term_ref_pics_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_long_term_ref_pics_present_flag = value;\nif(ps_sps->i1_long_term_ref_pics_present_flag)\n{\nUEV_PARSE(\"num_long_term_ref_pics_sps\", value, ps_bitstrm);\nps_sps->i1_num_long_term_ref_pics_sps = value;\nfor(i = 0; i < ps_sps->i1_num_long_term_ref_pics_sps; i++)\n{\nBITS_PARSE(\"lt_ref_pic_poc_lsb_sps[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\nps_sps->ai1_lt_ref_pic_poc_lsb_sps[i] = value;\nBITS_PARSE(\"used_by_curr_pic_lt_sps_flag[ i ]\", value, ps_bitstrm, 1);\nps_sps->ai1_used_by_curr_pic_lt_sps_flag[i] = value;\n}\n}\nBITS_PARSE(\"sps_temporal_mvp_enable_flag\", value, ps_bitstrm, 1);\nps_sps->i1_sps_temporal_mvp_enable_flag = value;\nBITS_PARSE(\"sps_strong_intra_smoothing_enable_flag\", value, ps_bitstrm, 1);\nps_sps->i1_strong_intra_smoothing_enable_flag = value;\nBITS_PARSE(\"vui_parameters_present_flag\", value, ps_bitstrm, 1);\nps_sps->i1_vui_parameters_present_flag = value;\nif(ps_sps->i1_vui_parameters_present_flag)\nihevcd_parse_vui_parameters(ps_bitstrm,\n&ps_sps->s_vui_parameters,\nps_sps->i1_sps_max_sub_layers - 1);\nBITS_PARSE(\"sps_extension_flag\", value, ps_bitstrm, 1);\n{\nWORD32 numerator;\nWORD32 ceil_offset;\nceil_offset = (1 << ps_sps->i1_log2_ctb_size) - 1;\nnumerator = ps_sps->i2_pic_width_in_luma_samples;\nps_sps->i2_pic_wd_in_ctb = ((numerator + ceil_offset) /\n(1 << ps_sps->i1_log2_ctb_size));\nnumerator = ps_sps->i2_pic_height_in_luma_samples;\nps_sps->i2_pic_ht_in_ctb = ((numerator + ceil_offset) /\n(1 << ps_sps->i1_log2_ctb_size));\nps_sps->i4_pic_size_in_ctb = ps_sps->i2_pic_ht_in_ctb *\nps_sps->i2_pic_wd_in_ctb;\nif(0 == ps_codec->i4_sps_done)\nps_codec->s_parse.i4_next_ctb_indx = ps_sps->i4_pic_size_in_ctb;\nnumerator = ps_sps->i2_pic_width_in_luma_samples;\nps_sps->i2_pic_wd_in_min_cb = numerator  /\n(1 << ps_sps->i1_log2_min_coding_block_size);\nnumerator = ps_sps->i2_pic_height_in_luma_samples;\nps_sps->i2_pic_ht_in_min_cb = numerator  /\n(1 << ps_sps->i1_log2_min_coding_block_size);\n}\nif((0 != ps_codec->i4_first_pic_done) &&\n((ps_codec->i4_wd != ps_sps->i2_pic_width_in_luma_samples) ||\n(ps_codec->i4_ht != ps_sps->i2_pic_height_in_luma_samples)))\n{\nps_codec->i4_reset_flag = 1;\nps_codec->i4_error_code = IVD_RES_CHANGED;\nreturn (IHEVCD_ERROR_T)IHEVCD_FAIL;\n}\n{\nWORD32 disp_wd, disp_ht;\nWORD32 crop_unit_x, crop_unit_y;\ncrop_unit_x = 1;\ncrop_unit_y = 1;\nif(CHROMA_FMT_IDC_YUV420 == ps_sps->i1_chroma_format_idc)\n{\ncrop_unit_x = 2;\ncrop_unit_y = 2;\n}\ndisp_wd = ps_sps->i2_pic_width_in_luma_samples;\ndisp_wd -= ps_sps->i2_pic_crop_left_offset * crop_unit_x;\ndisp_wd -= ps_sps->i2_pic_crop_right_offset * crop_unit_x;\ndisp_ht = ps_sps->i2_pic_height_in_luma_samples;\ndisp_ht -= ps_sps->i2_pic_crop_top_offset * crop_unit_y;\ndisp_ht -= ps_sps->i2_pic_crop_bottom_offset * crop_unit_y;\nif((0 >= disp_wd) || (0 >= disp_ht))\nreturn IHEVCD_INVALID_PARAMETER;\nps_codec->i4_disp_wd = disp_wd;\nps_codec->i4_disp_ht = disp_ht;\nps_codec->i4_wd = ps_sps->i2_pic_width_in_luma_samples;\nps_codec->i4_ht = ps_sps->i2_pic_height_in_luma_samples;\n{\nWORD32 ref_strd;\nref_strd = ALIGN32(ps_sps->i2_pic_width_in_luma_samples + PAD_WD);\nif(ps_codec->i4_strd < ref_strd)\n{\nps_codec->i4_strd = ref_strd;\n}\n}\nif(0 == ps_codec->i4_share_disp_buf)\n{\nif(ps_codec->i4_disp_strd < ps_codec->i4_disp_wd)\n{\nps_codec->i4_disp_strd = ps_codec->i4_disp_wd;\n}\n}\nelse\n{\nif(ps_codec->i4_disp_strd < ps_codec->i4_strd)\n{\nps_codec->i4_disp_strd = ps_codec->i4_strd;\n}\n}\n}\nps_codec->i4_sps_done = 1;\nreturn ret;\n}", "label": 0}
{"index": 183349, "code": "int Equalizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){\nint status = 0;\nint32_t preset;\nint32_t band;\nint32_t level;\nint32_t *pParamTemp = (int32_t *)pParam;\nint32_t param = *pParamTemp++;\nswitch (param) {\ncase EQ_PARAM_CUR_PRESET:\npreset = (int32_t)(*(uint16_t *)pValue);\nif ((preset >= EqualizerGetNumPresets())||(preset < 0)) {\nstatus = -EINVAL;\nbreak;\n}\nEqualizerSetPreset(pContext, preset);\nbreak;\ncase EQ_PARAM_BAND_LEVEL:\nband =  *pParamTemp;\nlevel = (int32_t)(*(int16_t *)pValue);\nif (band >= FIVEBAND_NUMBANDS) {\nstatus = -EINVAL;\nbreak;\n}\nEqualizerSetBandLevel(pContext, band, level);\nbreak;\ncase EQ_PARAM_PROPERTIES: {\nint16_t *p = (int16_t *)pValue;\nif ((int)p[0] >= EqualizerGetNumPresets()) {\nstatus = -EINVAL;\nbreak;\n}\nif (p[0] >= 0) {\nEqualizerSetPreset(pContext, (int)p[0]);\n} else {\nif ((int)p[1] != FIVEBAND_NUMBANDS) {\nstatus = -EINVAL;\nbreak;\n}\nfor (int i = 0; i < FIVEBAND_NUMBANDS; i++) {\nEqualizerSetBandLevel(pContext, i, (int)p[2 + i]);\n}\n}\n} break;\ndefault:\nALOGV(\"\\tLVM_ERROR : Equalizer_setParameter() invalid param %d\", param);\nstatus = -EINVAL;\nbreak;\n}\nreturn status;\n}", "contrast": "int Equalizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){\nint status = 0;\nint32_t preset;\nint32_t band;\nint32_t level;\nint32_t *pParamTemp = (int32_t *)pParam;\nint32_t param = *pParamTemp++;\nswitch (param) {\ncase EQ_PARAM_CUR_PRESET:\npreset = (int32_t)(*(uint16_t *)pValue);\nif ((preset >= EqualizerGetNumPresets())||(preset < 0)) {\nstatus = -EINVAL;\nbreak;\n}\nEqualizerSetPreset(pContext, preset);\nbreak;\ncase EQ_PARAM_BAND_LEVEL:\nband =  *pParamTemp;\nlevel = (int32_t)(*(int16_t *)pValue);\nif (band < 0 || band >= FIVEBAND_NUMBANDS) {\nstatus = -EINVAL;\nif (band < 0) {\nandroid_errorWriteLog(0x534e4554, \"32095626\");\nALOGE(\"\\tERROR Equalizer_setParameter() EQ_PARAM_BAND_LEVEL band %d\", band);\n}\nbreak;\n}\nEqualizerSetBandLevel(pContext, band, level);\nbreak;\ncase EQ_PARAM_PROPERTIES: {\nint16_t *p = (int16_t *)pValue;\nif ((int)p[0] >= EqualizerGetNumPresets()) {\nstatus = -EINVAL;\nbreak;\n}\nif (p[0] >= 0) {\nEqualizerSetPreset(pContext, (int)p[0]);\n} else {\nif ((int)p[1] != FIVEBAND_NUMBANDS) {\nstatus = -EINVAL;\nbreak;\n}\nfor (int i = 0; i < FIVEBAND_NUMBANDS; i++) {\nEqualizerSetBandLevel(pContext, i, (int)p[2 + i]);\n}\n}\n} break;\ndefault:\nALOGV(\"\\tLVM_ERROR : Equalizer_setParameter() invalid param %d\", param);\nstatus = -EINVAL;\nbreak;\n}\nreturn status;\n}", "label": 0}
{"index": 183361, "code": "void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\nuint8_t* p = (uint8_t*)p_data;\nuint8_t reason = SMP_INVALID_PARAMETERS;\nSMP_TRACE_DEBUG(\"%s\", __func__);\np_cb->status = *(uint8_t*)p_data;\nif (smp_command_has_invalid_parameters(p_cb)) {\nsmp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);\nreturn;\n}\nif (p != NULL) {\nSTREAM_TO_UINT8(p_cb->peer_keypress_notification, p);\n} else {\np_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;\n}\np_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;\n}", "contrast": "void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\nuint8_t* p = (uint8_t*)p_data;\nuint8_t reason = SMP_INVALID_PARAMETERS;\nSMP_TRACE_DEBUG(\"%s\", __func__);\nif (smp_command_has_invalid_parameters(p_cb)) {\nif (p_cb->rcvd_cmd_len < 2) {\nandroid_errorWriteLog(0x534e4554, \"111936834\");\n}\nsmp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);\nreturn;\n}\np_cb->status = *(uint8_t*)p_data;\nif (p != NULL) {\nSTREAM_TO_UINT8(p_cb->peer_keypress_notification, p);\n} else {\np_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;\n}\np_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;\n}", "label": 0}
{"index": 183368, "code": "void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,\nimpeg2d_video_decode_op_t *ps_op)\n{\nUWORD32 u4_bits_read;\ndec_state_t *ps_dec;\nUWORD32 u4_size = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\nps_dec = (dec_state_t *)pv_dec;\nps_op->s_ivd_video_decode_op_t.u4_error_code = 0;\nif (u4_size > MAX_BITSTREAM_BUFFER_SIZE)\n{\nu4_size = MAX_BITSTREAM_BUFFER_SIZE;\n}\nmemcpy(ps_dec->pu1_input_buffer, ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer, u4_size);\nimpeg2d_bit_stream_init(&(ps_dec->s_bit_stream), ps_dec->pu1_input_buffer,\nu4_size);\n{\n{\nIMPEG2D_ERROR_CODES_T e_error;\ne_error = impeg2d_process_video_header(ps_dec);\nif ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n{\nps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;\nu4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\nif(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n{\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n}\nif(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)\nps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;\nif (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)\n{\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;\nps_dec->u2_header_done = 0;\nps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;\nps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;\n}\nimpeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);\nreturn;\n}\n}\nps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;\nps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;\nps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;\nps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;\nu4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\nif(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n{\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n}\nps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;\nps_dec->u2_header_done = 1;\n}\n}", "contrast": "void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,\nimpeg2d_video_decode_op_t *ps_op)\n{\nUWORD32 u4_bits_read;\ndec_state_t *ps_dec;\nUWORD32 u4_size = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\nps_dec = (dec_state_t *)pv_dec;\nps_op->s_ivd_video_decode_op_t.u4_error_code = 0;\nif (u4_size > MAX_BITSTREAM_BUFFER_SIZE)\n{\nu4_size = MAX_BITSTREAM_BUFFER_SIZE;\n}\nmemcpy(ps_dec->pu1_input_buffer, ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer, u4_size);\nimpeg2d_bit_stream_init(&(ps_dec->s_bit_stream), ps_dec->pu1_input_buffer,\nu4_size);\n{\n{\nIMPEG2D_ERROR_CODES_T e_error;\ne_error = impeg2d_process_video_header(ps_dec);\nif ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n{\nps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;\nu4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\nif(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n{\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n}\nif(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)\nps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;\nif (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)\n{\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;\nps_dec->u2_header_done = 0;\nps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;\nps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;\n}\nimpeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);\nreturn;\n}\n}\nps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;\nps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;\nps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;\nps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;\nu4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\nif(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n{\nps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n}\nps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;\nif (0 == ps_dec->u4_frm_buf_stride)\n{\nps_dec->u4_frm_buf_stride = ps_dec->u2_horizontal_size;\n}\nps_dec->u2_header_done = 1;\n}\n}", "label": 0}
{"index": 183371, "code": "VOID ixheaacd_shiftrountine_with_rnd_hq(WORD32 *qmf_real, WORD32 *qmf_imag,\nWORD32 *filter_states, WORD32 len,\nWORD32 shift) {\nWORD32 *filter_states_rev = filter_states + len;\nWORD32 treal, timag;\nWORD32 j;\nfor (j = (len - 1); j >= 0; j -= 2) {\nWORD32 r1, r2, i1, i2;\ni2 = qmf_imag[j];\nr2 = qmf_real[j];\nr1 = *qmf_real++;\ni1 = *qmf_imag++;\ntimag = ixheaacd_add32(i1, r1);\ntimag = (ixheaacd_shl32_sat(timag, shift));\nfilter_states_rev[j] = timag;\ntreal = ixheaacd_sub32(i2, r2);\ntreal = (ixheaacd_shl32_sat(treal, shift));\nfilter_states[j] = treal;\ntreal = ixheaacd_sub32(i1, r1);\ntreal = (ixheaacd_shl32_sat(treal, shift));\n*filter_states++ = treal;\ntimag = ixheaacd_add32(i2, r2);\ntimag = (ixheaacd_shl32_sat(timag, shift));\n*filter_states_rev++ = timag;\n}\n}", "contrast": "VOID ixheaacd_shiftrountine_with_rnd_hq(WORD32 *qmf_real, WORD32 *qmf_imag,\nWORD32 *filter_states, WORD32 len,\nWORD32 shift) {\nWORD32 *filter_states_rev = filter_states + len;\nWORD32 treal, timag;\nWORD32 j;\nfor (j = (len - 1); j >= 0; j -= 2) {\nWORD32 r1, r2, i1, i2;\ni2 = qmf_imag[j];\nr2 = qmf_real[j];\nr1 = *qmf_real++;\ni1 = *qmf_imag++;\ntimag = ixheaacd_add32_sat(i1, r1);\ntimag = (ixheaacd_shl32_sat(timag, shift));\nfilter_states_rev[j] = timag;\ntreal = ixheaacd_sub32_sat(i2, r2);\ntreal = (ixheaacd_shl32_sat(treal, shift));\nfilter_states[j] = treal;\ntreal = ixheaacd_sub32_sat(i1, r1);\ntreal = (ixheaacd_shl32_sat(treal, shift));\n*filter_states++ = treal;\ntimag = ixheaacd_add32_sat(i2, r2);\ntimag = (ixheaacd_shl32_sat(timag, shift));\n*filter_states_rev++ = timag;\n}\n}", "label": 0}
{"index": 183385, "code": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\ndec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\nWORD32 i4_err_status = 0;\nUWORD8 *pu1_buf = NULL;\nWORD32 buflen;\nUWORD32 u4_max_ofst, u4_length_of_start_code = 0;\nUWORD32 bytes_consumed = 0;\nUWORD32 cur_slice_is_nonref = 0;\nUWORD32 u4_next_is_aud;\nUWORD32 u4_first_start_code_found = 0;\nWORD32 ret = 0,api_ret_value = IV_SUCCESS;\nWORD32 header_data_left = 0,frame_data_left = 0;\nUWORD8 *pu1_bitstrm_buf;\nivd_video_decode_ip_t *ps_dec_ip;\nivd_video_decode_op_t *ps_dec_op;\nithread_set_name((void*)\"Parse_thread\");\nps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\nps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n{\nUWORD32 u4_size;\nu4_size = ps_dec_op->u4_size;\nmemset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\nps_dec_op->u4_size = u4_size;\n}\nps_dec->pv_dec_out = ps_dec_op;\nif(ps_dec->init_done != 1)\n{\nreturn IV_FAIL;\n}\nDATA_SYNC();\nif(0 == ps_dec->u1_flushfrm)\n{\nif(ps_dec_ip->pv_stream_buffer == NULL)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\nreturn IV_FAIL;\n}\nif(ps_dec_ip->u4_num_Bytes <= 0)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\nreturn IV_FAIL;\n}\n}\nps_dec->u1_pic_decode_done = 0;\nps_dec_op->u4_num_bytes_consumed = 0;\nps_dec->ps_out_buffer = NULL;\nif(ps_dec_ip->u4_size\n>= offsetof(ivd_video_decode_ip_t, s_out_buffer))\nps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\nps_dec->u4_fmt_conv_cur_row = 0;\nps_dec->u4_output_present = 0;\nps_dec->s_disp_op.u4_error_code = 1;\nps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\nif(0 == ps_dec->u4_share_disp_buf\n&& ps_dec->i4_decode_header == 0)\n{\nUWORD32 i;\nif((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||\n(ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\nreturn IV_FAIL;\n}\nfor(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n{\nif(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\nreturn IV_FAIL;\n}\nif(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |=\nIVD_DISP_FRM_ZERO_OP_BUF_SIZE;\nreturn IV_FAIL;\n}\n}\n}\nif(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n{\nps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\nreturn IV_FAIL;\n}\nps_dec->u4_ts = ps_dec_ip->u4_ts;\nps_dec_op->u4_error_code = 0;\nps_dec_op->e_pic_type = -1;\nps_dec_op->u4_output_present = 0;\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec->i4_frametype = -1;\nps_dec->i4_content_type = -1;\nps_dec->u4_slice_start_code_found = 0;\nif(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n&& ps_dec->u1_flushfrm == 0)\n{\nUWORD32 i;\nWORD32 disp_avail = 0, free_id;\nfor(i = 0; i < ps_dec->u1_pic_bufs; i++)\n{\nif(0 == ps_dec->u4_disp_buf_mapping[i]\n|| 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n{\ndisp_avail = 1;\nbreak;\n}\n}\nif(0 == disp_avail)\n{\nps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\nps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\nreturn (IV_FAIL);\n}\nwhile(1)\n{\npic_buffer_t *ps_pic_buf;\nps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\nif(ps_pic_buf == NULL)\n{\nUWORD32 i, display_queued = 0;\nfor(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n{\nif(0 != ps_dec->u4_disp_buf_mapping[i])\n{\ndisplay_queued = 1;\nbreak;\n}\n}\nif(1 == display_queued)\n{\nps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\nps_dec_op->u4_error_code |= (1\n<< IVD_UNSUPPORTEDPARAM);\nreturn (IV_FAIL);\n}\n}\nelse\n{\nif(1 == ps_dec->u4_disp_buf_mapping[free_id])\n{\nih264_buf_mgr_set_status(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nfree_id,\nBUF_MGR_IO);\n}\nelse\n{\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nfree_id,\nBUF_MGR_IO);\nbreak;\n}\n}\n}\n}\nif(ps_dec->u1_flushfrm)\n{\nif(ps_dec->u1_init_dec_flag == 0)\n{\nps_dec->u1_flushfrm = 0;\nreturn (IV_FAIL);\n}\nih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 == ps_dec->s_disp_op.u4_error_code)\n{\nif(check_app_out_buf_size(ps_dec) != IV_SUCCESS)\n{\nps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\nreturn (IV_FAIL);\n}\nps_dec->u4_fmt_conv_cur_row = 0;\nps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\nih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\nps_dec->u4_fmt_conv_cur_row,\nps_dec->u4_fmt_conv_num_rows);\nps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\nps_dec->u4_output_present = 1;\n}\nih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\nps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\nps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\nps_dec_op->u4_new_seq = 0;\nps_dec_op->u4_output_present = ps_dec->u4_output_present;\nps_dec_op->u4_progressive_frame_flag =\nps_dec->s_disp_op.u4_progressive_frame_flag;\nps_dec_op->e_output_format =\nps_dec->s_disp_op.e_output_format;\nps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\nps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\nps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\nps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\nps_dec_op->u4_is_ref_flag = -1;\nps_dec_op->e_pic_type = IV_NA_FRAME;\nps_dec_op->u4_frame_decoded_flag = 0;\nif(0 == ps_dec->s_disp_op.u4_error_code)\n{\nreturn (IV_SUCCESS);\n}\nelse\nreturn (IV_FAIL);\n}\nif(ps_dec->u1_res_changed == 1)\n{\nih264d_init_decoder(ps_dec);\n}\nps_dec->u4_prev_nal_skipped = 0;\nps_dec->u2_cur_mb_addr = 0;\nps_dec->u2_total_mbs_coded = 0;\nps_dec->u2_cur_slice_num = 0;\nps_dec->cur_dec_mb_num = 0;\nps_dec->cur_recon_mb_num = 0;\nps_dec->u4_first_slice_in_pic = 1;\nps_dec->u1_slice_header_done = 0;\nps_dec->u1_dangling_field = 0;\nps_dec->u4_dec_thread_created = 0;\nps_dec->u4_bs_deblk_thread_created = 0;\nps_dec->u4_cur_bs_mb_num = 0;\nps_dec->u4_start_recon_deblk  = 0;\nps_dec->u4_sps_cnt_in_process = 0;\nDEBUG_THREADS_PRINTF(\" Starting process call\\n\");\nps_dec->u4_pic_buf_got = 0;\ndo\n{\nWORD32 buf_size;\npu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n+ ps_dec_op->u4_num_bytes_consumed;\nu4_max_ofst = ps_dec_ip->u4_num_Bytes\n- ps_dec_op->u4_num_bytes_consumed;\nif((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n(ps_dec->i4_header_decoded & 1))\n{\nWORD32 size;\nvoid *pv_buf;\nvoid *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\nsize = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\npv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\nRETURN_IF((NULL == pv_buf), IV_FAIL);\nps_dec->pu1_bits_buf_dynamic = pv_buf;\nps_dec->u4_dynamic_bits_buf_size = size;\n}\nif(ps_dec->pu1_bits_buf_dynamic)\n{\npu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\nbuf_size = ps_dec->u4_dynamic_bits_buf_size;\n}\nelse\n{\npu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\nbuf_size = ps_dec->u4_static_bits_buf_size;\n}\nu4_next_is_aud = 0;\nbuflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n&u4_length_of_start_code,\n&u4_next_is_aud);\nif(buflen == -1)\nbuflen = 0;\nbuflen = MIN(buflen, buf_size - 8);\nbytes_consumed = buflen + u4_length_of_start_code;\nps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n{\nUWORD8 u1_firstbyte, u1_nal_ref_idc;\nif(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n{\nu1_firstbyte = *(pu1_buf + u4_length_of_start_code);\nu1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\nif(u1_nal_ref_idc == 0)\n{\ncur_slice_is_nonref = 1;\ncontinue;\n}\nelse\n{\nif(1 == cur_slice_is_nonref)\n{\nps_dec_op->u4_num_bytes_consumed -=\nbytes_consumed;\nps_dec_op->e_pic_type = IV_B_FRAME;\nps_dec_op->u4_error_code =\nIVD_DEC_FRM_SKIPPED;\nps_dec_op->u4_error_code |= (1\n<< IVD_UNSUPPORTEDPARAM);\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec_op->u4_size =\nsizeof(ivd_video_decode_op_t);\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nreturn (IV_FAIL);\n}\n}\n}\n}\nif(buflen)\n{\nmemcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\nbuflen);\nif((buflen + 8) < buf_size)\n{\nmemset(pu1_bitstrm_buf + buflen, 0, 8);\n}\nu4_first_start_code_found = 1;\n}\nelse\n{\nif(u4_first_start_code_found == 0)\n{\nps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\nps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\nif(ps_dec->u4_pic_buf_got == 0)\n{\nih264d_fill_output_struct_from_context(ps_dec,\nps_dec_op);\nps_dec_op->u4_error_code = ps_dec->i4_error_code;\nps_dec_op->u4_frame_decoded_flag = 0;\nreturn (IV_FAIL);\n}\nelse\n{\nps_dec->u1_pic_decode_done = 1;\ncontinue;\n}\n}\nelse\n{\nframe_data_left = 0;\nheader_data_left = 0;\ncontinue;\n}\n}\nps_dec->u4_return_to_app = 0;\nret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\npu1_bitstrm_buf, buflen);\nif(ret != OK)\n{\nUWORD32 error =  ih264d_map_error(ret);\nps_dec_op->u4_error_code = error | ret;\napi_ret_value = IV_FAIL;\nif((ret == IVD_RES_CHANGED)\n|| (ret == IVD_MEM_ALLOC_FAILED)\n|| (ret == ERROR_UNAVAIL_PICBUF_T)\n|| (ret == ERROR_UNAVAIL_MVBUF_T)\n|| (ret == ERROR_INV_SPS_PPS_T)\n|| (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))\n{\nps_dec->u4_slice_start_code_found = 0;\nbreak;\n}\nif((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n{\nps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\napi_ret_value = IV_FAIL;\nbreak;\n}\nif(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n{\napi_ret_value = IV_FAIL;\nbreak;\n}\n}\nif(ps_dec->u4_return_to_app)\n{\nps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\nps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\nps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nreturn (IV_FAIL);\n}\nheader_data_left = ((ps_dec->i4_decode_header == 1)\n&& (ps_dec->i4_header_decoded != 3)\n&& (ps_dec_op->u4_num_bytes_consumed\n< ps_dec_ip->u4_num_Bytes));\nframe_data_left = (((ps_dec->i4_decode_header == 0)\n&& ((ps_dec->u1_pic_decode_done == 0)\n|| (u4_next_is_aud == 1)))\n&& (ps_dec_op->u4_num_bytes_consumed\n< ps_dec_ip->u4_num_Bytes));\n}\nwhile(( header_data_left == 1)||(frame_data_left == 1));\nif((ps_dec->u4_pic_buf_got == 1)\n&& (ret != IVD_MEM_ALLOC_FAILED)\n&& ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nWORD32 num_mb_skipped;\nWORD32 prev_slice_err;\npocstruct_t temp_poc;\nWORD32 ret1;\nWORD32 ht_in_mbs;\nht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);\nnum_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n- ps_dec->u2_total_mbs_coded;\nif(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\nprev_slice_err = 1;\nelse\nprev_slice_err = 2;\nif(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\nprev_slice_err = 1;\nret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n&temp_poc, prev_slice_err);\nif((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||\n(ret1 == ERROR_INV_SPS_PPS_T))\n{\nret = ret1;\n}\n}\nif((ret == IVD_RES_CHANGED)\n|| (ret == IVD_MEM_ALLOC_FAILED)\n|| (ret == ERROR_UNAVAIL_PICBUF_T)\n|| (ret == ERROR_UNAVAIL_MVBUF_T)\n|| (ret == ERROR_INV_SPS_PPS_T))\n{\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nif(ret == IVD_RES_CHANGED)\n{\nps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n}\nreturn IV_FAIL;\n}\nif(ps_dec->u1_separate_parse)\n{\nif(ps_dec->u4_num_cores == 2)\n{\nif((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n{\nUWORD32 u4_num_mbs,u4_max_addr;\ntfr_ctxt_t s_tfr_ctxt;\ntfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\npad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\nu4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\nps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\nih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\nps_dec->u2_frm_wd_in_mbs, 0);\nu4_num_mbs = u4_max_addr\n- ps_dec->u4_cur_deblk_mb_num + 1;\nDEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\nif(u4_num_mbs != 0)\nih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\nps_tfr_cxt,1);\nps_dec->u4_start_recon_deblk  = 0;\n}\n}\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\n}\nDATA_SYNC();\nif((ps_dec_op->u4_error_code & 0xff)\n!= ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n{\nps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\nps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n}\nif(ps_dec->i4_header_decoded != 3)\n{\nps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n}\nif(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n{\nps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n}\nif(ps_dec->u4_prev_nal_skipped)\n{\nps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\nps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nreturn (IV_FAIL);\n}\nif((ps_dec->u4_pic_buf_got == 1)\n&& (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n{\nif(ps_dec->ps_cur_slice->u1_field_pic_flag)\n{\nif(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n{\nps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n}\nelse\n{\nps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n}\n}\nelse\n{\nps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n}\nif ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n{\nret = ih264d_deblock_display(ps_dec);\n}\nif(ps_dec->i4_header_decoded == 3)\n{\nps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n}\nif(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n{\nps_dec->i4_frametype = IV_IDR_FRAME;\n}\nelse if(ps_dec->i4_pic_type == B_SLICE)\n{\nps_dec->i4_frametype = IV_B_FRAME;\n}\nelse if(ps_dec->i4_pic_type == P_SLICE)\n{\nps_dec->i4_frametype = IV_P_FRAME;\n}\nelse if(ps_dec->i4_pic_type == I_SLICE)\n{\nps_dec->i4_frametype = IV_I_FRAME;\n}\nelse\n{\nH264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n}\nps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\nps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\nps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n- ps_dec->ps_cur_slice->u1_field_pic_flag;\n}\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\n{\nif((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n&& ps_dec->u1_init_dec_flag)\n{\nih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 == ps_dec->s_disp_op.u4_error_code)\n{\nps_dec->u4_fmt_conv_cur_row = 0;\nps_dec->u4_output_present = 1;\n}\n}\nih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\nif(ps_dec->u4_output_present &&\n(ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n{\nps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n- ps_dec->u4_fmt_conv_cur_row;\nih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\nps_dec->u4_fmt_conv_cur_row,\nps_dec->u4_fmt_conv_num_rows);\nps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n}\nih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n}\nif(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n{\nps_dec_op->u4_progressive_frame_flag = 1;\nif((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n{\nif((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n&& (0 == ps_dec->ps_sps->u1_mb_aff_flag))\nps_dec_op->u4_progressive_frame_flag = 0;\n}\n}\nif((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n{\nps_dec->u1_top_bottom_decoded = 0;\n}\nif(ps_dec->u4_pic_buf_got == 1)\n{\nif(1 == ps_dec->u1_last_pic_not_decoded)\n{\nret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\nif(ret != OK)\nreturn ret;\nret = ih264d_end_of_pic(ps_dec);\nif(ret != OK)\nreturn ret;\n}\nelse\n{\nret = ih264d_end_of_pic(ps_dec);\nif(ret != OK)\nreturn ret;\n}\n}\nDATA_SYNC();\nH264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\nps_dec_op->u4_num_bytes_consumed);\nreturn api_ret_value;\n}", "contrast": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\ndec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\nWORD32 i4_err_status = 0;\nUWORD8 *pu1_buf = NULL;\nWORD32 buflen;\nUWORD32 u4_max_ofst, u4_length_of_start_code = 0;\nUWORD32 bytes_consumed = 0;\nUWORD32 cur_slice_is_nonref = 0;\nUWORD32 u4_next_is_aud;\nUWORD32 u4_first_start_code_found = 0;\nWORD32 ret = 0,api_ret_value = IV_SUCCESS;\nWORD32 header_data_left = 0,frame_data_left = 0;\nUWORD8 *pu1_bitstrm_buf;\nivd_video_decode_ip_t *ps_dec_ip;\nivd_video_decode_op_t *ps_dec_op;\nithread_set_name((void*)\"Parse_thread\");\nps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\nps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n{\nUWORD32 u4_size;\nu4_size = ps_dec_op->u4_size;\nmemset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\nps_dec_op->u4_size = u4_size;\n}\nps_dec->pv_dec_out = ps_dec_op;\nif(ps_dec->init_done != 1)\n{\nreturn IV_FAIL;\n}\nDATA_SYNC();\nif(0 == ps_dec->u1_flushfrm)\n{\nif(ps_dec_ip->pv_stream_buffer == NULL)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\nreturn IV_FAIL;\n}\nif(ps_dec_ip->u4_num_Bytes <= 0)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\nreturn IV_FAIL;\n}\n}\nps_dec->u1_pic_decode_done = 0;\nps_dec_op->u4_num_bytes_consumed = 0;\nps_dec->ps_out_buffer = NULL;\nif(ps_dec_ip->u4_size\n>= offsetof(ivd_video_decode_ip_t, s_out_buffer))\nps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\nps_dec->u4_fmt_conv_cur_row = 0;\nps_dec->u4_output_present = 0;\nps_dec->s_disp_op.u4_error_code = 1;\nps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\nif(0 == ps_dec->u4_share_disp_buf\n&& ps_dec->i4_decode_header == 0)\n{\nUWORD32 i;\nif((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||\n(ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\nreturn IV_FAIL;\n}\nfor(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n{\nif(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\nreturn IV_FAIL;\n}\nif(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n{\nps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\nps_dec_op->u4_error_code |=\nIVD_DISP_FRM_ZERO_OP_BUF_SIZE;\nreturn IV_FAIL;\n}\n}\n}\nif(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n{\nps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\nreturn IV_FAIL;\n}\nps_dec->u4_ts = ps_dec_ip->u4_ts;\nps_dec_op->u4_error_code = 0;\nps_dec_op->e_pic_type = -1;\nps_dec_op->u4_output_present = 0;\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec->i4_frametype = -1;\nps_dec->i4_content_type = -1;\nps_dec->u4_slice_start_code_found = 0;\nif(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n&& ps_dec->u1_flushfrm == 0)\n{\nUWORD32 i;\nWORD32 disp_avail = 0, free_id;\nfor(i = 0; i < ps_dec->u1_pic_bufs; i++)\n{\nif(0 == ps_dec->u4_disp_buf_mapping[i]\n|| 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n{\ndisp_avail = 1;\nbreak;\n}\n}\nif(0 == disp_avail)\n{\nps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\nps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\nreturn (IV_FAIL);\n}\nwhile(1)\n{\npic_buffer_t *ps_pic_buf;\nps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\nif(ps_pic_buf == NULL)\n{\nUWORD32 i, display_queued = 0;\nfor(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n{\nif(0 != ps_dec->u4_disp_buf_mapping[i])\n{\ndisplay_queued = 1;\nbreak;\n}\n}\nif(1 == display_queued)\n{\nps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\nps_dec_op->u4_error_code |= (1\n<< IVD_UNSUPPORTEDPARAM);\nreturn (IV_FAIL);\n}\n}\nelse\n{\nif(1 == ps_dec->u4_disp_buf_mapping[free_id])\n{\nih264_buf_mgr_set_status(\n(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nfree_id,\nBUF_MGR_IO);\n}\nelse\n{\nih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\nfree_id,\nBUF_MGR_IO);\nbreak;\n}\n}\n}\n}\nif(ps_dec->u1_flushfrm)\n{\nif(ps_dec->u1_init_dec_flag == 0)\n{\nps_dec->u1_flushfrm = 0;\nreturn (IV_FAIL);\n}\nih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 == ps_dec->s_disp_op.u4_error_code)\n{\nif(check_app_out_buf_size(ps_dec) != IV_SUCCESS)\n{\nps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\nreturn (IV_FAIL);\n}\nps_dec->u4_fmt_conv_cur_row = 0;\nps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\nih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\nps_dec->u4_fmt_conv_cur_row,\nps_dec->u4_fmt_conv_num_rows);\nps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\nps_dec->u4_output_present = 1;\n}\nih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\nps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\nps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\nps_dec_op->u4_new_seq = 0;\nps_dec_op->u4_output_present = ps_dec->u4_output_present;\nps_dec_op->u4_progressive_frame_flag =\nps_dec->s_disp_op.u4_progressive_frame_flag;\nps_dec_op->e_output_format =\nps_dec->s_disp_op.e_output_format;\nps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\nps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\nps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\nps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\nps_dec_op->u4_is_ref_flag = -1;\nps_dec_op->e_pic_type = IV_NA_FRAME;\nps_dec_op->u4_frame_decoded_flag = 0;\nif(0 == ps_dec->s_disp_op.u4_error_code)\n{\nreturn (IV_SUCCESS);\n}\nelse\nreturn (IV_FAIL);\n}\nif(ps_dec->u1_res_changed == 1)\n{\nih264d_init_decoder(ps_dec);\n}\nps_dec->u4_prev_nal_skipped = 0;\nps_dec->u2_cur_mb_addr = 0;\nps_dec->u2_total_mbs_coded = 0;\nps_dec->u2_cur_slice_num = 0;\nps_dec->cur_dec_mb_num = 0;\nps_dec->cur_recon_mb_num = 0;\nps_dec->u4_first_slice_in_pic = 1;\nps_dec->u1_slice_header_done = 0;\nps_dec->u1_dangling_field = 0;\nps_dec->u4_dec_thread_created = 0;\nps_dec->u4_bs_deblk_thread_created = 0;\nps_dec->u4_cur_bs_mb_num = 0;\nps_dec->u4_start_recon_deblk  = 0;\nps_dec->u4_sps_cnt_in_process = 0;\nDEBUG_THREADS_PRINTF(\" Starting process call\\n\");\nps_dec->u4_pic_buf_got = 0;\ndo\n{\nWORD32 buf_size;\npu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n+ ps_dec_op->u4_num_bytes_consumed;\nu4_max_ofst = ps_dec_ip->u4_num_Bytes\n- ps_dec_op->u4_num_bytes_consumed;\nif((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n(ps_dec->i4_header_decoded & 1))\n{\nWORD32 size;\nvoid *pv_buf;\nvoid *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\nsize = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\npv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128,\nsize + EXTRA_BS_OFFSET);\nRETURN_IF((NULL == pv_buf), IV_FAIL);\nps_dec->pu1_bits_buf_dynamic = pv_buf;\nps_dec->u4_dynamic_bits_buf_size = size;\n}\nif(ps_dec->pu1_bits_buf_dynamic)\n{\npu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\nbuf_size = ps_dec->u4_dynamic_bits_buf_size;\n}\nelse\n{\npu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\nbuf_size = ps_dec->u4_static_bits_buf_size;\n}\nu4_next_is_aud = 0;\nbuflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n&u4_length_of_start_code,\n&u4_next_is_aud);\nif(buflen == -1)\nbuflen = 0;\nbuflen = MIN(buflen, buf_size - 8);\nbytes_consumed = buflen + u4_length_of_start_code;\nps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n{\nUWORD8 u1_firstbyte, u1_nal_ref_idc;\nif(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n{\nu1_firstbyte = *(pu1_buf + u4_length_of_start_code);\nu1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\nif(u1_nal_ref_idc == 0)\n{\ncur_slice_is_nonref = 1;\ncontinue;\n}\nelse\n{\nif(1 == cur_slice_is_nonref)\n{\nps_dec_op->u4_num_bytes_consumed -=\nbytes_consumed;\nps_dec_op->e_pic_type = IV_B_FRAME;\nps_dec_op->u4_error_code =\nIVD_DEC_FRM_SKIPPED;\nps_dec_op->u4_error_code |= (1\n<< IVD_UNSUPPORTEDPARAM);\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec_op->u4_size =\nsizeof(ivd_video_decode_op_t);\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nreturn (IV_FAIL);\n}\n}\n}\n}\nif(buflen)\n{\nmemcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\nbuflen);\nif((buflen + 8) < buf_size)\n{\nmemset(pu1_bitstrm_buf + buflen, 0, 8);\n}\nu4_first_start_code_found = 1;\n}\nelse\n{\nif(u4_first_start_code_found == 0)\n{\nps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\nps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\nif(ps_dec->u4_pic_buf_got == 0)\n{\nih264d_fill_output_struct_from_context(ps_dec,\nps_dec_op);\nps_dec_op->u4_error_code = ps_dec->i4_error_code;\nps_dec_op->u4_frame_decoded_flag = 0;\nreturn (IV_FAIL);\n}\nelse\n{\nps_dec->u1_pic_decode_done = 1;\ncontinue;\n}\n}\nelse\n{\nframe_data_left = 0;\nheader_data_left = 0;\ncontinue;\n}\n}\nps_dec->u4_return_to_app = 0;\nret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\npu1_bitstrm_buf, buflen);\nif(ret != OK)\n{\nUWORD32 error =  ih264d_map_error(ret);\nps_dec_op->u4_error_code = error | ret;\napi_ret_value = IV_FAIL;\nif((ret == IVD_RES_CHANGED)\n|| (ret == IVD_MEM_ALLOC_FAILED)\n|| (ret == ERROR_UNAVAIL_PICBUF_T)\n|| (ret == ERROR_UNAVAIL_MVBUF_T)\n|| (ret == ERROR_INV_SPS_PPS_T)\n|| (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))\n{\nps_dec->u4_slice_start_code_found = 0;\nbreak;\n}\nif((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n{\nps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\napi_ret_value = IV_FAIL;\nbreak;\n}\nif(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n{\napi_ret_value = IV_FAIL;\nbreak;\n}\n}\nif(ps_dec->u4_return_to_app)\n{\nps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\nps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\nps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nreturn (IV_FAIL);\n}\nheader_data_left = ((ps_dec->i4_decode_header == 1)\n&& (ps_dec->i4_header_decoded != 3)\n&& (ps_dec_op->u4_num_bytes_consumed\n< ps_dec_ip->u4_num_Bytes));\nframe_data_left = (((ps_dec->i4_decode_header == 0)\n&& ((ps_dec->u1_pic_decode_done == 0)\n|| (u4_next_is_aud == 1)))\n&& (ps_dec_op->u4_num_bytes_consumed\n< ps_dec_ip->u4_num_Bytes));\n}\nwhile(( header_data_left == 1)||(frame_data_left == 1));\nif((ps_dec->u4_pic_buf_got == 1)\n&& (ret != IVD_MEM_ALLOC_FAILED)\n&& ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n{\nWORD32 num_mb_skipped;\nWORD32 prev_slice_err;\npocstruct_t temp_poc;\nWORD32 ret1;\nWORD32 ht_in_mbs;\nht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);\nnum_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n- ps_dec->u2_total_mbs_coded;\nif(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\nprev_slice_err = 1;\nelse\nprev_slice_err = 2;\nif(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\nprev_slice_err = 1;\nret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n&temp_poc, prev_slice_err);\nif((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||\n(ret1 == ERROR_INV_SPS_PPS_T))\n{\nret = ret1;\n}\n}\nif((ret == IVD_RES_CHANGED)\n|| (ret == IVD_MEM_ALLOC_FAILED)\n|| (ret == ERROR_UNAVAIL_PICBUF_T)\n|| (ret == ERROR_UNAVAIL_MVBUF_T)\n|| (ret == ERROR_INV_SPS_PPS_T))\n{\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nif(ret == IVD_RES_CHANGED)\n{\nps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n}\nreturn IV_FAIL;\n}\nif(ps_dec->u1_separate_parse)\n{\nif(ps_dec->u4_num_cores == 2)\n{\nif((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n{\nUWORD32 u4_num_mbs,u4_max_addr;\ntfr_ctxt_t s_tfr_ctxt;\ntfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\npad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\nu4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\nps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\nih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\nps_dec->u2_frm_wd_in_mbs, 0);\nu4_num_mbs = u4_max_addr\n- ps_dec->u4_cur_deblk_mb_num + 1;\nDEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\nif(u4_num_mbs != 0)\nih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\nps_tfr_cxt,1);\nps_dec->u4_start_recon_deblk  = 0;\n}\n}\nih264d_signal_decode_thread(ps_dec);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\n}\nDATA_SYNC();\nif((ps_dec_op->u4_error_code & 0xff)\n!= ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n{\nps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\nps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n}\nif(ps_dec->i4_header_decoded != 3)\n{\nps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n}\nif(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n{\nps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n}\nif(ps_dec->u4_prev_nal_skipped)\n{\nps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\nps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\nps_dec_op->u4_frame_decoded_flag = 0;\nps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\nreturn (IV_FAIL);\n}\nif((ps_dec->u4_pic_buf_got == 1)\n&& (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n{\nif(ps_dec->ps_cur_slice->u1_field_pic_flag)\n{\nif(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n{\nps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n}\nelse\n{\nps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n}\n}\nelse\n{\nps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n}\nif ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n{\nret = ih264d_deblock_display(ps_dec);\n}\nif(ps_dec->i4_header_decoded == 3)\n{\nps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n}\nif(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n{\nps_dec->i4_frametype = IV_IDR_FRAME;\n}\nelse if(ps_dec->i4_pic_type == B_SLICE)\n{\nps_dec->i4_frametype = IV_B_FRAME;\n}\nelse if(ps_dec->i4_pic_type == P_SLICE)\n{\nps_dec->i4_frametype = IV_P_FRAME;\n}\nelse if(ps_dec->i4_pic_type == I_SLICE)\n{\nps_dec->i4_frametype = IV_I_FRAME;\n}\nelse\n{\nH264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n}\nps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\nps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\nps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n- ps_dec->ps_cur_slice->u1_field_pic_flag;\n}\nif(ps_dec->u4_num_cores == 3)\n{\nih264d_signal_bs_deblk_thread(ps_dec);\n}\n{\nif((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n&& ps_dec->u1_init_dec_flag)\n{\nih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n&(ps_dec->s_disp_op));\nif(0 == ps_dec->s_disp_op.u4_error_code)\n{\nps_dec->u4_fmt_conv_cur_row = 0;\nps_dec->u4_output_present = 1;\n}\n}\nih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\nif(ps_dec->u4_output_present &&\n(ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n{\nps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n- ps_dec->u4_fmt_conv_cur_row;\nih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\nps_dec->u4_fmt_conv_cur_row,\nps_dec->u4_fmt_conv_num_rows);\nps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n}\nih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n}\nif(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n{\nps_dec_op->u4_progressive_frame_flag = 1;\nif((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n{\nif((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n&& (0 == ps_dec->ps_sps->u1_mb_aff_flag))\nps_dec_op->u4_progressive_frame_flag = 0;\n}\n}\nif((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n{\nps_dec->u1_top_bottom_decoded = 0;\n}\nif(ps_dec->u4_pic_buf_got == 1)\n{\nif(1 == ps_dec->u1_last_pic_not_decoded)\n{\nret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\nif(ret != OK)\nreturn ret;\nret = ih264d_end_of_pic(ps_dec);\nif(ret != OK)\nreturn ret;\n}\nelse\n{\nret = ih264d_end_of_pic(ps_dec);\nif(ret != OK)\nreturn ret;\n}\n}\nDATA_SYNC();\nH264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\nps_dec_op->u4_num_bytes_consumed);\nreturn api_ret_value;\n}", "label": 0}
{"index": 183393, "code": "IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,\nnal_header_t *ps_nal)\n{\nIHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\nWORD32 value;\nWORD32 i, j;\nWORD32 sps_id;\npps_t *ps_pps;\nsps_t *ps_sps;\nslice_header_t *ps_slice_hdr;\nWORD32 disable_deblocking_filter_flag;\nbitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\nWORD32 idr_pic_flag;\nWORD32 pps_id;\nWORD32 first_slice_in_pic_flag;\nWORD32 no_output_of_prior_pics_flag = 0;\nWORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;\nWORD32 num_poc_total_curr = 0;\nWORD32 slice_address;\nif(ps_codec->i4_slice_error == 1)\nreturn ret;\nidr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||\n(NAL_IDR_N_LP == i1_nal_unit_type);\nBITS_PARSE(\"first_slice_in_pic_flag\", first_slice_in_pic_flag, ps_bitstrm, 1);\nif((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n(NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n{\nBITS_PARSE(\"no_output_of_prior_pics_flag\", no_output_of_prior_pics_flag, ps_bitstrm, 1);\n}\nUEV_PARSE(\"pic_parameter_set_id\", pps_id, ps_bitstrm);\npps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);\nps_pps = ps_codec->s_parse.ps_pps_base + pps_id;\nif(0 == ps_pps->i1_pps_valid)\n{\npps_t *ps_pps_ref = ps_codec->ps_pps_base;\nwhile(0 == ps_pps_ref->i1_pps_valid)\n{\nps_pps_ref++;\nif((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))\nreturn IHEVCD_INVALID_HEADER;\n}\nihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);\n}\nsps_id = ps_pps->i1_sps_id;\nps_sps = ps_codec->s_parse.ps_sps_base + sps_id;\nif((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&\nfirst_slice_in_pic_flag)\n{\nif(ps_codec->i4_pic_present)\n{\nslice_header_t *ps_slice_hdr_next;\nps_codec->i4_slice_error = 1;\nps_codec->s_parse.i4_cur_slice_idx--;\nif(ps_codec->s_parse.i4_cur_slice_idx < 0)\nps_codec->s_parse.i4_cur_slice_idx = 0;\nps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\nps_slice_hdr_next->i2_ctb_x = 0;\nps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\nreturn ret;\n}\nelse\n{\nps_codec->i4_slice_error = 0;\n}\n}\nif(first_slice_in_pic_flag)\n{\nps_codec->s_parse.i4_cur_slice_idx = 0;\n}\nelse\n{\nif(0 == ps_codec->i4_pic_present)\nps_codec->s_parse.i4_cur_slice_idx = 1;\n}\nps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\nif((ps_pps->i1_dependent_slice_enabled_flag) &&\n(!first_slice_in_pic_flag))\n{\nBITS_PARSE(\"dependent_slice_flag\", value, ps_bitstrm, 1);\nif(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))\n{\nihevcd_copy_slice_hdr(ps_codec,\n(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),\n((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));\n}\nps_slice_hdr->i1_dependent_slice_flag = value;\n}\nelse\n{\nps_slice_hdr->i1_dependent_slice_flag = 0;\n}\nps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;\nps_slice_hdr->i1_pps_id = pps_id;\nps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;\nps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;\nif((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n(NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n{\nps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;\n}\nps_slice_hdr->i1_pps_id = pps_id;\nif(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n{\nWORD32 num_bits;\nnum_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);\nBITS_PARSE(\"slice_address\", value, ps_bitstrm, num_bits);\nslice_address = value;\nif(value >= ps_sps->i4_pic_size_in_ctb)\nreturn IHEVCD_IGNORE_SLICE;\n}\nelse\n{\nslice_address = 0;\n}\nif(!ps_slice_hdr->i1_dependent_slice_flag)\n{\nps_slice_hdr->i1_pic_output_flag = 1;\nps_slice_hdr->i4_pic_order_cnt_lsb = 0;\nps_slice_hdr->i1_num_long_term_sps = 0;\nps_slice_hdr->i1_num_long_term_pics = 0;\nfor(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)\n{\nBITS_PARSE(\"slice_reserved_undetermined_flag[ i ]\", value, ps_bitstrm, 1);\n}\nUEV_PARSE(\"slice_type\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_type = value;\nif((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&\n(ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))\nps_slice_hdr->i1_slice_type = ISLICE;\nif((ps_slice_hdr->i1_slice_type < 0) ||\n(ps_slice_hdr->i1_slice_type > 2))\nreturn IHEVCD_IGNORE_SLICE;\nif(ps_pps->i1_output_flag_present_flag)\n{\nBITS_PARSE(\"pic_output_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_pic_output_flag = value;\n}\nps_slice_hdr->i1_colour_plane_id = 0;\nif(1 == ps_sps->i1_separate_colour_plane_flag)\n{\nBITS_PARSE(\"colour_plane_id\", value, ps_bitstrm, 2);\nps_slice_hdr->i1_colour_plane_id = value;\n}\nps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;\nif(!idr_pic_flag)\n{\nWORD32 st_rps_idx;\nWORD32 num_neg_pics;\nWORD32 num_pos_pics;\nWORD8 *pi1_used;\nBITS_PARSE(\"pic_order_cnt_lsb\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\nps_slice_hdr->i4_pic_order_cnt_lsb = value;\nBITS_PARSE(\"short_term_ref_pic_set_sps_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;\nif(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)\n{\nWORD32 numbits;\nps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;\nif(ps_sps->i1_num_short_term_ref_pic_sets > 1)\n{\nnumbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);\nBITS_PARSE(\"short_term_ref_pic_set_idx\", value, ps_bitstrm, numbits);\nps_slice_hdr->i1_short_term_ref_pic_set_idx = value;\n}\nst_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;\nnum_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;\nnum_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;\npi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;\n}\nelse\n{\nihevcd_short_term_ref_pic_set(ps_bitstrm,\n&ps_sps->as_stref_picset[0],\nps_sps->i1_num_short_term_ref_pic_sets,\nps_sps->i1_num_short_term_ref_pic_sets,\n&ps_slice_hdr->s_stref_picset);\nst_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;\nnum_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;\nnum_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;\npi1_used = ps_slice_hdr->s_stref_picset.ai1_used;\n}\nif(ps_sps->i1_long_term_ref_pics_present_flag)\n{\nif(ps_sps->i1_num_long_term_ref_pics_sps > 0)\n{\nUEV_PARSE(\"num_long_term_sps\", value, ps_bitstrm);\nps_slice_hdr->i1_num_long_term_sps = value;\nps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,\n0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);\n}\nUEV_PARSE(\"num_long_term_pics\", value, ps_bitstrm);\nps_slice_hdr->i1_num_long_term_pics = value;\nps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,\n0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -\nps_slice_hdr->i1_num_long_term_sps);\nfor(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +\nps_slice_hdr->i1_num_long_term_pics); i++)\n{\nif(i < ps_slice_hdr->i1_num_long_term_sps)\n{\nif (ps_sps->i1_num_long_term_ref_pics_sps > 1)\n{\nWORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);\nBITS_PARSE(\"lt_idx_sps[ i ]\", value, ps_bitstrm, num_bits);\n}\nelse\n{\nvalue = 0;\n}\nps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];\nps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];\n}\nelse\n{\nBITS_PARSE(\"poc_lsb_lt[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\nps_slice_hdr->ai4_poc_lsb_lt[i] = value;\nBITS_PARSE(\"used_by_curr_pic_lt_flag[ i ]\", value, ps_bitstrm, 1);\nps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;\n}\nBITS_PARSE(\"delta_poc_msb_present_flag[ i ]\", value, ps_bitstrm, 1);\nps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;\nps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;\nif(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])\n{\nUEV_PARSE(\"delata_poc_msb_cycle_lt[ i ]\", value, ps_bitstrm);\nps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;\n}\nif((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))\n{\nps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];\n}\n}\n}\nfor(i = 0; i < num_neg_pics + num_pos_pics; i++)\n{\nif(pi1_used[i])\n{\nnum_poc_total_curr++;\n}\n}\nfor(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)\n{\nif(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])\n{\nnum_poc_total_curr++;\n}\n}\nif(ps_sps->i1_sps_temporal_mvp_enable_flag)\n{\nBITS_PARSE(\"enable_temporal_mvp_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;\n}\n}\nps_slice_hdr->i1_slice_sao_luma_flag = 0;\nps_slice_hdr->i1_slice_sao_chroma_flag = 0;\nif(ps_sps->i1_sample_adaptive_offset_enabled_flag)\n{\nBITS_PARSE(\"slice_sao_luma_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_sao_luma_flag = value;\nBITS_PARSE(\"slice_sao_chroma_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_sao_chroma_flag = value;\n}\nps_slice_hdr->i1_max_num_merge_cand = 1;\nps_slice_hdr->i1_cabac_init_flag = 0;\nps_slice_hdr->i1_num_ref_idx_l0_active = 0;\nps_slice_hdr->i1_num_ref_idx_l1_active = 0;\nps_slice_hdr->i1_slice_cb_qp_offset = 0;\nps_slice_hdr->i1_slice_cr_qp_offset = 0;\nif((PSLICE == ps_slice_hdr->i1_slice_type) ||\n(BSLICE == ps_slice_hdr->i1_slice_type))\n{\nBITS_PARSE(\"num_ref_idx_active_override_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_num_ref_idx_active_override_flag = value;\nif(ps_slice_hdr->i1_num_ref_idx_active_override_flag)\n{\nUEV_PARSE(\"num_ref_idx_l0_active_minus1\", value, ps_bitstrm);\nps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nUEV_PARSE(\"num_ref_idx_l1_active_minus1\", value, ps_bitstrm);\nps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;\n}\n}\nelse\n{\nps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;\n}\n}\nps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);\nps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);\nif(0 == num_poc_total_curr)\nreturn IHEVCD_IGNORE_SLICE;\nif((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))\n{\nihevcd_ref_pic_list_modification(ps_bitstrm,\nps_slice_hdr, num_poc_total_curr);\n}\nelse\n{\nps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;\nps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;\n}\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nBITS_PARSE(\"mvd_l1_zero_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_mvd_l1_zero_flag = value;\n}\nps_slice_hdr->i1_cabac_init_flag = 0;\nif(ps_pps->i1_cabac_init_present_flag)\n{\nBITS_PARSE(\"cabac_init_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_cabac_init_flag = value;\n}\nps_slice_hdr->i1_collocated_from_l0_flag = 1;\nps_slice_hdr->i1_collocated_ref_idx = 0;\nif(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)\n{\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nBITS_PARSE(\"collocated_from_l0_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_collocated_from_l0_flag = value;\n}\nif((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||\n(!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))\n{\nUEV_PARSE(\"collocated_ref_idx\", value, ps_bitstrm);\nps_slice_hdr->i1_collocated_ref_idx = value;\n}\n}\nps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);\nif((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||\n(ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))\n{\nihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);\n}\nUEV_PARSE(\"five_minus_max_num_merge_cand\", value, ps_bitstrm);\nps_slice_hdr->i1_max_num_merge_cand = 5 - value;\n}\nps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);\nSEV_PARSE(\"slice_qp_delta\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_qp_delta = value;\nif(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)\n{\nSEV_PARSE(\"slice_cb_qp_offset\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_cb_qp_offset = value;\nSEV_PARSE(\"slice_cr_qp_offset\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_cr_qp_offset = value;\n}\nps_slice_hdr->i1_deblocking_filter_override_flag = 0;\nps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;\nps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;\nps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;\ndisable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;\nif(ps_pps->i1_deblocking_filter_control_present_flag)\n{\nif(ps_pps->i1_deblocking_filter_override_enabled_flag)\n{\nBITS_PARSE(\"deblocking_filter_override_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_deblocking_filter_override_flag = value;\n}\nif(ps_slice_hdr->i1_deblocking_filter_override_flag)\n{\nBITS_PARSE(\"slice_disable_deblocking_filter_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;\ndisable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;\nif(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)\n{\nSEV_PARSE(\"beta_offset_div2\", value, ps_bitstrm);\nps_slice_hdr->i1_beta_offset_div2 = value;\nSEV_PARSE(\"tc_offset_div2\", value, ps_bitstrm);\nps_slice_hdr->i1_tc_offset_div2 = value;\n}\n}\n}\nps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;\nif(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&\n(ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))\n{\nBITS_PARSE(\"slice_loop_filter_across_slices_enabled_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;\n}\n}\nif((!first_slice_in_pic_flag) &&\n(ps_codec->i4_pic_present))\n{\nslice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;\nif((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||\n(ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\n}\nif(0 == ps_codec->i4_pic_present)\n{\nps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);\n}\nelse\n{\nps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;\n}\nif(!first_slice_in_pic_flag)\n{\nif(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n{\nif(slice_address > ps_codec->s_parse.i4_next_ctb_indx)\n{\nif(ps_codec->i4_pic_present)\n{\nslice_header_t *ps_slice_hdr_next;\nps_codec->i4_slice_error = 1;\nps_codec->s_parse.i4_cur_slice_idx--;\nif(ps_codec->s_parse.i4_cur_slice_idx < 0)\nps_codec->s_parse.i4_cur_slice_idx = 0;\nps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\nps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\nps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\nreturn ret;\n}\nelse\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\n}\nelse if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\nelse\n{\nps_codec->i4_slice_error = 0;\n}\n}\nelse\n{\nif(ps_codec->i4_pic_present)\n{\nslice_header_t *ps_slice_hdr_next;\nps_codec->i4_slice_error = 1;\nps_codec->s_parse.i4_cur_slice_idx--;\nif(ps_codec->s_parse.i4_cur_slice_idx < 0)\nps_codec->s_parse.i4_cur_slice_idx = 0;\nps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\nps_slice_hdr_next->i2_ctb_x = 0;\nps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\nreturn ret;\n}\nelse\n{\nif(ps_slice_hdr->i1_dependent_slice_flag)\nreturn IHEVCD_IGNORE_SLICE;\nps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n}\n}\n}\nelse\n{\nif(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\nreturn IHEVCD_IGNORE_SLICE;\nps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n}\nps_slice_hdr->i4_num_entry_point_offsets = 0;\nif((ps_pps->i1_tiles_enabled_flag) ||\n(ps_pps->i1_entropy_coding_sync_enabled_flag))\n{\nUEV_PARSE(\"num_entry_point_offsets\", value, ps_bitstrm);\nps_slice_hdr->i4_num_entry_point_offsets = value;\n{\nWORD32 max_num_entry_point_offsets;\nif((ps_pps->i1_tiles_enabled_flag) &&\n(ps_pps->i1_entropy_coding_sync_enabled_flag))\n{\nmax_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);\n}\nelse if(ps_pps->i1_tiles_enabled_flag)\n{\nmax_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;\n}\nelse\n{\nmax_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);\n}\nps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,\n0, max_num_entry_point_offsets);\n}\nif(ps_slice_hdr->i4_num_entry_point_offsets > 0)\n{\nUEV_PARSE(\"offset_len_minus1\", value, ps_bitstrm);\nps_slice_hdr->i1_offset_len = value + 1;\nfor(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)\n{\nBITS_PARSE(\"entry_point_offset\", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);\n}\n}\n}\nif(ps_pps->i1_slice_header_extension_present_flag)\n{\nUEV_PARSE(\"slice_header_extension_length\", value, ps_bitstrm);\nps_slice_hdr->i2_slice_header_extension_length = value;\nfor(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)\n{\nBITS_PARSE(\"slice_header_extension_data_byte\", value, ps_bitstrm, 8);\n}\n}\nihevcd_bits_flush_to_byte_boundary(ps_bitstrm);\nif((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)\nreturn IHEVCD_INVALID_PARAMETER;\n{\ndpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\nWORD32 r_idx;\nif((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(0 == ps_codec->u4_pic_cnt))\n{\nfor(i = 0; i < MAX_DPB_BUFS; i++)\n{\nif(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)\n{\npic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;\nmv_buf_t *ps_mv_buf;\nihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);\nps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;\nfor(j = 0; j < ps_codec->i4_max_dpb_size; j++)\n{\nif(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)\n{\nihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);\nbreak;\n}\nps_mv_buf++;\n}\n}\n}\nfor(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)\n{\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;\n}\n}\nelse\n{\nret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);\nif ((WORD32)IHEVCD_SUCCESS != ret)\n{\nreturn ret;\n}\n}\n}\nif(ps_codec->i4_pic_present)\n{\npic_buf_t *ps_pic_buf_ref;\nmv_buf_t *ps_mv_buf_ref;\nWORD32 r_idx;\ndpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\nbuf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;\nps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);\nif(NULL == ps_pic_buf_ref)\n{\nps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;\nps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;\n}\nelse\n{\nps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);\n}\nfor(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)\n{\nif(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)\n{\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\n}\nfor(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)\n{\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\nfor(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)\n{\nif(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)\n{\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\n}\nfor(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)\n{\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\n}\nif(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n{\nps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\nps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\nif(!ps_slice_hdr->i1_dependent_slice_flag)\n{\nps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;\nps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;\n}\n}\nelse\n{\nps_slice_hdr->i2_ctb_x = 0;\nps_slice_hdr->i2_ctb_y = 0;\nps_slice_hdr->i2_independent_ctb_x = 0;\nps_slice_hdr->i2_independent_ctb_y = 0;\n}\nif((!first_slice_in_pic_flag) &&\n(0 == ps_codec->i4_pic_present))\n{\nslice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;\nihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));\nps_codec->i4_slice_error = 1;\nps_slice_hdr_prev->i2_ctb_x = 0;\nps_slice_hdr_prev->i2_ctb_y = 0;\nps_codec->s_parse.i4_ctb_x = 0;\nps_codec->s_parse.i4_ctb_y = 0;\nps_codec->s_parse.i4_cur_slice_idx = 0;\nif((ps_slice_hdr->i2_ctb_x == 0) &&\n(ps_slice_hdr->i2_ctb_y == 0))\n{\nps_slice_hdr->i2_ctb_x++;\n}\n}\n{\nif((i1_nal_unit_type < NAL_BLA_W_LP) &&\n(i1_nal_unit_type % 2 == 0))\n{\nif(IVD_SKIP_B == ps_codec->e_pic_skip_mode)\nreturn IHEVCD_IGNORE_SLICE;\n}\nif((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&\n(ISLICE != ps_slice_hdr->i1_slice_type))\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\n}\nreturn ret;\n}", "contrast": "IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,\nnal_header_t *ps_nal)\n{\nIHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\nWORD32 value;\nWORD32 i, j;\nWORD32 sps_id;\npps_t *ps_pps;\nsps_t *ps_sps;\nslice_header_t *ps_slice_hdr;\nWORD32 disable_deblocking_filter_flag;\nbitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\nWORD32 idr_pic_flag;\nWORD32 pps_id;\nWORD32 first_slice_in_pic_flag;\nWORD32 no_output_of_prior_pics_flag = 0;\nWORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;\nWORD32 num_poc_total_curr = 0;\nWORD32 slice_address;\nWORD32 prev_slice_incomplete_flag = 0;\nif(ps_codec->i4_slice_error == 1)\nreturn ret;\nidr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||\n(NAL_IDR_N_LP == i1_nal_unit_type);\nBITS_PARSE(\"first_slice_in_pic_flag\", first_slice_in_pic_flag, ps_bitstrm, 1);\nif((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n(NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n{\nBITS_PARSE(\"no_output_of_prior_pics_flag\", no_output_of_prior_pics_flag, ps_bitstrm, 1);\n}\nUEV_PARSE(\"pic_parameter_set_id\", pps_id, ps_bitstrm);\npps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);\nps_pps = ps_codec->s_parse.ps_pps_base + pps_id;\nif(0 == ps_pps->i1_pps_valid)\n{\npps_t *ps_pps_ref = ps_codec->ps_pps_base;\nwhile(0 == ps_pps_ref->i1_pps_valid)\n{\nps_pps_ref++;\nif((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))\nreturn IHEVCD_INVALID_HEADER;\n}\nihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);\n}\nsps_id = ps_pps->i1_sps_id;\nps_sps = ps_codec->s_parse.ps_sps_base + sps_id;\nif((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&\nfirst_slice_in_pic_flag)\n{\nif(ps_codec->i4_pic_present)\n{\nslice_header_t *ps_slice_hdr_next;\nps_codec->i4_slice_error = 1;\nps_codec->s_parse.i4_cur_slice_idx--;\nif(ps_codec->s_parse.i4_cur_slice_idx < 0)\nps_codec->s_parse.i4_cur_slice_idx = 0;\nps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\nps_slice_hdr_next->i2_ctb_x = 0;\nps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\nreturn ret;\n}\nelse\n{\nps_codec->i4_slice_error = 0;\n}\n}\nif(first_slice_in_pic_flag)\n{\nps_codec->s_parse.i4_cur_slice_idx = 0;\n}\nelse\n{\nif(0 == ps_codec->i4_pic_present)\nps_codec->s_parse.i4_cur_slice_idx = 1;\n}\nps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\nif((ps_pps->i1_dependent_slice_enabled_flag) &&\n(!first_slice_in_pic_flag))\n{\nBITS_PARSE(\"dependent_slice_flag\", value, ps_bitstrm, 1);\nif(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))\n{\nihevcd_copy_slice_hdr(ps_codec,\n(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),\n((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));\n}\nps_slice_hdr->i1_dependent_slice_flag = value;\n}\nelse\n{\nps_slice_hdr->i1_dependent_slice_flag = 0;\n}\nps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;\nps_slice_hdr->i1_pps_id = pps_id;\nps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;\nps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;\nif((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n(NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n{\nps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;\n}\nps_slice_hdr->i1_pps_id = pps_id;\nif(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n{\nWORD32 num_bits;\nnum_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);\nBITS_PARSE(\"slice_address\", value, ps_bitstrm, num_bits);\nslice_address = value;\nif(value >= ps_sps->i4_pic_size_in_ctb)\nreturn IHEVCD_IGNORE_SLICE;\n}\nelse\n{\nslice_address = 0;\n}\nif(!ps_slice_hdr->i1_dependent_slice_flag)\n{\nps_slice_hdr->i1_pic_output_flag = 1;\nps_slice_hdr->i4_pic_order_cnt_lsb = 0;\nps_slice_hdr->i1_num_long_term_sps = 0;\nps_slice_hdr->i1_num_long_term_pics = 0;\nfor(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)\n{\nBITS_PARSE(\"slice_reserved_undetermined_flag[ i ]\", value, ps_bitstrm, 1);\n}\nUEV_PARSE(\"slice_type\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_type = value;\nif((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&\n(ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))\nps_slice_hdr->i1_slice_type = ISLICE;\nif((ps_slice_hdr->i1_slice_type < 0) ||\n(ps_slice_hdr->i1_slice_type > 2))\nreturn IHEVCD_IGNORE_SLICE;\nif(ps_pps->i1_output_flag_present_flag)\n{\nBITS_PARSE(\"pic_output_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_pic_output_flag = value;\n}\nps_slice_hdr->i1_colour_plane_id = 0;\nif(1 == ps_sps->i1_separate_colour_plane_flag)\n{\nBITS_PARSE(\"colour_plane_id\", value, ps_bitstrm, 2);\nps_slice_hdr->i1_colour_plane_id = value;\n}\nps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;\nif(!idr_pic_flag)\n{\nWORD32 st_rps_idx;\nWORD32 num_neg_pics;\nWORD32 num_pos_pics;\nWORD8 *pi1_used;\nBITS_PARSE(\"pic_order_cnt_lsb\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\nps_slice_hdr->i4_pic_order_cnt_lsb = value;\nBITS_PARSE(\"short_term_ref_pic_set_sps_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;\nif(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)\n{\nWORD32 numbits;\nps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;\nif(ps_sps->i1_num_short_term_ref_pic_sets > 1)\n{\nnumbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);\nBITS_PARSE(\"short_term_ref_pic_set_idx\", value, ps_bitstrm, numbits);\nps_slice_hdr->i1_short_term_ref_pic_set_idx = value;\n}\nst_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;\nnum_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;\nnum_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;\npi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;\n}\nelse\n{\nihevcd_short_term_ref_pic_set(ps_bitstrm,\n&ps_sps->as_stref_picset[0],\nps_sps->i1_num_short_term_ref_pic_sets,\nps_sps->i1_num_short_term_ref_pic_sets,\n&ps_slice_hdr->s_stref_picset);\nst_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;\nnum_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;\nnum_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;\npi1_used = ps_slice_hdr->s_stref_picset.ai1_used;\n}\nif(ps_sps->i1_long_term_ref_pics_present_flag)\n{\nif(ps_sps->i1_num_long_term_ref_pics_sps > 0)\n{\nUEV_PARSE(\"num_long_term_sps\", value, ps_bitstrm);\nps_slice_hdr->i1_num_long_term_sps = value;\nps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,\n0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);\n}\nUEV_PARSE(\"num_long_term_pics\", value, ps_bitstrm);\nps_slice_hdr->i1_num_long_term_pics = value;\nps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,\n0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -\nps_slice_hdr->i1_num_long_term_sps);\nfor(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +\nps_slice_hdr->i1_num_long_term_pics); i++)\n{\nif(i < ps_slice_hdr->i1_num_long_term_sps)\n{\nif (ps_sps->i1_num_long_term_ref_pics_sps > 1)\n{\nWORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);\nBITS_PARSE(\"lt_idx_sps[ i ]\", value, ps_bitstrm, num_bits);\n}\nelse\n{\nvalue = 0;\n}\nps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];\nps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];\n}\nelse\n{\nBITS_PARSE(\"poc_lsb_lt[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\nps_slice_hdr->ai4_poc_lsb_lt[i] = value;\nBITS_PARSE(\"used_by_curr_pic_lt_flag[ i ]\", value, ps_bitstrm, 1);\nps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;\n}\nBITS_PARSE(\"delta_poc_msb_present_flag[ i ]\", value, ps_bitstrm, 1);\nps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;\nps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;\nif(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])\n{\nUEV_PARSE(\"delata_poc_msb_cycle_lt[ i ]\", value, ps_bitstrm);\nps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;\n}\nif((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))\n{\nps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];\n}\n}\n}\nfor(i = 0; i < num_neg_pics + num_pos_pics; i++)\n{\nif(pi1_used[i])\n{\nnum_poc_total_curr++;\n}\n}\nfor(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)\n{\nif(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])\n{\nnum_poc_total_curr++;\n}\n}\nif(ps_sps->i1_sps_temporal_mvp_enable_flag)\n{\nBITS_PARSE(\"enable_temporal_mvp_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;\n}\n}\nps_slice_hdr->i1_slice_sao_luma_flag = 0;\nps_slice_hdr->i1_slice_sao_chroma_flag = 0;\nif(ps_sps->i1_sample_adaptive_offset_enabled_flag)\n{\nBITS_PARSE(\"slice_sao_luma_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_sao_luma_flag = value;\nBITS_PARSE(\"slice_sao_chroma_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_sao_chroma_flag = value;\n}\nps_slice_hdr->i1_max_num_merge_cand = 1;\nps_slice_hdr->i1_cabac_init_flag = 0;\nps_slice_hdr->i1_num_ref_idx_l0_active = 0;\nps_slice_hdr->i1_num_ref_idx_l1_active = 0;\nps_slice_hdr->i1_slice_cb_qp_offset = 0;\nps_slice_hdr->i1_slice_cr_qp_offset = 0;\nif((PSLICE == ps_slice_hdr->i1_slice_type) ||\n(BSLICE == ps_slice_hdr->i1_slice_type))\n{\nBITS_PARSE(\"num_ref_idx_active_override_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_num_ref_idx_active_override_flag = value;\nif(ps_slice_hdr->i1_num_ref_idx_active_override_flag)\n{\nUEV_PARSE(\"num_ref_idx_l0_active_minus1\", value, ps_bitstrm);\nps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nUEV_PARSE(\"num_ref_idx_l1_active_minus1\", value, ps_bitstrm);\nps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;\n}\n}\nelse\n{\nps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;\n}\n}\nps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);\nps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);\nif(0 == num_poc_total_curr)\nreturn IHEVCD_IGNORE_SLICE;\nif((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))\n{\nihevcd_ref_pic_list_modification(ps_bitstrm,\nps_slice_hdr, num_poc_total_curr);\n}\nelse\n{\nps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;\nps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;\n}\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nBITS_PARSE(\"mvd_l1_zero_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_mvd_l1_zero_flag = value;\n}\nps_slice_hdr->i1_cabac_init_flag = 0;\nif(ps_pps->i1_cabac_init_present_flag)\n{\nBITS_PARSE(\"cabac_init_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_cabac_init_flag = value;\n}\nps_slice_hdr->i1_collocated_from_l0_flag = 1;\nps_slice_hdr->i1_collocated_ref_idx = 0;\nif(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)\n{\nif(BSLICE == ps_slice_hdr->i1_slice_type)\n{\nBITS_PARSE(\"collocated_from_l0_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_collocated_from_l0_flag = value;\n}\nif((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||\n(!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))\n{\nUEV_PARSE(\"collocated_ref_idx\", value, ps_bitstrm);\nps_slice_hdr->i1_collocated_ref_idx = value;\n}\n}\nps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);\nif((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||\n(ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))\n{\nihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);\n}\nUEV_PARSE(\"five_minus_max_num_merge_cand\", value, ps_bitstrm);\nps_slice_hdr->i1_max_num_merge_cand = 5 - value;\n}\nps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);\nSEV_PARSE(\"slice_qp_delta\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_qp_delta = value;\nif(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)\n{\nSEV_PARSE(\"slice_cb_qp_offset\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_cb_qp_offset = value;\nSEV_PARSE(\"slice_cr_qp_offset\", value, ps_bitstrm);\nps_slice_hdr->i1_slice_cr_qp_offset = value;\n}\nps_slice_hdr->i1_deblocking_filter_override_flag = 0;\nps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;\nps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;\nps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;\ndisable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;\nif(ps_pps->i1_deblocking_filter_control_present_flag)\n{\nif(ps_pps->i1_deblocking_filter_override_enabled_flag)\n{\nBITS_PARSE(\"deblocking_filter_override_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_deblocking_filter_override_flag = value;\n}\nif(ps_slice_hdr->i1_deblocking_filter_override_flag)\n{\nBITS_PARSE(\"slice_disable_deblocking_filter_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;\ndisable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;\nif(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)\n{\nSEV_PARSE(\"beta_offset_div2\", value, ps_bitstrm);\nps_slice_hdr->i1_beta_offset_div2 = value;\nSEV_PARSE(\"tc_offset_div2\", value, ps_bitstrm);\nps_slice_hdr->i1_tc_offset_div2 = value;\n}\n}\n}\nps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;\nif(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&\n(ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))\n{\nBITS_PARSE(\"slice_loop_filter_across_slices_enabled_flag\", value, ps_bitstrm, 1);\nps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;\n}\n}\nif((!first_slice_in_pic_flag) &&\n(ps_codec->i4_pic_present))\n{\nslice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;\nif((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||\n(ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\n}\nif(0 == ps_codec->i4_pic_present)\n{\nps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);\n}\nelse\n{\nps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;\n}\nif(!first_slice_in_pic_flag)\n{\nif(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n{\nif(slice_address > ps_codec->s_parse.i4_next_ctb_indx)\n{\nif(ps_codec->i4_pic_present)\n{\nprev_slice_incomplete_flag = 1;\n}\nelse\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\n}\nelse if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\nelse\n{\nps_codec->i4_slice_error = 0;\n}\n}\nelse\n{\nif(ps_codec->i4_pic_present)\n{\nslice_header_t *ps_slice_hdr_next;\nps_codec->i4_slice_error = 1;\nps_codec->s_parse.i4_cur_slice_idx--;\nif(ps_codec->s_parse.i4_cur_slice_idx < 0)\nps_codec->s_parse.i4_cur_slice_idx = 0;\nps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\nps_slice_hdr_next->i2_ctb_x = 0;\nps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\nreturn ret;\n}\nelse\n{\nif(ps_slice_hdr->i1_dependent_slice_flag)\nreturn IHEVCD_IGNORE_SLICE;\nps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n}\n}\n}\nelse\n{\nif(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\nreturn IHEVCD_IGNORE_SLICE;\nps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n}\nps_slice_hdr->i4_num_entry_point_offsets = 0;\nif((ps_pps->i1_tiles_enabled_flag) ||\n(ps_pps->i1_entropy_coding_sync_enabled_flag))\n{\nUEV_PARSE(\"num_entry_point_offsets\", value, ps_bitstrm);\nps_slice_hdr->i4_num_entry_point_offsets = value;\n{\nWORD32 max_num_entry_point_offsets;\nif((ps_pps->i1_tiles_enabled_flag) &&\n(ps_pps->i1_entropy_coding_sync_enabled_flag))\n{\nmax_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);\n}\nelse if(ps_pps->i1_tiles_enabled_flag)\n{\nmax_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;\n}\nelse\n{\nmax_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);\n}\nps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,\n0, max_num_entry_point_offsets);\n}\nif(ps_slice_hdr->i4_num_entry_point_offsets > 0)\n{\nUEV_PARSE(\"offset_len_minus1\", value, ps_bitstrm);\nps_slice_hdr->i1_offset_len = value + 1;\nfor(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)\n{\nBITS_PARSE(\"entry_point_offset\", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);\n}\n}\n}\nif(ps_pps->i1_slice_header_extension_present_flag)\n{\nUEV_PARSE(\"slice_header_extension_length\", value, ps_bitstrm);\nps_slice_hdr->i2_slice_header_extension_length = value;\nfor(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)\n{\nBITS_PARSE(\"slice_header_extension_data_byte\", value, ps_bitstrm, 8);\n}\n}\nihevcd_bits_flush_to_byte_boundary(ps_bitstrm);\nif((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)\nreturn IHEVCD_INVALID_PARAMETER;\n{\ndpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\nWORD32 r_idx;\nif((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||\n(NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n(0 == ps_codec->u4_pic_cnt))\n{\nfor(i = 0; i < MAX_DPB_BUFS; i++)\n{\nif(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)\n{\npic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;\nmv_buf_t *ps_mv_buf;\nihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);\nps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;\nfor(j = 0; j < ps_codec->i4_max_dpb_size; j++)\n{\nif(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)\n{\nihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);\nbreak;\n}\nps_mv_buf++;\n}\n}\n}\nfor(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)\n{\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;\n}\n}\nelse\n{\nret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);\nif ((WORD32)IHEVCD_SUCCESS != ret)\n{\nreturn ret;\n}\n}\n}\nif(ps_codec->i4_pic_present)\n{\npic_buf_t *ps_pic_buf_ref;\nmv_buf_t *ps_mv_buf_ref;\nWORD32 r_idx;\ndpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\nbuf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;\nps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);\nif(NULL == ps_pic_buf_ref)\n{\nps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;\nps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;\n}\nelse\n{\nps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);\n}\nfor(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)\n{\nif(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)\n{\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\n}\nfor(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)\n{\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\nfor(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)\n{\nif(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)\n{\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\n}\nfor(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)\n{\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\nps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n}\n}\nif(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n{\nps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\nps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\nif(!ps_slice_hdr->i1_dependent_slice_flag)\n{\nps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;\nps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;\n}\n}\nelse\n{\nps_slice_hdr->i2_ctb_x = 0;\nps_slice_hdr->i2_ctb_y = 0;\nps_slice_hdr->i2_independent_ctb_x = 0;\nps_slice_hdr->i2_independent_ctb_y = 0;\n}\nif((!first_slice_in_pic_flag) &&\n(0 == ps_codec->i4_pic_present))\n{\nslice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;\nihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));\nprev_slice_incomplete_flag = 1;\nASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);\nps_slice_hdr_prev->i2_ctb_x = 0;\nps_slice_hdr_prev->i2_ctb_y = 0;\nps_codec->s_parse.i4_ctb_x = 0;\nps_codec->s_parse.i4_ctb_y = 0;\nps_codec->s_parse.i4_cur_slice_idx = 0;\nif((ps_slice_hdr->i2_ctb_x == 0) &&\n(ps_slice_hdr->i2_ctb_y == 0))\n{\nps_slice_hdr->i2_ctb_x++;\n}\n}\n{\nif((i1_nal_unit_type < NAL_BLA_W_LP) &&\n(i1_nal_unit_type % 2 == 0))\n{\nif(IVD_SKIP_B == ps_codec->e_pic_skip_mode)\nreturn IHEVCD_IGNORE_SLICE;\n}\nif((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&\n(ISLICE != ps_slice_hdr->i1_slice_type))\n{\nreturn IHEVCD_IGNORE_SLICE;\n}\n}\nif(prev_slice_incomplete_flag)\n{\nps_codec->i4_slice_error = 1;\nps_codec->s_parse.i4_cur_slice_idx--;\nif(ps_codec->s_parse.i4_cur_slice_idx < 0)\nps_codec->s_parse.i4_cur_slice_idx = 0;\n}\nreturn ret;\n}", "label": 0}
{"index": 183398, "code": "xmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\nconst xmlChar *name;\nxmlEntityPtr entity = NULL;\nxmlParserInputPtr input;\nif (RAW != '%')\nreturn;\nNEXT;\nname = xmlParseName(ctxt);\nif (name == NULL) {\nxmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\"xmlParsePEReference: no name\\n\");\nreturn;\n}\nif (RAW != ';') {\nxmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\nreturn;\n}\nNEXT;\nctxt->nbentities++;\nif ((ctxt->sax != NULL) &&\n(ctxt->sax->getParameterEntity != NULL))\nentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\nif (ctxt->instate == XML_PARSER_EOF)\nreturn;\nif (entity == NULL) {\nif ((ctxt->standalone == 1) ||\n((ctxt->hasExternalSubset == 0) &&\n(ctxt->hasPErefs == 0))) {\nxmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\"PEReference: %%%s; not found\\n\",\nname);\n} else {\nxmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\"PEReference: %%%s; not found\\n\",\nname, NULL);\nctxt->valid = 0;\n}\nxmlParserEntityCheck(ctxt, 0, NULL, 0);\n} else {\nif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n(entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\nxmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\"Internal: %%%s; is not a parameter entity\\n\",\nname, NULL);\n} else if (ctxt->input->free != deallocblankswrapper) {\ninput = xmlNewBlanksWrapperInputStream(ctxt, entity);\nif (xmlPushInput(ctxt, input) < 0)\nreturn;\n} else {\ninput = xmlNewEntityInputStream(ctxt, entity);\nif (xmlPushInput(ctxt, input) < 0)\nreturn;\nif ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n(IS_BLANK_CH(NXT(5)))) {\nxmlParseTextDecl(ctxt);\nif (ctxt->errNo ==\nXML_ERR_UNSUPPORTED_ENCODING) {\nxmlHaltParser(ctxt);\nreturn;\n}\n}\n}\n}\nctxt->hasPErefs = 1;\n}", "contrast": "xmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\nconst xmlChar *name;\nxmlEntityPtr entity = NULL;\nxmlParserInputPtr input;\nif (RAW != '%')\nreturn;\nNEXT;\nname = xmlParseName(ctxt);\nif (name == NULL) {\nxmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\"xmlParsePEReference: no name\\n\");\nreturn;\n}\nif (RAW != ';') {\nxmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\nreturn;\n}\nNEXT;\nctxt->nbentities++;\nif ((ctxt->sax != NULL) &&\n(ctxt->sax->getParameterEntity != NULL))\nentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\nif (ctxt->instate == XML_PARSER_EOF)\nreturn;\nif (entity == NULL) {\nif ((ctxt->standalone == 1) ||\n((ctxt->hasExternalSubset == 0) &&\n(ctxt->hasPErefs == 0))) {\nxmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\"PEReference: %%%s; not found\\n\",\nname);\n} else {\nxmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\"PEReference: %%%s; not found\\n\",\nname, NULL);\nctxt->valid = 0;\n}\nxmlParserEntityCheck(ctxt, 0, NULL, 0);\n} else {\nif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n(entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\nxmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\"Internal: %%%s; is not a parameter entity\\n\",\nname, NULL);\n} else if (ctxt->input->free != deallocblankswrapper) {\ninput = xmlNewBlanksWrapperInputStream(ctxt, entity);\nif (xmlPushInput(ctxt, input) < 0)\nreturn;\n} else {\nif ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n((ctxt->options & XML_PARSE_NOENT) == 0) &&\n((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n(ctxt->replaceEntities == 0) &&\n(ctxt->validate == 0))\nreturn;\ninput = xmlNewEntityInputStream(ctxt, entity);\nif (xmlPushInput(ctxt, input) < 0)\nreturn;\nif ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n(IS_BLANK_CH(NXT(5)))) {\nxmlParseTextDecl(ctxt);\nif (ctxt->errNo ==\nXML_ERR_UNSUPPORTED_ENCODING) {\nxmlHaltParser(ctxt);\nreturn;\n}\n}\n}\n}\nctxt->hasPErefs = 1;\n}", "label": 0}
{"index": 183419, "code": "static void local_socket_close_locked(asocket* s) {\nD(\"entered local_socket_close_locked. LS(%d) fd=%d\", s->id, s->fd);\nif (s->peer) {\nD(\"LS(%d): closing peer. peer->id=%d peer->fd=%d\", s->id, s->peer->id, s->peer->fd);\nif (s->peer->shutdown) {\ns->peer->shutdown(s->peer);\n}\ns->peer->peer = 0;\nif (s->peer->close == local_socket_close) {\nlocal_socket_close_locked(s->peer);\n} else {\ns->peer->close(s->peer);\n}\ns->peer = 0;\n}\nif (s->closing || s->has_write_error || s->pkt_first == NULL) {\nint id = s->id;\nlocal_socket_destroy(s);\nD(\"LS(%d): closed\", id);\nreturn;\n}\nD(\"LS(%d): closing\", s->id);\ns->closing = 1;\nfdevent_del(&s->fde, FDE_READ);\nremove_socket(s);\nD(\"LS(%d): put on socket_closing_list fd=%d\", s->id, s->fd);\ninsert_local_socket(s, &local_socket_closing_list);\nCHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);\n}", "contrast": "static void local_socket_close_locked(asocket* s) {\nstatic void local_socket_close(asocket* s) {\nD(\"entered local_socket_close. LS(%d) fd=%d\", s->id, s->fd);\nstd::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);\nif (s->peer) {\nD(\"LS(%d): closing peer. peer->id=%d peer->fd=%d\", s->id, s->peer->id, s->peer->fd);\nif (s->peer->shutdown) {\ns->peer->shutdown(s->peer);\n}\ns->peer->peer = nullptr;\ns->peer->close(s->peer);\ns->peer = nullptr;\n}\nif (s->closing || s->has_write_error || s->pkt_first == NULL) {\nint id = s->id;\nlocal_socket_destroy(s);\nD(\"LS(%d): closed\", id);\nreturn;\n}\nD(\"LS(%d): closing\", s->id);\ns->closing = 1;\nfdevent_del(&s->fde, FDE_READ);\nremove_socket(s);\nD(\"LS(%d): put on socket_closing_list fd=%d\", s->id, s->fd);\ninsert_local_socket(s, &local_socket_closing_list);\nCHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);\n}", "label": 0}
{"index": 183426, "code": "static jboolean enableNative(JNIEnv* env, jobject obj) {\nALOGV(\"%s:\",__FUNCTION__);\njboolean result = JNI_FALSE;\nif (!sBluetoothInterface) return result;\nint ret = sBluetoothInterface->enable();\nresult = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;\nreturn result;\n}", "contrast": "static jboolean enableNative(JNIEnv* env, jobject obj) {\nstatic jboolean enableNative(JNIEnv* env, jobject obj, jboolean isGuest) {\nALOGV(\"%s:\",__FUNCTION__);\njboolean result = JNI_FALSE;\nif (!sBluetoothInterface) return result;\nint ret = sBluetoothInterface->enable(isGuest == JNI_TRUE ? 1 : 0);\nresult = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;\nreturn result;\n}", "label": 0}
{"index": 183744, "code": "static void encode_frame(vpx_codec_ctx_t *ctx,\nconst vpx_image_t *img,\nvpx_codec_pts_t pts,\nunsigned int duration,\nvpx_enc_frame_flags_t flags,\nunsigned int deadline,\nVpxVideoWriter *writer) {\nvpx_codec_iter_t iter = NULL;\nconst vpx_codec_cx_pkt_t *pkt = NULL;\nconst vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\ndeadline);\nif (res != VPX_CODEC_OK)\ndie_codec(ctx, \"Failed to encode frame.\");\nwhile ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\nif (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\nconst int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\nif (!vpx_video_writer_write_frame(writer, pkt->data.frame.buf,\npkt->data.frame.sz,\npkt->data.frame.pts))\ndie_codec(ctx, \"Failed to write compressed frame.\");\nprintf(keyframe ? \"K\" : \".\");\nfflush(stdout);\n}\n}\n}", "contrast": "static void encode_frame(vpx_codec_ctx_t *ctx,\nstatic int encode_frame(vpx_codec_ctx_t *ctx,\nconst vpx_image_t *img,\nvpx_codec_pts_t pts,\nunsigned int duration,\nvpx_enc_frame_flags_t flags,\nunsigned int deadline,\nVpxVideoWriter *writer) {\nint got_pkts = 0;\nvpx_codec_iter_t iter = NULL;\nconst vpx_codec_cx_pkt_t *pkt = NULL;\nconst vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\ndeadline);\nif (res != VPX_CODEC_OK)\ndie_codec(ctx, \"Failed to encode frame.\");\nwhile ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\ngot_pkts = 1;\nif (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\nconst int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\nif (!vpx_video_writer_write_frame(writer, pkt->data.frame.buf,\npkt->data.frame.sz,\npkt->data.frame.pts))\ndie_codec(ctx, \"Failed to write compressed frame.\");\nprintf(keyframe ? \"K\" : \".\");\nfflush(stdout);\n}\n}\nreturn got_pkts;\n}\nstatic vpx_fixed_buf_t pass0(vpx_image_t *raw,\nFILE *infile,\nconst VpxInterface *encoder,\nconst vpx_codec_enc_cfg_t *cfg) {\nvpx_codec_ctx_t codec;\nint frame_count = 0;\nvpx_fixed_buf_t stats = {NULL, 0};\nif (vpx_codec_enc_init(&codec, encoder->codec_interface(), cfg, 0))\ndie_codec(&codec, \"Failed to initialize encoder\");\nwhile (vpx_img_read(raw, infile)) {\n++frame_count;\nget_frame_stats(&codec, raw, frame_count, 1, 0, VPX_DL_GOOD_QUALITY,\n&stats);\n}\nwhile (get_frame_stats(&codec, NULL, frame_count, 1, 0,\nVPX_DL_GOOD_QUALITY, &stats)) {}\nprintf(\"Pass 0 complete. Processed %d frames.\\n\", frame_count);\nif (vpx_codec_destroy(&codec))\ndie_codec(&codec, \"Failed to destroy codec.\");\nreturn stats;\n}\nstatic void pass1(vpx_image_t *raw,\nFILE *infile,\nconst char *outfile_name,\nconst VpxInterface *encoder,\nconst vpx_codec_enc_cfg_t *cfg) {\nVpxVideoInfo info = {\nencoder->fourcc,\ncfg->g_w,\ncfg->g_h,\n{cfg->g_timebase.num, cfg->g_timebase.den}\n};\nVpxVideoWriter *writer = NULL;\nvpx_codec_ctx_t codec;\nint frame_count = 0;\nwriter = vpx_video_writer_open(outfile_name, kContainerIVF, &info);\nif (!writer)\ndie(\"Failed to open %s for writing\", outfile_name);\nif (vpx_codec_enc_init(&codec, encoder->codec_interface(), cfg, 0))\ndie_codec(&codec, \"Failed to initialize encoder\");\nwhile (vpx_img_read(raw, infile)) {\n++frame_count;\nencode_frame(&codec, raw, frame_count, 1, 0, VPX_DL_GOOD_QUALITY, writer);\n}\nwhile (encode_frame(&codec, NULL, -1, 1, 0, VPX_DL_GOOD_QUALITY, writer)) {}\nprintf(\"\\n\");\nif (vpx_codec_destroy(&codec))\ndie_codec(&codec, \"Failed to destroy codec.\");\nvpx_video_writer_close(writer);\nprintf(\"Pass 1 complete. Processed %d frames.\\n\", frame_count);\n}", "label": 0}
{"index": 183758, "code": "static void TearDownTestCase() {\nvpx_free(input_ - 1);\ninput_ = NULL;\nvpx_free(output_);\noutput_ = NULL;\n}", "contrast": "static void TearDownTestCase() {\nvpx_free(input_ - 1);\ninput_ = NULL;\nvpx_free(output_);\noutput_ = NULL;\nvpx_free(output_ref_);\noutput_ref_ = NULL;\n#if CONFIG_VP9_HIGHBITDEPTH\nvpx_free(input16_ - 1);\ninput16_ = NULL;\nvpx_free(output16_);\noutput16_ = NULL;\nvpx_free(output16_ref_);\noutput16_ref_ = NULL;\n#endif\n}", "label": 0}
{"index": 183764, "code": "virtual void SetUp() {\nInitializeConfig();\nSetMode(GET_PARAM(1));\nset_cpu_used_ = GET_PARAM(2);\n}", "contrast": "virtual void SetUp() {\nInitializeConfig();\nSetMode(encoding_mode_);\nif (encoding_mode_ != ::libvpx_test::kRealTime) {\ncfg_.g_lag_in_frames = 25;\ncfg_.rc_end_usage = VPX_VBR;\n} else {\ncfg_.g_lag_in_frames = 0;\ncfg_.rc_end_usage = VPX_CBR;\n}\n}\nvirtual void BeginPassHook(unsigned int  ) {\nmin_psnr_ = kMaxPSNR;\n}", "label": 0}
{"index": 183776, "code": "void RunMemCheck() {\nACMRandom rnd(ACMRandom::DeterministicSeed());\nconst int count_test_block = 1000;\nDECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\nDECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\nDECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\nDECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\nfor (int i = 0; i < count_test_block; ++i) {\nfor (int j = 0; j < kNumCoeffs; ++j) {\ninput_block[j] = rnd.Rand8() - rnd.Rand8();\ninput_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n}\nif (i == 0)\nfor (int j = 0; j < kNumCoeffs; ++j)\ninput_extreme_block[j] = 255;\nif (i == 1)\nfor (int j = 0; j < kNumCoeffs; ++j)\ninput_extreme_block[j] = -255;\nfwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\nREGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\noutput_block, pitch_));\nfor (int j = 0; j < kNumCoeffs; ++j) {\nEXPECT_EQ(output_block[j], output_ref_block[j]);\nEXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n<< \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n}\n}\n}", "contrast": "void RunMemCheck() {\nACMRandom rnd(ACMRandom::DeterministicSeed());\nconst int count_test_block = 1000;\nDECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\nDECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\nDECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\nfor (int i = 0; i < count_test_block; ++i) {\nfor (int j = 0; j < kNumCoeffs; ++j) {\ninput_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n}\nif (i == 0) {\nfor (int j = 0; j < kNumCoeffs; ++j)\ninput_extreme_block[j] = mask_;\n} else if (i == 1) {\nfor (int j = 0; j < kNumCoeffs; ++j)\ninput_extreme_block[j] = -mask_;\n}\nfwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\nASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\noutput_block, pitch_));\nfor (int j = 0; j < kNumCoeffs; ++j) {\nEXPECT_EQ(output_block[j], output_ref_block[j]);\nEXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))\n<< \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n}\n}\n}", "label": 0}
{"index": 183780, "code": "void fht16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\nvp9_fht16x16_c(in, out, stride, tx_type);\n}", "contrast": "void fht16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\nvoid idct16x16_ref(const tran_low_t *in, uint8_t *dest, int stride,\nint  ) {\nvpx_idct16x16_256_add_c(in, dest, stride);\n}\nvoid fht16x16_ref(const int16_t *in, tran_low_t *out, int stride,\nint tx_type) {\nvp9_fht16x16_c(in, out, stride, tx_type);\n}", "label": 0}
{"index": 183791, "code": "static bool compare_img(const vpx_image_t *img1,\nconst vpx_image_t *img2) {\nbool match = (img1->fmt == img2->fmt) &&\n(img1->d_w == img2->d_w) &&\n(img1->d_h == img2->d_h);\nconst unsigned int width_y  = img1->d_w;\nconst unsigned int height_y = img1->d_h;\nunsigned int i;\nfor (i = 0; i < height_y; ++i)\nmatch = (memcmp(img1->planes[VPX_PLANE_Y] + i * img1->stride[VPX_PLANE_Y],\nimg2->planes[VPX_PLANE_Y] + i * img2->stride[VPX_PLANE_Y],\nwidth_y) == 0) && match;\nconst unsigned int width_uv  = (img1->d_w + 1) >> 1;\nconst unsigned int height_uv = (img1->d_h + 1) >> 1;\nfor (i = 0; i <  height_uv; ++i)\nmatch = (memcmp(img1->planes[VPX_PLANE_U] + i * img1->stride[VPX_PLANE_U],\nimg2->planes[VPX_PLANE_U] + i * img2->stride[VPX_PLANE_U],\nwidth_uv) == 0) && match;\nfor (i = 0; i < height_uv; ++i)\nmatch = (memcmp(img1->planes[VPX_PLANE_V] + i * img1->stride[VPX_PLANE_V],\nimg2->planes[VPX_PLANE_V] + i * img2->stride[VPX_PLANE_V],\nwidth_uv) == 0) && match;\nreturn match;\n}", "contrast": "static bool compare_img(const vpx_image_t *img1,\nconst vpx_image_t *img2) {\nbool match = (img1->fmt == img2->fmt) &&\n(img1->cs == img2->cs) &&\n(img1->d_w == img2->d_w) &&\n(img1->d_h == img2->d_h);\nconst unsigned int width_y  = img1->d_w;\nconst unsigned int height_y = img1->d_h;\nunsigned int i;\nfor (i = 0; i < height_y; ++i)\nmatch = (memcmp(img1->planes[VPX_PLANE_Y] + i * img1->stride[VPX_PLANE_Y],\nimg2->planes[VPX_PLANE_Y] + i * img2->stride[VPX_PLANE_Y],\nwidth_y) == 0) && match;\nconst unsigned int width_uv  = (img1->d_w + 1) >> 1;\nconst unsigned int height_uv = (img1->d_h + 1) >> 1;\nfor (i = 0; i <  height_uv; ++i)\nmatch = (memcmp(img1->planes[VPX_PLANE_U] + i * img1->stride[VPX_PLANE_U],\nimg2->planes[VPX_PLANE_U] + i * img2->stride[VPX_PLANE_U],\nwidth_uv) == 0) && match;\nfor (i = 0; i < height_uv; ++i)\nmatch = (memcmp(img1->planes[VPX_PLANE_V] + i * img1->stride[VPX_PLANE_V],\nimg2->planes[VPX_PLANE_V] + i * img2->stride[VPX_PLANE_V],\nwidth_uv) == 0) && match;\nreturn match;\n}", "label": 0}
{"index": 183806, "code": "virtual void SetUp() {\nfwd_txfm_ = GET_PARAM(0);\ninv_txfm_ = GET_PARAM(1);\ntx_type_  = GET_PARAM(2);\npitch_    = 4;\nfwd_txfm_ref = fht4x4_ref;\n}", "contrast": "virtual void SetUp() {\nfwd_txfm_ = GET_PARAM(0);\ninv_txfm_ = GET_PARAM(1);\ntx_type_  = GET_PARAM(2);\npitch_    = 4;\nfwd_txfm_ref = fht4x4_ref;\nbit_depth_ = GET_PARAM(3);\nmask_ = (1 << bit_depth_) - 1;\n}", "label": 0}
{"index": 183810, "code": "void RunRoundTripErrorCheck() {\nACMRandom rnd(ACMRandom::DeterministicSeed());\nint max_error = 0;\nint total_error = 0;\nconst int count_test_block = 100000;\nDECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\nDECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);\nDECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);\nDECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);\nfor (int i = 0; i < count_test_block; ++i) {\nfor (int j = 0; j < 64; ++j) {\nsrc[j] = rnd.Rand8();\ndst[j] = rnd.Rand8();\ntest_input_block[j] = src[j] - dst[j];\n}\nREGISTER_STATE_CHECK(\nRunFwdTxfm(test_input_block, test_temp_block, pitch_));\nfor (int j = 0; j < 64; ++j) {\nif (test_temp_block[j] > 0) {\ntest_temp_block[j] += 2;\ntest_temp_block[j] /= 4;\ntest_temp_block[j] *= 4;\n} else {\ntest_temp_block[j] -= 2;\ntest_temp_block[j] /= 4;\ntest_temp_block[j] *= 4;\n}\n}\nREGISTER_STATE_CHECK(\nRunInvTxfm(test_temp_block, dst, pitch_));\nfor (int j = 0; j < 64; ++j) {\nconst int diff = dst[j] - src[j];\nconst int error = diff * diff;\nif (max_error < error)\nmax_error = error;\ntotal_error += error;\n}\n}\nEXPECT_GE(1, max_error)\n<< \"Error: 8x8 FDCT/IDCT or FHT/IHT has an individual\"\n<< \" roundtrip error > 1\";\nEXPECT_GE(count_test_block/5, total_error)\n<< \"Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip \"\n<< \"error > 1/5 per block\";\n}", "contrast": "void RunRoundTripErrorCheck() {\nACMRandom rnd(ACMRandom::DeterministicSeed());\nint max_error = 0;\nint total_error = 0;\nconst int count_test_block = 100000;\nDECLARE_ALIGNED(16, int16_t, test_input_block[64]);\nDECLARE_ALIGNED(16, tran_low_t, test_temp_block[64]);\nDECLARE_ALIGNED(16, uint8_t, dst[64]);\nDECLARE_ALIGNED(16, uint8_t, src[64]);\n#if CONFIG_VP9_HIGHBITDEPTH\nDECLARE_ALIGNED(16, uint16_t, dst16[64]);\nDECLARE_ALIGNED(16, uint16_t, src16[64]);\n#endif\nfor (int i = 0; i < count_test_block; ++i) {\nfor (int j = 0; j < 64; ++j) {\nif (bit_depth_ == VPX_BITS_8) {\nsrc[j] = rnd.Rand8();\ndst[j] = rnd.Rand8();\ntest_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n} else {\nsrc16[j] = rnd.Rand16() & mask_;\ndst16[j] = rnd.Rand16() & mask_;\ntest_input_block[j] = src16[j] - dst16[j];\n#endif\n}\n}\nASM_REGISTER_STATE_CHECK(\nRunFwdTxfm(test_input_block, test_temp_block, pitch_));\nfor (int j = 0; j < 64; ++j) {\nif (test_temp_block[j] > 0) {\ntest_temp_block[j] += 2;\ntest_temp_block[j] /= 4;\ntest_temp_block[j] *= 4;\n} else {\ntest_temp_block[j] -= 2;\ntest_temp_block[j] /= 4;\ntest_temp_block[j] *= 4;\n}\n}\nif (bit_depth_ == VPX_BITS_8) {\nASM_REGISTER_STATE_CHECK(\nRunInvTxfm(test_temp_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n} else {\nASM_REGISTER_STATE_CHECK(\nRunInvTxfm(test_temp_block, CONVERT_TO_BYTEPTR(dst16), pitch_));\n#endif\n}\nfor (int j = 0; j < 64; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\nconst int diff =\nbit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\nconst int diff = dst[j] - src[j];\n#endif\nconst int error = diff * diff;\nif (max_error < error)\nmax_error = error;\ntotal_error += error;\n}\n}\nEXPECT_GE(1 << 2 * (bit_depth_ - 8), max_error)\n<< \"Error: 8x8 FDCT/IDCT or FHT/IHT has an individual\"\n<< \" roundtrip error > 1\";\nEXPECT_GE((count_test_block << 2 * (bit_depth_ - 8))/5, total_error)\n<< \"Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip \"\n<< \"error > 1/5 per block\";\n}", "label": 0}
{"index": 183815, "code": "void fht8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\nvp9_fht8x8_c(in, out, stride, tx_type);\n}", "contrast": "void fht8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\nvoid reference_8x8_dct_2d(const int16_t input[kNumCoeffs],\ndouble output[kNumCoeffs]) {\nfor (int i = 0; i < 8; ++i) {\ndouble temp_in[8], temp_out[8];\nfor (int j = 0; j < 8; ++j)\ntemp_in[j] = input[j*8 + i];\nreference_8x8_dct_1d(temp_in, temp_out, 1);\nfor (int j = 0; j < 8; ++j)\noutput[j * 8 + i] = temp_out[j];\n}\nfor (int i = 0; i < 8; ++i) {\ndouble temp_in[8], temp_out[8];\nfor (int j = 0; j < 8; ++j)\ntemp_in[j] = output[j + i*8];\nreference_8x8_dct_1d(temp_in, temp_out, 1);\nfor (int j = 0; j < 8; ++j)\noutput[j + i * 8] = temp_out[j] * 2;\n}\n}\nvoid fdct8x8_ref(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\nvpx_fdct8x8_c(in, out, stride);\n}\nvoid fht8x8_ref(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\nvp9_fht8x8_c(in, out, stride, tx_type);\n}", "label": 0}
{"index": 183820, "code": "void CheckSad(unsigned int max_sad) {\nunsigned int reference_sad, exp_sad;\nreference_sad = ReferenceSAD(max_sad);\nexp_sad = SAD(max_sad);\nif (reference_sad <= max_sad) {\nASSERT_EQ(exp_sad, reference_sad);\n} else {\nASSERT_GE(exp_sad, reference_sad);\n}\n}", "contrast": "void CheckSad(unsigned int max_sad) {", "label": 0}
{"index": 183821, "code": "void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\nfor (int h = 0; h < height_; ++h) {\nfor (int w = 0; w < width_; ++w) {\ndata[h * stride + w] = fill_constant;\n}\n}\n}", "contrast": "void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\nunsigned int ReferenceSADavg(int block_idx) {\nunsigned int sad = 0;\nconst uint8_t *const reference8 = GetReference(block_idx);\nconst uint8_t *const source8 = source_data_;\nconst uint8_t *const second_pred8 = second_pred_;\n#if CONFIG_VP9_HIGHBITDEPTH\nconst uint16_t *const reference16 =\nCONVERT_TO_SHORTPTR(GetReference(block_idx));\nconst uint16_t *const source16 = CONVERT_TO_SHORTPTR(source_data_);\nconst uint16_t *const second_pred16 = CONVERT_TO_SHORTPTR(second_pred_);\n#endif\nfor (int h = 0; h < height_; ++h) {\nfor (int w = 0; w < width_; ++w) {\nif (!use_high_bit_depth_) {\nconst int tmp = second_pred8[h * width_ + w] +\nreference8[h * reference_stride_ + w];\nconst uint8_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\nsad += abs(source8[h * source_stride_ + w] - comp_pred);\n#if CONFIG_VP9_HIGHBITDEPTH\n} else {\nconst int tmp = second_pred16[h * width_ + w] +\nreference16[h * reference_stride_ + w];\nconst uint16_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\nsad += abs(source16[h * source_stride_ + w] - comp_pred);\n#endif\n}\n}\n}\nreturn sad;\n}\nvoid FillConstant(uint8_t *data, int stride, uint16_t fill_constant) {\nuint8_t *data8 = data;\n#if CONFIG_VP9_HIGHBITDEPTH\nuint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n#endif\nfor (int h = 0; h < height_; ++h) {\nfor (int w = 0; w < width_; ++w) {\nif (!use_high_bit_depth_) {\ndata8[h * stride + w] = static_cast<uint8_t>(fill_constant);\n#if CONFIG_VP9_HIGHBITDEPTH\n} else {\ndata16[h * stride + w] = fill_constant;\n#endif\n}\n}\n}\n}", "label": 0}
{"index": 183827, "code": "virtual void SetUp() {\nsource_stride_ = (width_ + 31) & ~31;\nreference_stride_ = width_ * 2;\nrnd_.Reset(ACMRandom::DeterministicSeed());\n}", "contrast": "virtual void SetUp() {\nif (bd_ == -1) {\nuse_high_bit_depth_ = false;\nbit_depth_ = VPX_BITS_8;\nsource_data_ = source_data8_;\nreference_data_ = reference_data8_;\nsecond_pred_ = second_pred8_;\n#if CONFIG_VP9_HIGHBITDEPTH\n} else {\nuse_high_bit_depth_ = true;\nbit_depth_ = static_cast<vpx_bit_depth_t>(bd_);\nsource_data_ = CONVERT_TO_BYTEPTR(source_data16_);\nreference_data_ = CONVERT_TO_BYTEPTR(reference_data16_);\nsecond_pred_ = CONVERT_TO_BYTEPTR(second_pred16_);\n#endif\n}\nmask_ = (1 << bit_depth_) - 1;\nsource_stride_ = (width_ + 31) & ~31;\nreference_stride_ = width_ * 2;\nrnd_.Reset(ACMRandom::DeterministicSeed());\n}", "label": 0}
{"index": 183839, "code": "virtual void SetUp() {\nconst tuple<int, int, VarianceFunctionType>& params = this->GetParam();\nlog2width_  = get<0>(params);\nwidth_ = 1 << log2width_;\nlog2height_ = get<1>(params);\nheight_ = 1 << log2height_;\nvariance_ = get<2>(params);\nrnd(ACMRandom::DeterministicSeed());\nblock_size_ = width_ * height_;\nsrc_ = new uint8_t[block_size_];\nref_ = new uint8_t[block_size_];\nASSERT_TRUE(src_ != NULL);\nASSERT_TRUE(ref_ != NULL);\n}", "contrast": "virtual void SetUp() {\nconst tuple<int, int, VarianceFunctionType, int>& params = this->GetParam();\nlog2width_  = get<0>(params);\nwidth_ = 1 << log2width_;\nlog2height_ = get<1>(params);\nheight_ = 1 << log2height_;\nvariance_ = get<2>(params);\nif (get<3>(params)) {\nbit_depth_ = static_cast<vpx_bit_depth_t>(get<3>(params));\nuse_high_bit_depth_ = true;\n} else {\nbit_depth_ = VPX_BITS_8;\nuse_high_bit_depth_ = false;\n}\nmask_ = (1 << bit_depth_) - 1;\nrnd_.Reset(ACMRandom::DeterministicSeed());\nblock_size_ = width_ * height_;\nif (!use_high_bit_depth_) {\nsrc_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_ * 2));\nref_ = new uint8_t[block_size_ * 2];\n#if CONFIG_VP9_HIGHBITDEPTH\n} else {\nsrc_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(\nvpx_memalign(16, block_size_ * 2 * sizeof(uint16_t))));\nref_ = CONVERT_TO_BYTEPTR(new uint16_t[block_size_ * 2]);\n#endif\n}\nASSERT_TRUE(src_ != NULL);\nASSERT_TRUE(ref_ != NULL);\n}", "label": 0}
{"index": 183840, "code": "virtual void SetUp() {\nconst tuple<int, int, SubpelVarianceFunctionType>& params =\nthis->GetParam();\nlog2width_  = get<0>(params);\nwidth_ = 1 << log2width_;\nlog2height_ = get<1>(params);\nheight_ = 1 << log2height_;\nsubpel_variance_ = get<2>(params);\nrnd(ACMRandom::DeterministicSeed());\nblock_size_ = width_ * height_;\nsrc_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\nsec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\nref_ = new uint8_t[block_size_ + width_ + height_ + 1];\nASSERT_TRUE(src_ != NULL);\nASSERT_TRUE(sec_ != NULL);\nASSERT_TRUE(ref_ != NULL);\n}", "contrast": "virtual void SetUp() {\nconst tuple<int, int, MseFunctionType>& params = this->GetParam();\nlog2width_  = get<0>(params);\nwidth_ = 1 << log2width_;\nlog2height_ = get<1>(params);\nheight_ = 1 << log2height_;\nmse_ = get<2>(params);\nrnd(ACMRandom::DeterministicSeed());\nblock_size_ = width_ * height_;\nsrc_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\nref_ = new uint8_t[block_size_];\nASSERT_TRUE(src_ != NULL);\nASSERT_TRUE(ref_ != NULL);\n}", "label": 0}
{"index": 183846, "code": "static unsigned int variance_ref(const uint8_t *ref, const uint8_t *src,\nint l2w, int l2h, unsigned int *sse_ptr) {\nint se = 0;\nunsigned int sse = 0;\nconst int w = 1 << l2w, h = 1 << l2h;\nfor (int y = 0; y < h; y++) {\nfor (int x = 0; x < w; x++) {\nint diff = ref[w * y + x] - src[w * y + x];\nse += diff;\nsse += diff * diff;\n}\n}\n*sse_ptr = sse;\nreturn sse - (((int64_t) se * se) >> (l2w + l2h));\n}", "contrast": "static unsigned int variance_ref(const uint8_t *ref, const uint8_t *src,\nstatic void RoundHighBitDepth(int bit_depth, int64_t *se, uint64_t *sse) {\nswitch (bit_depth) {\ncase VPX_BITS_12:\n*sse = (*sse + 128) >> 8;\n*se = (*se + 8) >> 4;\nbreak;\ncase VPX_BITS_10:\n*sse = (*sse + 8) >> 4;\n*se = (*se + 2) >> 2;\nbreak;\ncase VPX_BITS_8:\ndefault:\nbreak;\n}\n}", "label": 0}
{"index": 183857, "code": "EAS_BOOL WT_CheckSampleEnd (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame, EAS_BOOL update)\n{\nEAS_U32 endPhaseAccum;\nEAS_U32 endPhaseFrac;\nEAS_I32 numSamples;\nEAS_BOOL done = EAS_FALSE;\nendPhaseFrac = pWTVoice->phaseFrac + (pWTIntFrame->frame.phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS);\nendPhaseAccum = pWTVoice->phaseAccum + GET_PHASE_INT_PART(endPhaseFrac);\nif (endPhaseAccum >= pWTVoice->loopEnd)\n{\nnumSamples = (EAS_I32) (pWTVoice->loopEnd - pWTVoice->phaseAccum);\nnumSamples = (EAS_I32) ((numSamples << NUM_PHASE_FRAC_BITS) - pWTVoice->phaseFrac);\nif (pWTIntFrame->frame.phaseIncrement) {\npWTIntFrame->numSamples = 1 + (numSamples / pWTIntFrame->frame.phaseIncrement);\n} else {\npWTIntFrame->numSamples = numSamples;\n}\nif (pWTIntFrame->numSamples < 0) {\nALOGE(\"b/26366256\");\npWTIntFrame->numSamples = 0;\n}\ndone = EAS_TRUE;\n}\nif (update)\n{\npWTVoice->phaseFrac = endPhaseFrac;\npWTVoice->phaseAccum = endPhaseAccum;\n}\nreturn done;\n}", "contrast": "EAS_BOOL WT_CheckSampleEnd (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame, EAS_BOOL update)\n{\nEAS_U32 endPhaseAccum;\nEAS_U32 endPhaseFrac;\nEAS_I32 numSamples;\nEAS_BOOL done = EAS_FALSE;\nendPhaseFrac = pWTVoice->phaseFrac + (pWTIntFrame->frame.phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS);\nendPhaseAccum = pWTVoice->phaseAccum + GET_PHASE_INT_PART(endPhaseFrac);\nif (endPhaseAccum >= pWTVoice->loopEnd)\n{\nnumSamples = (EAS_I32) (pWTVoice->loopEnd - pWTVoice->phaseAccum);\nnumSamples = (EAS_I32) ((numSamples << NUM_PHASE_FRAC_BITS) - pWTVoice->phaseFrac);\nif (pWTIntFrame->frame.phaseIncrement) {\npWTIntFrame->numSamples = 1 + (numSamples / pWTIntFrame->frame.phaseIncrement);\n} else {\npWTIntFrame->numSamples = numSamples;\n}\nif (pWTIntFrame->numSamples < 0) {\nALOGE(\"b/26366256\");\nandroid_errorWriteLog(0x534e4554, \"26366256\");\npWTIntFrame->numSamples = 0;\n}\ndone = EAS_TRUE;\n}\nif (update)\n{\npWTVoice->phaseFrac = endPhaseFrac;\npWTVoice->phaseAccum = endPhaseAccum;\n}\nreturn done;\n}", "label": 0}
